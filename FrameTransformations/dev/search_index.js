var documenterSearchIndex = {"docs":
[{"location":"Modules/frames_lapi/#low_frames_api","page":"Low-level API","title":"Frames's Low-level API","text":"","category":"section"},{"location":"Modules/frames_lapi/#Axes","page":"Low-level API","title":"Axes","text":"","category":"section"},{"location":"Modules/frames_lapi/","page":"Low-level API","title":"Low-level API","text":"Frames.AbstractFrameAxes\nFrames.FrameAxesNode\nFrames.axes_name\nFrames.axes_id\n\nFrames.build_axes\n\nFrames.ComputableAxesProperties\n","category":"page"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes","page":"Low-level API","title":"FrameTransformations.Frames.AbstractFrameAxes","text":"AbstractFrameAxes\n\nAbstract type for all reference frames axes.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.FrameAxesNode","page":"Low-level API","title":"FrameTransformations.Frames.FrameAxesNode","text":"FrameAxesNode{O, T, N} <: AbstractJSMDGraphNode\n\nDefine a set of axes.\n\nFields\n\nname – axes name \nclass – Symbol representing the class of the axes \nid – axes ID (equivalent of NAIFId for axes)\nparentid – ID of the parent axes \ncomp – properties for computable axes \nR – rotation matrix for fixed relative axes \nf – FrameAxesFunctions container \nangles – vector storing the libration angles retrived from ephemerides\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.axes_name","page":"Low-level API","title":"FrameTransformations.Frames.axes_name","text":"axes_name(axes::AbstractFrameAxes)\n\nReturn the name of axes.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.axes_id","page":"Low-level API","title":"FrameTransformations.Frames.axes_id","text":"axes_id(axes::AbstractFrameAxes)\n\nReturn the ID associated to axes.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.build_axes","page":"Low-level API","title":"FrameTransformations.Frames.build_axes","text":"build_axes(frames, name, id, class, funs; parentid, dcm, cax_prop)\n\nCreate and add a FrameAxesNode to frames based on the input parameters. Current  supported classes are: :InertialAxes, :FixedOffsetAxes, :RotatingAxes, :ProjectedAxes,  :EphemerisAxes and :ComputableAxes.\n\nInputs\n\nframes – Target frame system \nname – Axes name, must be unique within frames \nid – Axes ID, must be unique within frames\nclass – Axes class.  \nfuns – FrameAxesFunctions object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of frames.\n\nKeywords\n\nparentid – Axes ID of the parent axes. Not required only for the root axes.\ndcm – DCM with respect to the parent axes. Required only for FixedOffsetAxes. \ncax_prop – ComputableAxesProperties, required only by ComputableAxes.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see add_axes_inertial!, add_axes_rotating!,  add_axes_computable!, add_axes_fixedoffset! and add_axes_projected!.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.ComputableAxesProperties","page":"Low-level API","title":"FrameTransformations.Frames.ComputableAxesProperties","text":"ComputableAxesProperties\n\nStore the properties required to retrieve all the vectors required by   a computable set of axes. \n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#Points","page":"Low-level API","title":"Points","text":"","category":"section"},{"location":"Modules/frames_lapi/","page":"Low-level API","title":"Low-level API","text":"Frames.AbstractFramePoint\nFrames.FramePointNode\n\nFrames.point_name\nFrames.point_id \n\nFrames.build_point\n\nFrames._get_comp_axes_vector3\nFrames._get_comp_axes_vector6\nFrames._get_comp_axes_vector9\nFrames._get_comp_axes_vector12\n","category":"page"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.AbstractFramePoint","page":"Low-level API","title":"FrameTransformations.Frames.AbstractFramePoint","text":"AbstractFramePoint\n\nAbstract type for all reference frames points.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.FramePointNode","page":"Low-level API","title":"FrameTransformations.Frames.FramePointNode","text":"FramePointNode{O, T, N} <: AbstractJSMDGraphNode\n\nDefine a frame system point.\n\nFields\n\nname – point name \nclass – Symbol representing the class of the point \naxesid – ID of the axes in which the point coordinates are expressed \nparentid – NAIF ID of the parent point \nNAIFId – NAIF ID of the point\nstv – vector storing the point state vectors\nepochs – vector storing the epochs associated to stv\nnzo – last order at which stv has been computed \nf – FramePointFunctions container \n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.point_name","page":"Low-level API","title":"FrameTransformations.Frames.point_name","text":"point_name(point::AbstractFramePoint)\n\nReturn the name of point.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.point_id","page":"Low-level API","title":"FrameTransformations.Frames.point_id","text":"point_id(point::AbstractFramePoint)\n\nReturn the NAIF ID associated to point.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.build_point","page":"Low-level API","title":"FrameTransformations.Frames.build_point","text":"build_point(frames, name, NAIFId, class, axesid, funs; parentid, offset)\n\nCreate and add a FramePointNode to frames based on the input parameters.  Current supported point classes are: :RootPoint, :TimePoint, :EphemerisPoint, :FixedPoint and :UpdatablePoint.\n\nInputs\n\nframes – Target frame system \nname – Point name, must be unique within frames \nNAIFId – Point NAIF ID, must be unique within frames\nclass – Point class. \naxesid – ID of the axes in which the state vector of the point is expressed. \nfuns – FramePointFunctions object storing the functions to update the state            vectors of the point. It must match the type and order of frames\n\nKeywords\n\nparentid – NAIF ID of the parent point. Not required only for the root point.\noffset – Position offset with respect to a parent point. Required only for FixedPoints.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see add_point_ephemeris!, add_point_fixed!, etc...\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector3","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector3","text":"_get_comp_axes_vector3(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 3-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position\n2: velocity\n3: acceleration \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector6","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector6","text":"_get_comp_axes_vector6(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 6-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position, velocity\n2: velocity, acceleration\n3: acceleration, jerk\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector9","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector9","text":"_get_comp_axes_vector9(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 9-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position, velocity, acceleration\n2: velocity, acceleration, jerk\n\nwarning: Warning\nThis function does not support orders of `v' higher than 2, because it would  require the computation of vectors of order 5, which is currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector12","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector12","text":"_get_comp_axes_vector12(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 12-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position, velocity, acceleration, jerk\n\nwarning: Warning\nThis function does not support orders of `v' higher than 1, because it would  require the computation of vectors of order 5 and 6, which are currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#Two-Vectors","page":"Low-level API","title":"Two Vectors","text":"","category":"section"},{"location":"Modules/frames_lapi/","page":"Low-level API","title":"Low-level API","text":"Frames.twovectors_to_dcm \nFrames.twovectors_to_δdcm \nFrames.twovectors_to_δ³dcm \nFrames.twovectors_to_δ²dcm\n\nFrames._twovectors_to_dcm \nFrames._two_vectors_to_rot6\nFrames._two_vectors_to_rot9\nFrames._two_vectors_to_rot12\nFrames._two_vectors_basis\n","category":"page"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_dcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_dcm","text":"twovectors_to_dcm(a, b, seq)\n\nGenerate a direction cosine matrix from two time-dependent vectors a and b,  following the directions specified in seq. \n\nInputs\n\na – The primary vector that will be aligned with the first directions specified in seq. \nb – The secondary vector. The component of this vector that is orthogonal to the         primary vector is aligned with the second direction specified in the sequence seq.\nseq – Accepted sequence directions are:       :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\nwarning: Warning\nThe primary and secondary vectors do not have to be orthogonal. However, a great loss of precision happens when the two vectors are almost aligned. This function does not perform  any check on the angular separation of the two vectors. The user should ensure that the  primary and secondary vector differ of at least 1 milliradian.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δdcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δdcm","text":"twovectors_to_δdcm(a, b, seq)\n\nCompute the time derivative of a direction cosine matrix generated from two time-dependent  state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 6-elements state vectors (position and velocity).\nseq – Accepted sequence directions are:       :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ³dcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ³dcm","text":"twovectors_to_δ³dcm(a, b, seq)\n\nCompute the 3rd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 12-elements state vectors (position, velocity, acceleration and jerk).\nseq – Accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ²dcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ²dcm","text":"twovectors_to_δ²dcm(a, b, seq)\n\nCompute the 2nd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 9-elements state vectors (position velocity and acceleration).\nseq – Accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._twovectors_to_dcm","page":"Low-level API","title":"FrameTransformations.Frames._twovectors_to_dcm","text":"_twovectors_to_dcm(a, b, seq::Symbol, fc::Function, fn::Function, fk::Function)\n\nGenerate a direction cosine matrix and/or its time derivatives from the vectors a and b,  according to the directions specifeid in seq. \n\nNotes\n\nfc and fn are used to control the derivative order. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot6","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot6","text":"_two_vectors_to_rot6(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and time-derivative, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δdcm for more information. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot9","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot9","text":"_two_vectors_to_rot9(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and its 1st and 2nd-order time-derivatives, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δ²dcm for more information. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot12","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot12","text":"_two_vectors_to_rot12(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and its 1st, 2nd and 3r-order time-derivatives, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δdcm for more information. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_basis","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_basis","text":"_two_vectors_basis(a, b, seq::Symbol, fc::Function, fk::Function)\n\nGenerate a 3D right-handed orthogonal vector basis and/or its time derivatives from the  vectors a and b, according to the directions specified in seq and the input cross  function fc. fk is a function that filters a to guarantee type-stability.\n\nThe accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\nThe standard basis, its 1st, 2nd-order and 3rd order time derivatives can be computed by  passing cross, cross6, cross9 or cross12 to fc. The returned vectors will have  a length of 3, 6 or 9, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"EditURL = \"../e01_cr3bp.jl\"","category":"page"},{"location":"Examples/gen/e01_cr3bp/#example_01_cr3bp","page":"CR3BP","title":"Use Case: CR3BP","text":"","category":"section"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"This example was generated on 2024-01-05T08:58:22.071.","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"The power of the FrameSystem is its capability to handle axes transformations and point translations of both high-accuracy and simplified models. The use-case here presented includes the case of the Circular-Restricted Three-Body Problem (CR3BP) rotating frame transformation handling.","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"In particular, when dealing with the CR3BP, mission analysis are used to exploit non-dimensional, rotating coordinates to express the equations of motion and perform the computations.","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"In this tutorial, we create a FrameSystem to handle transformations within the Earth-Moon CR3BP, which is characterized by a mass ratio of approximately μ = 0.012. We start off by creating a frame system without any ephemeris provider, since we are using a simplified model.","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"using FrameTransformations\n\nCR3BP = FrameSystem{2, Float64}()","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"As always, the first step requires the definition of the root axes and points. In this case, we use the a generic set of inertial axes and the Earth-Moon Barycenter (EMB).","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"@axes InertialAx 1 InertialFrame\n\nadd_axes_inertial!(CR3BP, InertialAx)\n\n@point EMBc 1 EarthMoonBarycenterCr3bp\n\nadd_point_root!(CR3BP, EMBc, InertialAx)","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"We now proceed to add our synodic axes: in the CR3BP these are uniformly rotating with respect to the InertialAx about the Z-axis. Therefore, we leverage the rotating axes type:","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"using ReferenceFrameRotations\n\nf(t) = angle_to_dcm(t, :Z)\n\n@axes SynodicAx 2 SynodicFrame\n\nadd_axes_rotating!(CR3BP, SynodicAx, InertialAx, f)","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"Note that there is no need to specify the rotation derivatives, as they'll be computed by  automatic differentiation via the ForwardDiff package. For performace-critical transformations, however, it is reccomended to manually define these derivatives.","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"Now, let's assume we have our spacecraft. Most likely, its states will be expressed in the synodic frame. In this case, we leverage updatable points, since we desire to manually update its state at each time.","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"@point Spacecraft -1_900_000\n\nadd_point_updatable!(CR3BP, Spacecraft, EMBc, SynodicAx)","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"We know assume that at t = 0.8 our spacecraft is at L4, therefore we update its state accordingly:","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"μ = 0.012\nxL4 = [1/2-μ, sqrt(3)/2, 0.0, 0.0, 0.0, 0.0]\nt = 0.8\n\nupdate_point!(CR3BP, Spacecraft, xL4, t)","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"Finally we can retrieve the spacecraft state in both the synodic as well as the inertial axes:","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"vector6(CR3BP, EMBc, Spacecraft, SynodicAx, t)","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"vector6(CR3BP, EMBc, Spacecraft, InertialAx, t)","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"","category":"page"},{"location":"Examples/gen/e01_cr3bp/","page":"CR3BP","title":"CR3BP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"EditURL = \"../t01_axes.jl\"","category":"page"},{"location":"Tutorials/gen/t01_axes/#tutorial_01_axes","page":"02 - Axes","title":"Axes Creation and Rotations","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"This example was generated on 2024-01-05T08:58:22.048.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"To compute relative orientations, FrameTransformations provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the FrameSystem In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"At the time being, the following types of axes are supported:","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Inertial axes: these are the only ones which can be used as root axes to initialise the axes graph.\nFixed offset axes: they have a constant orientation with respect to their parent axes.\nRotating axes: the orientation of these axes depends only on time and is computed t through the custom functions provided by the user\nComputable axes: they are computed through two vectors that are defined within the frame system itself. Computable axes are the equivalent of SPICE's parameterized two-vector frames.\nProjected axes: the orientation of these axes depends only on time and is computed through the custom functions provided by the user. Projected axes are similar to rotating axis, except that all the positions, velocity, etc ... are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null, despite the rotation depends on time).\nEphemeris axes: these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nThis package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g., add_axes_eclipj2000!.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Before diving into the creation of the axes graph, it is worth highlighting that transformations that express the relative orientation or its time-derivatives between two generic set of axes are represented by a Rotation object, which stores a Direction Cosine Matrix (DCM) and its derivatives. This package leverages the already available ReferenceFrameRotations.jl to define the DCM objects.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"A time-fixed rotation between two axes and its derivative can then be expressed as follows:","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nusing ReferenceFrameRotations\n\ndcm  = angle_to_dcm(π/3, :Z)\nδdcm = DCM(0I)\n\nR = Rotation(dcm, δdcm)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"A rotation object is returned by all the rotation functions that are applied to the FrameSystem. It provide overloads to the basic algebraic operations so that multiplication and inversions can be efficiently computed leveraging the properties of rotation matrixes. For example, to rotate a generic vector v, we can simply do:","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"v = [1., -6., 3., 0., 5., 0]\nR*v","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"The inverse can instead be taken as:","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"inv(R)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"See the Rotation API for more information on this object.","category":"page"},{"location":"Tutorials/gen/t01_axes/#Graph-Initialisation","page":"02 - Axes","title":"Graph Initialisation","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon's Principal Axes (PA) 440,  whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, we will use our own  Ephemerides.jl package and download the kernels from NAIF's website.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using Ephemerides\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([download(url_spk), download(url_pck)])\n\nG = FrameSystem{3, Float64}(eph)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"To initialise the axes computational graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Before registering the axes, the @axes macro is used to define an acronym, an ID and a name of each set of axes that we wish to register in the system. If a name is not provided, a default one is used. In this example, we will use the ICRF as our base root inertial axes.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes ICRF 1 InternationalCelestialReferenceFrame\n\nadd_axes_inertial!(G, ICRF)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Once a set of root axes has been registered, any other type of axes can be added to the system.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nFor standard applications, it is good practice that the axes's IDs are as in agreement with NAIF's numbering system. A list of IDs for the most common axes is provided in the Orient submodule.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nThe frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the axes are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. For instance, one could register a set of rotating axes named ICRF.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we register the ECLIPJ2000 as a set of inertial axes with respect to the ICRF. Since the set of root axes has already been defined, all the future usages of the add_axes_inertial! function require a parent set of axes and a DCM with the relative orientation.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes ECLIPJ2000 17\n\nadd_axes_inertial!(G, ECLIPJ2000; parent=ICRF, dcm=DCM_ICRF_TO_ECLIPJ2000)\n\nR = rotation6(G, ICRF, ECLIPJ2000, 10.0)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Notice that we leveraged the default DCM provided by Orient's to express the relative orientation between the ICRF and the ECLIPJ2000. For a set of default DCM exported by Orient, check the API documentation. Additionally, since it is an inertial frame, the time derivative of the rotation is null.","category":"page"},{"location":"Tutorials/gen/t01_axes/#Fixed-offset-Axes","page":"02 - Axes","title":"Fixed-offset Axes","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation  with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we register FO1 as a set of axes with a fixed rotation of π/4 around the Z-axis with respect to the ICRF.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes FO1 2\n\nrot = angle_to_dcm(π/4, :Z)\n\nadd_axes_fixedoffset!(G, FO1, ICRF, rot)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"The state rotation matrix can then be obtained as:","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R = rotation6(G, ICRF, FO1, 86400)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Since FO1 has a constant orientation with respect to the ICRF, the time derivative of the rotation matrix R[2] is infact null. For further information see the add_axes_fixedoffset! documentation.","category":"page"},{"location":"Tutorials/gen/t01_axes/#rot_axes","page":"02 - Axes","title":"Rotating Axes","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from the ReferenceFrameRotations.jl package.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes RotAx 3\n\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(G, RotAx, FO1, fun)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"If we now compute the orientation between the ICRF and RotAx at π/4 we obtain an identity rotation, since the orientation of RotAx is directed in the opposite direction of FO1.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R1 = rotation6(G, ICRF, RotAx, π/4)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R1[1]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R2 = rotation6(G, ICRF, RotAx, π/2)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R2[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of fun. This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example:","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using JSMDUtils.Math\n\n@axes RotAx2 4\n\nfun(t) = angle_to_dcm(-t, :Z)\ndfun(t) = (angle_to_dcm(-t, :Z), Math.angle_to_δdcm([-t, -1], :Z))\n\nadd_axes_rotating!(G, RotAx2, FO1, fun, dfun)\n\nR2 = rotation6(G, ICRF, RotAx2, π/2)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R2[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"We can see the results are in agreement with the previous example. For more details, see add_axes_rotating! documentation.","category":"page"},{"location":"Tutorials/gen/t01_axes/#Projected-Axes","page":"02 - Axes","title":"Projected Axes","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Projected axes are a particular type of inertial axes. In this case the rotation is built by means of a time dependant function f(t). However, all the derivatives of f(t) are assumed to be zero. This axes type is usually used to build True-of-Date (TOD) axes sets.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we illustrate this difference by registering two new set of axes with the same relative orientation with respect to the ICRF, one rotating and one projected.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes ProjAx 500\n@axes RotAx3 501\n\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(G, RotAx3, ICRF, fun)\nadd_axes_projected!(G, ProjAx, ICRF, fun)\n\nR1 = rotation6(G, ICRF, RotAx3, 50.0)\nR2 = rotation6(G, ICRF, ProjAx, 50.0)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R1[1] - R2[1]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R1[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R2[2]","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"As you can see, while the relative orientation R[1] is equal, the time-derivative of the projected-axes orientation is null. For further information see the add_axes_projected! documentation.","category":"page"},{"location":"Tutorials/gen/t01_axes/#Computable-Axes","page":"02 - Axes","title":"Computable Axes","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Computable axes are a kind of time-dependant axes. In this case, differently from the rotating axes, the axes and their derivatives are computed through two time-dependant vectors which are expressed using any type of point that is registered in the system. These axes are the equivalent of SPICE's two-vector frames.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we will register two ephemeris points, the Solar system barycenter and the Sun. For more information on how this operation is performed, see the points tutorial. The two vectors that generate the set of computable axes are defined with the ComputableAxesVector object, by specifing the vector center and target point and its order, i.e., whether we are interested in the position, velocity or acceleration of that vector. A symbol is used to specify which direction the vectors have to align with.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, the axes are constructed with the X-axis parallel to the instantaneous SSB to Sun direction, whereas the secondary vector is chosen parallel to the SSB to Sun velocity vector (order 2). Then, the component of this vector orthogonal to the X-axis is used to create the Y-axis.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes SunFrame 600\n\n@point SSB 0 SolarSystemBarycenter\n@point Sun 10 SunPoint\n\nadd_point_root!(G, SSB, ICRF)\nadd_point_ephemeris!(G, Sun)\n\nv1 = ComputableAxesVector(Sun, SSB, 1)\nv2 = ComputableAxesVector(Sun, SSB, 2)\n\nadd_axes_computable!(G, SunFrame, ICRF, v1, v2, :XY)\n\nR = rotation6(G, ICRF, SunFrame, 0.0)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"For further information see the add_axes_computable! documentation.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nThe center and target point can either be specified with their integer IDs or their name aliases.","category":"page"},{"location":"Tutorials/gen/t01_axes/#Ephemeris-Axes","page":"02 - Axes","title":"Ephemeris Axes","text":"","category":"section"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth's ITRF.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nTo properly compute the orientation of these axes, the FrameSystem object must contain an ephemeris provider that has loaded the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, the ephemeris provider eph in the frame system G has loaded the DE421 PCK kernel containing the orientation of the Moon's Principal Axes (PA421). NAIF's system has assigned to such set of axes the ID 31006. If a different ID was assigned to the MoonPA, the function would have thrown an error. A set of default axes IDs is also defined within the Orient's submodule for ease of use.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes MoonPA 31006\n\nadd_axes_ephemeris!(G, MoonPA, :ZXZ)\n\nR = rotation9(G, ICRF, MoonPA, 86400.0)","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"For further information see the add_axes_ephemeris! documentation.","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"","category":"page"},{"location":"Tutorials/gen/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"EditURL = \"../t04_lighttime.jl\"","category":"page"},{"location":"Tutorials/gen/t04_lighttime/#tutorial_04_lighttime","page":"05 - Light Time Corrections","title":"Light Time Corrections","text":"","category":"section"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"This example was generated on 2024-01-05T08:58:22.062.","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"In this tutorial we will explore FrameTransformations.jl capabilities to account for aberration corrections when computing the relative position and velocity between two points. Indeed, this package is capable of replicating all of SPICE's aberration correction features.","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"Assuming we are in the Reception case, in which photons depart from the target's location at the light-time correted epoch et-lt and arrive at the observer's location at et, the following corrections are available:","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"One-way Light Time: it provides the position of the target at the moment it emitted photons arriving at the observer at et.\nStellar Aberration: it corrects for one-way light time aswell as stellar aberration by modifiying the relative position to account for the observer's velocity relative to the solar system barycenter. The output is the apparent position of the target as seen by the observer.","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"For a more detailed overview of this concepts, please refer to the original SPICE documentation.","category":"page"},{"location":"Tutorials/gen/t04_lighttime/#One-way-Light-Time","page":"05 - Light Time Corrections","title":"One-way Light Time","text":"","category":"section"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"note: Note\nWork in progress","category":"page"},{"location":"Tutorials/gen/t04_lighttime/#Stellar-Aberration","page":"05 - Light Time Corrections","title":"Stellar Aberration","text":"","category":"section"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"note: Note\nWork in progress","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"","category":"page"},{"location":"Tutorials/gen/t04_lighttime/","page":"05 - Light Time Corrections","title":"05 - Light Time Corrections","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Modules/orient_lapi/#low_orient_api","page":"Low-level API","title":"Orient's Low-level API","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Although this routines are not meant to be used outside of the package, they are here documented to aid future developments or to help users that require specific computations.","category":"page"},{"location":"Modules/orient_lapi/#Outdated-IAU-Models","page":"Low-level API","title":"Outdated IAU Models","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.iau1980","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.iau1980","page":"Low-level API","title":"FrameTransformations.Orient.iau1980","text":"iau1980\n\nThe singleton instance of type IAU1980, representing the IAU 1980 family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_lapi/#Fundamental-Arguments","page":"Low-level API","title":"Fundamental Arguments","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.FundamentalArguments\nOrient.LuniSolarArguments\nOrient.PlanetaryArguments\nOrient.fa_mano_moon\nOrient.fa_mano_sun\nOrient.fa_mlon_moon\nOrient.fa_mlat_moon\nOrient.fa_melo_moon\nOrient.fa_precession\nOrient.fa_mlon_mercury\nOrient.fa_mlon_venus\nOrient.fa_mlon_earth\nOrient.fa_mlon_mars\nOrient.fa_mlon_jupiter\nOrient.fa_mlon_saturn\nOrient.fa_mlon_uranus\nOrient.fa_mlon_neptune","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.FundamentalArguments","page":"Low-level API","title":"FrameTransformations.Orient.FundamentalArguments","text":"FundamentalArguments{N <: Number}\n\nType storing the fundamental luni-solar and planetary arguments.\n\nFields\n\nMₐ – Mean anomaly of the Moon \nSₐ – Mean anomaly of the Sun\nuₘ – Mean longitude of the Moon minus mean longitude of the ascending node F\nDₛ – Mean elongation of the Moon from the Sun \nΩₘ – Mean longitude of the Moon's ascending node\nλ_Me – Mercury's mean heliocentric longitude\nλ_Ve – Venus's mean heliocentric longitude\nλ_Ea – Earth's mean heliocentric longitude\nλ_Ma – Mars's mean heliocentric longitude\nλ_Ju – Jupiter's mean heliocentric longitude\nλ_Sa – Saturn's mean heliocentric longitude\nλ_Ur – Uranus's mean heliocentric longitude\nλ_Ne – Neptune's mean heliocentric longitude\npₐ – General precession in longitude\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.LuniSolarArguments","page":"Low-level API","title":"FrameTransformations.Orient.LuniSolarArguments","text":"LuniSolarArguments(t::Number, m::IAUModel)\n\nCompute the fundamental (Delaunay) Luni-Solar arguments, in radians, associated to the  desired IAU model m, at time t expressed in TDB Julian centuries since J2000.\n\nThe returned values depend on the input model as follows: \n\nIAU2006A: the Delaunay expressions are taken from the IERS 2010 Conventions.\nIAU2000B: the expressions are taken from Simon et al. (1994), following ERFA's   implementation of nut00b.c\n\nOutputs\n\nMₐ – Mean anomaly of the Moon\nSₐ – Mean anomaly of the Sun\nuₘ – Mean longitude of the Moon minus mean longitude of the         ascending node F\nDₛ – Mean elongation of the Moon from the Sun\nΩₘ – Mean longitude of the Moon's ascending node\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nSimon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets.\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.PlanetaryArguments","page":"Low-level API","title":"FrameTransformations.Orient.PlanetaryArguments","text":"PlanetaryArguments(t::Number)\n\nCompute the fundamental planetary arguments and the general precession, in radians,  at time t expressed in TDB Julian centuries since J2000.\n\nOutputs\n\nλ☿ – Mercury's mean heliocentric longitude.\nλ♀ – Venus's mean heliocentric longitude.\nλe – Earth's mean heliocentric longitude.\nλ♂ – Mars's mean heliocentric longitude.\nλ♃ – Jupiter's mean heliocentric longitude.\nλ♄ – Saturn's mean heliocentric longitude.\nλ⛢ – Uranus's mean heliocentric longitude.\nλ♆ – Neptune's mean heliocentric longitude.\npλ – General precession in longitude.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_mano_moon","text":"fa_mano_moon(t::Number)\n\nReturn the mean anomaly of the Moon Mₐ, in radians, at time t expressed in TDB Julian  centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_sun","page":"Low-level API","title":"FrameTransformations.Orient.fa_mano_sun","text":"fa_mano_sun(t::Number)\n\nReturn the mean anomaly of the Sun Sₐ in radians, at time t expressed in TDB Julian  centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_moon","text":"fa_mlon_moon(t::Number)\n\nReturn the mean longitude of the Moon's ascending node Ω in radians, at time t expressed in TDB Julian centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlat_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlat_moon","text":"fa_mlat_moon(t::Number)\n\nReturn the mean longitude of the Moon minus the mean longitude of the ascending node F in radians, at time t expressed in TDB Julian centuries since J2000.  \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_melo_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_melo_moon","text":"fa_melo_moon(t::Number)\n\nReturn the mean elongation of the Moon from the Sun D in radians, at time t expressed in  TDB Julian centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_precession","page":"Low-level API","title":"FrameTransformations.Orient.fa_precession","text":"fa_precession(t::Number) \n\nReturn the general accumulated precession in longitude pₐ in radians, at time t  expressed in TDB Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mercury","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mercury","text":"fa_mlon_mercury(t::Number)\n\nReturn the mean heliocentric longitude of Mercury in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_venus","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_venus","text":"fa_mlon_venus(t::Number)\n\nReturn the mean heliocentric longitude of Venus in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_earth","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_earth","text":"fa_mlon_earth(t::Number)\n\nReturn the mean heliocentric longitude of Earth in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mars","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mars","text":"fa_mlon_mars(t::Number)\n\nReturn the mean heliocentric longitude of Mars in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_jupiter","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_jupiter","text":"fa_mlon_jupiter(t::Number)\n\nReturn the mean heliocentric longitude of Jupiter in radians, at time t expressed in TDB Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_saturn","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_saturn","text":"fa_mlon_saturn(t::Number)\n\nReturn the mean heliocentric longitude of Saturn in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_uranus","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_uranus","text":"fa_mlon_uranus(t::Number)\n\nReturn the mean heliocentric longitude of Uranus in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_neptune","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_neptune","text":"fa_mlon_neptune(t::Number)\n\nReturn the mean heliocentric longitude of Neptune in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#Precession","page":"Low-level API","title":"Precession","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.frame_bias\nOrient.fw_angles\nOrient.fw_matrix\nOrient.precession_angles\nOrient.precession_rate","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.frame_bias","page":"Low-level API","title":"FrameTransformations.Orient.frame_bias","text":"frame_bias(::IAU2000Model)\n\nCompute the frame bias components of the IAU 2000 precession-nutation models, in radians.\n\nNotes\n\nThe frame bias corrections in longitude and obliquity are required to correct for the  offset between the GCRS pole and the mean J2000 pole. They define, with respect  to the GCRS axes, a J2000 mean pole that is consistent with teh IAU 2000A precession-nutation  model. \nThe function also returns an offset in right ascension taken from Chapront et al. (2002), necessary to completely describe the frame bias, but that is not part of the original IAU  2000A model.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fw_angles","page":"Low-level API","title":"FrameTransformations.Orient.fw_angles","text":"fw_angles(m::IAU2006Model, t::Number)\n\nCompute the precession angles in radians, following the IAU 2006 Fukushima-Williams 4-angle  formulation at time t expressed in TT Julian centuries since J2000.\n\nOutputs\n\nγ – F-W 1st angle\nϕ – F-W 2nd angle\nψ – F-W 3rd angle   \nε – F-W 4th angle\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fw_matrix","page":"Low-level API","title":"FrameTransformations.Orient.fw_matrix","text":"fw_matrix(γ, ϕ, ψ, ε)\n\nForm the Nutation-Precession-Bias (NPB) rotation matrix given the Fukushima-Williams angles,  expressed in radians.\n\nThe present function can construct three different matrices depending on which angles are  supplied as arguments: \n\nNPB: To obtain the Nutation-Precession-Bias matrix, generate the four standard FW    precession angles (̄γ, ̄ϕ, ̄ψ, ϵₐ) then generate the nutation components Δψ and Δϵ and add them    to ̄ψ, ϵₐ. Finally, call the present functions using those four angles as arguments. \nPB: To obtain the precession-frame bias matrix, generate the four standard FW precession    angles and call the present function. \nB: To obtain the frame bias matrix, generate the four standard FW precession angles at    date J2000.0 and call this function.\n\nThe remaining nutation-only and precession only matrices can be obtained by combining these  three appropriately. \n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.precession_angles","page":"Low-level API","title":"FrameTransformations.Orient.precession_angles","text":"precession_angles(m::IAU1980Model, t::Number)\n\nCompute the precession angles from Lieske et al. 1977 model, in radians, at time t  expressed in TT Julian centuries since J2000.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.precession_rate","page":"Low-level API","title":"FrameTransformations.Orient.precession_rate","text":"precession_rate(m::IAU2000Model, t::Number)\n\nCompute the precession-rate part of the IAU 2000 precession-nutation models, in radians, at  time t expressed as TT Julian centuries since J2000.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#IERS-Routines","page":"Low-level API","title":"IERS Routines","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.bpn2xy\nOrient.cip_coords\nOrient.cio_locator\nOrient.cip_motion\nOrient.earth_rotation_angle\nOrient.earth_rotation_rate \nOrient.equinoxes_equation\nOrient.era_rotm\nOrient.fw2xy\nOrient.origins_equation\nOrient.tio_locator\nOrient.polar_motion\nOrient.xys2m\nOrient.ecliptic_pole\nOrient.cip","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.bpn2xy","page":"Low-level API","title":"FrameTransformations.Orient.bpn2xy","text":"bpn2xy(A::AbstractMatrix)\n\nCompute the CIP X and Y coordinates from the bias-precession-nutation matrix, in radians.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cip_coords","page":"Low-level API","title":"FrameTransformations.Orient.cip_coords","text":"cip_coords(m::IAUModel, t::Number)\n\nComputes the CIP X, Y coordinates, in radians, according to the IAU model m at time t  expressed in TT Julian Centuries since J2000.\n\nThis function has been implemented for the IAU2000, IAU2006 and the CPN models.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cio_locator","page":"Low-level API","title":"FrameTransformations.Orient.cio_locator","text":"cio_locator(m::IAUModel, t::Number, x::Number, y::Number)\n\nCompute the CIO Locator s in radians, according to the IAU Model m, given the CIP  coordinates X and Y at time t expressed in TT Julian centuries since J2000\n\nThe function has been implemented for the IAU2000, IAU2006 and the CPN models.\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\nERFA library\nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cip_motion","page":"Low-level API","title":"FrameTransformations.Orient.cip_motion","text":"cip_motion(m::IAUModel, t::Number, dx::Number=0.0, dy::Number=0.0)\n\nCompute the CIRS to GCRS rotation matrix, according to the IAU Model m, at time t expressed in TT Julian centuries since J2000. Optional IERS corrections for  free-core nutation and time depedented effects can be provided through dx and dy. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_angle","page":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_angle","text":"earth_rotation_angle(t::Number)\n\nCompute the Earth Rotation Angle (ERA) in radians, i.e., the angle between the Celestial  Intermediate Origin (CIO) and the Terrestrial Intermediate Origin (TIO) at time t  expressed as UT1 days since J2000.\n\nnote: Note\nThe function uses the fractional UT1 date to gain additional precision in the  computations (0.002737.. instead of 1.002737..)\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_rate","page":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_rate","text":"earth_rotation_rate()\n\nCompute the nominal Earth angular velocity. \n\n\n\n\n\nearth_rotation_rate(LOD::Number)\n\nCompute the true angular velocity of the Earth accounting for the Length of the Day, i.e.,  the instantaneous rate of change of UT1 with respect to a uniform time scale. \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.equinoxes_equation","page":"Low-level API","title":"FrameTransformations.Orient.equinoxes_equation","text":"equinoxes_equation(m::IAUModel, tt::Number)\n\nCompute the Equation of the Equinoxes, in radians, according to the IAU Model m given  time tt expressed in TT Julian centuries since J2000. \n\nThis function has been implemented for the IAU2006 and IAU2000 models.\n\nnote: Note\nThis function neglects the difference between TT and TDB.\n\nReferences\n\nERFA ee00a routine.\nERFA ee06a routine.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.era_rotm","page":"Low-level API","title":"FrameTransformations.Orient.era_rotm","text":"era_rotm(t::Number)\n\nCompute the TIRS to CIRS Earth Rotation matrix, according to the IERS 2010  conventions at time t expressed as UT1 days since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fw2xy","page":"Low-level API","title":"FrameTransformations.Orient.fw2xy","text":"fw2xy(ϵ::Number, ψ::Number, γ::Number, φ::Number)\n\nCompute the CIP X and Y coordinates from Fukushima-Williams bias-precession-nutation  angles, in radians.\n\nInputs\n\nϵ – F-W angle with IAU 2006A/B nutation corrections. \nψ – F-W angle with IAU 2006A/B nutation corrections.\nγ – F-W angle  \nϕ – F-W angle\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.origins_equation","page":"Low-level API","title":"FrameTransformations.Orient.origins_equation","text":"origins_equation(m::IAU2006Model, t::Number)\n\nCompute the Equation of the Origins (EO), in radians, following the IAU2006 precession and  IAU2000A nutation models, given time t expressed in TT Julian centuries since J2000.0. \n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA eo06a routine.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.tio_locator","page":"Low-level API","title":"FrameTransformations.Orient.tio_locator","text":"tio_locator(t::Number)\n\nCompute the TIO locator s' at date, positioning the Terrestrial Intermediate Origin on  the equator of the Celestial Intermediate Pole (CIP) at time t expressed as TT Julian  centuries since J2000. \n\nThis function approximates the unpredictable motion of the TIO locator s' with its secular  drift of ~0.47 μas/century. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nLambert, S. and Bizouard C. (2002), Positioning the Terrestrial Ephemeris Origin in the  Terrestrial Reference Frame, DOI: 10.1051/0004-6361:20021139\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.polar_motion","page":"Low-level API","title":"FrameTransformations.Orient.polar_motion","text":"polar_motion(t::Number, xₚ::Number, yₚ::Number)\n\nCompute the Polar Motion rotation matrix from ITRF to TIRS, according to the  IERS 2010 Conventions, at time t expressed in TT Julian centuries since J2000.  The function requires xp and yp, the Celestial Intermediate Pole (CIP) coordinates with  respect to the International Celestial Reference Frame (ITFR).\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.xys2m","page":"Low-level API","title":"FrameTransformations.Orient.xys2m","text":"xys2m(x::Number, y::Number, s::Number)\n\nCompute the Intermediate-to-Celestial matrix given the CIP x, y' coordinates and the CIO  locators`, all in radians.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.ecliptic_pole","page":"Low-level API","title":"FrameTransformations.Orient.ecliptic_pole","text":"ecliptic_pole(m::IAU2006Model, t::Number)\n\nComputes ecliptic pole of date in ICRF.\n\nWallace, P. T., & Capitaine, N. (2006). Precession-nutation procedures consistent with IAU \n\n2006 resolutions. Astronomy & Astrophysics, Eq. 20.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cip","page":"Low-level API","title":"FrameTransformations.Orient.cip","text":"cip(m::IAUModel, t::Number)\n\nCompute Celestial Intermediate Pole vector.\n\nWallace, P. T., & Capitaine, N. (2006). Precession-nutation procedures consistent with IAU \n\n2006 resolutions. Astronomy & Astrophysics.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#EOP-Data","page":"Low-level API","title":"EOP Data","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.EOPData\nOrient.EOPInterpolator\nOrient.IERS_EOP_DATA\nOrient.set_eop_data\nOrient.read_iers_eop_finals \nOrient.read_eop \nOrient.offset_utc2ut1","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.EOPData","page":"Low-level API","title":"FrameTransformations.Orient.EOPData","text":"EOPData{T}\n\nEOP Data for IAU 2000A.\n\nFields\n\nfilename : File where the EOP data are stored. \nj2000 : Independent valiable - time - in UTC.\nj2000_TT : Independent valiable - time - in TT.\nx, y: Polar motion with respect to the crust (arcsec).\nUT1_UTC: Irregularities of the rotation angle (s).\nUT1_TT: Irregularities of the rotation angle (s) w.r.t. TT timescale.\nLOD: Length of day offset (ms).\ndX, dY: Celestial pole offsets referred to the model IAU2000A (milliarcsec).\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.EOPInterpolator","page":"Low-level API","title":"FrameTransformations.Orient.EOPInterpolator","text":"EOPInterpolator{T}\n\nEOP Data for IAU 2000A.\n\nFields\n\ninit: A flag indicating whether the EOPInterpolator has been initialized.\nj2000: Independent variable (time), in UTC.\nj2000_TT: Independent variable (time), in TT.\nx, y: Polar motion with respect to the crust (arcsec).\nUT1_UTC: Irregularities of the rotation angle (s).\nUT1_TT: Irregularities of the rotation angle (s) with respect to TT timescale.\nLOD: Length of day offset (ms).\ndX, dY: Celestial pole offsets referred to the model IAU2000A (milliarcsec).\nx_TT, y_TT: Polar motion with respect to the crust (arcsec) parametrized by TT epoch.\nUT1_TT: Irregularities of the rotation angle (s) parametrized by TT epoch.\nLOD_TT: Length of day offset (ms) parametrized by TT epoch.\ndX_TT, dY_TT: Celestial pole offsets referred to the model IAU2000A (milliarcsec) parametrized by TT epoch.\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.IERS_EOP_DATA","page":"Low-level API","title":"FrameTransformations.Orient.IERS_EOP_DATA","text":"IERS_EOP_DATA\n\nEarth Orientation Parameters Data: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values at 1-day  intervals) with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014.\n\nSee also: EOPData\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.set_eop_data","page":"Low-level API","title":"FrameTransformations.Orient.set_eop_data","text":"set_eop_data(filename)\n\nSet Earth Orientation Parameters (EOP) to be used for frames transformations from JSMD  .eop.dat file.  \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.read_iers_eop_finals","page":"Low-level API","title":"FrameTransformations.Orient.read_iers_eop_finals","text":"read_iers_eop_finals(filename::AbstractString)\n\nRead IERS EOP C04 files in csv format.\n\nReturns\n\nj2000_utc: Julian days since J2000 in UTC.\nj2000_tt: Julian days since J2000 in TT (Terrestrial Time).\nx_pole: Celestial pole offset in the X direction (arcsec).\ny_pole: Celestial pole offset in the Y direction (arcsec).\nut1_utc: UT1-UTC time difference (s).\nut1_tt: UT1-TT time difference (s).\nlod: Length of Day (s).\ndX: Celestial pole offset rate in the X direction (milliarcsec).\ndY: Celestial pole offset rate in the Y direction (milliarcsec).\n\nThe function reads IERS EOP C04 files in CSV format and extracts relevant Earth Orientation  Parameters (EOP) data. It then updates predictions, filling missing values with zeros for  LOD, dX, and dY.  Finally, the function parametrizes EOP with respect to both UTC and TT time scales for  convenience.\n\nReferences\n\nhttps://maia.usno.navy.mil/ser7/readme.finals2000A\nhttp://hpiers.obspm.fr/eoppc/bul/bulb/explanatory.html\nhttps://maia.usno.navy.mil\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.read_eop","page":"Low-level API","title":"FrameTransformations.Orient.read_eop","text":"read_eop(filename)\n\nRead Earth Orientation Parameters (EOP) from JSMD .eop.dat file.  \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.offset_utc2ut1","page":"Low-level API","title":"FrameTransformations.Orient.offset_utc2ut1","text":"offset_utc2ut1(seconds)\n\nReturn the offset, in seconds, between UTC and UT1.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#Transformations","page":"Low-level API","title":"Transformations","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.orient_rot3_icrf_to_mod\nOrient.orient_rot3_icrf_to_tod\nOrient.orient_rot3_icrf_to_teme\nOrient.orient_rot3_mod_to_teme\nOrient.orient_rot3_itrf_to_pef\nOrient.orient_rot3_pef_to_tod\nOrient.orient_rot6_pef_to_tod\nOrient.orient_rot3_tod_to_mod\nOrient.orient_rot3_icrf_to_pef\nOrient.orient_rot6_icrf_to_pef","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_mod","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_mod","text":"orient_rot3_icrf_to_mod(tt::Number)\n\nCompute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Mean Equinox Mean Equator of Date at time tt, expressed in TT seconds since J2000.\n\nMean Equator Of Date is obtained applying frame bias and precession to the ICRF pole and origin. Fukushima-Williams parametrization for the equator and ecliptic precession is used.  Consistent with the IAU2006 precession model.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_tod","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_tod","text":"orient_rot3_icrf_to_tod(tt::Number; [m]::IAU2006Model=iau2006a)\n\nCompute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the True Equator of Date at time tt, expressed in TT seconds since J2000.\n\nTrue Equator of Date is obtained applying frame bias, precession and nutation to the ICRF  pole and origin.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_teme","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_teme","text":"orient_rot3_icrf_to_teme(tt::Number; [m]::IAUModel=iau2006a)\n\nCompute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the True Equator, Mean Equinox of date at time tt, expressed in TT seconds since J2000.\n\nSee also\n\nSee also orient_rot3_mod_to_teme and orient_rot3_icrf_to_mod.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_mod_to_teme","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_mod_to_teme","text":"orient_rot3_mod_to_teme(tt::Number; [m]::IAU2006Model=iau2006a)\n\nCompute the rotation matrix from the Mean Equator of Date (MOD) frame to the True Equator,  Mean Equinox of date at time tt, expressed in TT seconds since J2000.\n\nThis is implemented with a small angle approx of Eq. 4 of Vallado, \"Coordinate Frames of the  US Space Object Catalogs.\" \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_itrf_to_pef","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_itrf_to_pef","text":"orient_rot3_itrf_to_pef(t::Number)\n\nCompute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Pseudo-Earth Fixed Frame at time t, expressed in TT seconds since J2000.\n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\nSee also\n\nSee also IERS_EOP.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_pef_to_tod","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_pef_to_tod","text":"orient_rot3_pef_to_tod(tt::Number; [m]::IAUModel=iau2006a)\n\nCompute the rotation matrix from the Pseudo-Earth Fixed (PEF) to the True Equator of Date  (TOD) Frame at time tt, expressed in TT seconds since J2000.\n\nThis is using IAU-76/FK5 Reduction. This is a sidereal time only rotation. Eq. 3-80, Sec. 3.7.3 of Vallado (2013).\n\nSee also\n\nSee also orient_gast.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot6_pef_to_tod","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot6_pef_to_tod","text":"orient_rot6_pef_to_tod(tt::Number; [m]::IAUModel=iau2006a)\n\nCompute the rotation matrix and the derivative of the transformation from the Pseudo-Earth  Fixed (PEF) to the True Equator of Date (TOD) Frame at time tt, expressed in TT seconds  since J2000.\n\nThis is using IAU-76/FK5 Reduction. This is a sidereal time only rotation. Eq. 3-80, Sec. 3.7.3 of Vallado (2013).\n\nSee also\n\nSee also orient_rot3_pef_to_tod, orient_gast and IERS_EOP.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_tod_to_mod","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_tod_to_mod","text":"orient_rot3_tod_to_mod(tt::Number; [m]::IAU2006Model=iau2006a)\n\nCompute the rotation matrix from the True Equator of Date (TOD) to the Mean Equator of Date (MOD)  Frame at time tt, expressed in TT seconds since J2000.\n\nThis is using IAU-76/FK5 Reduction. This is a nutation only rotation. Eq. 3-86, Sec. 3.7.3 of Vallado (2013).\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_pef","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pef","text":"orient_rot3_icrf_to_pef(tt::Number; [m]::IAU2006Model=iau2006a)\n\nCompute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Pseudo Earth Fixed (PEF) Frame at time tt, expressed in TT seconds since J2000.\n\nSee also\n\nSee also orient_rot3_icrf_to_tod, orient_rot3_pef_to_tod and  orient_rot6_icrf_to_pef.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot6_icrf_to_pef","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot6_icrf_to_pef","text":"orient_rot6_icrf_to_pef(tt::Number; [m]::IAU2006Model=iau2006a)\n\nCompute the rotation matrix the derivative of the transformation from the International  Celestial Reference Frame (ICRF) to the Pseudo Earth Fixed (PEF) Frame at time tt,  expressed in TT seconds since J2000.\n\nSee also\n\nSee also orient_rot3_icrf_to_pef.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#Geodesy","page":"Low-level API","title":"Geodesy","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.geoc2pv \nOrient.pv2geoc","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.geoc2pv","page":"Low-level API","title":"FrameTransformations.Orient.geoc2pv","text":"geoc2pv(geoc::AbstractVector)\n\nTransform a spherical geocentric 6-elements state vector (radius, longitude, geocentric  latitude and their derivatives) into a cartesian 6-elements vector (position and velocity).\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.pv2geoc","page":"Low-level API","title":"FrameTransformations.Orient.pv2geoc","text":"pv2geoc(pv::AbstractVector)\n\nTransform a cartesian 6-elements state vector (position and velocity) into radius, longitude,  geocentric latitude and their derivatives, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#TPC-Parsing","page":"Low-level API","title":"TPC Parsing","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.TPC\nOrient.FilesIO.load\n","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.TPC","page":"Low-level API","title":"FrameTransformations.Orient.TPC","text":"TPC <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing TPC files.\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient_lapi/#JSMDInterfaces.FilesIO.load","page":"Low-level API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::TPC{1})\n\nOpen a JPL ASCII .tpc file and parse its data in a dictionary.\n\n\n\n\n\nload(files::TPC)\n\nOpen a group of JPL ASCII .tpc files and parse their data in a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/#Performance-Benchmarks","page":"Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"A comparative analysis of the execution times of various routines of this package against  other state-of-the-art packages and libraries is here reported. ","category":"page"},{"location":"benchmarks/#IERS-Rotation-Models","page":"Benchmarks","title":"IERS Rotation Models","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The Orient sub-module provides the capability to compute high-accuracy Earth rotation models based on the IERS 2010 conventions. However, differently from traditional packages, it leverages Julia's metaprogramming capabilities to generate optimised functions for the computation of the lengthy 2000A/B nutation series. A comparison against both ERFA.jl and SatelliteToolbox.jl is here reported.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/assets/85893254/1bbd17b6-c487-487a-8f24-99bc671eeabf\" width = \"512\" /> \n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: Details\nThese time benchmarks have been obtained on an Intel Core i7-6700 @ 3.4 GHz with 16 GB of RAM","category":"page"},{"location":"benchmarks/#Relative-Orientation","page":"Benchmarks","title":"Relative Orientation","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Frames' performance have been tested against both GODOT and SPICE.jl, two of the most-popular packages that can be used to define a system of reference axes and points and to compute the transformations between them. In particular, a comparative analysis of the execution times for computing the relative orientation between different reference axes has been carried out across four distinct scenarios: ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Case 1: From ICRF to the ECLIPJ2000 frame, a time-fixed rotation. \nCase 2: From the IAU-MOON to the ICRF, a time-dependent rotation. \nCase 3: From the IAU-MOON to the ICRF and subsequently to the IAU_EARTH. \nCase 4: From the IAU-MOON, to the ICRF, to the ECLIPJ2000 and finally a shift to the Sun-Earth rotating two-vector frame. Notice that the Sun and Earth positions are retrieved from binary ephemeris kernels.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/assets/85893254/c8688165-728b-4053-9912-f5ac973e892d\" width = \"512\" /> \n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: Details\nThese time benchmarks have been obtained on an Intel Core i7-12700 @ 4.7 GHz with 32 GB of RAM","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This figure also underlines the capability of FrameTransformations (here referred to as Multiverse) to use different ephemeris readers as backends within the computational graph.","category":"page"},{"location":"benchmarks/#Relative-States","page":"Benchmarks","title":"Relative States","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"note: Note\nWork in progress","category":"page"},{"location":"Tutorials/gen/t05_multithread/","page":"06 - Multithreading","title":"06 - Multithreading","text":"EditURL = \"../t05_multithread.jl\"","category":"page"},{"location":"Tutorials/gen/t05_multithread/#tutorial_05_threads","page":"06 - Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"Tutorials/gen/t05_multithread/","page":"06 - Multithreading","title":"06 - Multithreading","text":"This example was generated on 2024-01-05T08:58:22.066.","category":"page"},{"location":"Tutorials/gen/t05_multithread/","page":"06 - Multithreading","title":"06 - Multithreading","text":"note: Note\nWork in progress","category":"page"},{"location":"Tutorials/gen/t05_multithread/","page":"06 - Multithreading","title":"06 - Multithreading","text":"","category":"page"},{"location":"Tutorials/gen/t05_multithread/","page":"06 - Multithreading","title":"06 - Multithreading","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"EditURL = \"../e03_customorb.jl\"","category":"page"},{"location":"Examples/gen/e03_customorb/#example_03_orb","page":"Custom Orbit Representation","title":"Use Case: Custom spacecraft orbit","text":"","category":"section"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"This example was generated on 2024-01-05T08:58:22.080.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"Once the general structure of the FrameSystem is understood, we can pass to a use case in which we want to build and exploit our frame system to perform computations inserting a custom orbit. This becomes especially crucial in complex cases like Trajectory Optimization and Navigation Analysis.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"In such scenarios, the trajectory is under design, and the trajectory information might not be completely available. Moreover, in these cases derivatives could be required for various quantities such as time, states, and parameters.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"In this context, we shall remember that FrameTransformations is able to perform operations, including AD, on the frames independent variable, e.g. only time.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"A proper orbit representation is essential to avoid perturbation confusion and ensure proper custom orbit handling. For this purpose, two point types can seems suitable: updatable and dynamical points. In this case, however, updatable points are not well-suited as they are essentially constants for the AD system. Then, dynamical points can effectively handle this scenario.","category":"page"},{"location":"Examples/gen/e03_customorb/#Frame-system-setup","page":"Custom Orbit Representation","title":"Frame system setup","text":"","category":"section"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"First of all, a new FrameSystem shall be created.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"using FrameTransformations\n\nG = FrameSystem{4, Float64}()\n\nadd_axes_inertial!(G, :ICRF, 1)\nadd_point_root!(G, :Earth, 399, 1)","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"note: Note\nAs the orbit considered in this example is custom, there is no requirement to load ephemeris.","category":"page"},{"location":"Examples/gen/e03_customorb/#Custom-orbit-model","page":"Custom Orbit Representation","title":"Custom orbit model","text":"","category":"section"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"A custom orbit model is then required. In this case two dummy orbits are created and stored in a CubicSpline object.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"using JSMDInterfaces.Math: interpolate\nusing JSMDUtils.Math: InterpCubicSplines\n\nc = 2π/86400\nde = 0:3600:2*86400;\nfv(t) = [cos(c*t), sin(c*t), 0, -c*sin(c*t), c*cos(c*t), 0];\nfv2(t) = [sin(c*t), cos(c*t), 0];\nconst ORB1 = InterpCubicSplines(de, hcat([fv(e) for e in de]...));\nconst ORB2 = InterpCubicSplines(de, hcat([fv2(e) for e in de]...));\nnothing #hide","category":"page"},{"location":"Examples/gen/e03_customorb/#Custom-orbit-handling","page":"Custom Orbit Representation","title":"Custom orbit handling","text":"","category":"section"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"Given the custom orbit model, add_point_dynamical! could be used to link it to the frame system.","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"Insert dynamical points","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"add_point_dynamical!(G, :SC1, -1, 399, 1, t->interpolate(ORB1, t)[1:3], t->interpolate(ORB1, t))\nadd_point_dynamical!(G, :SC2, -2, 399, 1, t->interpolate(ORB2, t))","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"Once in the frame system, AD could be exploited to retrieve states+gradients w.r.t. time in any registered frame:","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"vector12(G, 399, -1, 1, 12345.0)","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"It is also possible to use the computational graph to compute quantities between completely custom states representations:","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"vector12(G, -1, -2, 1, 12345.0)","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"","category":"page"},{"location":"Examples/gen/e03_customorb/","page":"Custom Orbit Representation","title":"Custom Orbit Representation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"roadmap/#Development-Roadmap","page":"Roadmap","title":"Development Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"The following table reports the desired list of features considered in the development of  this package, together with their development status. The following color legend is used: ","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":" Description\n🔵 Stable, deeply tested\n🟢 Developed, working, partially tested\n🟡 In development\n🔴 Development not started but planned\n⚪ Outdated/no more supported","category":"page"},{"location":"roadmap/#Frames","page":"Roadmap","title":"Frames","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"All the initially desired features of Frames have been implemented. We are currently working  to avoid undesired allocations when using dual numbers.","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\" style=\"width:40%\">Feature</th>\n    <th class=\"tg-fymr\" style=\"width:10%\">Status</th>\n    <th class=\"tg-fymr\" style=\"width:50%\">Comment</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create a graph of custom points.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Points could be defined in different ways (not only associated to ephemeris).</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create a graph of custom axes.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Axes models for MEME2000, ITRF, IAU models and many others are already implemented and tested within FrameTransformationsFrameTransformations.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Get a state of a point relative to another in a custom frame.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against NAIF's SPICE.</td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">\n        Full compatibility with ForwardDiff.jl shall be assured.\n    </td>\n    <td class=\"tg-0pky\">🟡</td>\n    <td class=\"tg-0pky\">Partial compatibility is already available. We are resolving the \n    last issues related to undesired allocations when using dual numbers. </td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"roadmap/#Orient","page":"Roadmap","title":"Orient","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"All the features of the Orient submodule have been developed and tested. No major updates are currently foreseen.","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\" style=\"width:40%\">Feature</th>\n    <th class=\"tg-fymr\" style=\"width:10%\">Status</th>\n    <th class=\"tg-fymr\" style=\"width:50%\">Comment</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create IAU standard-based body-fixed rotation matrices.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against NAIF's SPICE.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create ITRF (IERS-based) rotation matrices.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against ERFA. Models with different precisions are available.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Fetch leapseconds files automatically.\n    </td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"EditURL = \"../t00_frames.jl\"","category":"page"},{"location":"Tutorials/gen/t00_frames/#tutorial_00_frames","page":"01 - Frame System","title":"Frame System Overview","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"This example was generated on 2024-01-05T08:58:21.990.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"The core object of FrameTransformations is the FrameSystem, which provides the capability to compute relative position, orientation and their time derivatives up to order 3 (jerk), between standard and user-defined point and axes. It works by creating two separate graphs that silently store and manage all the parent-child relationships between the user-registered axes and points, in the form of Frames.FramePointNode and Frames.FrameAxesNode.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"These two objects define two precise entities:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Axes: defines an orientation in space. These are related each other by means of a Rotation transformation which relate one axes to a parent axes in a certain time interval.\nPoints: defines a location in space. These are related each other by means of a Translation transformation which relate one point to a parent point in a particular axes in a certain time interval.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"note: Note\nA single FrameSystem instance simultaneously handles both the axes and point graphs, regardless of what the user registers in it. For instance, if no points are added, the point graph will remain empty.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Additionally, any node can have several childs, each with different transformations with respect to the parent node. Moreover, nodes can be created independenlty of each other (by means of the @axes, and @point macros). However, they shall be registered within the FrameSystem before being used in a transformation or as parents of other nodes.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"using FrameTransformations #hide","category":"page"},{"location":"Tutorials/gen/t00_frames/#Basic-Constructors","page":"01 - Frame System","title":"Basic Constructors","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"The creation of a generic FrameSystem requires the definition of the maximum desired transformation order and of its DataType, which in most applications is a Float64. The transformation order is always one greater than the maximum desired time derivative. For instance, if the user only desires to compute position and velocity components (i.e., order 1 time-derivative), the transformation order to be used is 2. Thus, the maximum allowed transformation order is 4.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"In this example, we highlight the most basic way to initialise a FrameSystem:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"F = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"From this example, you can see that within the frame system there are both point and axes graphs. However, at the moment they are completely empty since the graph was just created.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Each FrameSystem object is assigned a reference timescale that is used to perform computations with epochs and to parse ephemeris files. The default timescale is the BarycentricDynamicalTime, however, the user is free to select the most suited timescale for his applications. In this example, we set the InternationalAtomicTime as the reference scale.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"F = FrameSystem{2, Float64, InternationalAtomicTime}()","category":"page"},{"location":"Tutorials/gen/t00_frames/#Ephemerides-Support","page":"01 - Frame System","title":"Ephemerides Support","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"In certain scenarios, the transformations require usage of binary ephemeris kernels, e.g., the JPL's DE440 files. To support this applications, an ephemeris provider can be associated to a FrameSystem. Since this package leverages a set of standard interfaces, any ephemeris reader that exposes JSMD-compatible interfaces can be used as a backend in FrameTransformations. Currently, the only two supported readers are our own Ephemerides.jl or CalcephEphemeris.jl. Although the former only can only parse binary PCK/SPK kernels, it seamlessly integrates with ForwardDiff since it is completely written in Julia.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Once the desired ephemeris provider is created, it can be associated to the frame system object. However, in this case the reference timescale is retrieved from the ephemeris kernels and cannot be specified by the user. In this example we begin loading an old DE421 kernerl to pass to the ephemeris reader.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"using Ephemerides, Downloads\n\nurl = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(Downloads.download(url));\n\nF = FrameSystem{2, Float64}(eph)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"As you can see, the default NullEphemerisProvider has been replaced by the user-constructed one.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Modules/frames_api/#basic_frames_api","page":"Public API","title":"Frames's Public Documentation","text":"","category":"section"},{"location":"Modules/frames_api/#Frame-System","page":"Public API","title":"Frame System","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"FrameSystem","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.FrameSystem","page":"Public API","title":"FrameTransformations.Frames.FrameSystem","text":"FrameSystem{O, T, S, E}\n\nA FrameSystem instance manages a collection of user-defined FramePointNode and  FrameAxesNode objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order O, the outputs  datatype T and an AbstractTimeScale instance S. Additionally, an AbstractEphemerisProvider  instance E can be provided to compute transformations that require ephemeris data. \n\nThe following transformation orders are accepted: \n\n1: position \n2: position and velocity \n3: position, velocity and acceleration\n4: position, velocity, acceleration and jerk\n\nBy specifying the maximum transformation the FrameSystem memory usage and performance can  be optimised and tailored to the user's needs.\n\n\n\nFrameSystem{O, T}()\n\nCreate a FrameSystem object of order O and datatype T. The BarycentricDynamicalTime  is automatically assigned as the default time scale. The resulting object is constructed  with a NullEphemerisProvider, which does not allow the computation of transformation that  involve ephemeris files.\n\nExamples\n\njulia> F = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> rotation6(F, ICRF, ECLIPJ2000, 0.0)\nRotation{2, Float64}\n[...]\n\njulia> rotation9(F, ICRF, ECLIPJ2000, 0.0)\nERROR: Insufficient frame system order: transformation requires at least order 3.\n\n\n\n\nFrameSystem{O, T, S}()\n\nCreate a FrameSystem object of order O, datatype T and time scale S. The resulting  object is constructed with a NullEphemerisProvider, which does not allow the computation  of transformation that involve ephemeris files.\n\nExamples\n\njulia> F = FrameSystem{1, Float64, TerrestrialTime}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> ep_tt = Epoch(\"2023-02-10T12:00:00 TT\")\n2023-02-10T12:00:00.000 TT\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tt)\nRotation{1,Float64}([...])\n\njulia> ep_tdb = Epoch(\"2023-02-10T12:00:00 TDB\")\n2023-02-10T12:00:00.000 TDB\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tdb)\nERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.\n[...]\n\n\n\nFrameSystem{O, T}(eph::AbstractEphemerisProvider)\n\nCreate a FrameSystem object of order O and datatype T by providing an instance of an  AbstractEphemerisProvider subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in eph. This constructor shall be used when the user desires  to compute transformations that involve ephemeris data. \n\nnote: Note\nAll the kernels that will be used must be loaded within eph. Once the FrameSystem  has been created, no additional kernel can be added nor removed.\n\nExamples\n\njulia> using Ephemerides \n\njulia> eph = EphemerisProvider(DE440_KERNEL_PATH);\n\njulia> F = FrameSystem{2, Float64}(eph)\nFrameSystem{2, Float64, BarycentricDynamicalTime, EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n)\n\nSee also\n\nSee also add_axes_inertial!, add_point_root!, vector3 and rotation3\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_api/#Axes","page":"Public API","title":"Axes","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"@axes\naxes_alias\n\nis_inertial\nis_timefixed\n\nComputableAxesVector\n\nadd_axes_bci2000!\nadd_axes_bcrtod!\nadd_axes_computable!\nadd_axes_eclipj2000!\nadd_axes_ephemeris!\nadd_axes_fixedoffset!\nadd_axes_gcrf!\nadd_axes_inertial!\nadd_axes_icrf!\nadd_axes_itrf!\nadd_axes_me421!\nadd_axes_meme2000!\nadd_axes_mod!\nadd_axes_tod!\nadd_axes_teme!\nadd_axes_pef!\nadd_axes_pa421!\nadd_axes_pa440!\nadd_axes_projected!\nadd_axes_rotating!\nadd_axes_topocentric!\n","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.@axes","page":"Public API","title":"FrameTransformations.Frames.@axes","text":"@axes(name, id, type=nothing)\n\nDefine a new axes instance to alias the given id. This macro creates an  AbstractFrameAxes subtype and its singleton instance callen name. Its type name  is obtained by appending Axes to either name or type (if provided). \n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> typeof(ICRF)\nInternationalCelestialReferenceFrameAxes\n\njulia> axes_alias(ICRF) \n1\n\njulia> @axes IAU_EARTH 10013\n\njulia> typeof(IAU_EARTH)\nIauEarthAxes\n\nSee also\n\nSee also @point and axes_alias.\n\n\n\n\n\n","category":"macro"},{"location":"Modules/frames_api/#FrameTransformations.Frames.axes_alias","page":"Public API","title":"FrameTransformations.Frames.axes_alias","text":"axes_alias(ax::AbstractFrameAxes)\n\nReturn the axes ID. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.is_inertial","page":"Public API","title":"FrameTransformations.Frames.is_inertial","text":"is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)\nis_inertial(frame::FrameSystem, axesid::Int)\n\nReturn true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes.\n\nnote: Note\nFixedOffsetAxes with respect to an inertial set of axes, are also consired inertial.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.is_timefixed","page":"Public API","title":"FrameTransformations.Frames.is_timefixed","text":"is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)\nis_timefixed(frame::FrameSystem, axesid::Int)\n\nReturn true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes. \n\nnote: Note\nOnly :InertialAxes and :FixedOffsetAxes defined with respect to other inertial axes  are here considered as time fixed. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.ComputableAxesVector","page":"Public API","title":"FrameTransformations.Frames.ComputableAxesVector","text":"ComputableAxesVector(from, to, order::Int)\n\nStore the properties required to retrieve the i-th order components of a  desired vector. Arguments from and to are the NAIFIDs or AbstractFramePoint instances  that define the observer and target points.\n\nOnly orders between 1 and 3 are supported.\n\nExample\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> ComputableAxesVector(SSB, Sun, 1)\nComputableAxesVector(0, 10, 1)\n\njulia> ComputableAxesVector(0, 10, 1)\nComputableAxesVector(0, 10, 1)\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_bci2000!","page":"Public API","title":"FrameTransformations.Frames.add_axes_bci2000!","text":"add_axes_bci2000!(frames, axes::AbstractFrameAxes, center, data)\n\nAdd axes as a set of Body-Centered Inertial (BCI) axes at J2000 relative to the frames  system. The center point (i.e., the reference body) is center and can either be the point  ID or an AbstractFramePoint instance. data is a dictionary containing a parsed  TPC file. \n\nwarning: Warning\nThe parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in frames, an error is thrown.\n\n\n\nadd_axes_bci2000!(frames, name::Symbol, axesid::Int, cid::Int, data)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_fixedoffset!, add_axes_bcrtod! and Orient.AXESID_ICRF.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_bcrtod!","page":"Public API","title":"FrameTransformations.Frames.add_axes_bcrtod!","text":"add_axes_bcrtod!(frames, axes::AbstractFrameAxes, center::AbstractFramePoint, data)\n\nAdd axes as a set of Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the  frames system. The center point (i.e., the reference body) is center. data is a dictionary  containing a parsed TPC file. These axes are the equivalent of SPICE's IAU_<BODY_NAME> frames.\n\nwarning: Warning\nThe parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in frames, an error is thrown.\n\n\n\nadd_axes_bcrtod!(frames, name::Symbol, axesid::Int, cname::Symbol, cid::Int, data)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro and of an AbstractFramePoint via the @point macro.\n\nSee also\n\nSee also add_axes_rotating!, add_axes_bci2000! and Orient.AXESID_ICRF.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_computable!","page":"Public API","title":"FrameTransformations.Frames.add_axes_computable!","text":"add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol)\n\nAdd axes as a set of computable axes to frames. Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE's parameterized two-vector frames. \n\nThese axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis. \n\nThe primary and secondary vectors, v1 and v2 are instances of ComputableAxesVector,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration). \n\nFor example, to define a primary vector that is parallel to the Sun's (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0), v1 must be set as:  v1 = ComputableAxesVector(10, 0, 1).\n\nseq is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are: :XY, :YX, :XZ, :ZX, :YZ and :ZY. \n\nGiven a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf's nadir direction and  velocity direction define the axes orientation.  \n\nnote: Note\nRegardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to parent.\n\n\n\nadd_axes_computable!(frames, name::Symbol, axesid::Int, parentid::Int, v1, v2, seq)\n\nLow-level function to add axes name with id axesid to frames as computable axes without  requiring the creation of an AbstractFrameAxes type via the @axes macro.\n\nExamples\n\njulia> using Ephemerides \n\njulia> eph = EphemerisProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{4, Float64}(eph);\n\njulia> @point SSB 0 SolarySystemBarycenter \n\njulia> @point Sun 10 \n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @axes SunFrame 2\n\njulia> v1 = ComputableAxesVector(10, 0, 1)\nComputableAxesVector(10, 0, 1)\n\njulia> v2 = ComputableAxesVector(10, 0, 2)\nComputableAxesVector(10, 0, 2)\n\njulia> add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY)\n\nSee also\n\nSee also ComputableAxesVector, add_axes_fixedoffset!, add_axes_inertial!  and add_axes_computable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_eclipj2000!","page":"Public API","title":"FrameTransformations.Frames.add_axes_eclipj2000!","text":"add_axes_eclipj2000!(frames, axes::AbstractFrameAxes, parent, iau_model::IAUModel=iau1980)\n\nAdd axes as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to frames. The obliquity of the ecliptic is computed using the IAU Model iau_model.\n\nThe admissed parent set of axes are the following: \n\nICRF: for the International Celestial Reference Frame, with ID = 1\nMEME2000: the Mean Earth/Moon Ephemeris of J2000, with ID = 22\n\n\n\nadd_axes_eclipj2000!(frames, name::Symbol, parentid::Int, iau_model::IAUModel=iau1980, \n    axesid::Int = Orient.AXESID_ECLIPJ2000)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes ECLIPJ2000 17 EclipticEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF)\n\nSee also\n\nSee also add_axes_inertial! and Orient.DCM_ICRF_TO_MEME2000\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_ephemeris!","page":"Public API","title":"FrameTransformations.Frames.add_axes_ephemeris!","text":"add_axes_ephemeris!(frames, axes, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd axes as a set of ephemeris axes to frames. The orientation of these axes is computed  with a series of 3 rotations specified by rot_seq. The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in frames. The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels.\n\nThis operation is only possible if the ephemeris kernels loaded within frames contain  orientation data for the AXES ID associated to axes. An error is returned if the parent  axes ID is yet to be added to frames.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. This function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation.  The possible rot_seq values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX,  :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ.\n\nAlternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a Direction Cosine Matrix (DCM).\nδfun: return the DCM and its 1st order time derivative.\nδ²fun: return the DCM and its 1st and 2nd order time derivatives.\nδ³fun: return the DCM and its 1st, 2nd and 3rd order time derivatives.\n\nwarning: Warning\nIt is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels.\n\n\n\nadd_axes_ephemeris!(frames, name::Symbol, axesid::Int, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, name::Symbol, axesid::Int, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nLow-level functions to add axes name with id axesid to frames as ephemeris axes without  requiring the creation of an AbstractFrameAxes type via the @axes macro.\n\nSee also\n\nSee also ComputableAxesVector, add_axes_fixedoffset!, add_axes_inertial!  and add_axes_computable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_fixedoffset!","page":"Public API","title":"FrameTransformations.Frames.add_axes_fixedoffset!","text":"add_axes_fixedoffset!(frames::FrameSystem, axes, parent, dcm::DCM)\n\nAdd axes as a set of fixed offset axes to frames. Fixed offset axes have a constant  orientation with respect to their parent axes, represented by dcm, a  Direction Cosine Matrix (DCM).\n\nnote: Note\nWhile inertial axes do not rotate with respect to the star background, fixed offset axes  are only constant with respect to their parent axes, but might be rotating with respect  to some other inertial axes.\n\n\n\nadd_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DCM)\n\nLow-level function to add axes name with id axesid to frames with a fixed-offset from  parentid without requiring the creation of an AbstractFrameAxes type via the  @axes macro.\n\nExamples\n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z))\n\nSee also\n\nSee also add_axes_rotating!, add_axes_inertial! and add_axes_computable! \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_gcrf!","page":"Public API","title":"FrameTransformations.Frames.add_axes_gcrf!","text":"add_axes_gcrf!(frames::FrameSystem)\n\nAdd the Geocentric Celestial Reference Frame (GCRF) to the frames graph. The axes are  automatically named GCRF and assigned the 23 ID. These axes can only  be defined as a set of root axes or as child of the ICRF (ID = 1).\n\nSee also\n\nSee also add_axes_inertial!, add_axes_icrf! and Orient.AXESID_GCRF.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_inertial!","page":"Public API","title":"FrameTransformations.Frames.add_axes_inertial!","text":"add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing)\n\nAdd axes as a set of inertial axes to frames. Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added, parent and dcm  become mandatory fields.\n\nnote: Note\nThe parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted.\n\n\n\nadd_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing)\n\nLow-level function to add axes name with id axesid to frames without requiring the  creation of an AbstractFrameAxes type via the @axes macro.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000)\nERROR: A set of parent axes for ECLIPJ2000 is required\n[...]\n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z))\n\nSee also\n\nSee also add_axes_rotating!, add_axes_fixedoffset! and add_axes_computable! \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_icrf!","page":"Public API","title":"FrameTransformations.Frames.add_axes_icrf!","text":"add_axes_icrf!(frames::FrameSystem)\n\nAdd the International Celestial Reference Frame (ICRF) as the root axes of the frames graph. The axes are automatically named ICRF and assigned the 1 ID. \n\nSee also\n\nSee also add_axes_inertial!, add_axes_gcrf! and Orient.AXESID_ICRF.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_itrf!","page":"Public API","title":"FrameTransformations.Frames.add_axes_itrf!","text":"add_axes_itrf!(frames, axes::AbstractFrameAxes, parent, model::IAU2006Model=iau2006b)\n\nAdd axes as a set of axes representing the International Terrestrial Reference Frame (ITRF) to frames. Use the model argument to specify which IAU model model should be used for  the computations. The default is set to iau2006b.\n\nwarning: Warning\nIf the ID of the parent set of axes is neither the ICRF (ID = 1) nor the GCRF (ID = 23), an error is thrown. \n\n\n\nadd_axes_itrf!(frames, name::Symbol, parentid::Int, model::IAU2006Model=iau2006b, \n    axesid::Int = Orient.AXESID_ITRF)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_rotating! and orient_rot3_itrf_to_gcrf.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_me421!","page":"Public API","title":"FrameTransformations.Frames.add_axes_me421!","text":"add_axes_me421!(frames, axes::AbstractFrameAxes, parent)\n\nAdd axes as fixed offset axes representing the DE421 Moon's Mean Earth/Mean Rotation (ME)  to frames.\n\nwarning: Warning\nThe parent set of axes must either the DE440 Principal Axes (PA440, ID = or the DE421 Principal Axes (PA421, ID = 31006), otherwise an error is thrown. Depending on that, the  relative axes orientation will be automatically selected by this function. \n\n\n\nadd_axes_me421!(frames, name::Symbol, parentid::Int, axesid::Int = Orient.AXESID_MOONME_DE421)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_pa440!, and add_axes_pa421!,  Orient.DCM_MOON_PA421_TO_ME421 and Orient.DCM_MOON_PA421_TO_ME421, \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_meme2000!","page":"Public API","title":"FrameTransformations.Frames.add_axes_meme2000!","text":"add_axes_meme2000!(frames, axes::AbstractFrameAxes, parent)\n\nAdd axes as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to frames. \n\nwarning: Warning\nThe the axes ID of the parent set of axes must be 1 (ICRF) or  17 (ECLIPJ2000) otherwise and error is thrown.\n\n\n\nadd_axes_meme2000!(frames, name::Symbol, parentid::Int, axesid::Int = Orient.AXESID_MEME2000)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_meme2000!(FRAMES, MEME2000, ICRF)\n\nSee also\n\nSee also add_axes_inertial! and Orient.DCM_ICRF_TO_MEME2000\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_mod!","page":"Public API","title":"FrameTransformations.Frames.add_axes_mod!","text":"add_axes_mod!(frames, axes::AbstractFrameAxes, parent)\n\nAdd axes as a set of projected axes representing the Mean Equator and Equinox of Date (MOD) to frames. \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF),  otherwise an error is thrown. \n\n\n\nadd_axes_mod!(frames, name::Symbol, axesid::Int, parentid::Int)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_projected! and Orient.orient_rot3_icrf_to_mod\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_tod!","page":"Public API","title":"FrameTransformations.Frames.add_axes_tod!","text":"add_axes_tod!(frames, axes::AbstractFrameAxes, parent)\n\nAdd axes as a set of projected axes representing the True Equator of Date (TOD) to frames. \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF),  otherwise an error is thrown. \n\n\n\nadd_axes_tod!(frames, name::Symbol, axesid::Int, parentid::Int)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_projected! and Orient.orient_rot3_icrf_to_tod\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_teme!","page":"Public API","title":"FrameTransformations.Frames.add_axes_teme!","text":"add_axes_teme!(frames, axes::AbstractFrameAxes, parent)\n\nAdd axes as a set of projected axes representing the True Equator, Mean Equinox (TEME) to frames. \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF),  otherwise an error is thrown. \n\n\n\nadd_axes_teme!(frames, name::Symbol, axesid::Int, parentid::Int)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_projected! and Orient.orient_rot3_icrf_to_teme\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_pef!","page":"Public API","title":"FrameTransformations.Frames.add_axes_pef!","text":"add_axes_pef!(frames, axes::AbstractFrameAxes, parent)\n\nAdd axes as a set of rotating axes representing the Pseudo Earth Fixed (PEF) axes to frames. \n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF),  otherwise an error is thrown. \n\n\n\nadd_axes_pef!(frames, name::Symbol, axesid::Int, parentid::Int)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also add_axes_rotating!, Orient.orient_rot3_icrf_to_pef and  Orient.orient_rot6_icrf_to_pef.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_pa421!","page":"Public API","title":"FrameTransformations.Frames.add_axes_pa421!","text":"add_axes_pa421!(frames, axes::AbstractFrameAxes)\n\nAdd axes as a set of ephemeris axes representing the DE421 Moon's Principal Axes (PA) to  frames. The libration angles are extracted from the ephemeris kernels loaded within frames,  an error is thrown if such orientation data is not available. \n\nwarning: Warning\nThe parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006).\n\n\n\nadd_axes_pa421!(frames, name::Symbol, axesid::Int = Orient.AXESID_MOONPA_DE421)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also Orient.AXESID_MOONPA_DE421, Orient.orient_rot3_icrf_to_pa421,  add_axes_pa440!, and add_axes_me421!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_pa440!","page":"Public API","title":"FrameTransformations.Frames.add_axes_pa440!","text":"add_axes_pa440!(frames, axes::AbstractFrameAxes)\n\nAdd axes as a set of ephemeris axes representing the DE440 Moon's Principal Axes (PA) to  frames. The libration angles are extracted from the ephemeris kernels loaded within frames,  an error is thrown if such orientation data is not available. \n\nwarning: Warning\nThe parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008).\n\n\n\nadd_axes_pa440!(frames, name::Symbol, axesid::Int = Orient.AXESID_MOONPA_DE440)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes type  via the @axes macro.\n\nSee also\n\nSee also Orient.AXESID_MOONPA_DE440, Orient.orient_rot3_icrf_to_pa440 and add_axes_pa421!.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_projected!","page":"Public API","title":"FrameTransformations.Frames.add_axes_projected!","text":"add_axes_projected!(frames, axes, parent, fun)\n\nAdd axes as a set of projected axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nProjected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time).\n\nwarning: Warning\nIt is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\n\n\nadd_axes_projected!(frames, name::Symbol, axesid::Int, parentid::Int, fun)\n\nLow-level function to add axes name with id axesid to frames as projected axes without  requiring the creation of an AbstractFrameAxes type via the @axes macro.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_rotating!","page":"Public API","title":"FrameTransformations.Frames.add_axes_rotating!","text":"add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd axes as a set of rotating axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a Direction Cosine Matrix (DCM).\nδfun: return the DCM and its 1st order time derivative.\nδ²fun: return the DCM and its 1st and 2nd order time derivatives.\nδ³fun: return the DCM and its 1st, 2nd and 3rd order time derivatives.\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed via automatic differentiation.\n\nwarning: Warning\nIt is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\n\n\nadd_axes_rotating!(frames, name::Symbol, axesid::Int, parentid::Int, fun, δfun=nothing, \n    δ²fun=nothing, δ³fun=nothing)\n\nLow-level function to add axes name with id axesid to frames as rotating axes without  requiring the creation of an AbstractFrameAxes type via the @axes macro.\n\nExamples\n\njulia> FRAMES = FrameSystem{3, Float64}();\n\njulia> @axes Inertial 1\n\njulia> add_axes_inertial!(FRAMES, Inertial)\n\njulia> @axes Synodic 2 \n\njulia> fun(t) = angle_to_dcm(t, :Z);\n\njulia> add_axes_rotating!(FRAMES, Synodic, Inertial, fun)\n\njulia> R = rotation6(FRAMES, Inertial, Synodic, π/6);\n\njulia> R[1]\nDCM{Float64}:\n  0.866025  0.5       0.0\n -0.5       0.866025  0.0\n  0.0       0.0       1.0\n\njulia> R[2]\nDCM{Float64}:\n -0.5        0.866025  0.0\n -0.866025  -0.5       0.0\n  0.0        0.0       0.0\n\nSee also\n\nSee also add_axes_fixedoffset!, add_axes_inertial! and add_axes_computable! \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_topocentric!","page":"Public API","title":"FrameTransformations.Frames.add_axes_topocentric!","text":"add_axes_topocentric!(frames, axes::AbstractFrameAxes, parent, λ::Number, ϕ::Number, type::Symbol)\n\nAdd axes as a set of fixed-offset topocentric axes to frames. The orientation relative  to the parent axes parent is defined throuh the longitude λ, the geodetic latitude ϕ  and the type type, which may be any of the following: \n\n:NED (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir.\n:SEZ (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith.\n:ENU (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith. \n\nwarning: Warning\nThe parent axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong. \n\n\n\nadd_axes_topocentric!(frames, name::Symbol, axesid::Int, parentid::Int, λ, ϕ, type)\n\nLow-level function to avoid requiring the creation of an AbstractFrameAxes via  the @axes macro.\n\nSee also\n\nSee also add_axes_fixedoffset! and add_point_surface!.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#Points","page":"Public API","title":"Points","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"@point\npoint_alias\n\nadd_point_dynamical!\nadd_point_ephemeris!\nadd_point_fixed!\nadd_point_root!\nadd_point_surface!\nadd_point_updatable!\n\nupdate_point!","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.@point","page":"Public API","title":"FrameTransformations.Frames.@point","text":"@point(name, id, type=nothing)\n\nDefine a new point instance to alias the given NAIFID id. This macro creates an  AbstractFramePoint subtype and its singleton instance called name. Its type name  is obtained by appending Point to either name or type (if provided).\n\nExamples\n\njulia> @point Venus 299\n\njulia> typeof(Venus)\nVenusPoint \n\njulia> point_alias(Venus)\n299\n\njulia> @point EMB 3 EarthMoonBarycenter\n\njulia> typeof(EMB) \nEarthMoonBarycenterPoint\n\njulia> point_alias(EMB) \n3 \n\nSee also\n\nSee also @axes and point_alias.\n\n\n\n\n\n","category":"macro"},{"location":"Modules/frames_api/#FrameTransformations.Frames.point_alias","page":"Public API","title":"FrameTransformations.Frames.point_alias","text":"point_alias(ax::AbstractFramePoint)\n\nReturn the NAIF ID associated to the input point. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_dynamical!","page":"Public API","title":"FrameTransformations.Frames.add_point_dynamical!","text":"add_point_dynamical!(frames, point::AbstractFramePoint, parent, axes, fun, δfun=nothing, \n    δ²fun=nothing, δ³fun=nothing)\n\nAdd point as a time point to frames. The state vector for these points depends only on  time and is computed through the custom functions provided by the user. axes is the ID or  AbstractFrameAxes instance in which the point state-vector is expressed.\n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a 3-elements vector: position\nδfun: return a 6-elements vector: position and velocity\nδ²fun: return a 9-elements vector: position, velocity and acceleration\nδ³fun: return a 12-elements vector: position, velocity, acceleration and jerk\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed with automatic differentiation. \n\nwarning: Warning\nIt is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions. \n\n\n\nadd_point_dynamical!(frames, name::Symbol, pointid::Int, parentid::Int, axes, fun, \n    δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nLow-level function to add point name with ID id to frames as a dynamical point without  requiring the creation of an AbstractFramePoint type via the @point macro. axes is the ID or AbstractFrameAxes instance in which the point state-vector is  expressed.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}()\n\njulia> @axes ICRF 1 \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> @point Satellite 1 \n\njulia> satellite_pos(t::T) where T = [cos(t), sin(t), 0]\n\njulia> add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, π/6)\n6-element SVector{6, Float64} with indices SOneTo(6):\n  0.8660254037844387\n  0.49999999999999994\n  0.0\n -0.49999999999999994\n  0.8660254037844387\n  0.0\n\nSee also\n\nSee also add_point_root!, add_point_ephemeris!,add_point_fixed! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_ephemeris!","page":"Public API","title":"FrameTransformations.Frames.add_point_ephemeris!","text":"add_point_ephemeris!(frames::FrameSystem, point::AbstractFramePoint)\n\nAdd point as an ephemeris point to frames. This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). The parent point is  automatically assigned to the point with respect to which the ephemeris data is written  in the kernels. If that point is not available as an ephemeris point in the frame system,  an error is thrown.\n\nnote: Note\nThe axes in which the state-vector is expressed are taken from the ephemeris data: an  error is returned if the axes ID is yet to be added to frames.\n\nwarning: Warning\nIt is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels.\n\n\n\nadd_point_ephemeris!(frames::FrameSystem, name::Symbol, naifid::Int)\n\nLow-level function to add point name with ID id to frames as an ephemeris point without  requiring the creation of an AbstractFramePoint type via the @point macro.\n\nExamples\n\njulia> using Ephemerides \n\njulia> eph = EphemerisProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{2, Float64}(eph);\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @point Jupiter 599\n\njulia> add_point_ephemeris!(FRAMES, Jupiter)\nERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.\n[...]\n\nSee also\n\nSee also add_point_root!, add_point_fixed!, add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_fixed!","page":"Public API","title":"FrameTransformations.Frames.add_point_fixed!","text":"add_point_fixed!(frames, point::AbstractFramePoint, parent, axes, offset::AbstractVector)\n\nAdd point as a fixed point to frames. Fixed points are those whose positions have a  constant offset with respect their parent points in the given set of axes. Thus, points  eligible for this class must have null velocity and acceleration with respect to parent. axes is the ID or AbstractFrameAxes instance in which the point state-vector is  expressed.\n\n\n\nadd_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector)\n\nLow-level function to add point name with ID id to frames as a fixed-point with respect  to point parentid without requiring the creation of an AbstractFramePoint type  via the @point macro. axes is the ID or AbstractFrameAxes instance in  which the point state-vector is expressed.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes SF -3000 SatelliteFrame\n\njulia> add_axes_inertial!(FRAMES, SF)\n\njulia> @point SC -10000 Spacecraft\n\njulia> @point SolarArrayCenter -10001\n\njulia> add_point_root!(FRAMES, SC, SF)\n\njulia> sa_offset = [0.10, 0.15, 0.30];\n\njulia> add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset)\n\nSee also\n\nSee also add_point_root!, add_point_ephemeris!,  add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_root!","page":"Public API","title":"FrameTransformations.Frames.add_point_root!","text":"add_point_root!(frames::FramesSystem, point::AbstractFramePoint, axes)\n\nAdd point as a root point to frames to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.). axes is the ID or AbstractFrameAxes instance in which the point state-vector is expressed.\n\nnote: Note\nThis operation can be performed only once per FrameSystem object: multiple root  points in the same graph are both inadmissible and meaningless.\n\n\n\nadd_point_root!(frames::FrameSystem, name::Symbol, pointid::Int, axes)\n\nLow-level function to add point name with ID pointid to frames as a root-point without  requiring the creation of an AbstractFramePoint type via the @point macro. axes is the ID or AbstractFrameAxes instance in which the point state-vector is  expressed.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> @point Sun 10\n\njulia> add_point_root!(FRAMES, Sun, ICRF)\nERROR: ArgumentError: A root-point is already registed in the given FrameSystem.\n[...]\n\nSee also\n\nSee also add_point_ephemeris!, add_point_fixed!, add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_surface!","page":"Public API","title":"FrameTransformations.Frames.add_point_surface!","text":"add_point_surface!(frames, point::AbstractFramePoint, parent, axes, λ::Number, \n    ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0)\n\nAdd point to frames as a fixed point on the surface of the parent point body. The relative  position is specified by the longitude λ, the geodetic latitude ϕ, the reference radius  of the ellipsoid R and its flattening f. The altitude over the reference surface of the  ellipsoid h defaults to 0. \n\nwarning: Warning\naxes must be a set of body-fixed reference axes for the body represented by parent.  When this constraint is not satisfied, the results may be fundamentally wrong. \n\n\n\nadd_point_surface!(frames, point::AbstractFramePoint, parent, axes, pck,  λ, ϕ, h::Number=0.0)\n\nIn this case, the ellipsoid parameters are extracted from the input TPC kernel pck using  the NAIFId associated to the parent point.\n\n\n\nadd_point_surface!(frames, name::Symbol, pointid::Int, parentid::Int, axesid::Int, \n    λ::Number, ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0,)\n\nLow-level function to avoid requiring the creation of an AbstractFramePoint via  the @point macro.\n\nSee also\n\nSee also add_point_fixed! and add_axes_topocentric!.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_updatable!","page":"Public API","title":"FrameTransformations.Frames.add_point_updatable!","text":"add_point_updatable!(frames, point::AbstractFramePoint, parent, axes)\n\nAdd point as an updatable point to frames. Differently from all the other classes, the  state vector for updatable points (expressed in the set of input axes) must be manually  updated before being used for other computations. axes is the ID or  AbstractFrameAxes instance in which the point state-vector is expressed. \n\nnote: Note\nThis class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system.\n\n\n\nadd_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes)\n\nLow-level function to add point name with ID id to frames as an updatable point without  requiring the creation of an AbstractFramePoint type via the @point macro. axes is the ID or AbstractFrameAxes instance in which the point state-vector is  expressed.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.]\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2\n[...]\n\nSee also\n\nSee also update_point!, add_point_root!, add_point_ephemeris!,  add_point_dynamical! and add_point_fixed!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.update_point!","page":"Public API","title":"FrameTransformations.Frames.update_point!","text":"update_point!(frames, point, stv::AbstractVector, epoch::Epoch)\n\n\n\n\n\nupdate_point!(frames::FrameSystem, point, stv::AbstractVector, time)\n\nUpdate the state vector of point at the input time in frames. The only  accepted length for the input vector stv are 3, 6, 9 or 12. The order is automatically  inferred from the vector length.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n  \njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.];\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 \n[...]\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 \n[...] \n\nSee also\n\nSee also add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#rotation_api","page":"Public API","title":"Rotations","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"Rotation\nFrames.order\nBase.inv\n\nrotation3\nrotation6\nrotation9\nrotation12","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.Rotation","page":"Public API","title":"FrameTransformations.Frames.Rotation","text":"Rotation{S, N}\n\nA container to efficiently compute S-th order rotation matrices of type N between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the (S-1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later.\n\nThe rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object R, constructed from the  DCM A and its time derivatives δA and δ²A rotates a vector v = [p, v, a] as: \n\n̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a]\n\nA Rotation object R call always be converted to a SMatrix or a MMatrix by invoking  the proper constructor. \n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\n\n\nRotation(dcms::DCM...)\n\nCreate a Rotation object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64}\n\n\n\nRotation{S}(dcms::DCM...) where S\n\nCreate a Rotation object of order S. If the number of dcms is smaller than S, the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than  S, only the first S DCMs are used. \n\nwarning: Warning\nUsage of this constructor is not recommended as it may yield unexpected results to  unexperienced users. \n\n\n\nRotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N}\n\nCreate a Rotation object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If S1 < S2, only the first S1 DCMs are considered, otherwise the  remaining orders are filled with null DCMs.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R3 = Rotation{3}((A,B));\n\njulia> R3[1] == A\ntrue \n\njulia> R3[3] \nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\nRotation{S}(u::UniformScaling{N}) where {S, N}\nRotation{S, N}(u::UniformScaling) where {S, N}\n\nCreate an S-order identity Rotation object of type N with identity position rotation  and null time derivatives.\n\nExamples\n\njulia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],))\n\n\n\nRotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\nRotation{S1, N}(R::Rotation{S2}) where {S1, S2, N}\n\nTransform a Rotation object of order S2 to order S1 and type N. The behaviour of  these functions depends on the values of S1 and S2: \n\nS1 < S2: Only the first S1 components of rot are considered.\nS1 > S2: The missing orders are filled with null DCMs.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1);\n\njulia> R3[3]\nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\nRotation(m::DCM{N}, ω::AbstractVector) where N\n\nCreate a 2nd order Rotation object of type N to rotate between two set of axes a and  b from a Direction Cosine Matrix (DCM) and the angular velocity vector ω of b with  respect to a, expressed in b\n\nSee also\n\nSee also rotation3, rotation6 and rotation9.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_api/#FrameTransformations.Frames.order","page":"Public API","title":"FrameTransformations.Frames.order","text":"order(R::Rotation{S}) where S\n\nReturn the rotation order S.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#Base.inv","page":"Public API","title":"Base.inv","text":"inv(rot::Rotation)\n\nCompute the invese of the rotation object rot. The operation is efficiently performed by  taking the transpose of each rotation matrix within rot.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation3","page":"Public API","title":"FrameTransformations.Frames.rotation3","text":"rotation3(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 1.\n\n\n\n\n\nrotation3(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation6","page":"Public API","title":"FrameTransformations.Frames.rotation6","text":"rotation6(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 2.\n\n\n\n\n\nrotation6(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation9","page":"Public API","title":"FrameTransformations.Frames.rotation9","text":"rotation9(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 3.\n\n\n\n\n\nrotation9(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation12","page":"Public API","title":"FrameTransformations.Frames.rotation12","text":"rotation12(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 4.\n\n\n\n\n\nrotation12(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#Transformations","page":"Public API","title":"Transformations","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"\nLightTime\nPlanetaryAberration\n\nvector3\nvector6\nvector9 \nvector12 ","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.LightTime","page":"Public API","title":"FrameTransformations.Frames.LightTime","text":"LightTime\n\nThe singleton instance of type LightTimeCorrection, used to apply light-time (planetary  aberration) corrections when computing vectors from the FrameSystem.\n\nSee also\n\nSee also vector3 and vector6.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/frames_api/#FrameTransformations.Frames.PlanetaryAberration","page":"Public API","title":"FrameTransformations.Frames.PlanetaryAberration","text":"PlanetaryAberration\n\nThe singleton instance of type PlanetaryAberrationCorrection, used to apply one-way  light-time and stellar aberration corrections when computing vectors from the FrameSystem.\n\nSee also\n\nSee also vector3 and vector6.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector3","page":"Public API","title":"FrameTransformations.Frames.vector3","text":"vector3(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector3(frame, from, to, axes, t::Number)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\nvector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch ep,  using the aberration flag ltcorr, which may be any of the following AbstractLightTimeCorrection:\n\nLightTimeCorrection: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. \nPlanetaryAberrationCorrection: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the LightTimeCorrection option to account for the observer velocity    with respect to the Solar System Barycenter. \n\nThe integer argument dir is used to specify the correction direction, as follows:\n\n-1: for Reception, in which photons depart from the target's location at the    light-time corrected epoch ep-lt and arrive at the observer's location at ep.\n+1: for Transmission, in which photons depart from the observer's location at   ep and arrive at the target's location at the light-time corrected epoch ep+lt.\n\nKeyword Arguments\n\niters::Int=1: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.\naxescenter: ID or instance of the center point for axes. This parameter is used        only when axes have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to from.\n\nnote: Note\nIf the PlanetaryAberrationCorrection is applied, the frame system must be at  least one order higher than that of the requested transformation.\n\nSee also\n\nSee also LightTime, PlanetaryAberration and vector6.\n\nReferences\n\nCSPICE Library\n\n\n\n\n\nvector3(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time t,   expressed in seconds since J2000, using the aberration flag ltcorr and  the direction dir.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector6","page":"Public API","title":"FrameTransformations.Frames.vector6","text":"vector6(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector6(frame, from, to, axes, t::Number)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\nvector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch ep,  using the aberration flag ltcorr, which may be any of the following AbstractLightTimeCorrection:\n\nLightTimeCorrection: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. \nPlanetaryAberrationCorrection: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the LightTimeCorrection option to account for the observer velocity    with respect to the Solar System Barycenter. \n\nThe integer argument dir is used to specify the correction direction, as follows:\n\n-1: for Reception, in which photons depart from the target's location at the    light-time corrected epoch ep-lt and arrive at the observer's location at ep.\n+1: for Transmission, in which photons depart from the observer's location at   ep and arrive at the target's location at the light-time corrected epoch ep+lt.\n\nKeyword Arguments\n\niters::Int=1: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.\naxescenter: ID or instance of the center point for axes. This parameter is used        only when axes have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to from.\n\nnote: Note\nIf the PlanetaryAberrationCorrection is applied, the frame system must be at  least one order higher than that of the requested transformation.\n\nSee also\n\nSee also LightTime, PlanetaryAberration and vector6.\n\nReferences\n\nCSPICE Library\n\n\n\n\n\nvector6(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time t,   expressed in seconds since J2000, using the aberration flag ltcorr and  the direction dir.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector9","page":"Public API","title":"FrameTransformations.Frames.vector9","text":"vector9(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector9(frame, from, to, axes, t::Number)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector12","page":"Public API","title":"FrameTransformations.Frames.vector12","text":"vector12(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector12(frame, from, to, axes, t::Number)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"EditURL = \"../t02_points.jl\"","category":"page"},{"location":"Tutorials/gen/t02_points/#tutorial_02_points","page":"03 - Points","title":"Points Creation and Translations","text":"","category":"section"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"This example was generated on 2024-01-05T08:58:22.053.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Similarly to axes, FrameTransformations also provides the capability to define custom and standard reference points (e.g., the Solar System Barycenter) and arbitrarily connect them through the FrameSystem In turn, this allows the computation of the relative position and its derivatives (up to order 3) between any two registered points and express it in any known set of axes.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"At the time being, the following types of points are supported:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Root point: it is the root of the point graph.\nFixed points: are those whose positions have a constant offset with respect their parent point in a given set of axes.\nDynamical points: the position of these points depends only on time and is computed through custom user-defined functions.\nEphemeris points: are those whose state-vector is retrieved from binary SPK kernels (e.g., DE440) that are loaded within the FrameSystem.\nUpdatable points: differently from all the other classes, the state vector for updatable points must be manually updated at a given epoch before it can be used in any transformation at the same epoch.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nThis package provides a dedicated function to register each type of supported points.","category":"page"},{"location":"Tutorials/gen/t02_points/#Graph-Initialisation","page":"03 - Points","title":"Graph Initialisation","text":"","category":"section"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"In this section we will display how to create a frame system to compute generic points transformation. Differently from the axes graph, each register point is also associated to a set of axes. Hence, this tutorial assumes the reader to already be familiar with the different types of axes and their definitions. First of all, we need to load both this package and an ephemeris reader. The latter will be used to retrieve the positions of the planets from the binary SPK kernels. In this example, we will use our own Ephemerides.jl package and download the kernels from NAIF's website.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"To initialise the point graph, we first need to define a root point. This, in turn, must be associated to an arbitrary set of axes. Therefore, we begin by definining a generic SatelliteFrame, here considered as inertial, and then register a root point, called SpacecraftCenter in our graph. Similarly, to axes, the @point macro is used to define an acronym, an ID and a name of each point that we wish to register in the system. If a name is not provided, a default one is used.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations\n\nG = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"A root point can be registered using the add_point_root! function:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"@axes SATF 1 SatelliteFrame\n\nadd_axes_inertial!(G, SATF)\n\n@point SC -10000 SpacecraftCenter\n\nadd_point_root!(G, SC, SATF)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"tip: Tip\nFor standard applications, it is good practice that the points's IDs are as in agreement with NAIF's numbering system. This becomes mandatory to properly read JPL's SPK kernels.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nThe frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the point are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"We can now see that our axes and point graphs are populating themselves:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"G","category":"page"},{"location":"Tutorials/gen/t02_points/#Fixed-Points","page":"03 - Points","title":"Fixed Points","text":"","category":"section"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Fixed points have a constant relative position vector with respect to their parent points in a given set of axes. Similarly to fixed-offset axes, these points are fixed w.r.t. their parents but might be moving with respect to others.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"In this example, we use the add_point_fixed! function to register the location of an antenna and two solar panels, which are generally fixed in the satellite body-fixed frame. To do so, we define a position offset in the form of a 3-elements vector with respect to the SpacecraftCenter.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point SACL -10101 SolarArrayCenterLeft\n@point SACR -10102 SolarArrayCenterRight\n@point Antenna -10001\n\nsa_offset_left = [1.0, 0.0, 0.0]\nsa_offset_right = [-1.0, 0.0, 0.0]\nan_offset = [0.0, 0.0, -1.0]\n\nadd_point_fixed!(G, SACL, SC, SATF, sa_offset_left)\nadd_point_fixed!(G, SACR, SC, SATF, sa_offset_right)\nadd_point_fixed!(G, Antenna, SC, SATF, an_offset)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"As a result the graph is now populated with the new points and we can finally compute their relative positions and velocities with the proper transformation functions:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"vector3(G, SACL, SC, SATF, 0.0)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"vector6(G, Antenna, SACR, SATF, 10.0)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"As expected, since these points are fixed, the relative velocity vector is null.","category":"page"},{"location":"Tutorials/gen/t02_points/#Dynamical-Points","page":"03 - Points","title":"Dynamical Points","text":"","category":"section"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Dynamical points are generic time-dependent points whose position vector (and optionally its derivatives) are only function of time. However, differently from ephemeris points, their position is computed through user-defined functions.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point TimeDependantAppendage -10003\n\nfun(t) = [cos(t), sin(t), 0]\n\nadd_point_dynamical!(G, TimeDependantAppendage, SACL, SATF, fun)\n\nvector6(G, TimeDependantAppendage, SC, SATF, π/3)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nTo avoid allocations, fun should return a static array.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Similarly to rotating-axes, if the user only provides the function to compute the relative position, the remaining derivatives are automatically retrievied via automatic differentiation of fun. On the other hand, if those functions are specified, they must return a single vector that stacks all the components. For instance, for the second order derivative of fun, the function should return a 9-elements vector containing the relative position, velocity and acceleration. For example:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point TimeDependantAppendage2 -10004\n\nfun(t) = [cos(t), sin(t), 0]\ndfun(t) = [cos(t), sin(t), 0, -sin(t), cos(t), 0]\n\nadd_point_dynamical!(G, TimeDependantAppendage2, SACL, SATF, fun, dfun)\n\nvector6(G, TimeDependantAppendage2, SC, SATF, π/3)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"We can again see that the results are in agreement with the previous example. For more details, consult the add_point_dynamical! documentation.","category":"page"},{"location":"Tutorials/gen/t02_points/#updatable_points","page":"03 - Points","title":"Updatable Points","text":"","category":"section"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Updatable points are a class of point whose states at a given epoch must be manually updated before any other computation at the same epoch can occur. They can be inserted in the computational graphs as follows:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point UA -10002 UpdatableAppendage\n\nadd_point_updatable!(G, UA, SC, SATF)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"If we now call a transformation involving this point, an error will be thrown because we have not registered any state for this point. To do so, we use the update_point! function and then evaluate the relative position:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"ua_pos = [0.0, -1.0, 0.0]\nupdate_point!(G, UA, ua_pos, 0.0)\nvector3(G, Antenna, UA, SATF, 0.0)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nUpdatable points do not store any history of the updated states. Meaning that each time a state is updated at a different epoch, the information of the older epochs is completely lost.","category":"page"},{"location":"Tutorials/gen/t02_points/#Ephemeris-Points","page":"03 - Points","title":"Ephemeris Points","text":"","category":"section"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Ephemeris points are a type of time-dependent points whose position and higher-order derivatives are retrieved from a binary SPK ephemeris kernel. However, differently from all other points, in this case the set of axes is automatically inferred from those contained in the ephemeris kernels. In case such set is not yet registered in the frame system, an error will be thrown.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nTo properly compute the position of these points, the FrameSystem object must contain an ephemeris provider that has loaded the necessary kernels. Additionally, in this case the ID of the registered points must match the ID contained in the SPK kernels.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"In this example, we define a new frame system F and give it an ephemeris provider that has loaded the DE421 SPK kernel, containing the position of the major planets and/or their barycenters of the Solar System.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"using Ephemerides\n\nspk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(download(spk))\n\nF = FrameSystem{2, Float64}(eph)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"We now register some points that are stored in the kernels using the add_point_ephemeris! function:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"@axes ICRF 1\n\n@point SSB 0\n@point Sun 10\n@point EMB 3\n@point Earth 399\n\nadd_axes_inertial!(F, ICRF)\nadd_point_root!(F, SSB, ICRF)\nadd_point_ephemeris!(F, Sun)\nadd_point_ephemeris!(F, EMB)\nadd_point_ephemeris!(F, Earth)\n\nF","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Notice that this function does not requires the parent point. Indeed, the parent is automatically set to those contained in the descriptors of the ephemeris kernels. For instance, in the DE421, the Earth-Moon Barycenter (EMB) is defined with respect to the SSB, which the frame system automatically uses as parent for the EMB. Similarly, the EMB is the default parent point for the Earth.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"warning: Warning\nIf a parent point is not specified and the point in the kernels has not yet been registered, an error is thrown.","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"Finally, we can retrieve the transformation data as usual:","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"vector6(F, EMB, SSB, ICRF, 1000.0)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"vector3(F, Earth, SSB, ICRF, 0.0)","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"","category":"page"},{"location":"Tutorials/gen/t02_points/","page":"03 - Points","title":"03 - Points","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"EditURL = \"../e02_hifi.jl\"","category":"page"},{"location":"Examples/gen/e02_hifi/#example_02_hifi","page":"High-Fidelity Earth-Moon Environment","title":"Use Case: High Fidelity","text":"","category":"section"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"This example was generated on 2024-01-05T08:58:22.075.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"Once the general structure of the FrameSystem is understood, we can pass to a use case in which we want to build and exploit our frame system to perform computations in a high-fidelity environment.","category":"page"},{"location":"Examples/gen/e02_hifi/#Frame-system-setup","page":"High-Fidelity Earth-Moon Environment","title":"Frame system setup","text":"","category":"section"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"In this example, we plan on using ephemeris data to retrieve accurate positions of the planets and the orientation of certain reference frames. Therefore, we create an ephemeris provider object leveraging our own Ephemerides.jl package and use it to generate a frame system instance:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"using FrameTransformations\nusing Ephemerides\nusing LinearAlgebra\nusing ReferenceFrameRotations\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/de432s.bsp\";\n\neph = EphemerisProvider([download(url_spk), download(url_pck)])\n\nFRAMES = FrameSystem{3, Float64}(eph)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"Once the graph is created, we assign the GCRF (Geocentric Celestial Reference Frame) as our set of inertial root-axes:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"@axes GCRF 1 GeocentricCelestialReferenceFrame\n\nadd_axes_inertial!(FRAMES, GCRF)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"These axes are practically coincident with the ICRF.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"In this scenario, we will be working within the Cislunar environment, therefore we will need the major bodies that influence this dynamic regime, i..e, the Earth, the Moon and the Sun. To do so, we also define the Solar System Barycenter (SSB) and the Earth-Moon Barycenter (EMB) as the ephemeris data of the remaining bodies is expressed with respect to those.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"For this example, we will assume the SSB is our root point:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"@point SSB 0\n@point EMB 3\n@point Sun 10\n@point Earth 399\n@point Moon 301\n\nadd_point_root!(FRAMES, SSB, GCRF)\nadd_point_ephemeris!(FRAMES, EMB)\nadd_point_ephemeris!(FRAMES, Earth)\nadd_point_ephemeris!(FRAMES, Moon)\nadd_point_ephemeris!(FRAMES, Sun)","category":"page"},{"location":"Examples/gen/e02_hifi/#Registering-body-fixed-axes","page":"High-Fidelity Earth-Moon Environment","title":"Registering body-fixed axes","text":"","category":"section"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"At this point, we want to be able to transform back and forth from body-fixed axes of the Earth and the Moon to the GCRF. The Earth and the Moon cases are actually special cases because they have both high-accuracy and low-precision body-fixed rotation models.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"Let's start with the low precision ones: IAU_EARTH and IAU_MOON. To register such frames, we first need to parse a TPC file with the required constants:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"tpc = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/pck00011.tpc\"\niau = load(TPC(download(tpc)));\n\n@axes IAU_EARTH 3\n@axes IAU_MOON 4\n\nadd_axes_bcrtod!(FRAMES, IAU_EARTH, Earth, iau)\nadd_axes_bcrtod!(FRAMES, IAU_MOON, Moon, iau)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"The registration of this type of axes requires either an alias or the ID of the point associated to the body.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"For convenience, let us also insert a set of inertial axes for the Moon. This can be done using the IAU-based Body-Centric Inertial J2000 axes available through the add_axes_bci2000! function, which defines a rotation from the ICRF to the local equatorial plane of the body at the J2000 epoch.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"@axes LME2000 5\n\nadd_axes_bci2000!(FRAMES, LME2000, Moon, iau);\nnothing #hide","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"Finally, we complete the axes definition by inserting the high-precision Earth and Lunar body-fixed rotation models.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"warning: Warning\nIn order to use IERS associated reference frames, EOP must be loaded. See also Orient.prepare_eop, Orient.init_eop.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"url_eop = \"https://datacenter.iers.org/data/csv/finals2000A.data.csv\"\neopfile = \"iau2000a\"\n\nOrient.prepare_eop(download(url_eop), eopfile)\nOrient.init_eop(eopfile * \".eop.dat\")","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"For this purpose, FrameTransformations provides two  high-level functions that can be used to ease these definitions: add_axes_itrf! and add_axes_pa421!.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"@axes ITRF 6\n@axes MOONPA_DE421 31006\n\nadd_axes_itrf!(FRAMES, ITRF, GCRF)\nadd_axes_pa421!(FRAMES, MOONPA_DE421)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"The default ITRF model is the iau2006b, but other approximations are also available. If one was interested in the Moon's PA440 axes, a similar function named add_axes_pa440! is available.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"note: Note\nTo correctly use the add_axes_pa421! function, the frame system must contain an ephemeris provider that has loaded the necessary PCK kernels with the DE421 data.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"FRAMES","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"To begin exploiting our newly completed frame system, we assumed that our SC is on a circular equatorial orbit around the Moon at an altitude of 500 km, so that at the epoch e, the spacecraft state vector is updated as:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"@point SC -1_900_000\n\nadd_point_updatable!(FRAMES, SC, Moon, LME2000)\n\ne = Epoch(\"2020-01-01T12:45:30.0 TDB\");\nx = [2274.0, 0.0, 0.0, 0.0, sqrt(4904.87/2274.0), 0.0];\n\nupdate_point!(FRAMES, SC, x, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"note: Note\nThe timescale used for the Epoch must be the same used in the FrameSystem.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"At this point, we are completely free to compute the state of the spacecraft with respect to any other point registered in the frame system with respect to any known set of axes at the epoch e. For example, the state in the LME2000 is:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"vector6(FRAMES, Moon, SC, LME2000, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"The spacecraft state with respect to the Earth in the GCRF, IAU_EARTH and ITRF is instead:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"vector6(FRAMES, Earth, SC, GCRF, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"vector6(FRAMES, Earth, SC, IAU_EARTH, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"vector6(FRAMES, Earth, SC, ITRF, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"while the position with respect to the Moon in the IAU_MOON and PA421 axes:","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"vector3(FRAMES, Moon, SC, IAU_MOON, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"vector3(FRAMES, Moon, SC, MOONPA_DE421, e)","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"These last examples are intended to show how easily the state of a spacecraft with respect to any other body can be retrieved by properly leveraging the FrameSystem and the high-level routines provided by this package.","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"","category":"page"},{"location":"Examples/gen/e02_hifi/","page":"High-Fidelity Earth-Moon Environment","title":"High-Fidelity Earth-Moon Environment","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"EditURL = \"../t03_eop.jl\"","category":"page"},{"location":"Tutorials/gen/t03_eop/#tutorial_03_eop","page":"04 - Loading EOP Data","title":"Loading IERS EOP data","text":"","category":"section"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"This example was generated on 2024-01-05T08:58:22.058.","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"When working with frames associated with the Earth, it is imperative to incorporate Earth Orientation Parameters (EOP) data. The EOP data are required for the accurate construction of  various Earth associated frames within the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t03_eop/#Creating-compatible-EOP-file","page":"04 - Loading EOP Data","title":"Creating compatible EOP file","text":"","category":"section"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"To minimize dependencies on external sources, FrameTransformations defines a standardized format for EOP data. The expected format consists of a file with the '.eop.dat' extension. This file should contain columns representing different Earth orientation parameters. The columns include:","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"J2000 UTC: Julian Date (UTC) for J2000 epoch.\nJ2000 TT: Julian Date (Terrestrial Time) for J2000 epoch.\nX-Pole: X-coordinate of the Celestial Intermediate Pole (CIP) in microarcseconds.\nY-Pole: Y-coordinate of the Celestial Intermediate Pole (CIP) in microarcseconds.\nUT1-UTC: The difference between Coordinated Universal Time (UTC) and Universal Time 1 (UT1), in seconds.\nUT1-TT: The difference between UT1 and TT, in seconds.\nLOD: Length of Day, the excess length of a day in milliseconds.\ndX: Nutation correction in the X-direction in microarcseconds.\ndY: Nutation correction in the Y-direction in microarcseconds.","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"Ensure that the provided EOP file adheres to this format.","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"If needed, use the Orient.prepare_eop utility function to generate a file in the correct format before attempting to load the data.","category":"page"},{"location":"Tutorials/gen/t03_eop/#Loading-EOP-data","page":"04 - Loading EOP Data","title":"Loading EOP data","text":"","category":"section"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"Once a EOP file compatible with the reader is avaliable, the data could be loaded in the environment for later use by the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"To initialize the EOP just run the Orient.init_eop function and provide as input the previosly formatted file.","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"","category":"page"},{"location":"Tutorials/gen/t03_eop/","page":"04 - Loading EOP Data","title":"04 - Loading EOP Data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Welcome-to-FrameTransformations.jl!","page":"Home","title":"Welcome to FrameTransformations.jl!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, this package is the ideal starting point. FrameTransformations.jl is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert between different time scales and representations (via Tempo.jl);\nRead binary ephemeris files (via Ephemerides.jl or CalcephEphemeris.jl)\nCreate custom reference frame systems with both standard and user-defined points and axes.\nTransform states and their higher-order derivatives between different frames (up to jerk)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of this seamlessly integrated with ForwardDiff.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using Julia's package manager: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"FrameTransformations.jl\");","category":"page"},{"location":"Modules/orient_api/#basic_orient_api","page":"Public API","title":"Orient's Public Documentation","text":"","category":"section"},{"location":"Modules/orient_api/#iers_models","page":"Public API","title":"IAU Models","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"This is a list of the supported IAU models and their approximations that can be used to select the desired procedure for the computation of the ITRF to GCRF rotation.","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"\niau2000a\niau2000b\n\niau2006a\niau2006b \n\nCPNc\nCPNd","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2000a","page":"Public API","title":"FrameTransformations.Orient.iau2000a","text":"iau2000a\n\nThe singleton instance of type IAU2006a, representing the IAU 2000B family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2000b","page":"Public API","title":"FrameTransformations.Orient.iau2000b","text":"iau2000b\n\nThe singleton instance of type IAU2006a, representing the IAU 2000B family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2006a","page":"Public API","title":"FrameTransformations.Orient.iau2006a","text":"iau2006a\n\nThe singleton instance of type IAU2006a, representing the IAU 2006A family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2006b","page":"Public API","title":"FrameTransformations.Orient.iau2006b","text":"iau2006b\n\nThe singleton instance of type IAU2006B, representing the IAU 2006B family of models.\n\nnote: Note\nThis is not an official IERS model.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.CPNc","page":"Public API","title":"FrameTransformations.Orient.CPNc","text":"CPNc\n\nThe singleton instance of type CPNC, representing the concise CPNc from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few mas.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.CPNd","page":"Public API","title":"FrameTransformations.Orient.CPNd","text":"CPNd\n\nThe singleton instance of type CPND, representing the concise CPNd from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few arcseconds.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#EOP-Data","page":"Public API","title":"EOP Data","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"init_eop\nprepare_eop\neop_data_filename \nIERS_EOP","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.init_eop","page":"Public API","title":"FrameTransformations.Orient.init_eop","text":"init_eop(filename)\n\nInitialize Earth Orientation Parameters (EOP) from file.  \n\nwarn: Warn\nThis function must be called to initialize the EOP data used by frames, in case  Earth-associated frames are used.  \n\nwarn: Warn\nThis function accept only .eop.dat files. Please use prepare_eop to transform  IERS EOP files in this format.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.prepare_eop","page":"Public API","title":"FrameTransformations.Orient.prepare_eop","text":"prepare_eop(iers_file::AbstractString, output_filename::AbstractString=\"iau2000a\")\n\nPrepare Earth Orientation Parameters (EOP) data from IERS EOP C04 files to JSMD's eop.dat  convenience format. The output_filename should not include the file extension, which is  automatically added by this function. \n\n# Save a new file called: test.eop.dat\nprepare_eop(\"input.csv\", \"test\")\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.eop_data_filename","page":"Public API","title":"FrameTransformations.Orient.eop_data_filename","text":"eop_data_filename()\n\nGet loaded Earth Orientation Parameters (EOP) filename.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.IERS_EOP","page":"Public API","title":"FrameTransformations.Orient.IERS_EOP","text":"IERS_EOP\n\nEarth Orientation Parameters interpolators: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values  at 1-day intervals) with respect to IAU 2006/2000A precession-nutation model and consistent  with ITRF2014.\n\nSee also: EOPInterpolator\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#IERS-Transformations","page":"Public API","title":"IERS Transformations","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"orient_rot3_itrf_to_gcrf\norient_rot6_itrf_to_gcrf\norient_rot9_itrf_to_gcrf\norient_rot12_itrf_to_gcrf\norient_bias_precession\norient_bias_precession_nutation\norient_gast \norient_gmst\norient_nutation\norient_obliquity","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","text":"orient_rot3_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF at time t expressed as  TT seconds since J2000, according to the IAU Model m, as follows:\n\nIAU2000A: the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2000A model.\nIAU2000B: only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation    matrix is computed following the IAU 2000 model but with truncated expressions for the    nutation corrections. \nIAU2006A: the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2006/2000A model.\nIAU2006B: only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation   matrix is computed following the IAU 2006A model but with truncated expressions for the    nutation corrections. \nCPNc: a concise model with a cut-off at 2.5 mas of the X and Y series, delivering a    worst-case accuracy of about 15 mas between 1995-2050. It does not take into account the    Free Core Nutation (~0.2 mas). \nCPNd: an extremely concise formulation with an accuracy of about 1 arcsec between 1995    and 2050. It neglects polar-motion (~0.25 arcsec), the FCN corrections and the CIO locator. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\n\n\n\n\n\norient_rot3_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0)\n\nCompute the rotation matrix from ITRF to GCRF according to the IAU Model m, at time tt  and ut1 expressed in TT seconds and UT1 days since J2000, respectively.  \n\nThis function has been implemented for IAU2000, IAU2006 and CPN models.\n\nnote: Note\nAll the input quantities xₚ, yₚ, dX and dY must be expressed in radians\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","text":"orient_rot6_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its derivative at time t  expressed as TT seconds since J2000, according to the the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","text":"orient_rot9_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its time derivatives up to order 2 at  time t expressed as TT seconds since J2000, according to the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","text":"orient_rot12_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its time derivatives up to order 3 at  time t expressed as TT seconds since J2000, according to the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession","page":"Public API","title":"FrameTransformations.Orient.orient_bias_precession","text":"orient_bias_precession(m::IAUModel, t::Number)\n\nForm the precession-frame bias (PB) matrix that transforms vectors from the GCRS to the  mean of date, following the IAU Model m at time t expressed as TT Julian centuries  since J2000.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nReferences:\n\nIAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc. 24th General Assembly,  Manchester, UK.  Resolutions B1.3, B1.6. (2000)\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with IAU  2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA pmat06 function.\nERFA pmat00 function.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession_nutation","page":"Public API","title":"FrameTransformations.Orient.orient_bias_precession_nutation","text":"orient_bias_precession_nutation(m::IAUModel, t::Number)\n\nCompute the equinox-based bias-precession-nutation matrix using the IAU Model m procedures  at time t expressed in TT Julian centuries since J2000.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nnote: Note\nThe computed matrix rotates a vector from the GCRS to the true equatorial triad of date.\n\nReferences\n\nERFA pn06 function\nERFA pn00 function\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_gast","page":"Public API","title":"FrameTransformations.Orient.orient_gast","text":"orient_gast(m::IAUModel, t::Number)\n\nCompute the Greenwich Apparent Sidereal Time (GAST), in radians, given time t as TT Julian  centuries since J2000 according to the IAU Model m.\n\nnote: Note\nFor the IAU2000B model, as an approximation ERFA uses UT1 instead of TDB (or TT) to  compute the precession component of GMST and the equation of the equinoxes. This  approximation is not performed in this framework.\n\nnote: Note\nThis function computes the Earth Rotation Angle (ERA) by automatically converting TT to  UT1. Lower-level interfaces are also available to minimise the number of repeated  computations. \n\nSee also\n\nSee also orient_gmst.\n\n\n\n\n\norient_gast(m::IAUModel, t::Number, θ::Number)\n\nCompute the Greenwich Apparent Sidereal Time (GAST), in radians, given time t as TT  Julian centuries since J2000 and the Earth Rotation Angle (ERA) θ, in radians, according  to the IAU Model m.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nReferences\n\nERFA gst00a routine.\nERFA gst06a routine.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_gmst","page":"Public API","title":"FrameTransformations.Orient.orient_gmst","text":"orient_gmst(::IAUModel, t::Number)\n\nCompute the Greenwich Mean Sidereal Time (GMST), in radians, according to the IAU Model m,  given time tt expressed in TT Julian centuries since J2000. \n\nnote: Note\nThis function is valid for the IAU2000 and IAU2006 models only.\n\nnote: Note\nThis function computes the Earth Rotation Angle (ERA) by automatically converting TT to  UT1. Lower-level interfaces are also available to minimise the number of repeated  computations. \n\nSee also\n\nSee also orient_gast.\n\n\n\n\n\norient_gmst(m::IAU1980Model, ut1::Number)\n\nCompute the Greenwich Mean Sidereal Time (GMST), in radians, according to the IAU 1980  models, given time ut1 expressed in UT1 Julian centuries since J2000. \n\nReferences\n\nERFA gmst82 routine.\n\n\n\n\n\norient_gmst(m::IAUModel, tt::Number, θ::Number)\n\nCompute the Greenwich Mean Sidereal Time (GMST), in radians, according to the IAU Model m,  given the Earth Rotation Angle (ERA) θ, in radians and the time tt expressed in TT  Julian centuries since J2000. \n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nReferences\n\nERFA gmst00 routine.\nERFA gmst06 routine.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_nutation","page":"Public API","title":"FrameTransformations.Orient.orient_nutation","text":"orient_nutation(m::IAUModel, t::Number)\n\nCompute the nutation components in longitude and obliquity for the IAU Model m, in radians,  at time t expressed in TT Julian Centuries since J2000.\n\nNotes\n\nDue to their theoretical basis, the original developments required t expressed as TDB.  However, in practice, it is usually more convenient to use Terrestrial Time (TT) as it makes  no significant differences (< 0.01 μas) in the final result.\nFor the IAU 2006A model, the function strictly follows the SOFA implementation. It first  computes the IAU 2000A nutation, then applies adjustments for the consequences of the change  in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) for the secular  variation in the Earth's dynamical form factor J2. These corrections ensure that the IAU  2000A nutation is consistent with the IAU 2006 precession model. Please note that the  coefficients available on the IERS tables already include those corrections, and are  retrieved by multiplying the amplitudes of the SOFA nutation in longitude coefficients by  1.00000047. \nThe computation of the free-core nutation and time dependent effects are excluded from this  model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation models,  such effects must be included a-posteriori (through dX and dY) using the IERS EOP data.\nFor the IAU 2000B model, the nutation series is truncated from nearly 1400 terms to only 77,  yet it still delivers results of 1 mas accuracy at present epochs. In particular, it delivers  a pole accurate to 1 mas from 1900 to 2100 (only very occasionally just outside 1 mas).  The coefficients are taken from SOFA's implementation, which slighlty differ from those  reported in McCarthy and Luzum (2003). Comparisons with IAU 2006A show that the SOFA version  between 1995 and 2050 delivers 0.283 mas RMSE (0.994 mas in the worst case), whereas the  IERS Conventions website version delivers 0.312 RMSE (1.125 mas in the worst case).\nThe IAU 2000B model includes constant planetary bias terms that compensate for long-period  nutations. These amplitudes used in this implementation are optimised for a rigorous method,  where frame bias, precession and nutation are applied separately and in that order  (see SOFA's documentation for further insights).\nA simplified version of the Fundamental Arguments, taken from Simon et al (1994) is exploited  for IAU2000B as the error introduced is below the model accuracy ( ~0.1 mas).\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nSimon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets.\nERFA nut06a and  nut00b functions \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_obliquity","page":"Public API","title":"FrameTransformations.Orient.orient_obliquity","text":"orient_obliquity(m::IAUModel, t::Number)\n\nCompute the mean obliquity of the ecliptic at epoch, in radians, at time t expressed  in TT Julian centuries since J2000. \n\nnote: Note\nThis function is implemented only for IAU1980 and IAU2006 models. IAU 2000 Models  implement proper precession-rate corrections to the IAU1980 mean obliquity. \n\nReferences\n\nERFA obl80 and  obl06 functions.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#Moon-Transformations","page":"Public API","title":"Moon Transformations","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"orient_rot3_icrf_to_pa421\norient_rot3_icrf_to_pa440","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421","page":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa421","text":"orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, t::Number)\n\nCompute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the given  input time t, expressed in seconds since J2000. \n\nwarning: Warning\nThis function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions.\n\n\n\n\n\norient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, ep::Epoch)\n\nCompute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the input  epoch ep.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440","page":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa440","text":"orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, t::Number)\n\nCompute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the given  input time t, expressed in seconds since J2000. \n\nwarning: Warning\nThis function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions.\n\n\n\n\n\norient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, ep::Epoch)\n\nCompute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the input  epoch ep.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#Geodesy","page":"Public API","title":"Geodesy","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"geoc2pos\npos2geoc\ngeod2pos\npos2geod","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.geoc2pos","page":"Public API","title":"FrameTransformations.Orient.geoc2pos","text":"geoc2pos(r::Number, λ::Number, ϕ::Number)\ngeoc2pos(geoc::AbstractArray)\n\nTransform geocentric coordinates in a cartesian position vector, given the longitude λ,  the geocentric latitude ϕ and the radius r.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.pos2geoc","page":"Public API","title":"FrameTransformations.Orient.pos2geoc","text":"pos2geoc(pos::AbstractVector)\n\nTransform a cartesian 3-elements position vector pos into radius, longitude and geocentric  latitude, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.geod2pos","page":"Public API","title":"FrameTransformations.Orient.geod2pos","text":"geod2pos(h::Number, λ::Number, ϕ::Number, R::Number, f::Number)\n\nTransform longitude λ, geodetic latitude ϕ and altitude over the reference ellipsoid to  a cartesian position vector, given the reference radius R and the flattening f.\n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.pos2geod","page":"Public API","title":"FrameTransformations.Orient.pos2geod","text":"pos2geod(pos::AbstratVector, R::Number, f::Number, toll::Number=1e-12)\n\nTransform a cartesian 3-elements position vector pos into longitude, geodetic latitude  and altitude over the reference ellipsoid with radius R and flattening f. \n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#orient_axesid","page":"Public API","title":"Axes ID","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"This is a list of NAIF IDs for standard axes that are used in astrodynamic applications. ","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"note: Note\nAlthough they are listed in the public documentation section, these IDs are not directly exported by the package.","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"Orient.AXESID_B1950\nOrient.AXESID_ECLIPB1950\nOrient.AXESID_ECLIPJ2000\nOrient.AXESID_FK4\nOrient.AXESID_GALACTIC \nOrient.AXESID_GCRF\nOrient.AXESID_ICRF\nOrient.AXESID_ITRF\nOrient.AXESID_MEME2000\nOrient.AXESID_MOONME_DE421\nOrient.AXESID_MOONPA_DE421\nOrient.AXESID_MOONPA_DE440","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_B1950","page":"Public API","title":"FrameTransformations.Orient.AXESID_B1950","text":"AXESID_B1950\n\nNAIF Axes ID for the Mean Equator and Dynamical Equinox of the Besselian year 1950. \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_ECLIPB1950","page":"Public API","title":"FrameTransformations.Orient.AXESID_ECLIPB1950","text":"AXESID_ECLIPB1950\n\nNAIF Axes ID for the Mean Ecliptic Equinox of B1950.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_ECLIPJ2000","page":"Public API","title":"FrameTransformations.Orient.AXESID_ECLIPJ2000","text":"AXESID_ECLIPJ2000\n\nNAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECLIPJ2000) \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_FK4","page":"Public API","title":"FrameTransformations.Orient.AXESID_FK4","text":"AXESID_FK4\n\nNAIF Axes ID for the FK4 reference frame.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_GALACTIC","page":"Public API","title":"FrameTransformations.Orient.AXESID_GALACTIC","text":"AXESID_GALACTIC\n\nNAIF Axes ID for the Galactic System II reference frame.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_GCRF","page":"Public API","title":"FrameTransformations.Orient.AXESID_GCRF","text":"AXESID_GCRF\n\nAxes ID for the Geocentric Celestial Reference Frame (GCRFF)\n\nnote: Note\nAlthough the ICRF and GCRF axes are identical, they are based upon a different  timescale. A different ID is here assigned to provide a robust way of distinguishing  between the two. 23 has been chosen because it is one the unassigned axes ID among the  built-in SPICE frames.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_ICRF","page":"Public API","title":"FrameTransformations.Orient.AXESID_ICRF","text":"AXESID_ICRF\n\nNAIF Axes ID for the International Celestial Reference Frame (ICRF)\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_ITRF","page":"Public API","title":"FrameTransformations.Orient.AXESID_ITRF","text":"AXESID_ITRF\n\nNAIF Axes ID for the International Terrestrial Reference Frame (ITRF)\n\nnote: Note\nThis ID is based upon the ID used to refer to the ITRF93 in NAIF's high-accuracy  Earth rotation model PCK kernels.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MEME2000","page":"Public API","title":"FrameTransformations.Orient.AXESID_MEME2000","text":"AXESID_MEME2000\n\nAxes ID for the Mean Dynamical Equator and Equinox of J2000.0. \n\nnote: Note\nIn SPICE the J2000 and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the MEME2000 axes. 22 has been chosen because it is the  first unassigned axes ID among the built-in SPICE frames. \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONME_DE421","page":"Public API","title":"FrameTransformations.Orient.AXESID_MOONME_DE421","text":"AXESID_MOONME_DE421\n\nNAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE421","page":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE421","text":"AXESID_MOONPA_DE421\n\nNAIF axes id for the DE421 Moon Principal Axes (PA421).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE440","page":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE440","text":"AXESID_MOONPA_DE440\n\nNAIF Axes id for the DE440 Moon Principal Axes (PA440).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#orient_dcms","page":"Public API","title":"Default Rotation Matrices","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"note: Note\nAlthough they are listed in the public documentation section, the rotation matrices of some older frames (e.g., B1950, FK4 and GALACTIC) are not exported by the package.","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"Orient.DCM_B1950_TO_ECLIPB1950\nOrient.DCM_B1950_TO_FK4\nOrient.DCM_ICRF_TO_ECLIPJ2000\nOrient.DCM_ICRF_TO_MEME2000\nOrient.DCM_FK4_TO_GALACTIC\nOrient.DCM_MEME2000_TO_ECLIPJ2000\nOrient.DCM_MEME2000_TO_B1950\nOrient.DCM_MOON_PA421_TO_ME421\nOrient.DCM_MOON_PA430_TO_ME421\nOrient.DCM_MOON_PA430_TO_ME430\nOrient.DCM_MOON_PA440_TO_ME421","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_B1950_TO_ECLIPB1950","page":"Public API","title":"FrameTransformations.Orient.DCM_B1950_TO_ECLIPB1950","text":"DCM_B1950_TO_ECLIPB1950\n\nDCM for the rotation from the Mean Equator and Dynamical Equinox of B1950 (MEMEB1950) to the Mean Ecliptic Equinox of B1950. This corresponds to the transformation B1950 -> ECLIPB1950  in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory.\n\nReferences\n\nSPICE Library\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_B1950_TO_FK4","page":"Public API","title":"FrameTransformations.Orient.DCM_B1950_TO_FK4","text":"DCM_B1950_TO_FK4\n\nDCM for the rotation from the Mean Equator and Dynamical Equinox of B1950 (MEMEB1950) ot  the FK4 reference frame. \n\nnote: Note\nThe FK4 reference frame is obtained from the B1950 frame by applying the equinox offset  determined by Fricke.\n\nReferences\n\nSPICE Library\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","page":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","text":"DCM_ICRF_TO_ECLIPJ2000\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) to the  Mean Ecliptic Equinox of J2000 (ECLIPJ2000).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_MEME2000","page":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_MEME2000","text":"DCM_ICRF_TO_MEME2000\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) and the  Mean Equator and Equinox of J2000.0 (MEME2000). This corresponds to the J2000 frame in  the SPICE toolkit.\n\nnote: Note\nThe frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond.Moreover, according to Hilton  there are multiple possibilities to define the proper rotation between the ICRS and  the MEME2000. The transformation implemented here correspond to Eq. 6 using the parameters  in Table 3, line 1 (RIERS).\n\nReferences\n\nHilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI: 10.1051/0004-6361:20031552\nSOFA docs\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_FK4_TO_GALACTIC","page":"Public API","title":"FrameTransformations.Orient.DCM_FK4_TO_GALACTIC","text":"DCM_FK4_TO_GALACTIC\n\nDCM for the rotation from the FK4 frame to the Galactic System II reference frame.\n\nnote: Note\nAs the SPICE toolkit, we assume that this rotation is derived from the FK4 frame.\n\nReferences\n\nSPICE Library\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MEME2000_TO_ECLIPJ2000","page":"Public API","title":"FrameTransformations.Orient.DCM_MEME2000_TO_ECLIPJ2000","text":"DCM_MEME2000_TO_ECLIPJ2000\n\nDCM for the rotation from the Mean Equator and Equinox of J2000 (MEME2000) to the  Mean Ecliptic Equinox. This corresponds to the transformation J2000 -> ECLIPJ2000  in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MEME2000_TO_B1950","page":"Public API","title":"FrameTransformations.Orient.DCM_MEME2000_TO_B1950","text":"DCM_MEME2000_TO_B1950\n\nDCM for the rotation from the Mean Equator and Equinox of J2000.0 (MEME2000) to the Mean Equator and Dynamical Equinox of B1950 (B1950).\n\nnote: Note\nThis rotation is obtained by precessing the J2000 frame backwards from Julian year 2000  to Besselian year 1950, using the 1976 IAU precession model. The rotation values  are taken from the SPICE toolkit. \n\nReferences\n\nSPICE Library\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","text":"DCM_MOON_PA421_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 421 (PA421) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nJ. G. Williams et al. (2008), DE421 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE421 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","text":"DCM_MOON_PA430_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nFolkner M. William et al. (2014), The Planetary and Lunar EphemeridesDE430 and DE431\nJ. G. Williams et al. (2013), DE430 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE430 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","text":"DCM_MOON_PA430_TO_ME430\n\nDCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE430 (ME430) axes.\n\nReferences\n\nFolkner M. William et al. (2014), The Planetary and Lunar EphemeridesDE430 and DE431\nJ. G. Williams et al. (2013), DE430 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE430 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","text":"DCM_MOON_PA440_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 440 (PA440) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nPark, S. R. et al. (2021), The JPL Planetary and Lunar Ephemerides DE440 and DE441,  DOI: 10.3847/1538-3881/abd414 \n\n\n\n\n\n","category":"constant"}]
}
