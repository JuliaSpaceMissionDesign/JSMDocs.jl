var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Performance-Benchmarks","page":"Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"A comparative analysis of the execution times of various routines of this package against  other state-of-the-art packages and libraries is here reported. ","category":"page"},{"location":"benchmarks/#IERS-Rotation-Models","page":"Benchmarks","title":"IERS Rotation Models","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The Orient sub-module provides the capability to compute high-accuracy Earth rotation models based on the IERS 2010 conventions. However, differently from traditional packages, it leverages Julia's metaprogramming capabilities to generate optimised functions for the computation of the lengthy 2000A/B nutation series. A comparison against both ERFA.jl and SatelliteToolbox.jl is here reported.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/assets/85893254/1bbd17b6-c487-487a-8f24-99bc671eeabf\" width = \"512\" /> \n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: Details\nThese time benchmarks have been obtained on an Intel Core i7-6700 @ 3.4 GHz with 16 GB of RAM","category":"page"},{"location":"benchmarks/#Relative-Orientation","page":"Benchmarks","title":"Relative Orientation","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Frames' performance have been tested against both GODOT and SPICE.jl, two of the most-popular packages that can be used to define a system of reference axes and points and to compute the transformations between them. In particular, a comparative analysis of the execution times for computing the relative orientation between different reference axes has been carried out across four distinct scenarios: ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Case 1: From ICRF to the ECLIPJ2000 frame, a time-fixed rotation. \nCase 2: From the IAU-MOON to the ICRF, a time-dependent rotation. \nCase 3: From the IAU-MOON to the ICRF and subsequently to the IAU_EARTH. \nCase 4: From the IAU-MOON, to the ICRF, to the ECLIPJ2000 and finally a shift to the Sun-Earth rotating two-vector frame. Notice that the Sun and Earth positions are retrieved from binary ephemeris kernels.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/assets/85893254/c8688165-728b-4053-9912-f5ac973e892d\" width = \"512\" /> \n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: Details\nThese time benchmarks have been obtained on an Intel Core i7-12700 @ 4.7 GHz with 32 GB of RAM","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This figure also underlines the capability of FrameTransformations (here referred to as Multiverse) to use different ephemeris readers as backends within the computational graph.","category":"page"},{"location":"benchmarks/#Relative-States","page":"Benchmarks","title":"Relative States","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"note: Note\nWork in progress","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"EditURL = \"../t01_rotation.jl\"","category":"page"},{"location":"Tutorials/gen/t01_rotation/#tutorial_01_rotation","page":"02 - Rotation","title":"Rotations","text":"","category":"section"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"This example was generated on 2024-05-31T12:29:08.603.","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"Before diving into the creation of the axes graph, it is worth highlighting that transformations that express the relative orientation or its time-derivatives between two generic set of axes are represented by a Rotation object, which stores a Direction Cosine Matrix (DCM) and its derivatives. This package leverages the already available ReferenceFrameRotations.jl to define the DCM objects.","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"A time-fixed rotation between two axes and its derivative can then be expressed as follows:","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"using FrameTransformations\nusing ReferenceFrameRotations\n\ndcm  = angle_to_dcm(π/3, :Z)\nδdcm = DCM(0I)\n\nR = Rotation(dcm, δdcm)","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"A rotation object is returned by all the rotation functions that are applied to the FrameSystem. It provide overloads to the basic algebraic operations so that multiplication and inversions can be efficiently computed leveraging the properties of rotation matrixes.","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"For example, to rotate a generic vector v, we can simply do:","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"v = [1., -6., 3., 0., 5., 0]\nR*v","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"The inverse can instead be taken as:","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"inv(R)","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"See the Rotation API for more information on this object.","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"","category":"page"},{"location":"Tutorials/gen/t01_rotation/","page":"02 - Rotation","title":"02 - Rotation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/axes_api/#axes_api","page":"Axes","title":"Axes","text":"","category":"section"},{"location":"API/axes_api/#Core","page":"Axes","title":"Core","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes!\n\nadd_axes_root!\nadd_axes_inertial!\nadd_axes_rotating!\nadd_axes_fixedoffset!\nadd_axes_alias!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes!","page":"Axes","title":"FrameTransformations.add_axes!","text":"add_axes!(frames, name::Symbol, id::Int, class::Int, funs, parentid)\n\nAdd a new axes node to frames.\n\nInputs\n\nframes – Target frame system \nname – Axes name, must be unique within frames \nid – Axes ID, must be unique within frames\nclass – Axes class.  \nfuns – FrameAxesFunctions object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of frames.\nparentid – Axes ID of the parent axes. Not required only for the root axes.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see add_axes_inertial!, add_axes_rotating!,  add_axes_fixedoffset! and add_axes_root!.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_root!","page":"Axes","title":"FrameTransformations.add_axes_root!","text":"add_axes_root!(frames, name::Symbol, id::Int)\n\nCreate root axes in frames.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_inertial!","page":"Axes","title":"FrameTransformations.add_axes_inertial!","text":"add_axes_inertial!(frames, name, id, parent, fun)\n\nAdd inertial axes name and id id as a set of inertial axes to frames. The axes relation  to the parent axes are given by a fun.\n\nSee also\n\nSee also add_axes!.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_rotating!","page":"Axes","title":"FrameTransformations.add_axes_rotating!","text":"add_axes_rotating!(frames, name::Symbol, id::Int, parent, fun, δfun=nothing, \n    δ²fun=nothing, δ³fun=nothing)\n\nAdd axes as a set of rotating axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a Direction Cosine Matrix (DCM).\nδfun: return the DCM and its 1st order time derivative.\nδ²fun: return the DCM and its 1st and 2nd order time derivatives.\nδ³fun: return the DCM and its 1st, 2nd and 3rd order time derivatives.\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed via automatic differentiation.\n\nwarning: Warning\nIt is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_fixedoffset!","page":"Axes","title":"FrameTransformations.add_axes_fixedoffset!","text":"add_axes_fixedoffset!(frames, name::Symbol, id::Int, parent, dcm:DCM)\n\nAdd axes name with id id to frames with a fixed-offset from parent.  Fixed offset axes have a constant orientation with respect to their parent axes,  represented by dcm, a Direction Cosine Matrix (DCM).\n\nSee also\n\nSee also add_axes!.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_alias!","page":"Axes","title":"FrameTransformations.add_axes_alias!","text":"add_axes_alias!(frames, target, alias::Symbol)\n\nAdd a name alias to a target axes registered in frames.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Celestial","page":"Axes","title":"Celestial","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes_gcrf!\nadd_axes_icrf!\nadd_axes_eme2000!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes_gcrf!","page":"Axes","title":"FrameTransformations.add_axes_gcrf!","text":"add_axes_gcrf!(frames::FrameSystem)\n\nAdd the Geocentric Celestial Reference Frame (GCRF) to the frames graph. The axes are  automatically named GCRF and assigned the 23 ID. These axes can only  be defined as a set of root axes or as child of the ICRF (ID = 1).\n\nSee also\n\nSee also add_axes_icrf! and AXESID_GCRF.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_icrf!","page":"Axes","title":"FrameTransformations.add_axes_icrf!","text":"add_axes_icrf!(frames::FrameSystem)\n\nAdd the International Celestial Reference Frame (ICRF) as the root axes of the frames graph. The axes are automatically named ICRF and assigned the 1 ID. \n\nSee also\n\nSee also add_axes_root!, add_axes_gcrf! and AXESID_ICRF.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_eme2000!","page":"Axes","title":"FrameTransformations.add_axes_eme2000!","text":"add_axes_eme2000!(frames, name::Symbol=:EME2000, parentid::Int=AXESID_ICRF, \n    id::Int = AXESID_EME2000)\n\nAdd Mean Equator Mean Equinox of J2000 axes to frames. Custom name, id and parentid  can be assigned by the user.\n\nSee also\n\nSee also DCM_ICRF_TO_EME2000.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Ecliptic","page":"Axes","title":"Ecliptic","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes_ecl2000!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes_ecl2000!","page":"Axes","title":"FrameTransformations.add_axes_ecl2000!","text":"add_axes_ecl2000!(frames, name::Symbol=:ECL2000, parentid::Int, id::Int = AXESID_ECL2000; \n    model::IERSModel=iers1996)\n\nAdd Ecliptic Equinox of J2000 (ECL2000) axes to frames. Custom id, name and parentid can be assigned by the user. The admissible parent axes are the following: \n\nICRF: for the International Celestial Reference Frame, with ID = 1\nGCRF: for the Geocentric Celestial Reference Frame, with ID = 23\nEME2000: the Mean Earth/Moon Ephemeris of J2000, with ID = 22\n\nnote: Note\nThe obliquity of the ecliptic is computed using the IERS convention model. To retrieve the same orientation of the ECLIPJ2000 axes avaialble in the SPICE  Toolkit, the iers1996 model must be used.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Terrestrial","page":"Axes","title":"Terrestrial","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes_itrf!\nadd_axes_tirf!\nadd_axes_cirf!\n\nadd_axes_mod!\nadd_axes_tod!\nadd_axes_gtod!\nadd_axes_pef!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes_itrf!","page":"Axes","title":"FrameTransformations.add_axes_itrf!","text":"add_axes_itrf!(frames::FrameSystem, name::Symbol, parentid::Int=AXESID_ICRF, id::Int=AXESID_ITRF,\n    model::IERSModel=iers2010b)\n\nAdd International Terrestrial Reference Frame (ITRF) axes to frames. Use the model  argument to specify which IERS convention should be used for the computations.\n\nwarning: Warning\nIf the ID of the parent set of axes is neither the ICRF (ID = 1) nor the GCRF (ID = 23), an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_tirf!","page":"Axes","title":"FrameTransformations.add_axes_tirf!","text":"add_axes_tirf!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b)\n\nAdd Terrestrial Intermediate Reference Frame (TIRF) axes to frames. Use the model argument  to specify which IERS convention should be used for the computations.\n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_cirf!","page":"Axes","title":"FrameTransformations.add_axes_cirf!","text":"add_axes_cirf!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b)\n\nAdd Celestial Intermediate Reference Frame (CIRF) axes to frames. Use the model argument  to specify which IERS convention should be used for the computations.\n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_mod!","page":"Axes","title":"FrameTransformations.add_axes_mod!","text":"add_axes_mod!(frames, name::Symbol, axesid::Int, parentid::Int, \n    model::IERSConventions.IERSModel=iers2010b)\n\nAdd Mean Equator and Equinox of Date (MOD) axes to frames. Use the model argument to  specify which IERS convention should be used for the computations.\n\nnote: Note\nThe Mean-of-Date axes are obtained by applying the frame bias and precession matrix.  For this reason, if the IERS 1996 conventions are used, the rotation is  actually computed starting from the EME2000 rather than the GCRF.  \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_tod!","page":"Axes","title":"FrameTransformations.add_axes_tod!","text":"add_axes_tod!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b)\n\nAdd True Equator of Date (TOD) axes to frames. Use the model argument to specify which  IERS convention should be used for the computations.\n\nnote: Note\nThe True-of-Date axes are obtained by applying the frame bias, precession and  nutation matrix. For this reason, if the IERS 1996 conventions are used, the  rotation is actually computed starting from the EME2000 rather than the GCRF.  \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_gtod!","page":"Axes","title":"FrameTransformations.add_axes_gtod!","text":"add_axes_gtod!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b)\n\nAdd Greenwich True-of-Date (GTOD) axes to frames. Use the model argument to specify  which IERS convention should be used for the computations.\n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_pef!","page":"Axes","title":"FrameTransformations.add_axes_pef!","text":"add_axes_pef!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b)\n\nAdd Pseudo-Earth Fixed (PEF) axes to frames. Use the model argument to specify which  IERS convention should be used for the computations.\n\nwarning: Warning\nThe ID of the parent set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Lunar","page":"Axes","title":"Lunar","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes_me421!\nadd_axes_pa421!\nadd_axes_pa440!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes_me421!","page":"Axes","title":"FrameTransformations.add_axes_me421!","text":"add_axes_me421!(frames, name::Symbol, parentid::Int, axesid::Int=AXESID_MOONME_DE421)\n\nAdd DE421 Moon's Mean Earth/Mean Rotation (ME) axes to frames.\n\nwarning: Warning\nThe parent set of axes must either the DE440 Principal Axes (PA440, ID = or the DE421 Principal Axes (PA421, ID = 31006), otherwise an error is thrown. Depending on that, the  relative axes orientation will be automatically selected by this function. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_pa421!","page":"Axes","title":"FrameTransformations.add_axes_pa421!","text":"add_axes_pa421!(frames, eph::AbstractEphemerisProvider, name::Symbol, \n    id::Int=AXESID_MOONPA_DE421)\n\nAdd DE421 Moon's Principal Axes (PA) axes to frames. The libration angles are extracted  from the eph ephemeris kernels, an error is thrown if such orientation data is not available. \n\nwarning: Warning\nThe parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006).\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_pa440!","page":"Axes","title":"FrameTransformations.add_axes_pa440!","text":"add_axes_pa440!(frames, eph::AbstractEphemerisProvider, name::Symbol, \n    id::Int=AXESID_MOONPA_DE440)\n\nAdd DE440 Moon's Principal Axes (PA) axes to frames. The libration angles are extracted  from the eph ephemeris kernels, an error is thrown if such orientation data is not available. \n\nwarning: Warning\nThe parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008).\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Topocentric","page":"Axes","title":"Topocentric","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes_topocentric!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes_topocentric!","page":"Axes","title":"FrameTransformations.add_axes_topocentric!","text":"add_axes_topocentric!(frames, name::Symbol, id::Int, parentid::Int, λ, ϕ, mount)\n\nAdd topocentric axes to frames at a specified location and mounting.\n\nThe orientation relative to the parent axes parentid is defined throuh the longitude λ,  the geodetic latitude ϕ and the mounting type mount, which may be any of the following: \n\n:NED (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir.\n:SEZ (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith.\n:ENU (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith. \n\nwarning: Warning\nThe parent axes must be a set of body-fixed reference axes. This is under user  resposibility. \n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Others","page":"Axes","title":"Others","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"add_axes_twovectors!\nadd_axes_ephemeris!","category":"page"},{"location":"API/axes_api/#FrameTransformations.add_axes_twovectors!","page":"Axes","title":"FrameTransformations.add_axes_twovectors!","text":"add_axes_twovectors!(frames, name::Symbol, id::Int, parentid::Int,\n    from1::Int, to1::Int, from2::Int, to2::Int, seq::Symbol; \n    inertial::Bool=false)\n\nAdd a set of axes to frames based on two vectors defined by four points. \n\nThis function adds a new set of axes to frames using two vectors defined by four points.  The vectors are constructed from the points specified by from1 to to1 and from2 to to2.  A right-handed coordinate system is generated based on the specified sequence direction (seq),  which determines the order in which the vectors are used to define the basis.  The inertial flag specifies whether the resulting axes are inertial.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#FrameTransformations.add_axes_ephemeris!","page":"Axes","title":"FrameTransformations.add_axes_ephemeris!","text":"add_axes_ephemeris!(frames::FrameSystem{O, N}, eph::AbstractEphemerisProvider, \n    name::Symbol, id::Int, seq::Symbol, class::Int) where {O, N}\n\nAdd axes coming from an AbstractEphemerisProvider subtype to frames.  The axes are identifies by the id and a have a user defined name. The rotation matrix  is build using the rotation sequence specified in seq. The axes type is specified by class.\n\nwarning: Warning\nThis is an interface only, concrete subtypes of AbstractEphemerisProvider requires  an proper implementation.\n\n\n\n\n\n","category":"function"},{"location":"API/axes_api/#Utils","page":"Axes","title":"Utils","text":"","category":"section"},{"location":"API/axes_api/#frames_axesid","page":"Axes","title":"IDs","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"This is a list of NAIF IDs for standard axes that are used in astrodynamic applications.","category":"page"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"FrameTransformations.AXESID_ICRF\nFrameTransformations.AXESID_MOONME_DE421\nFrameTransformations.AXESID_MOONPA_DE421\nFrameTransformations.AXESID_MOONPA_DE440\nFrameTransformations.AXESID_ECL2000\nFrameTransformations.AXESID_EME2000\nFrameTransformations.AXESID_GCRF","category":"page"},{"location":"API/axes_api/#FrameTransformations.AXESID_ICRF","page":"Axes","title":"FrameTransformations.AXESID_ICRF","text":"AXESID_ICRF\n\nNAIF Axes ID for the International Celestial Reference Frame (ICRF)\n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#FrameTransformations.AXESID_MOONME_DE421","page":"Axes","title":"FrameTransformations.AXESID_MOONME_DE421","text":"AXESID_MOONME_DE421\n\nNAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421).\n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#FrameTransformations.AXESID_MOONPA_DE421","page":"Axes","title":"FrameTransformations.AXESID_MOONPA_DE421","text":"AXESID_MOONPA_DE421\n\nNAIF axes id for the DE421 Moon Principal Axes (PA421).\n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#FrameTransformations.AXESID_MOONPA_DE440","page":"Axes","title":"FrameTransformations.AXESID_MOONPA_DE440","text":"AXESID_MOONPA_DE440\n\nNAIF Axes id for the DE440 Moon Principal Axes (PA440).\n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#FrameTransformations.AXESID_ECL2000","page":"Axes","title":"FrameTransformations.AXESID_ECL2000","text":"AXESID_ECL2000\n\nNAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECL2000).\n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#FrameTransformations.AXESID_EME2000","page":"Axes","title":"FrameTransformations.AXESID_EME2000","text":"AXESID_EME2000\n\nAxes ID for the Mean Dynamical Equator and Equinox of J2000.0. \n\nnote: Note\nIn SPICE the J2000 (EME2000) and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the EME2000 axes. 22 has been chosen because it is the first  unassigned axes ID among the built-in SPICE frames. \n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#FrameTransformations.AXESID_GCRF","page":"Axes","title":"FrameTransformations.AXESID_GCRF","text":"AXESID_GCRF\n\nAxes ID for the Geocentric Celestial Reference Frame (GCRFF)\n\nnote: Note\nAlthough the ICRF and GCRF axes are identical, they are based upon a different  timescale. A different ID is here assigned to provide a robust way of distinguishing  between the two. 23 has been chosen because it is one of the unassigned axes ID among  the built-in SPICE frames.\n\n\n\n\n\n","category":"constant"},{"location":"API/axes_api/#frames_dcms","page":"Axes","title":"Rotation Matrices","text":"","category":"section"},{"location":"API/axes_api/","page":"Axes","title":"Axes","text":"FrameTransformations.DCM_ICRF_TO_EME2000","category":"page"},{"location":"API/axes_api/#FrameTransformations.DCM_ICRF_TO_EME2000","page":"Axes","title":"FrameTransformations.DCM_ICRF_TO_EME2000","text":"DCM_ICRF_TO_EME2000\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) and the  Mean Equator and Equinox of J2000.0 (EME2000). This corresponds to the J2000 frame in  the SPICE toolkit.\n\nnote: Note\nThe frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond.Moreover, according to Hilton  there are multiple possibilities to define the proper rotation between the ICRS and  the EME2000. The transformation implemented here correspond to Eq. 6 using the parameters  in Table 3, line 1 (RIERS).\n\nReferences\n\nHilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI: 10.1051/0004-6361:20031552\nSOFA docs\n\n\n\n\n\n","category":"constant"},{"location":"API/dir_api/#dir_api","page":"Directions","title":"Directions","text":"","category":"section"},{"location":"API/dir_api/","page":"Directions","title":"Directions","text":"add_direction!\n\nadd_direction_fixed!\nadd_direction_position!\nadd_direction_velocity!\nadd_direction_orthogonal!\nadd_direction_normalize!","category":"page"},{"location":"API/dir_api/#FrameTransformations.add_direction!","page":"Directions","title":"FrameTransformations.add_direction!","text":"add_direction!(frames, name::Symbol, funs)\n\nAdd a new direction node to frames.\n\nInputs\n\nframes – Target frame system \nname – Direction name, must be unique within frames \nfuns – DirectionFunctions object storing the functions to compute the direction and,            eventually, its time derivatives. It must match the type and order of frames.\n\n\n\n\n\nadd_direction!(frames, name::Symbol, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd a new direction node to frames. The orientation of these direction depends only  on time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a direction vector.\nδfun: return a direction vector and its 1st order time derivative.\nδ²fun: return a direction vector and its 1st and 2nd order time derivatives.\nδ³fun: return a direction vector and its 1st, 2nd and 3rd order time derivatives.\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed via automatic differentiation.\n\nwarning: Warning\nIt is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\n\n\n\n\n","category":"function"},{"location":"API/dir_api/#FrameTransformations.add_direction_fixed!","page":"Directions","title":"FrameTransformations.add_direction_fixed!","text":"add_direction_fixed!(frames, name, offset::AbstractVector)\n\nAdd a fixed direction to frames.\n\n\n\n\n\n","category":"function"},{"location":"API/dir_api/#FrameTransformations.add_direction_position!","page":"Directions","title":"FrameTransformations.add_direction_position!","text":"add_direction_position!(frames, name::Symbol, origin, target, ax)\n\nAdd a direction based on the position vector from origin to target in the specified ax.\n\n\n\n\n\n","category":"function"},{"location":"API/dir_api/#FrameTransformations.add_direction_velocity!","page":"Directions","title":"FrameTransformations.add_direction_velocity!","text":"add_direction_velocity!(frames, name::Symbol, origin, target, ax)\n\nAdd a direction based on the velocity vector from origin to target in the specified ax.\n\n\n\n\n\n","category":"function"},{"location":"API/dir_api/#FrameTransformations.add_direction_orthogonal!","page":"Directions","title":"FrameTransformations.add_direction_orthogonal!","text":"add_direction_orthogonal!(frames, name::Symbol, dir1, dir2)\n\nAdd a direction as the cross product between two existing directions (i.e. dir1 and dir2).\n\n\n\n\n\n","category":"function"},{"location":"API/dir_api/#FrameTransformations.add_direction_normalize!","page":"Directions","title":"FrameTransformations.add_direction_normalize!","text":"add_direction_normalize!(frames, name::Symbol, dir)\n\nAdd a direction as the normalized version of dir.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#frames_api","page":"Frames","title":"Frame System","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"FrameSystem\norder \nFrameTransformations.timescale ","category":"page"},{"location":"API/frames_api/#FrameTransformations.FrameSystem","page":"Frames","title":"FrameTransformations.FrameSystem","text":"FrameSystem{O, N, S, D}\n\nA FrameSystem instance manages a collection of user-defined FramePointNode,  FrameAxesNode and Direction objects, enabling computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order O, the outputs  datatype N and an AbstractTimeScale instance S; the parameter D is the length of  the output ad shall always be 3O.\n\nThe following transformation orders are accepted: \n\n1: position \n2: position and velocity \n3: position, velocity and acceleration\n4: position, velocity, acceleration and jerk\n\n\n\nFrameSystem{O, N, S}()\n\nCreate a new, empty FrameSystem object of order O, datatype N and timescale S. The parameter S can be dropped, in case the default (BarycentricDynamicalTime) is used. \n\n\n\n\n\n","category":"type"},{"location":"API/frames_api/#FrameTransformations.order","page":"Frames","title":"FrameTransformations.order","text":"order(R::Rotation{O}) where O\n\nReturn the rotation order O.\n\n\n\n\n\norder(frames::FrameSystem{O}) where O\n\nReturn the frame system order O.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.timescale","page":"Frames","title":"FrameTransformations.timescale","text":"timescale(frames::FrameSystem{O, N, S}) where {O, N, S}\n\nReturn the frame system order timescale S.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#Points","page":"Frames","title":"Points","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"has_point\npoints \npoints_graph","category":"page"},{"location":"API/frames_api/#FrameTransformations.has_point","page":"Frames","title":"FrameTransformations.has_point","text":"has_point(frames::FrameSystem, id)\n\nCheck if id point is within frames.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.points","page":"Frames","title":"FrameTransformations.points","text":"points(f::FrameSystem)\n\nReturn the registered points names/ids map.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.points_graph","page":"Frames","title":"FrameTransformations.points_graph","text":"points_graph(frames::FrameSystem)\n\nReturn the frame system points graph.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#Axes","page":"Frames","title":"Axes","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"has_axes \nFrameTransformations.axes\naxes_graph","category":"page"},{"location":"API/frames_api/#FrameTransformations.has_axes","page":"Frames","title":"FrameTransformations.has_axes","text":"has_axes(frames::FrameSystem, ax)\n\nCheck if ax axes is within frames.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#Base.axes","page":"Frames","title":"Base.axes","text":"axes(f::FrameSystem)\n\nReturn the registered axes names/ids map.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.axes_graph","page":"Frames","title":"FrameTransformations.axes_graph","text":"axes_graph(frames::FrameSystem)\n\nReturn the frame system axes graph.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#Directions","page":"Frames","title":"Directions","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"has_direction\ndirections\ndirections_map","category":"page"},{"location":"API/frames_api/#FrameTransformations.has_direction","page":"Frames","title":"FrameTransformations.has_direction","text":"has_axes(frames::FrameSystem, name::Symbol)\n\nCheck if name direction is within frames.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.directions","page":"Frames","title":"FrameTransformations.directions","text":"directions(f::FrameSystem)\n\nReturn the registered directions names.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.directions_map","page":"Frames","title":"FrameTransformations.directions_map","text":"directions_map(f::FrameSystem)\n\nReturn the direction dictionary.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#rotation_api","page":"Frames","title":"Rotations","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"Rotation\nBase.inv","category":"page"},{"location":"API/frames_api/#FrameTransformations.Rotation","page":"Frames","title":"FrameTransformations.Rotation","text":"Rotation{O, N}\n\nA container to efficiently compute O-th order rotation matrices of type N between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the (O-1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later.\n\nThe rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object R, constructed from the  DCM A and its time derivatives δA and δ²A rotates a vector v = [p, v, a] as: \n\n̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a]\n\nA Rotation object R call always be converted to a SMatrix or a MMatrix by invoking  the proper constructor. \n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\n\n\nRotation(dcms::DCM...)\n\nCreate a Rotation object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64}\n\n\n\nRotation{O}(dcms::DCM...) where O\n\nCreate a Rotation object of order O. If the number of dcms is smaller than O, the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than  O, only the first O DCMs are used. \n\nwarning: Warning\nUsage of this constructor is not recommended as it may yield unexpected results to  unexperienced users. \n\n\n\nRotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N}\n\nCreate a Rotation object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If S1 < S2, only the first S1 DCMs are considered, otherwise the  remaining orders are filled with null DCMs.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R3 = Rotation{3}((A,B));\n\njulia> R3[1] == A\ntrue \n\njulia> R3[3] \nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\nRotation{O}(u::UniformScaling{N}) where {O, N}\nRotation{O, N}(u::UniformScaling) where {O, N}\n\nCreate an O-order identity Rotation object of type N with identity position rotation  and null time derivatives.\n\nExamples\n\njulia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],))\n\n\n\nRotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\nRotation{S1, N}(R::Rotation{S2}) where {S1, S2, N}\n\nTransform a Rotation object of order S2 to order S1 and type N. The behaviour of  these functions depends on the values of S1 and S2: \n\nS1 < S2: Only the first S1 components of rot are considered.\nS1 > S2: The missing orders are filled with null DCMs.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1);\n\njulia> R3[3]\nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\nRotation(m::DCM{N}, ω::AbstractVector) where N\n\nCreate a 2nd order Rotation object of type N to rotate between two set of axes a and  b from a Direction Cosine Matrix (DCM) and the angular velocity vector ω of b with  respect to a, expressed in b\n\n\n\n\n\n","category":"type"},{"location":"API/frames_api/#Base.inv","page":"Frames","title":"Base.inv","text":"inv(rot::Rotation)\n\nCompute the invese of the rotation object rot. The operation is efficiently performed by  taking the transpose of each rotation matrix within rot.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#transformations_api","page":"Frames","title":"Transformations","text":"","category":"section"},{"location":"API/frames_api/#points_transform_api","page":"Frames","title":"Points","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"vector3\nvector6\nvector9 \nvector12 ","category":"page"},{"location":"API/frames_api/#FrameTransformations.vector3","page":"Frames","title":"FrameTransformations.vector3","text":"vector3(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector3(frame, from, to, axes, t::Number)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.vector6","page":"Frames","title":"FrameTransformations.vector6","text":"vector6(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector6(frame, from, to, axes, t::Number)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.vector9","page":"Frames","title":"FrameTransformations.vector9","text":"vector9(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector9(frame, from, to, axes, t::Number)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.vector12","page":"Frames","title":"FrameTransformations.vector12","text":"vector12(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector12(frame, from, to, axes, t::Number)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#axes_transform_api","page":"Frames","title":"Axes","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"rotation3\nrotation6\nrotation9\nrotation12","category":"page"},{"location":"API/frames_api/#FrameTransformations.rotation3","page":"Frames","title":"FrameTransformations.rotation3","text":"rotation3(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 1.\n\n\n\n\n\nrotation3(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.rotation6","page":"Frames","title":"FrameTransformations.rotation6","text":"rotation6(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 2.\n\n\n\n\n\nrotation6(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.rotation9","page":"Frames","title":"FrameTransformations.rotation9","text":"rotation9(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 3.\n\n\n\n\n\nrotation9(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.rotation12","page":"Frames","title":"FrameTransformations.rotation12","text":"rotation12(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 4.\n\n\n\n\n\nrotation12(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000. \n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#directions_transform_api","page":"Frames","title":"Directions","text":"","category":"section"},{"location":"API/frames_api/","page":"Frames","title":"Frames","text":"direction3 \ndirection6 \ndirection9\ndirection12","category":"page"},{"location":"API/frames_api/#FrameTransformations.direction3","page":"Frames","title":"FrameTransformations.direction3","text":"direction3(frame::FrameSystem, name::Symbol, ep::Epoch)\n\nCompute the direction vector name of order 3 at epoch ep.\n\nRequires a frame system of order ≥ 1.\n\n\n\n\n\ndirection3(frame::FrameSystem, name::Symbol, t::Number)\n\nCompute the direction vector name of order 3 at epoch t, where t is  expressed in seconds since J2000.\n\nRequires a frame system of order ≥ 1.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.direction6","page":"Frames","title":"FrameTransformations.direction6","text":"direction6(frame::FrameSystem, name::Symbol, ep::Epoch)\n\nCompute the direction vector name of order 6 at epoch ep.\n\nRequires a frame system of order ≥ 2.\n\n\n\n\n\ndirection6(frame::FrameSystem, name::Symbol, t::Number)\n\nCompute the direction vector name of order 6 at epoch t, where t is  expressed in seconds since J2000.\n\nRequires a frame system of order ≥ 2.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.direction9","page":"Frames","title":"FrameTransformations.direction9","text":"direction9(frame::FrameSystem, name::Symbol, ep::Epoch)\n\nCompute the direction vector name of order 9 at epoch ep.\n\nRequires a frame system of order ≥ 3.\n\n\n\n\n\ndirection9(frame::FrameSystem, name::Symbol, t::Number)\n\nCompute the direction vector name of order 9 at epoch t, where t is  expressed in seconds since J2000.\n\nRequires a frame system of order ≥ 3.\n\n\n\n\n\n","category":"function"},{"location":"API/frames_api/#FrameTransformations.direction12","page":"Frames","title":"FrameTransformations.direction12","text":"direction12(frame::FrameSystem, name::Symbol, ep::Epoch)\n\nCompute the direction vector name of order 12 at epoch ep.\n\nRequires a frame system of order ≥ 4.\n\n\n\n\n\ndirection12(frame::FrameSystem, name::Symbol, t::Number)\n\nCompute the direction vector name of order 12 at epoch t, where t is  expressed in seconds since J2000.\n\nRequires a frame system of order ≥ 4.\n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#points_api","page":"Points","title":"Points","text":"","category":"section"},{"location":"API/point_api/","page":"Points","title":"Points","text":"add_point!\n\nadd_point_root!\nadd_point_dynamical!\nadd_point_fixedoffset!\n\nadd_point_ephemeris!\nadd_point_surface!\n\nadd_point_alias!","category":"page"},{"location":"API/point_api/#FrameTransformations.add_point!","page":"Points","title":"FrameTransformations.add_point!","text":"add_point!(frames, name, id, axesid, class, funs, parentid=nothing)\n\nCreate and add a new point node name to frames based on the input parameters. \n\nInputs\n\nframes – Target frame system \nname – Point name, must be unique within frames \nid – Point ID, must be unique within frames\naxesid – ID of the axes in which the state vector of the point is expressed. \nclass – Point class. \nfuns – FramePointFunctions object storing the functions to update the state            vectors of the point. It must match the type and order of frames\nparentid – NAIF ID of the parent point. Not required only for the root point.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see add_point_dynamical!, add_point_fixedoffset! and add_point_root!.\n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#FrameTransformations.add_point_root!","page":"Points","title":"FrameTransformations.add_point_root!","text":"add_point_root!(frames, name, id, axes)\n\nAdd root name root point with the specified id to frames.\n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#FrameTransformations.add_point_dynamical!","page":"Points","title":"FrameTransformations.add_point_dynamical!","text":"add_point_dynamical!(frames, name, id, parent, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd point as a time point to frames. The state vector for these points depends only on  time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a 3-elements vector: position\nδfun: return a 6-elements vector: position and velocity\nδ²fun: return a 9-elements vector: position, velocity and acceleration\nδ³fun: return a 12-elements vector: position, velocity, acceleration and jerk\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed with automatic differentiation. \n\nwarning: Warning\nIt is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions. \n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#FrameTransformations.add_point_fixedoffset!","page":"Points","title":"FrameTransformations.add_point_fixedoffset!","text":"add_point_fixedoffset!(frames, name, id, parent, axes, offset::AbstractVector)\n\nAdd point as a fixed-offset point to frames. Fixed points are those whose positions have a  constant offset with respect their parent points in the given set of axes. Thus, points  eligible for this class must have null velocity and acceleration with respect to parent.\n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#FrameTransformations.add_point_ephemeris!","page":"Points","title":"FrameTransformations.add_point_ephemeris!","text":"add_point_ephemeris!(frames::FrameSystem{O, N}, eph::AbstractEphemerisProvider, \n    name::Symbol, id::Int) where {O, N}\n\nAdd a point coming from an AbstractEphemerisProvider subtype.  The point is identifies by the id and a have a user defined name.\n\nwarning: Warning\nThis is an interface only, concrete subtypes of AbstractEphemerisProvider requires  an proper implementation.\n\n\n\n\n\nadd_point_ephemeris!(frames, eph::AbstractEphemerisProvider, book::Dict{Int, Symbol})\n\nAdd all points found in the eph and using id-names relationships specified in book.\n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#FrameTransformations.add_point_surface!","page":"Points","title":"FrameTransformations.add_point_surface!","text":"add_point_surface!(frames, name::Symbol, pointid::Int, parentid::Int, axesid::Int, \n    λ::Number, ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0)\n\nAdd point to frames as a fixed point on the surface of the parent point body.  The relative  position is specified by the longitude λ, the geodetic latitude ϕ,  the reference radius of the ellipsoid R and its flattening f.  The altitude over the reference surface of the  ellipsoid h defaults to 0. \n\nwarning: Warning\nAxes used here must be a set of body-fixed reference axes for the body represented by  parentid. This is under user resposibility. \n\n\n\n\n\n","category":"function"},{"location":"API/point_api/#FrameTransformations.add_point_alias!","page":"Points","title":"FrameTransformations.add_point_alias!","text":"add_point_alias!(frames, target, alias::Symbol)\nadd_point_alias!(frames, target, alias::Symbol)\n\nAdd a name alias to a target point registered in frames.\n\n\n\n\n\n","category":"function"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"EditURL = \"../t02_axes.jl\"","category":"page"},{"location":"Tutorials/gen/t02_axes/#tutorial_01_axes","page":"03 - Axes","title":"Axes","text":"","category":"section"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"This example was generated on 2024-05-31T12:29:08.608.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"To compute relative orientations, FrameTransformations provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the FrameSystem In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"At the time being, the following types of axes are supported:","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Inertial axes: these are the only ones which can be used as root axes to initialise the axes graph.\nFixed offset axes: they have a constant orientation with respect to their parent axes.\nRotating axes: the orientation of these axes depends only on time and is computed t through the custom functions provided by the user.\nEphemeris axes: these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"note: Note\nThis package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g., add_axes_ecl2000!.","category":"page"},{"location":"Tutorials/gen/t02_axes/#Graph-Initialisation","page":"03 - Axes","title":"Graph Initialisation","text":"","category":"section"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon's Principal Axes (PA) 440,  whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, Ephemerides.jl package and download the kernels from NAIF's website.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"using FrameTransformations\nusing Ephemerides\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\nconst EPH = EphemerisProvider([download(url_spk), download(url_pck)])\nconst F = FrameSystem{3, Float64}()","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"To initialise the axes graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"In this example, we will use the ICRF as our base root inertial axes.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"add_axes_root!(F, :ICRF, AXESID_ICRF)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Once a set of root axes has been registered, any other type of axes can be added to the system.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"note: Note\nFor standard applications, it is good practice that the axes's IDs are as in agreement with NAIF's numbering system. A list of IDs for the most common axes is provided in this package.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"note: Note\nThe frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis.","category":"page"},{"location":"Tutorials/gen/t02_axes/#ine_axes","page":"03 - Axes","title":"Inertial Axes","text":"","category":"section"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"In this example, we register the GCRF as a set of inertial axes with respect to the ICRF. We assume that the two frames are equivalent, thus:","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"using ReferenceFrameRotations\nusing LinearAlgebra\n\nfun(t) = DCM(1.0I)\nadd_axes_inertial!(F, :GCRF, AXESID_GCRF, AXESID_ICRF, fun)\n\nR = rotation6(F, AXESID_ICRF, AXESID_GCRF, 1.0)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Since it is an inertial frame, the time derivative of the rotation is null.","category":"page"},{"location":"Tutorials/gen/t02_axes/#fox_axes","page":"03 - Axes","title":"Fixed-offset Axes","text":"","category":"section"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation  with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"In this example, we register FOX as a set of axes with a fixed rotation of π/4 around the Z-axis with respect to the ICRF.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"rot = angle_to_dcm(π/4, :Z)\n\nadd_axes_fixedoffset!(F, :FOX, 2, AXESID_ICRF, rot)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"The state rotation matrix can then be obtained as:","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R = rotation6(F, 1, 2, 86400)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Since FOX has a constant orientation with respect to the ICRF, the time derivative of the rotation matrix R[2] is, in fact, null. For further information see the add_axes_fixedoffset! documentation.","category":"page"},{"location":"Tutorials/gen/t02_axes/#rot_axes","page":"03 - Axes","title":"Rotating Axes","text":"","category":"section"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from ReferenceFrameRotations.jl.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"fun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(F, :ROX, 3, AXESID_ICRF, fun)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"If we now compute the orientation between the FOX and ROX at π/4 we obtain an identity rotation, since the orientation of ROX is directed in the opposite direction of FOX.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R = rotation6(F, 2, 3, π/4)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of fun.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R2 = rotation6(F, 1, 3, π/4)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R2[2]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example:","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"using JSMDUtils.Math\n\nfun(t) = angle_to_dcm(-t, :Z)\ndfun(t) = (angle_to_dcm(-t, :Z), Math.angle_to_δdcm([-t, -1], :Z))\n\nadd_axes_rotating!(F, :ROX2, 4, AXESID_ICRF, fun, dfun)\n\nR2 = rotation6(F, 1, 3, π/4)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R2[2]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"We can see the results are in agreement with the previous example. For more details, see add_axes_rotating! documentation.","category":"page"},{"location":"Tutorials/gen/t02_axes/#Ephemeris-Axes","page":"03 - Axes","title":"Ephemeris Axes","text":"","category":"section"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth's ITRF.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"note: Note\nTo properly compute the orientation of these axes, the ephemeris provider used must contain the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"In this example, the ephemeris provider EPH has loaded the DE421 PCK kernel containing the orientation of the Moon's Principal Axes (PA421). NAIF's system has assigned to such set of axes the ID 31006. If a different ID was assigned to the MoonPA, the function would have thrown an error.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"add_axes_ephemeris!(F, EPH, :MOONPA, 31006, :ZXZ)\n\nR = rotation6(F, 1, 31006, 86400.0)","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[1]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"R[2]","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"For further information see the add_axes_ephemeris! documentation.","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"","category":"page"},{"location":"Tutorials/gen/t02_axes/","page":"03 - Axes","title":"03 - Axes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Welcome-to-FrameTransformations.jl!","page":"Home","title":"Welcome to FrameTransformations.jl!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, this package is the ideal starting point. FrameTransformations.jl is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert between different time scales and representations (via Tempo.jl).\nRead binary ephemeris files (via Ephemerides.jl or CalcephEphemeris.jl extensions).\nCreate custom reference frame systems with both standard and user-defined points, axes and directions.\nTransform states and their higher-order derivatives between different frames (up to jerk).","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of this seamlessly integrated with ForwardDiff.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed using Julia's package manager: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"FrameTransformations.jl\");","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"EditURL = \"../t00_frames.jl\"","category":"page"},{"location":"Tutorials/gen/t00_frames/#tutorial_00_frames","page":"01 - Frame System","title":"Frame System Overview","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"This example was generated on 2024-05-31T12:29:08.470.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"The core object of FrameTransformations is the FrameSystem, which provides the capability to compute relative position, orientation and their time derivatives up to order 3 (jerk), between standard and user-defined point and axes. It works by creating two separate graphs that silently store and manage all the parent-child relationships between the user-registered axes and points, in the form of FramePointNode and FrameAxesNode.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"These two objects define two precise entities:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Axes: defines an orientation in space. These are related each other by means of a Rotation transformation which relate one axes to a parent axes in a certain time interval.\nPoints: defines a location in space. These are related each other by means of a Translation transformation which relate one point to a parent point in a particular axes in a certain time interval.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Additionally, it is possible to create Directions, as vector valued functions that could be used to define custom frames.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"note: Note\nA single FrameSystem instance simultaneously handles both the axes and point graphs, regardless of what the user registers in it. For instance, if no points are added, the point graph will remain empty. The same applies for directions.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Additionally, any node can have several childs, each with different transformations with respect to the parent node. However, they shall be registered within the FrameSystem before being used in a transformation or as parents of other nodes.","category":"page"},{"location":"Tutorials/gen/t00_frames/#Basic-Constructors","page":"01 - Frame System","title":"Basic Constructors","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"The creation of a generic FrameSystem requires the definition of the maximum desired transformation order and of its DataType, which in most applications is a Float64. The transformation order is always one greater than the maximum desired time derivative. For instance, if the user only desires to compute position and velocity components (i.e., order 1 time-derivative), the transformation order to be used is 2. Thus, the maximum allowed transformation order is 4.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"In this example, we highlight the most basic way to initialise a FrameSystem:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"using FrameTransformations\nusing Tempo\n\nF = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"From this example, you can see that within the frame system there are both point and axes graphs. However, at the moment they are completely empty since the graph was just created.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Each FrameSystem object is assigned a reference timescale that is used to perform computations with epochs and to parse ephemeris files. The default timescale is the BarycentricDynamicalTime, however, the user is free to select the most suited timescale for his applications. In this example, we set the InternationalAtomicTime as the reference scale.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"F = FrameSystem{2, Float64, InternationalAtomicTime}()","category":"page"},{"location":"Tutorials/gen/t00_frames/#Graph-Inspection","page":"01 - Frame System","title":"Graph Inspection","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Once a FrameSystem is constructed (and populated) there are many routines devoted to inspect its content. As already said, there are three main objects that are contained in the FrameSystem: points, axes and directions. For each of them series of utility functions are made available in order to check for the presence of a registered point:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"has_point(F, 1)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"a registered axes:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"has_axes(F, 1)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"or a registered direction:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"has_direction(F, :Root)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Additionally, the possibility to get a dictionary containing all name-id relationships is made available for axes, via the axes method:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"axes(F)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"and points, via the points method:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"points(F)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Finally, the FrameSystem order and timescale might be retrieved via the associated methods:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"order(F)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"FrameTransformations.timescale(F)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Refer to the API for additional details.","category":"page"},{"location":"Tutorials/gen/t00_frames/#Basic-Usage","page":"01 - Frame System","title":"Basic Usage","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"note: Note\nWork in progress","category":"page"},{"location":"Tutorials/gen/t00_frames/#Ephemerides-Support","page":"01 - Frame System","title":"Ephemerides Support","text":"","category":"section"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"In certain scenarios, the transformations require usage of binary ephemeris kernels, e.g., the JPL's DE440 files. To support this applications, this package has an interface relying on JSMDInterfaces.jl AbstractEphemerisProviders. Currently, this package is shipped with extension for the following two ephemeris readers:","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Ephemerides.jl\nCalcephEphemeris.jl","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Once the desired ephemeris provider is created, it can be used to register points or axes. In this example we begin loading an old DE421 kernels to pass to the ephemeris reader.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"using Ephemerides, Downloads\n\nurl = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\nE = EphemerisProvider(Downloads.download(url));\n\nF = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Before registering any node, a set of root axes and a root node shall be anyway registered.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"add_axes_icrf!(F)\nadd_point_root!(F, :SSB, 0, 1)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Points from the EphemerisProvider can be now registered.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"add_point_ephemeris!(F, E, :Sun, 10)\nadd_point_ephemeris!(F, E, :EMB, 3)","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Here the parent point will be inferred from the ephemeris.","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"","category":"page"},{"location":"Tutorials/gen/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"EditURL = \"../t03_points.jl\"","category":"page"},{"location":"Tutorials/gen/t03_points/#tutorial_02_points","page":"04 - Points","title":"Points Creation and Translations","text":"","category":"section"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"This example was generated on 2024-05-31T12:29:08.614.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"Similarly to axes, FrameTransformations also provides the capability to define custom and standard reference points (e.g., the Solar System Barycenter) and arbitrarily connect them through the FrameSystem. In turn, this allows the computation of the relative position and its derivatives (up to order 3) between any two registered points and express it in any known set of axes.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"At the time being, the following types of points are supported:","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"Root point: it is the root of the point graph.\nFixed points: are those whose positions have a constant offset with respect their parent point in a given set of axes.\nDynamical points: the position of these points depends only on time and is computed through custom user-defined functions.\nEphemeris points: are those whose state-vector is retrieved from binary SPK kernels (e.g., DE440) that are loaded within the FrameSystem.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"note: Note\nThis package provides a dedicated function to register each type of supported points.","category":"page"},{"location":"Tutorials/gen/t03_points/#Graph-Initialisation","page":"04 - Points","title":"Graph Initialisation","text":"","category":"section"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"In this section we will display how to create a frame system to compute generic points transformation. Differently from the axes graph, each register point is also associated to a set of axes. Hence, this tutorial assumes the reader to already be familiar with the different types of axes and their definitions.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"We then can go ahead and initialise the graph.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"using FrameTransformations\n\nF = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/gen/t03_points/#Root-Point","page":"04 - Points","title":"Root Point","text":"","category":"section"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"To initialise the point graph, we first need to define a root point. This, in turn, must be associated to an arbitrary set of axes. Therefore, we begin by definining a generic SatFrame, here considered as inertial, and then register a root point, called SC in our graph.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"A root point can be registered using the add_point_root! function:","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"add_axes_root!(F, :SatFrame, -1)\n\nadd_point_root!(F, :SC, -10000, :SatFrame)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"tip: Tip\nFor standard applications, it is good practice that the points's IDs are as in agreement with NAIF's numbering system. This becomes mandatory to properly read JPL's SPK kernels.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"note: Note\nThe frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the point are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning.","category":"page"},{"location":"Tutorials/gen/t03_points/#Fixed-Points","page":"04 - Points","title":"Fixed Points","text":"","category":"section"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"Fixed points have a constant relative position vector with respect to their parent points in a given set of axes. Similarly to fixed-offset axes, these points are fixed w.r.t. their parents but might be moving with respect to others.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"In this example, we use the add_point_fixedoffset! function to register the location of an antenna and two solar panels, which are generally fixed in the satellite body-fixed frame. To do so, we define a position offset in the form of a 3-elements vector with respect to the SC.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"sa_offset_left = [1.0, 0.0, 0.0]\nsa_offset_right = [-1.0, 0.0, 0.0]\nan_offset = [0.0, 0.0, -1.0]\n\nadd_point_fixedoffset!(F, :SolArrLeft, -10101, :SC, :SatFrame, sa_offset_left)\nadd_point_fixedoffset!(F, :SolArrRight, -10102, :SC, :SatFrame, sa_offset_right)\nadd_point_fixedoffset!(F, :Antenna, -10001, :SC, :SatFrame, an_offset)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"As a result the graph is now populated with the new points and we can finally compute their relative positions and velocities with the proper transformation functions:","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"vector3(F, :SolArrLeft, :SC, :SatFrame, 123.0)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"vector6(F, :Antenna, :SolArrRight, :SatFrame, 456.0)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"As expected, since these points are fixed, the relative velocity vector is null.","category":"page"},{"location":"Tutorials/gen/t03_points/#Dynamical-Points","page":"04 - Points","title":"Dynamical Points","text":"","category":"section"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"Dynamical points are generic time-dependent points whose position vector (and optionally its derivatives) are only function of time. However, differently from ephemeris points, their position is computed through user-defined functions.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"fun(t) = [cos(t), sin(t), 0]\n\nadd_point_dynamical!(F, :TimedAppendage, -10003, :SolArrLeft, :SatFrame, fun)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"vector6(F, :TimedAppendage, :SC, :SatFrame, π/3)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"note: Note\nTo avoid allocations, fun should return a static array.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"Similarly to rotating-axes, if the user only provides the function to compute the relative position, the remaining derivatives are automatically retrievied via automatic differentiation of fun. On the other hand, if those functions are specified, they must return a single vector that stacks all the components. For instance, for the first order derivative of fun, the function should return a 6-elements vector containing the relative position and velocity. For example:","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"fun(t) = [cos(t), sin(t), 0]\ndfun(t) = [cos(t), sin(t), 0, -sin(t), cos(t), 0]\n\nadd_point_dynamical!(F, :TimedAppendage2, -10004, :SolArrLeft, :SatFrame, fun, dfun)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"vector6(F, :TimedAppendage2, :SC, :SatFrame, π/3)","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"We can again see that the results are in agreement with the previous example. For more details, consult the add_point_dynamical! documentation.","category":"page"},{"location":"Tutorials/gen/t03_points/#Ephemeris-Points","page":"04 - Points","title":"Ephemeris Points","text":"","category":"section"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"Refer to the frames tutorial's Ephemeris Support section.","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"","category":"page"},{"location":"Tutorials/gen/t03_points/","page":"04 - Points","title":"04 - Points","text":"This page was generated using Literate.jl.","category":"page"}]
}
