<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/'</script><script charset="utf-8" src="../../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Frames · FrameTransformations.jl</title><script data-outdated-warner="" src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><link href="https://juliaspacemissiondesign.github.io/FrameTransformations/stable/Modules/frames/" rel="canonical"/><link href="../../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><div class="nav-dropdown"><button class="nav-item dropdown-label">Core</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../../Ephemerides/">Ephemerides</a><a class="nav-link nav-item" href="../../../../Tempo/">Tempo</a><a class="nav-link active nav-item" href="../../../">FrameTransformations</a></ul></div><div class="search nav-item"><input id="search-input" placeholder="Search..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="FrameTransformations.jl logo" src="../../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FrameTransformations.jl</a></span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Modules</span><ul><li><a class="tocitem" href="../orient/">Orient</a></li><li class="is-active"><a class="tocitem" href="">Frames</a><ul class="internal"><li><a class="tocitem" href="#basic_frames_api"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../utils/">Utils</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modules</a></li><li class="is-active"><a href="">Frames</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Frames</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/main/docs/src/Modules/frames.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h2 id="basic_frames_api"><a class="docs-heading-anchor" href="#basic_frames_api">API</a><a id="basic_frames_api-1"></a><a class="docs-heading-anchor-permalink" href="#basic_frames_api" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.AbstractFrameAxes" id="FrameTransformations.Frames.AbstractFrameAxes"><code>FrameTransformations.Frames.AbstractFrameAxes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFrameAxes</code></pre><p>Abstract type for all reference frames axes.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L25-L29" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.AbstractFramePoint" id="FrameTransformations.Frames.AbstractFramePoint"><code>FrameTransformations.Frames.AbstractFramePoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFramePoint</code></pre><p>Abstract type for all reference frames points.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L18-L22" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.ComputableAxesProperties" id="FrameTransformations.Frames.ComputableAxesProperties"><code>FrameTransformations.Frames.ComputableAxesProperties</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComputableAxesProperties</code></pre><p>Store the properties required to retrieve all the vectors required by   a computable set of axes. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L81-L87" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.ComputableAxesVector" id="FrameTransformations.Frames.ComputableAxesVector"><code>FrameTransformations.Frames.ComputableAxesVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComputableAxesVector(from, to, order::Int)</code></pre><p>Store the properties required to retrieve the i-th order components of a  desired vector. Arguments <code>from</code> and <code>to</code> are the NAIFIDs or <code>AbstractFramePoint</code> instances  that define the observer and target points.</p><p>Only orders between 1 and 3 are supported.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @point SSB 0 SolarSystemBarycenter

julia&gt; @point Sun 10 

julia&gt; ComputableAxesVector(SSB, Sun, 1)
ComputableAxesVector(0, 10, 1)

julia&gt; ComputableAxesVector(0, 10, 1)
ComputableAxesVector(0, 10, 1)</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L36-L57" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.FrameAxesNode" id="FrameTransformations.Frames.FrameAxesNode"><code>FrameTransformations.Frames.FrameAxesNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrameAxesNode{O, T, N} &lt;: AbstractGraphNode</code></pre><p>Define a set of axes.</p><p><strong>Fields</strong></p><ul><li><code>name</code> – axes name </li><li><code>class</code> – <code>Symbol</code> representing the class of the axes </li><li><code>id</code> – axes ID (equivalent of NAIFId for axes)</li><li><code>parentid</code> – ID of the parent axes </li><li><code>comp</code> – properties for computable axes </li><li><code>R</code> – vector storing rotation matrices </li><li><code>epochs</code> – vector storing the epochs associated to <code>R</code></li><li><code>nzo</code> – last order at which <code>R</code> has been computed </li><li><code>f</code> – <code>FrameAxesFunctions</code> container </li><li><code>angles</code> – vector storing the libration angles retrived from ephemerides</li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L138-L154" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.FramePointNode" id="FrameTransformations.Frames.FramePointNode"><code>FrameTransformations.Frames.FramePointNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FramePointNode{O, T, N} &lt;: AbstractGraphNode</code></pre><p>Define a frame system point.</p><p><strong>Fields</strong></p><ul><li><code>name</code> – point name </li><li><code>class</code> – <code>Symbol</code> representing the class of the point </li><li><code>axesid</code> – ID of the axes in which the point coordinates are expressed </li><li><code>parentid</code> – NAIF ID of the parent point </li><li><code>NAIFId</code> – NAIF ID of the point</li><li><code>stv</code> – vector storing the point state vectors</li><li><code>epochs</code> – vector storing the epochs associated to <code>stv</code></li><li><code>nzo</code> – last order at which <code>stv</code> has been computed </li><li><code>f</code> – <code>FramePointFunctions</code> container </li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L223-L238" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.FrameSystem" id="FrameTransformations.Frames.FrameSystem"><code>FrameTransformations.Frames.FrameSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrameSystem{O, T, S, E}</code></pre><p>A <code>FrameSystem</code> instance manages a collection of user-defined <code>FramePointNode</code> and  <code>FrameAxesNode</code> objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order <code>O</code>, the outputs  datatype <code>T</code> and an <code>AbstractTimeScale</code> instance <code>S</code>. Additionally, an <code>AbstractEphemerisProvider</code>  instance <code>E</code> can be provided to compute transformations that require ephemeris data. </p><p>The following transformation orders are accepted: </p><ul><li><strong>1</strong>: position </li><li><strong>2</strong>: position and velocity </li><li><strong>3</strong>: position, velocity and acceleration</li><li><strong>4</strong>: position, velocity, acceleration and jerk</li></ul><p>By specifying the maximum transformation the <code>FrameSystem</code> memory usage and performance can  be optimised and tailored to the user's needs.</p><hr/><pre><code class="nohighlight hljs">FrameSystem{O, T}()</code></pre><p>Create a <code>FrameSystem</code> object of order <code>O</code> and datatype <code>T</code>. The <code>BarycentricDynamicalTime</code>  is automatically assigned as the default time scale. The resulting object is constructed  with a <code>NullEphemerisProvider</code>, which does not allow the computation of transformation that  involve ephemeris files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1 

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_inertial!(F, ICRF)

julia&gt; add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)

julia&gt; rotation6(F, ICRF, ECLIPJ2000, 0.0)
Rotation{2, Float64}
[...]

julia&gt; rotation9(F, ICRF, ECLIPJ2000, 0.0)
ERROR: Insufficient frame system order: transformation requires at least order 3.
</code></pre><hr/><pre><code class="nohighlight hljs">FrameSystem{O, T, S}()</code></pre><p>Create a <code>FrameSystem</code> object of order <code>O</code>, datatype <code>T</code> and time scale <code>S</code>. The resulting  object is constructed with a <code>NullEphemerisProvider</code>, which does not allow the computation  of transformation that involve ephemeris files.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; F = FrameSystem{1, Float64, TerrestrialTime}();

julia&gt; @axes ICRF 1 

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_inertial!(F, ICRF)

julia&gt; add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)

julia&gt; ep_tt = Epoch("2023-02-10T12:00:00 TT")
2023-02-10T12:00:00.000 TT

julia&gt; rotation3(F, ICRF, ECLIPJ2000, ep_tt)
Rotation{1,Float64}([...])

julia&gt; ep_tdb = Epoch("2023-02-10T12:00:00 TDB")
2023-02-10T12:00:00.000 TDB

julia&gt; rotation3(F, ICRF, ECLIPJ2000, ep_tdb)
ERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.
[...]</code></pre><hr/><pre><code class="nohighlight hljs">FrameSystem{O, T}(eph::AbstractEphemerisProvider)</code></pre><p>Create a <code>FrameSystem</code> object of order <code>O</code> and datatype <code>T</code> by providing an instance of an  <code>AbstractEphemerisProvider</code> subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in <code>eph</code>. This constructor shall be used when the user desires  to compute transformations that involve ephemeris data. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All the kernels that will be used must be loaded within <code>eph</code>. Once the <code>FrameSystem</code>  has been created, no additional kernel can be added nor removed.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eph = CalcephProvider(DE440_KERNEL_PATH)
CalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0))

julia&gt; F = FrameSystem{2, Float64}(eph)
FrameSystem{2, Float64, BarycentricDynamicalTime, CalcephProvider}(
  eph: CalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0)),
  points: EMPTY
  axes: EMPTY
)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a>, <a href="#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.vector3-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector3</code></a> and <a href="#FrameTransformations.Frames.rotation3-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>rotation3</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/types.jl#L273-L383" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.Rotation" id="FrameTransformations.Frames.Rotation"><code>FrameTransformations.Frames.Rotation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rotation{S, N}</code></pre><p>A container to efficiently compute <code>S</code>-th order rotation matrices of type <code>N</code> between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the (<code>S</code>-1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later.</p><p>The rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object <code>R</code>, constructed from the  DCM <code>A</code> and its time derivatives <code>δA</code> and <code>δ²A</code> rotates a vector <code>v</code> = <code>[p, v, a]</code> as: </p><p><code>̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a]</code></p><p>A <code>Rotation</code> object <code>R</code> call always be converted to a <code>SMatrix</code> or a <code>MMatrix</code> by invoking  the proper constructor. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z)
DCM{Float64}:
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0

julia&gt; R = Rotation(A);

julia&gt; SM = SMatrix(R)
3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0

julia&gt; MM = MMatrix(R)
3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):
  0.5       0.866025  0.0
 -0.866025  0.5       0.0
  0.0       0.0       1.0</code></pre><hr/><pre><code class="nohighlight hljs">Rotation(dcms::DCM...)</code></pre><p>Create a <code>Rotation</code> object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z); 

julia&gt; δA = DCM(0.0I); 

julia&gt; δ²A = DCM(0.0I); 

julia&gt; R = Rotation(A, δA, δ²A); 

julia&gt; typeof(R) 
Rotation{3, Float64}

julia&gt; R2 = Rotation(A, B, C, DCM(0.0im*I)); 

julia&gt; typeof(R2)
Rotation{4, ComplexF64}</code></pre><hr/><pre><code class="nohighlight hljs">Rotation{S}(u::UniformScaling{N}) where {S, N}
Rotation{S, N}(u::UniformScaling) where {S, N}</code></pre><p>Create an <code>S</code>-order identity <code>Rotation</code> object of type <code>N</code> with identity position rotation  and null time derivatives.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Rotation{1}(1.0I) 
Rotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))

julia&gt; Rotation{1, Int64}(I)
Rotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],))</code></pre><hr/><pre><code class="nohighlight hljs">Rotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}</code></pre><p>Transform a <code>Rotation</code> object of order <code>S2</code> to order <code>S1</code>. This conversion is only possible  if <code>S1</code> &lt; <code>S2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = angle_to_dcm(π/3, :Z);

julia&gt; B = angle_to_dcm(π/4, π/6, :XY);

julia&gt; R1 = Rotation(A, B);

julia&gt; order(R1)
2

julia&gt; R2 = Rotation{1}(R1);

julia&gt; order(R2)
1

julia&gt; R2[1] == A 
true

julia&gt; R3 = Rotation{3}(R1)
ERROR: DimensionMismatch: Cannot convert a `Rotation` of order 2 to order 3
[...]</code></pre><hr/><pre><code class="nohighlight hljs">Rotation(m::DCM{N}, ω::AbstractVector) where N</code></pre><p>Create a 2nd order <code>Rotation</code> object of type <code>N</code> to rotate between two set of axes <code>a</code> and  <code>b</code> from a Direction Cosine Matrix (DCM) and the angular velocity vector <code>ω</code> of <code>b</code> with  respect to <code>a</code>, expressed in <code>b</code></p><hr/><pre><code class="nohighlight hljs">Rotation{S}(dcms::DCM...) where S</code></pre><p>Create a <code>Rotation</code> object of order <code>S</code>. If the number of <code>dcms</code> is smaller than <code>S</code>, the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than  <code>S</code>, only the first <code>S</code> DCMs are used. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Usage of this constructor is not recommended as it may yield unexpected results to  unexperienced users. </p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.rotation3-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>rotation3</code></a>, <a href="#FrameTransformations.Frames.rotation6-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>rotation6</code></a> and <a href="#FrameTransformations.Frames.rotation9-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>rotation9</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/rotation.jl#L7-L144" target="_blank">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#Base.inv-Tuple{Rotation}" id="Base.inv-Tuple{Rotation}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(rot::Rotation)</code></pre><p>Compute the invese of the rotation object <code>rot</code>. The operation is efficiently performed by  taking the transpose of each rotation matrix within <code>rot</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/rotation.jl#L283-L289" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames._get_comp_axes_vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, ComputableAxesVector, Int64, Number}} where {O, T}" id="FrameTransformations.Frames._get_comp_axes_vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, ComputableAxesVector, Int64, Number}} where {O, T}"><code>FrameTransformations.Frames._get_comp_axes_vector3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_comp_axes_vector3(frame, v, axesid, t)</code></pre><p>Compute a 3-elements vector in the desired axes at the given time  between two points of the frame system </p><p>The returned vector depends on the order in <code>v</code> as follows: </p><ul><li><strong>1</strong>: position</li><li><strong>2</strong>: velocity</li><li><strong>3</strong>: acceleration </li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L554-L567" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames._two_vectors_basis-Tuple{AbstractVector, AbstractVector, Symbol, Function}" id="FrameTransformations.Frames._two_vectors_basis-Tuple{AbstractVector, AbstractVector, Symbol, Function}"><code>FrameTransformations.Frames._two_vectors_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_two_vectors_basis(a, b, seq::Symbol, fc::Function)</code></pre><p>Generate a 3D right-handed orthogonal vector basis and/or its time derivatives from the  vectors <code>a</code> and <code>b</code>, according to the directions specified in <code>seq</code> and the input cross  function <code>fc</code>.</p><p>The accepted sequence directions are: <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code>, <code>:ZY</code></p><p>The standard basis, its 1st, 2nd-order and 3rd order time derivatives can be computed by  passing <code>cross</code>, <code>cross6</code>, <code>cross9</code> or <code>cross12</code> to <code>fc</code>. The returned vectors will have  a length of 3, 6 or 9, respectively.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L1-L14" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames._two_vectors_to_rot12-Tuple{AbstractVector, AbstractVector, Symbol}" id="FrameTransformations.Frames._two_vectors_to_rot12-Tuple{AbstractVector, AbstractVector, Symbol}"><code>FrameTransformations.Frames._two_vectors_to_rot12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_two_vectors_to_rot12(a, b, seq::Symbol)</code></pre><p>Generate a direction cosine matrix and its 1st, 2nd and 3r-order time-derivatives, minimising  the number of repeated computations. </p><p><strong>See also</strong></p><p>See <a href="#FrameTransformations.Frames.twovectors_to_dcm-Tuple{Any, Any, Any}"><code>twovectors_to_dcm</code></a> and <a href="#FrameTransformations.Frames.twovectors_to_δdcm-Tuple{Any, Any, Any}"><code>twovectors_to_δdcm</code></a> for more information. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L212-L220" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames._two_vectors_to_rot9-Tuple{AbstractVector, AbstractVector, Symbol}" id="FrameTransformations.Frames._two_vectors_to_rot9-Tuple{AbstractVector, AbstractVector, Symbol}"><code>FrameTransformations.Frames._two_vectors_to_rot9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_two_vectors_to_rot9(a, b, seq::Symbol)</code></pre><p>Generate a direction cosine matrix and its 1st and 2nd-order time-derivatives, minimising  the number of repeated computations. </p><p><strong>See also</strong></p><p>See <code>twovectors_to_dcm</code> and <code>twovectors_to_δdcm</code> for more information. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L167-L175" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames._twovectors_to_dcm-Tuple{AbstractVector, AbstractVector, Symbol, Function, Function}" id="FrameTransformations.Frames._twovectors_to_dcm-Tuple{AbstractVector, AbstractVector, Symbol, Function, Function}"><code>FrameTransformations.Frames._twovectors_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_twovectors_to_dcm(a, b, seq::Symbol, fc::Function, fn::Function)</code></pre><p>Generate a direction cosine matrix and/or its time derivatives from the vectors <code>a</code> and <code>b</code>,  according to the directions specifeid in <code>seq</code>. </p><p><strong>Notes</strong></p><p><code>fc</code> and <code>fn</code> are used to control the derivative order. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L52-L61" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_bci2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, AbstractDict, FrameTransformations.Frames.AbstractFramePoint, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}" id="FrameTransformations.Frames.add_axes_bci2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, AbstractDict, FrameTransformations.Frames.AbstractFramePoint, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}"><code>FrameTransformations.Frames.add_axes_bci2000!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_bci2000!(frames::FrameSystem{O, T}, 
    data::AbstractDict, center::AbstractFramePoint, 
    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O}</code></pre><p>Insert Body-Centered Inertial (BCI) axes at J2000 relative to the body <code>center</code> to the  <code>frames</code> system.</p><p><strong>Input/s</strong></p><ul><li><code>frames</code> - The frame system to which the new frame will be added.</li><li><code>data</code> - A dictionary containing a parsed <code>TPC</code> file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data.</li><li><code>center</code>: The center point of the new axes.</li><li><code>axes</code>: The new axes to be added to the frame system.</li><li><code>parent</code>: The parent axes of the new ones.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>parent</code> set of axes must be the International Celestial Reference Frame (ICRF).  If the <code>parent</code> set of axes is not ICRF, an error is thrown.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/planets.jl#L114-L135" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_bcrtod!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, AbstractDict, FrameTransformations.Frames.AbstractFramePoint, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}" id="FrameTransformations.Frames.add_axes_bcrtod!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, AbstractDict, FrameTransformations.Frames.AbstractFramePoint, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}"><code>FrameTransformations.Frames.add_axes_bcrtod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_bcrtod!(frames::FrameSystem{O, T}, 
    data::AbstractDict, center::AbstractFramePoint, 
    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O}</code></pre><p>Insert a Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the <code>frames</code> system.</p><p><strong>Input/s</strong></p><ul><li><code>frames</code> - The frame system to which the new frame will be added.</li><li><code>data</code> - A dictionary containing a parsed <code>TPC</code> file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data.</li><li><code>center</code>: The center point of the new axes.</li><li><code>axes</code>: The new axes to be added to the frame system.</li><li><code>parent</code>: The parent axes of the new ones.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The axes constructed here corresponds to the SPICE <code>IAU_&lt;BODY_NAME&gt;</code> frames. </p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>parent</code> set of axes must be the International Celestial Reference Frame (ICRF).  If the <code>parent</code> set of axes is not ICRF, an error is thrown.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/planets.jl#L3-L26" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}" id="FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>FrameTransformations.Frames.add_axes_computable!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol)</code></pre><p>Add <code>axes</code> as a set of computable axes to <code>frames</code>. Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE's parameterized two-vector frames. </p><p>These axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis. </p><p>The primary and secondary vectors, <code>v1</code> and <code>v2</code> are instances of <code>ComputableAxesVector</code>,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration). </p><p>For example, to define a primary vector that is parallel to the Sun's (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0), <code>v1</code> must be set as:  <code>v1 = ComputableAxesVector(10, 0, 1)</code>.</p><p><code>seq</code> is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are: <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code> and <code>:ZY</code>. </p><p>Given a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf's nadir direction and  velocity direction define the axes orientation.  </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Regardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to <code>parent</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eph = CalcephProvider(DE440_KERNEL_PATH);

julia&gt; FRAMES = FrameSystem{4, Float64}(eph);

julia&gt; @point SSB 0 SolarySystemBarycenter 

julia&gt; @point Sun 10 

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; add_point_root!(FRAMES, SSB, ICRF)

julia&gt; add_point_ephemeris!(FRAMES, Sun, SSB)

julia&gt; @axes SunFrame 2

julia&gt; v1 = ComputableAxesVector(10, 0, 1)
ComputableAxesVector(10, 0, 1)

julia&gt; v2 = ComputableAxesVector(10, 0, 2)
ComputableAxesVector(10, 0, 2)

julia&gt; add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.ComputableAxesVector"><code>ComputableAxesVector</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a>  and <a href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L560-L626" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_eclipj2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Orient.IAUModel}} where {T, O}" id="FrameTransformations.Frames.add_axes_eclipj2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Orient.IAUModel}} where {T, O}"><code>FrameTransformations.Frames.add_axes_eclipj2000!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_eclipj2000!(frames, axes, parent::AbstractFrameAxes, iau_model::IAUModel=iau1980)</code></pre><p>Add <code>axes</code> as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to <code>frames</code>. The obliquity of the ecliptic is computed using the IAU Model <code>iau_model</code>.</p><p>The admissed <code>parent</code> set of axes are the following: </p><ul><li><strong>ICRF</strong>: for the International Celestial Reference Frame, with ID = 1</li><li><strong>MEME2000</strong>: the Mean Earth/Moon Ephemeris of J2000, with ID = 22</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If the name (or the axes ID) of the parent set of <code>axes</code> is neither ICRF (ID = 1) nor  MEME2000 (ID = 22), an error is thrown. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; @axes ECLIPJ2000 17 EclipticEquinoxJ2000 

julia&gt; FRAMES = FrameSystem{1, Float64}();

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a> and <a href="../orient/#FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS"><code>Orient.DCM_ICRF_TO_J2000_BIAS</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/ecliptic.jl#L53-L82" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Symbol}} where {O, T}" id="FrameTransformations.Frames.add_axes_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Symbol}} where {O, T}"><code>FrameTransformations.Frames.add_axes_ephemeris!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_ephemeris!(frames, axes, rot_seq::Symbol)
add_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)</code></pre><p>Add <code>axes</code> as a set of ephemeris axes to <code>frames</code>. The orientation of these axes is computed  with a series of 3 rotations specified by <code>rot_seq</code>. The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in <code>frames</code>. The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels.</p><p>The rotation sequence is defined by a <code>Symbol</code> specifing the rotation axes. This function assigns <code>dcm = A3 * A2 * A1</code> in which <code>Ai</code> is the DCM related with the <strong>i-th</strong> rotation.  The possible <code>rot_seq</code> values are: <code>:XYX</code>, <code>XYZ</code>, <code>:XZX</code>, <code>:XZY</code>, <code>:YXY</code>, <code>:YXZ</code>, <code>:YZX</code>,  <code>:YZY</code>, <code>:ZXY</code>, <code>:ZXZ</code>, <code>:ZYX</code>, or <code>:ZYZ</code>.</p><p>Alternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives. </p><p>This operation is only possible if the ephemeris kernels loaded within <code>frames</code> contain  orientation data for the AXES ID associated to <code>axes</code>. An error is returned if the parent  axes ID is yet to be added to <code>frames.</code></p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels.</p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.ComputableAxesVector"><code>ComputableAxesVector</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a>  and <a href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L720-L751" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}" id="FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>FrameTransformations.Frames.add_axes_fixedoffset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_fixedoffset!(frames::FrameSystem{T}, axes, parent, dcm::DCM{T}) where T</code></pre><p>Add <code>axes</code> as a set of fixed offset axes to <code>frames</code>. Fixed offset axes have a constant  orientation with respect to their <code>parent</code> axes, represented by <code>dcm</code>, a Direction Cosine Matrix (DCM).</p><hr/><pre><code class="nohighlight hljs">add_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DMC{T}) where {T}</code></pre><p>Add new axes <code>name</code> with id <code>axesid</code> to <code>frames</code> with a fixed-offset from <code>parentid</code>.  <em>Low-level function.</em></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>While inertial axes do not rotate with respect to the star background, fixed offset axes are only  constant with respect to their parent axes, but might be rotating with respect to some other  inertial axes.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{1, Float64}();

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z))</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Vararg{Any, 5}}, Tuple{FrameSystem{O, T}, Vararg{Any, 6}}, Tuple{FrameSystem{O, T}, Vararg{Any, 7}}} where {O, T}"><code>add_axes_rotating!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a> and <a href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L370-L403" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}" id="FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>FrameTransformations.Frames.add_axes_inertial!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing)</code></pre><p>Add <code>axes</code> as a set of inertial axes to <code>frames</code>. Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added, <code>parent</code> and <code>dcm</code>  become mandatory fields.</p><hr/><pre><code class="nohighlight hljs">add_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing)</code></pre><p>Add new axes <code>name</code> with id <code>axesid</code> to <code>frames</code>. <em>Low-level function.</em></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @axes ECLIPJ2000 17 

julia&gt; add_axes_inertial!(FRAMES, ECLIPJ2000)
ERROR: A set of parent axes for ECLIPJ2000 is required
[...]

julia&gt; add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z))</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_rotating!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Vararg{Any, 5}}, Tuple{FrameSystem{O, T}, Vararg{Any, 6}}, Tuple{FrameSystem{O, T}, Vararg{Any, 7}}} where {O, T}"><code>add_axes_rotating!</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>add_axes_fixedoffset!</code></a> and <a href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L268-L305" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_itrf!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Orient.IAUModel}} where {T, O}" id="FrameTransformations.Frames.add_axes_itrf!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Orient.IAUModel}} where {T, O}"><code>FrameTransformations.Frames.add_axes_itrf!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_itrf!(frames, axes, parent, model::Orient.IAU2006Model=Orient.iau2006b)</code></pre><p>Add <code>axes</code> as a set of axes representing the International Terrestrial Reference Frame (ITRF) to <code>frames</code>. Only the :ICRF and :GCRF are accepted as <code>parent</code> axes. Use the <code>model</code> argument  to specify which IAU model model should be used for the computations. The default is set to  <code>iau2006b</code>.</p><p><strong>See also</strong></p><p>See also <a href="../orient/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf"><code>orient_rot3_itrf_to_gcrf</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/earth.jl#L3-L13" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_me421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.add_axes_me421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.add_axes_me421!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_me421!(frames, axes, parent)</code></pre><p>Add <code>axes</code> as fixed offset axes representing the DE421 Moon's Mean Earth/Mean Rotation (ME)  to <code>frames</code>.</p><p>The <code>parent</code> set of axes can be either the DE440 Principal Axes (PA440) or the DE421  Principal Axes (PA421), otherwise an error is thrown. Depending on that, the relative axes  orientation will be automatically selected by this function. </p><p><strong>See also</strong></p><pre><code class="nohighlight hljs">See also [`add_axes_pa440!`](@ref), and [`add_axes_pa421!`](@ref), 
[`Orient.DCM_MOON_PA421_TO_ME421`](@ref) and [`Orient.DCM_MOON_PA421_TO_ME421`](@ref),</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/moon.jl#L89-L103" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_meme2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}" id="FrameTransformations.Frames.add_axes_meme2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}"><code>FrameTransformations.Frames.add_axes_meme2000!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_meme2000!(frames::, axes, parent::AbstractFrameAxes)</code></pre><p>Add <code>axes</code> as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to <code>frames</code>. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The name (or the axes ID) of the parent set of axes must be <code>ICRF</code> (i.e., the International  Celestial Reference Frame, ID = 1), or the <code>ECLIPJ2000</code> (i.e., the Ecliptic Equinox of 7 J2000, ID = 17), otherwise and error is thrown.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 

julia&gt; FRAMES = FrameSystem{1, Float64}();

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; add_axes_meme2000!(FRAMES, MEME2000, ICRF)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a> and <a href="../orient/#FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS"><code>Orient.DCM_ICRF_TO_J2000_BIAS</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/ecliptic.jl#L3-L29" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_mememod!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.add_axes_mememod!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.add_axes_mememod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_mememod!(frames, axes, parent::AbstractFrameAxes, model::IAU2006Model=iau2006b)</code></pre><p>Add <code>axes</code> as a set of projected axes representing the Mean of Date Ecliptic Equinox to  <code>frames</code>. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The name of the <code>parent</code> set of axes must be the ICRF or have ID = 1 (i.e., the  International Celestial Reference Frame), otherwise an error is thrown. </p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/ecliptic.jl#L111-L125" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_pa421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.add_axes_pa421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.add_axes_pa421!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_pa421!(frames, axes, parent)</code></pre><p>Add <code>axes</code> as a set of ephemeris axes representing the DE421 Moon's Principal Axes (PA) to  <code>frames</code>. The libration angles are extracted from the ephemeris kernels loaded within <code>frames</code>,  an error is thrown if such orientation data is not available. </p><p>The <code>parent</code> set of axes must be named <code>ICRF</code> or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To properly read the ephemeris kernels, the ID associated to the input <code>axes</code> must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006).</p></div></div><p><strong>See also</strong></p><pre><code class="nohighlight hljs">See also [`Orient.AXESID_MOONPA_DE421`](@ref), [`Orient.orient_icrf_to_pa421`](@ref), 
[`add_axes_pa440!`](@ref), and [`add_axes_me421!`](@ref)</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/moon.jl#L46-L63" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_pa440!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.add_axes_pa440!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.add_axes_pa440!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_pa440!(frames, axes, parent)</code></pre><p>Add <code>axes</code> as a set of ephemeris axes representing the DE440 Moon's Principal Axes (PA) to  <code>frames</code>. The libration angles are extracted from the ephemeris kernels loaded within <code>frames</code>,  an error is thrown if such orientation data is not available. </p><p>The <code>parent</code> set of axes must be named <code>ICRF</code> or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To properly read the ephemeris kernels, the ID associated to the input <code>axes</code> must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008).</p></div></div><p><strong>See also</strong></p><p>See also <a href="../orient/#FrameTransformations.Orient.AXESID_MOONPA_DE440"><code>Orient.AXESID_MOONPA_DE440</code></a>, <a href="../orient/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440-Tuple{JSMDInterfaces.Ephemeris.AbstractEphemerisProvider, Epoch}"><code>Orient.orient_rot3_icrf_to_pa440</code></a>,  <a href="#FrameTransformations.Frames.add_axes_pa421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}"><code>add_axes_pa421!</code></a>, and <a href="#FrameTransformations.Frames.add_axes_me421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}"><code>add_axes_me421!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/moon.jl#L3-L20" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_projected!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}} where {O, T}" id="FrameTransformations.Frames.add_axes_projected!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}} where {O, T}"><code>FrameTransformations.Frames.add_axes_projected!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_projected!(frames, axes, parent, fun)</code></pre><p>Add <code>axes</code> as a set of projected axes to <code>frames</code>. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. </p><p>Projected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types. </p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L685-L698" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_rotating!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Vararg{Any, 5}}, Tuple{FrameSystem{O, T}, Vararg{Any, 6}}, Tuple{FrameSystem{O, T}, Vararg{Any, 7}}} where {O, T}" id="FrameTransformations.Frames.add_axes_rotating!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Vararg{Any, 5}}, Tuple{FrameSystem{O, T}, Vararg{Any, 6}}, Tuple{FrameSystem{O, T}, Vararg{Any, 7}}} where {O, T}"><code>FrameTransformations.Frames.add_axes_rotating!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) where T</code></pre><p>Add <code>axes</code> as a set of rotating axes to <code>frames</code>. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. </p><p>The input functions must accept only time as argument and their outputs must be as follows: </p><ul><li><strong>fun</strong>: return a Direction Cosine Matrix (DCM).</li><li><strong>δfun</strong>: return the DCM and its 1st order time derivative.</li><li><strong>δ²fun</strong>: return the DCM and its 1st and 2nd order time derivatives</li><li><strong>δ³fun</strong>: return the DCM and its 1st, 2nd and 3rd order time derivatives</li></ul><p>If <code>δfun</code>, <code>δ²fun</code> or <code>δ³fun</code> are not provided, they are computed via automatic differentiation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{3, Float64}();

julia&gt; @axes Inertial 1

julia&gt; add_axes_inertial!(FRAMES, Inertial)

julia&gt; @axes Synodic 2 

julia&gt; fun(t) = angle_to_dcm(t, :Z);

julia&gt; add_axes_rotating!(FRAMES, Synodic, Inertial, fun)

julia&gt; R = rotation6(FRAMES, Inertial, Synodic, π/6);

julia&gt; R[1]
DCM{Float64}:
  0.866025  0.5       0.0
 -0.5       0.866025  0.0
  0.0       0.0       1.0

julia&gt; R[2]
DCM{Float64}:
 -0.5        0.866025  0.0
 -0.866025  -0.5       0.0
  0.0        0.0       0.0</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>add_axes_fixedoffset!</code></a>, <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a> and <a href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>add_axes_computable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L432-L482" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_axes_topocentric!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, Number, Number, Symbol, Any}" id="FrameTransformations.Frames.add_axes_topocentric!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, Number, Number, Symbol, Any}"><code>FrameTransformations.Frames.add_axes_topocentric!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_axes_topocentric!(frames, axes, λ::Number, ϕ::Number, type::Symbol, parent)</code></pre><p>Add <code>axes</code> as a set of fixed-offset topocentric axes to <code>frames</code>. The orientation relative  to the parent axes <code>parent</code> is defined throuh the longitude <code>λ</code>, the geodetic latitude <code>ϕ</code>  and the type <code>type</code>, which may be any of the following: </p><ul><li><strong>:NED</strong> (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir.</li><li><strong>:SEZ</strong> (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith.</li><li><strong>:ENU</strong> (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith. </li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>parent</code> axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong. </p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>add_axes_fixedoffset!</code></a> and <a href="#FrameTransformations.Frames.add_point_surface!"><code>add_point_surface!</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/topocentric.jl#L3-L23" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}" id="FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}"><code>FrameTransformations.Frames.add_point_dynamical!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point_dynamical!(frames, point, parent, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)</code></pre><p>Add <code>point</code> as a time point to <code>frames</code>. The state vector for these points depends only on  time and is computed through the custom functions provided by the user. </p><p>The input functions must accept only time as argument and their outputs must be as follows: </p><ul><li><strong>fun</strong>: return a 3-elements vector: position</li><li><strong>δfun</strong>: return a 6-elements vector: position and velocity</li><li><strong>δ²fun</strong>: return a 9-elements vector: position, velocity and acceleration</li><li><strong>δ³fun</strong>: return a 12-elements vector: position, velocity, acceleration and jerk</li></ul><p>If <code>δfun</code>, <code>δ²fun</code> or <code>δ³fun</code> are not provided, they are computed with automatic differentiation. </p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions. </p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}()

julia&gt; @axes ICRF 1 

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point Origin 0 

julia&gt; add_point_root!(FRAMES, Origin, ICRF)

julia&gt; @point Satellite 1 

julia&gt; satellite_pos(t::T) where T = [cos(t), sin(t), 0]

julia&gt; add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)

julia&gt; vector6(FRAMES, Origin, Satellite, ICRF, π/6)
6-element SVector{6, Float64} with indices SOneTo(6):
  0.8660254037844387
  0.49999999999999994
  0.0
 -0.49999999999999994
  0.8660254037844387
  0.0</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}"><code>add_point_ephemeris!</code></a>,<a href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>add_point_fixed!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L683-L734" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}" id="FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}"><code>FrameTransformations.Frames.add_point_ephemeris!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point_ephemeris!(frames, point, parent=nothing)</code></pre><p>Add <code>point</code> as an ephemeris point to <code>frames</code>. This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). If a parent point is not specified, it will automatically be assigned to the point with respect to which the ephemeris  data is written in the kernels.</p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object </li><li><code>point</code> – <a href="#FrameTransformations.Frames.FramePointNode"><code>FramePointNode</code></a> instance </li><li><code>parent</code> – <a href="#FrameTransformations.Frames.FramePointNode"><code>FramePointNode</code></a> parent instance </li></ul><hr/><pre><code class="nohighlight hljs">add_point_ephemeris!(frames, name::Symbol, naifid::Int, parentid::Int=nothing, axes=nothing)</code></pre><p>Add a new point called <code>name</code> and with id <code>naifid</code> to <code>frames</code>. If a parentid is not specified, it will be automatically assigned depending on the ephemeris kernels.</p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object </li><li><code>name::Symbol</code> – name of the point </li><li><code>naifid::Int</code> – NAIFId associated to the point </li><li><code>parentid::Int</code> – NAIFId associated to the parent point, default is <code>nothing</code></li><li><code>axes</code> – Id associated to the axes in which the states are expressed, default <code>nothing</code>    (taken automatically from the ephemeris files).</li></ul><p>Ephemeris points only accept as parent points root-points or other ephemeris points.</p><p><strong>Notes</strong></p><p>This operation is only possible if the ephemeris kernels loaded within <code>frames</code> contain  data for the NAIF ID associated to <code>point</code> and to its <code>parent</code>. </p><p>The axes in which the state-vector is expressed are taken from the ephemeris data: an error  is returned if the axes ID is yet to be added to <code>frames</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eph = CalcephProvider(DE440_KERNEL_PATH);

julia&gt; FRAMES = FrameSystem{2, Float64}(eph);

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point SSB 0 SolarSystemBarycenter

julia&gt; @point Sun 10 

julia&gt; add_point_root!(FRAMES, SSB, ICRF)

julia&gt; add_point_ephemeris!(FRAMES, Sun)

julia&gt; @point Jupiter 599

julia&gt; add_point_ephemeris!(FRAMES, Jupiter)
ERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.
[...]</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>add_point_fixed!</code></a>, <a href="#FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L297-L369" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}" id="FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>FrameTransformations.Frames.add_point_fixed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point_fixed!(frames, point, parent, axes, offset::AbstractVector)</code></pre><p>Add <code>point</code> as a fixed point to <code>frames</code>. Fixed points are those whose positions have a  constant <code>offset</code> with respect their <code>parent</code> points in the given set of <code>axes</code>. Thus, points  eligible for this class must have null velocity and acceleration with respect to <code>parent</code>.</p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object </li><li><code>point</code> – <a href="#FrameTransformations.Frames.FramePointNode"><code>FramePointNode</code></a> instance </li><li><code>parent</code> – <a href="#FrameTransformations.Frames.FramePointNode"><code>FramePointNode</code></a> parent instance </li><li><code>axes</code> – <a href="#FrameTransformations.Frames.FrameAxesNode"><code>FrameAxesNode</code></a> instance </li><li><code>offset</code> – Offset with respect to the parent</li></ul><hr/><pre><code class="nohighlight hljs">add_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector)</code></pre><p>Add a new fixed point called <code>name</code> with id <code>pointid</code> and parent <code>parentid</code> in the axes  <code>axesid</code> to <code>frames</code>.</p><ul><li><code>frames</code> – <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object </li><li><code>name::Symbol</code> – name of the point </li><li><code>naifid::Int</code> – NAIFId associated to the point </li><li><code>parentid::Int</code> – NAIFId associated to the parent point, default is <code>nothing</code></li><li><code>axesid::Int</code> – Id associated to the axes in which the states are expressed, default <code>nothing</code>    (taken automatically from the ephemeris files).</li><li><code>offset</code> – Offset with respect to the parent</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes SF -3000 SatelliteFrame

julia&gt; add_axes_inertial!(FRAMES, SF)

julia&gt; @point SC -10000 Spacecraft

julia&gt; @point SolarArrayCenter -10001

julia&gt; add_point_root!(FRAMES, SC, SF)

julia&gt; sa_offset = [0.10, 0.15, 0.30];

julia&gt; add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset)</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}"><code>add_point_ephemeris!</code></a>,  <a href="#FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L502-L553" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}" id="FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}"><code>FrameTransformations.Frames.add_point_root!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point_root!(frames, point, axes)</code></pre><p>Add <code>point</code> as a root point to <code>frames</code> to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.).</p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object </li><li><code>point</code> – Target point instance</li><li><code>axes</code> – Id or instance of the axes where the point state-vector is expressed. </li></ul><hr/><pre><code class="nohighlight hljs">add_point_root!(frames, name, id, axes)</code></pre><p>Add a root point fo <code>frames</code> to initialize the points graphs. </p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object </li><li><code>name</code> – Name of the root point </li><li><code>id</code> – Id (NAIFId) of the root point </li><li><code>axes</code> – Id or instance of the axes where the point state-vector is expressed.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This operation can be performed only once per <a href="#FrameTransformations.Frames.FrameSystem"><code>FrameSystem</code></a> object: multiple root  points in the same graph are both inadmissible and meaningless.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point SSB 0 SolarSystemBarycenter 

julia&gt; add_point_root!(FRAMES, SSB, ICRF)

julia&gt; @point Sun 10

julia&gt; add_point_root!(FRAMES, Sun, ICRF)
ERROR: ArgumentError: A root-point is already registed in the given FrameSystem.
[...]</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}"><code>add_point_ephemeris!</code></a>, <a href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>add_point_fixed!</code></a>, <a href="#FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L228-L279" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_surface!" id="FrameTransformations.Frames.add_point_surface!"><code>FrameTransformations.Frames.add_point_surface!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_surface!(frames, point, parent, axes, pck, λ, ϕ, h::Number=0.0)</code></pre><p>Add <code>point</code> to <code>frames</code> as a fixed point on the surface of the <code>parent</code> point. The  relative position is specified by the longitude <code>λ</code>, the geodetic latitude <code>ϕ</code> and the altitude  over the surface of the reference ellipsoid <code>h</code>, which defaults to 0.0. The ellipsoid  parameters are extracted from the input TPC kernel <code>pck</code> using the NAIFId associated to the  <code>parent</code> point.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>axes</code> must be a set of body-fixed reference axes for the body represented by <code>parent</code>.  When this constraint is not satisfied, the results may be fundamentally wrong. </p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>add_point_fixed!</code></a>, <a href="#FrameTransformations.Frames.add_axes_topocentric!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, Number, Number, Symbol, Any}"><code>add_axes_topocentric!</code></a> and <a href="../utils/#FrameTransformations.Utils.geod2pos-NTuple{5, Number}"><code>geod2pos</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/topocentric.jl#L40-L55" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_surface!" id="FrameTransformations.Frames.add_point_surface!"><code>FrameTransformations.Frames.add_point_surface!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_point_surface!(frames, point, parent, axes, λ, ϕ, R, f::Number=0.0, h::Number=0.0)</code></pre><p>Add <code>point</code> to <code>frames</code> as a fixed point on the surface of the <code>parent</code> point body. The relative  position is specified by the longitude <code>λ</code>, the geodetic latitude <code>ϕ</code>, the reference radius  of the ellipsoid <code>R</code> and its flattening <code>f</code>. The altitude over the reference surface of the  ellipsoid <code>h</code> defaults to 0. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/topocentric.jl#L84-L91" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}" id="FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}"><code>FrameTransformations.Frames.add_point_updatable!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_point_updatable!(frames, point, parent, axes)</code></pre><p>Add <code>point</code> as an updatable point to <code>frames</code>. Differently from all the other classes, the  state vector for updatable points (expressed in the set of input <code>axes</code>) must be manually  updated before being used for other computations.  </p><hr/><pre><code class="nohighlight hljs">add_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes)</code></pre><p>Add a point called <code>name</code> with id <code>pointid</code> to <code>frames</code> as a state vector with respect to  <code>parentid</code> in the <code>axes</code> axes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();

julia&gt; @axes ICRF 1  

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point Origin 0

julia&gt; @point Satellite 1 

julia&gt; add_point_root!(FRAMES, Origin, ICRF)

julia&gt; add_point_updatable!(FRAMES, Satellite, Origin, ICRF)

julia&gt; y = [10000., 200., 300.]

julia&gt; update_point!(FRAMES, Satellite, y, 0.1)

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.1)
3-element SVector{3, Float64} with indices SOneTo(3):
 10000.0
   200.0
   300.0

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.2)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1

julia&gt; vector6(FRAMES, Origin, Satellite, ICRF, 0.1)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2
[...]</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.update_point!-Union{Tuple{S}, Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T, S}, Any, AbstractVector{T}, Epoch{S}}} where {O, T, S}"><code>update_point!</code></a>, <a href="#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}"><code>add_point_root!</code></a>, <a href="#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}"><code>add_point_ephemeris!</code></a>,  <a href="#FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}"><code>add_point_dynamical!</code></a> and <a href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>add_point_fixed!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L599-L654" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.axes_alias-Tuple{FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.axes_alias-Tuple{FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.axes_alias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axes_alias(ax::AbstractFrameAxes)</code></pre><p>Return the axes ID. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L83-L87" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.axes_id" id="FrameTransformations.Frames.axes_id"><code>FrameTransformations.Frames.axes_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axes_id(axes::AbstractFrameAxes)</code></pre><p>Return the ID associated to <code>axes</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L19-L24" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.axes_name" id="FrameTransformations.Frames.axes_name"><code>FrameTransformations.Frames.axes_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">axes_name(axes::AbstractFrameAxes)</code></pre><p>Return the name of <code>axes</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L12-L16" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.build_axes-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Symbol, FrameTransformations.Frames.FrameAxesFunctions{T, O}}} where {O, T}" id="FrameTransformations.Frames.build_axes-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Symbol, FrameTransformations.Frames.FrameAxesFunctions{T, O}}} where {O, T}"><code>FrameTransformations.Frames.build_axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_axes(frames, name, id, class, funs; parentid, dcm, cax_prop)</code></pre><p>Create and add a <a href="#FrameTransformations.Frames.FrameAxesNode"><code>FrameAxesNode</code></a> to <code>frames</code> based on the input parameters. Current  supported classes are: <code>:InertialAxes</code>, <code>:FixedOffsetAxes</code>, <code>:RotatingAxes</code>, <code>:ProjectedAxes</code>,  <code>:EphemerisAxes</code> and <code>:ComputableAxes</code>.</p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – Target frame system </li><li><code>name</code> – Axes name, must be unique within <code>frames</code></li><li><code>id</code> – Axes ID, must be unique within <code>frames</code></li><li><code>class</code> – Axes class.  </li><li><code>funs</code> – <code>FrameAxesFunctions</code> object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of <code>frames</code>.</li></ul><p><strong>Keywords</strong></p><ul><li><code>parentid</code> – Axes ID of the parent axes. Not required only for the root axes.</li><li><code>dcm</code> – DCM with respect to the parent axes. Required only for FixedOffsetAxes. </li><li><code>cax_prop</code> – <code>ComputableAxesProperties</code>, required only by ComputableAxes.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see <a href="#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}"><code>add_axes_inertial!</code></a>, <a href="#FrameTransformations.Frames.add_axes_rotating!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Vararg{Any, 5}}, Tuple{FrameSystem{O, T}, Vararg{Any, 6}}, Tuple{FrameSystem{O, T}, Vararg{Any, 7}}} where {O, T}"><code>add_axes_rotating!</code></a>,  <a href="#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}"><code>add_axes_computable!</code></a>, <a href="#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}"><code>add_axes_fixedoffset!</code></a> and <a href="#FrameTransformations.Frames.add_axes_projected!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}} where {O, T}"><code>add_axes_projected!</code></a>.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L150-L175" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.build_point-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Symbol, Int64, FrameTransformations.Frames.FramePointFunctions{T, O}}} where {O, T}" id="FrameTransformations.Frames.build_point-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Symbol, Int64, FrameTransformations.Frames.FramePointFunctions{T, O}}} where {O, T}"><code>FrameTransformations.Frames.build_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_point(frames, name, NAIFId, class, axesid, funs; parentid, offset)</code></pre><p>Create and add a <a href="#FrameTransformations.Frames.FramePointNode"><code>FramePointNode</code></a> to <code>frames</code> based on the input parameters.  Current supported point classes are: <code>:RootPoint</code>, <code>:TimePoint</code>, <code>:EphemerisPoint</code>, <code>:FixedPoint</code> and <code>:UpdatablePoint</code>.</p><p><strong>Inputs</strong></p><ul><li><code>frames</code> – Target frame system </li><li><code>name</code> – Point name, must be unique within <code>frames</code></li><li><code>NAIFId</code> – Point NAIF ID, must be unique within <code>frames</code></li><li><code>class</code> – Point class. </li><li><code>axesid</code> – ID of the axes in which the state vector of the point is expressed. </li><li><code>funs</code> – <code>FramePointFunctions</code> object storing the functions to update the state            vectors of the point. It must match the type and order of <code>frames</code></li></ul><p><strong>Keywords</strong></p><ul><li><code>parentid</code> – NAIF ID of the parent point. Not required only for the root point.</li><li><code>offset</code> – Position offset with respect to a parent point. Required only for FixedPoints.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see <a href="#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}"><code>add_point_ephemeris!</code></a>, <a href="#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}"><code>add_point_fixed!</code></a>, etc...</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L96-L120" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.is_inertial-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.is_inertial-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.is_inertial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)
is_inertial(frame::FrameSystem, axesid::Int)</code></pre><p>Return true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>FixedOffsetAxes with respect to an inertial set of axes, are also consired inertial.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L26-L36" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.is_timefixed-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes}" id="FrameTransformations.Frames.is_timefixed-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes}"><code>FrameTransformations.Frames.is_timefixed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)
is_timefixed(frame::FrameSystem, axesid::Int)</code></pre><p>Return true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only <code>:InertialAxes</code> and <code>:FixedOffsetAxes</code> defined with respect to other inertial axes  are here considered as time fixed. </p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L54-L65" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.order-Union{Tuple{Rotation{S}}, Tuple{S}} where S" id="FrameTransformations.Frames.order-Union{Tuple{Rotation{S}}, Tuple{S}} where S"><code>FrameTransformations.Frames.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(R::Rotation{S}) where S</code></pre><p>Return the rotation order S.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/rotation.jl#L154-L159" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.point_alias-Tuple{FrameTransformations.Frames.AbstractFramePoint}" id="FrameTransformations.Frames.point_alias-Tuple{FrameTransformations.Frames.AbstractFramePoint}"><code>FrameTransformations.Frames.point_alias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_alias(ax::AbstractFramePoint)</code></pre><p>Return the NAIF ID associated to the input point. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L25-L30" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.point_id" id="FrameTransformations.Frames.point_id"><code>FrameTransformations.Frames.point_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_id(point::AbstractFramePoint)</code></pre><p>Return the NAIF ID associated to <code>point</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L18-L23" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.point_name" id="FrameTransformations.Frames.point_name"><code>FrameTransformations.Frames.point_name</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">point_name(point::AbstractFramePoint)</code></pre><p>Return the name of <code>point</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L11-L15" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation12-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S" id="FrameTransformations.Frames.rotation12-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>FrameTransformations.Frames.rotation12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation12(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 4.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <code>Rotation</code> object of order 4.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L30-L46" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation12-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.rotation12-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.rotation12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation12(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L53-L59" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation3-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S" id="FrameTransformations.Frames.rotation3-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>FrameTransformations.Frames.rotation3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation3(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 1.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <code>Rotation</code> object of order 1.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L30-L46" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.rotation3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.rotation3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation3(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L53-L59" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation6-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S" id="FrameTransformations.Frames.rotation6-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>FrameTransformations.Frames.rotation6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation6(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 2.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <code>Rotation</code> object of order 2.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L30-L46" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.rotation6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.rotation6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation6(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L53-L59" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation9-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S" id="FrameTransformations.Frames.rotation9-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Epoch{S}}} where S"><code>FrameTransformations.Frames.rotation9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation9(frame::FrameSystem, from, to, ep::Epoch)</code></pre><p>Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch. </p><p>Requires a frame system of order ≥ 3.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the axes to transform from </li><li><code>to</code> – ID or instance of the axes to transform to </li><li><code>ep</code> – <code>Epoch</code> of the rotation. Its timescale must match that of the frame system. </li></ul><p><strong>Output</strong></p><p>A <code>Rotation</code> object of order 3.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L30-L46" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.rotation9-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.rotation9-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.rotation9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotation9(frame::FrameSystem, from, to, t::Number)</code></pre><p>Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time <code>t</code>, expressed in seconds since  <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L53-L59" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.twovectors_to_dcm-Tuple{Any, Any, Any}" id="FrameTransformations.Frames.twovectors_to_dcm-Tuple{Any, Any, Any}"><code>FrameTransformations.Frames.twovectors_to_dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twovectors_to_dcm(a, b, seq)</code></pre><p>Generate a direction cosine matrix from two time-dependent vectors <code>a</code> and <code>b</code>,  following the directions specified in <code>seq</code>. </p><p><strong>Inputs</strong></p><ul><li><p><code>a</code> – The primary vector that will be aligned with the first directions specified in <code>seq</code>. </p></li><li><p><code>b</code> – The secondary vector. The component of this vector that is orthogonal to the         primary vector is aligned with the second direction specified in the sequence <code>seq</code>.</p></li><li><p><code>seq</code> – Accepted sequence directions are:       <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code>, <code>:ZY</code></p></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The primary and secondary vectors do not have to be orthogonal. However, a great loss of precision happens when the two vectors are almost aligned. This function does not perform  any check on the angular separation of the two vectors. The user should ensure that the  primary and secondary vector differ of at least 1 milliradian.</p></div></div></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L71-L92" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.twovectors_to_δdcm-Tuple{Any, Any, Any}" id="FrameTransformations.Frames.twovectors_to_δdcm-Tuple{Any, Any, Any}"><code>FrameTransformations.Frames.twovectors_to_δdcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twovectors_to_δdcm(a, b, seq)</code></pre><p>Compute the time derivative of a direction cosine matrix generated from two time-dependent  state vectors <code>a</code> and <code>b</code>, following the directions specified in <code>seq</code>. </p><p><strong>Inputs</strong></p><ul><li><code>a</code> and <code>b</code> – 6-elements state vectors (position and velocity).</li><li><code>seq</code> – Accepted sequence directions are:       <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code>, <code>:ZY</code></li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L95-L105" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.twovectors_to_δ²dcm-Tuple{Any, Any, Any}" id="FrameTransformations.Frames.twovectors_to_δ²dcm-Tuple{Any, Any, Any}"><code>FrameTransformations.Frames.twovectors_to_δ²dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twovectors_to_δ²dcm(a, b, seq)</code></pre><p>Compute the 2nd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors <code>a</code> and <code>b</code>, following the directions specified in <code>seq</code>. </p><p><strong>Inputs</strong></p><ul><li><code>a</code> and <code>b</code> – 9-elements state vectors (position velocity and acceleration).</li><li><code>seq</code> – Accepted sequence directions are: <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code>, <code>:ZY</code></li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L108-L117" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.twovectors_to_δ³dcm-Tuple{Any, Any, Any}" id="FrameTransformations.Frames.twovectors_to_δ³dcm-Tuple{Any, Any, Any}"><code>FrameTransformations.Frames.twovectors_to_δ³dcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">twovectors_to_δ³dcm(a, b, seq)</code></pre><p>Compute the 3rd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors <code>a</code> and <code>b</code>, following the directions specified in <code>seq</code>. </p><p><strong>Inputs</strong></p><ul><li><code>a</code> and <code>b</code> – 12-elements state vectors (position, velocity, acceleration and jerk).</li><li><code>seq</code> – Accepted sequence directions are: <code>:XY</code>, <code>:YX</code>, <code>:XZ</code>, <code>:ZX</code>, <code>:YZ</code>, <code>:ZY</code></li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/Definitions/twovectors.jl#L120-L129" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.update_point!-Union{Tuple{S}, Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T, S}, Any, AbstractVector{T}, Epoch{S}}} where {O, T, S}" id="FrameTransformations.Frames.update_point!-Union{Tuple{S}, Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T, S}, Any, AbstractVector{T}, Epoch{S}}} where {O, T, S}"><code>FrameTransformations.Frames.update_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_point!(frames, point, stv::AbstractVector, epoch::Epoch)</code></pre></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L461-L464" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.update_point!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, AbstractVector{T}, T}} where {O, T}" id="FrameTransformations.Frames.update_point!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, AbstractVector{T}, T}} where {O, T}"><code>FrameTransformations.Frames.update_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_point!(frames::FrameSystem, point, stv::AbstractVector, time)</code></pre><p>Update the state vector of <code>point</code> at the input <code>time</code> in <code>frames</code>. The only  accepted length for the input vector <code>stv</code> are 3, 6, 9 or 12. The order is automatically  inferred from the vector length.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; FRAMES = FrameSystem{2, Float64}();
  
julia&gt; @axes ICRF 1  

julia&gt; add_axes_inertial!(FRAMES, ICRF)

julia&gt; @point Origin 0

julia&gt; @point Satellite 1 

julia&gt; add_point_root!(FRAMES, Origin, ICRF)

julia&gt; add_point_updatable!(FRAMES, Satellite, Origin, ICRF)

julia&gt; y = [10000., 200., 300.];

julia&gt; update_point!(FRAMES, Satellite, y, 0.1)

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.1)
3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):
 10000.0
   200.0
   300.0

julia&gt; vector3(FRAMES, Origin, Satellite, ICRF, 0.2)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 
[...]

julia&gt; vector6(FRAMES, Origin, Satellite, ICRF, 0.1)
ERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 
[...] </code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}"><code>add_point_updatable!</code></a></p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L470-L514" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector12-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}" id="FrameTransformations.Frames.vector12-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>FrameTransformations.Frames.vector12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector12(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 4.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L154-L169" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector12-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.vector12-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.vector12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector12(frame, from, to, axes, t::Number)</code></pre><p>Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L182-L189" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector3-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}" id="FrameTransformations.Frames.vector3-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>FrameTransformations.Frames.vector3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector3(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 1.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L154-L169" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector3-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Any, Epoch{S}, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where S" id="FrameTransformations.Frames.vector3-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Any, Epoch{S}, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where S"><code>FrameTransformations.Frames.vector3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch <code>ep</code>,  using the aberration flag <code>ltcorr</code>, which may be any of the following <code>AbstractLightTimeCorrection</code>:</p><ul><li><p><strong>LightTimeCorrection</strong>: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. </p></li><li><p><strong>PlanetaryAberrationCorrection</strong>: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the <code>LightTimeCorrection</code> option to account for the observer velocity    with respect to the Solar System Barycenter. </p></li></ul><p>The integer argument <code>dir</code> is used to specify the correction direction, as follows:</p><ul><li><p><strong>-1</strong>: for <strong>Reception</strong>, in which photons depart from the target's location at the    light-time corrected epoch <code>ep-lt</code> and arrive at the observer's location at <code>ep</code>.</p></li><li><p><strong>+1</strong>: for <strong>Transmission</strong>, in which photons depart from the observer's location at   <code>ep</code> and arrive at the target's location at the light-time corrected epoch <code>ep+lt</code>.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>iters::Int=1</code>: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.</p></li><li><p><code>axescenter</code>: ID or instance of the center point for <code>axes</code>. This parameter is used        only when <code>axes</code> have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to <code>from</code>.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the <code>PlanetaryAberrationCorrection</code> is applied, the frame system must be at  least one order higher than that of the requested transformation.</p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.LightTime"><code>LightTime</code></a>, <a href="#FrameTransformations.Frames.PlanetaryAberration"><code>PlanetaryAberration</code></a> and <a href="#FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector6</code></a>.</p><p><strong>References</strong></p><ul><li>CSPICE <a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkez_c.html">Library</a></li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L349-L392" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where {O, T}" id="FrameTransformations.Frames.vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where {O, T}"><code>FrameTransformations.Frames.vector3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector3(frame, from, to, axes, t::Number, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time <code>t</code>,   expressed in seconds since <code>J2000</code>, using the aberration flag <code>ltcorr</code> and  the direction <code>dir</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L406-L413" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.vector3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector3(frame, from, to, axes, t::Number)</code></pre><p>Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L182-L189" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}" id="FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>FrameTransformations.Frames.vector6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector6(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 2.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L154-L169" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector6-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Any, Epoch{S}, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where S" id="FrameTransformations.Frames.vector6-Union{Tuple{S}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S}, Any, Any, Any, Epoch{S}, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where S"><code>FrameTransformations.Frames.vector6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch <code>ep</code>,  using the aberration flag <code>ltcorr</code>, which may be any of the following <code>AbstractLightTimeCorrection</code>:</p><ul><li><p><strong>LightTimeCorrection</strong>: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. </p></li><li><p><strong>PlanetaryAberrationCorrection</strong>: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the <code>LightTimeCorrection</code> option to account for the observer velocity    with respect to the Solar System Barycenter. </p></li></ul><p>The integer argument <code>dir</code> is used to specify the correction direction, as follows:</p><ul><li><p><strong>-1</strong>: for <strong>Reception</strong>, in which photons depart from the target's location at the    light-time corrected epoch <code>ep-lt</code> and arrive at the observer's location at <code>ep</code>.</p></li><li><p><strong>+1</strong>: for <strong>Transmission</strong>, in which photons depart from the observer's location at   <code>ep</code> and arrive at the target's location at the light-time corrected epoch <code>ep+lt</code>.</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>iters::Int=1</code>: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.</p></li><li><p><code>axescenter</code>: ID or instance of the center point for <code>axes</code>. This parameter is used        only when <code>axes</code> have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to <code>from</code>.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the <code>PlanetaryAberrationCorrection</code> is applied, the frame system must be at  least one order higher than that of the requested transformation.</p></div></div><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.LightTime"><code>LightTime</code></a>, <a href="#FrameTransformations.Frames.PlanetaryAberration"><code>PlanetaryAberration</code></a> and <a href="#FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector6</code></a>.</p><p><strong>References</strong></p><ul><li>CSPICE <a href="https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/spkez_c.html">Library</a></li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L349-L392" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where {O, T}" id="FrameTransformations.Frames.vector6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where {O, T}"><code>FrameTransformations.Frames.vector6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector6(frame, from, to, axes, t::Number, ltcorr, dir; &lt;keyword arguments&gt;)</code></pre><p>Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time <code>t</code>,   expressed in seconds since <code>J2000</code>, using the aberration flag <code>ltcorr</code> and  the direction <code>dir</code>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L406-L413" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.vector6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.vector6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector6(frame, from, to, axes, t::Number)</code></pre><p>Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L182-L189" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector9-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}" id="FrameTransformations.Frames.vector9-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>FrameTransformations.Frames.vector9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector9(frame::FrameSystem, from, to, axes, ep::Epoch)</code></pre><p>Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch <code>ep</code>.</p><p>Requires a frame system of order ≥ 3.</p><p><strong>Inputs</strong></p><ul><li><code>frame</code> – The <code>FrameSystem</code> container object </li><li><code>from</code> – ID or instance of the observing point</li><li><code>to</code> – ID or instance of the target point </li><li><code>axes</code> – ID or instance of the output state vector axes </li><li><code>ep</code> – <code>Epoch</code> of the observer. Its timescale must match that of the frame system. </li></ul></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L154-L169" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.vector9-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}" id="FrameTransformations.Frames.vector9-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}"><code>FrameTransformations.Frames.vector9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector9(frame, from, to, axes, t::Number)</code></pre><p>Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time <code>t</code> expressed in  seconds since <code>J2000</code> if ephemerides are used. </p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/transform.jl#L182-L189" target="_blank">source</a></section></article><h3 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.@axes" id="FrameTransformations.Frames.@axes"><code>FrameTransformations.Frames.@axes</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@axes(name, id, type=nothing)</code></pre><p>Define a new axes instance to alias the given <code>id</code>. This macro creates an  <a href="#FrameTransformations.Frames.AbstractFrameAxes"><code>AbstractFrameAxes</code></a> subtype and its singleton instance callen <code>name</code>. Its type name  is obtained by appending <code>Axes</code> to either <code>name</code> or <code>type</code> (if provided). </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @axes ICRF 1 InternationalCelestialReferenceFrame

julia&gt; typeof(ICRF)
InternationalCelestialReferenceFrameAxes

julia&gt; axes_alias(ICRF) 
1

julia&gt; @axes IAU_EARTH 10013

julia&gt; typeof(IAU_EARTH)
IauEarthAxes</code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.@point"><code>@point</code></a> and <a href="#FrameTransformations.Frames.axes_alias-Tuple{FrameTransformations.Frames.AbstractFrameAxes}"><code>axes_alias</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/axes.jl#L91-L117" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.@point" id="FrameTransformations.Frames.@point"><code>FrameTransformations.Frames.@point</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@point(name, id, type=nothing)</code></pre><p>Define a new point instance to alias the given NAIFID <code>id</code>. This macro creates an  <a href="#FrameTransformations.Frames.AbstractFramePoint"><code>AbstractFramePoint</code></a> subtype and its singleton instance called <code>name</code>. Its type name  is obtained by appending <code>Point</code> to either <code>name</code> or <code>type</code> (if provided).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @point Venus 299

julia&gt; typeof(Venus)
VenusPoint 

julia&gt; point_alias(Venus)
299

julia&gt; @point EMB 3 EarthMoonBarycenter

julia&gt; typeof(EMB) 
EarthMoonBarycenterPoint

julia&gt; point_alias(EMB) 
3 </code></pre><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.@axes"><code>@axes</code></a> and <a href="#FrameTransformations.Frames.point_alias-Tuple{FrameTransformations.Frames.AbstractFramePoint}"><code>point_alias</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/points.jl#L34-L64" target="_blank">source</a></section></article><h3 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.LightTime" id="FrameTransformations.Frames.LightTime"><code>FrameTransformations.Frames.LightTime</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">LightTime</code></pre><p>The singleton instance of type <code>LightTimeCorrection</code>, used to apply light-time (planetary  aberration) corrections when computing vectors from the <code>FrameSystem</code>.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.vector3-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector3</code></a> and <a href="#FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector6</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/lightime.jl#L8-L17" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-binding" href="#FrameTransformations.Frames.PlanetaryAberration" id="FrameTransformations.Frames.PlanetaryAberration"><code>FrameTransformations.Frames.PlanetaryAberration</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">PlanetaryAberration</code></pre><p>The singleton instance of type <code>PlanetaryAberrationCorrection</code>, used to apply one-way  light-time and stellar aberration corrections when computing vectors from the <code>FrameSystem</code>.</p><p><strong>See also</strong></p><p>See also <a href="#FrameTransformations.Frames.vector3-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector3</code></a> and <a href="#FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{&lt;:Any, &lt;:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}"><code>vector6</code></a>.</p></div><a class="docs-sourcelink" href="https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/blob/a4236d355d7d6d38f785cae4f41e7eb7d08497a4/src/Frames/lightime.jl#L19-L28" target="_blank">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../orient/">« Orient</a><a class="docs-footer-nextpage" href="../utils/">Utils »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 July 2023 13:27">Monday 24 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>