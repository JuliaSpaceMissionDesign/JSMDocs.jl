var documenterSearchIndex = {"docs":
[{"location":"api/#Math","page":"API","title":"Math","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils.Math]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.Math.InterpAkima","page":"API","title":"JSMDUtils.Math.InterpAkima","text":"InterpAkima{T, N} <: AbstractInterpolationMethod\n\nType storing an Akima spline nodes and coefficient. T is the interpolation data type  and N is the spline dimension (i.e., the number of interpolated functions).\n\nFields\n\nn – Number of node points.\nxn – Interpolated node points. \nyn – Node points function values \nc – Akima polynomial coefficients. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Math.InterpAkima-Tuple{AbstractVector, AbstractArray}","page":"API","title":"JSMDUtils.Math.InterpAkima","text":"InterpAkima(x::AbstractVector, y::AbstractArray)\n\nConstruct an Akima spline interpolant from a set of data points x and their values y.  Multi-dimensional splines can be constructed passing y as a subtype of AbstractMatrix such  that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points.\n\nReferences\n\nAkima, H. (1970),  A New Method of Interpolation and Smooth Curve Fitting Based on Local   Procedures, Journal of the ACM, DOI: \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.InterpCubicSplines","page":"API","title":"JSMDUtils.Math.InterpCubicSplines","text":"InterpCubicSplines(x::AbstractVector, y::AbstractArray, type::Symbol=:Natural)\n\nConstruct a cubic spline interpolant from a set of data points x and their values y.  Multi-dimensional splines can be constructed by passing y as a subtype of AbstractMatrix,  such that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points.\n\nDifferent boundary conditions can be applied based on the specified type: \n\n:Natural: the second derivative of the first and the last polynomial are equal to    zero at the boundary points. \n:NotAKnot: the third derivatives of the first and last two polynomials are    equal in the points where they meet each other.\n:Periodic: the first and second derivatives at the initial and final points are equal.\n:Quadratic: the first and the last polynomial are quadratic. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Math.InterpCubicSplines-2","page":"API","title":"JSMDUtils.Math.InterpCubicSplines","text":"InterpCubicSplines{T, N} <: AbstractInterpolationMethod\n\nType storing a cubic spline nodes and coefficients. T is the spline data type and  N is the spline dimension (i.e., the number of interpolated functions). \n\nFields\n\nn – Number of node points.\nxn – Interpolated node points.\nyn – Node points function values. \nc –  Spline polynomials coefficients. \ntype – Boundary conditions type.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number, Bool}} where T","page":"API","title":"JSMDInterfaces.Math.interpolate","text":"interpolate(ak::InterpAkima, x::Number, flat::Bool=true)\n\nInterpolate the Akima spline ak at point x. If the spline has a single  dimension (e.g., InterpAkima{T, 1}), a scalar value is returned. Otherwise, an SVector is computed. \n\nIf x is outside the boundary range of sp a flat extrapolation is used by default.  If the flat argument is false, the first and last polynomials will be used to  compute all the outside values.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number, Bool}} where T","page":"API","title":"JSMDInterfaces.Math.interpolate","text":"interpolate(sp::InterpCubicSplines, x::Number, flat::Bool=true)\n\nInterpolate the cubic spline sp at point x. If the spline has a single  dimension (e.g., InterpCubicSpline{T, 1}), a scalar value is returned. Otherwise, an SVector is computed. \n\nIf x is outside the boundary range of sp a flat extrapolation is used by default.  If the flat argument is false, the first and last polynomials will be used to  compute all the outside values.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.D²-Tuple{Any, Any}","page":"API","title":"JSMDUtils.Math.D²","text":"D²(f, x::Real)\n\nReturn d²f/dx² evaluated at x using ForwardDiff, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Union{Real, AbstractArray}).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.D³-Tuple{Any, Any}","page":"API","title":"JSMDUtils.Math.D³","text":"D³(f, x::Real)\n\nReturn d³f/dx³ evaluated at x using ForwardDiff, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Union{Real, AbstractArray}).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.D¹-Tuple{Any, Any}","page":"API","title":"JSMDUtils.Math.D¹","text":"D¹(f, x::Real)\n\nReturn df/dx evaluated at x using ForwardDiff, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Union{Real, AbstractArray}).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.angleplane-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.angleplane","text":"angleplane(v1::AbstractArray, n::AbstractArray)\n\nCompute the angle between a vector v1 and (its projection on) a plane with normal n, in rad. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.angleplaned-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.angleplaned","text":"angleplaned(v1::AbstractArray, n::AbstractArray)\n\nCompute the angle between a vector v1 and (its projection on) a plane with normal n, in deg. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.anglevec-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.anglevec","text":"anglevec(v1::AbstractArray, v2::AbstractArray)\n\nCompute the angle between two vectors v1 and v2, in rad.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.anglevecd-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.anglevecd","text":"anglevecd(v1::AbstractArray, v2::AbstractArray)\n\nCompute the angle between two vectors v1 and v2, in deg.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.projplane-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.projplane","text":"projplane(v1::AbstractArray, n::AbstractArray)\n\nCompute the orthogonal projection of a vector v1 on a plane with normal n.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.projvec-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.projvec","text":"projvec(v1::AbstractArray, v2::AbstractArray)\n\nCompute the orthogonal projection of a vector v1 on a vector v2.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.skew","page":"API","title":"JSMDUtils.Math.skew","text":"skew(v::AbstractArray{N}) where {N<:Number}\n\nCompute a skew-symmetric matrix from the vector v. \n\n\n\n\n\n","category":"function"},{"location":"api/#JSMDUtils.Math.unitcross-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.unitcross","text":"unitcross(v1::AbstractArray, v2::AbstractArray)\n\nCompute the normalized cross product of v1 and v2.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.unitvec-Tuple{AbstractArray}","page":"API","title":"JSMDUtils.Math.unitvec","text":"unitvec(v::AbstractArray)\n\nCompute the normalized vector of v.\n\n\n\n\n\n","category":"method"},{"location":"api/#Autodiff","page":"API","title":"Autodiff","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils.Autodiff]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.Autodiff.AutoHessianConfig","page":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","text":"AutoHessianConfig\n\nWrapper object around a ForwardDiff.HessianConfig type. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Autodiff.AutoHessianConfig-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","text":"AutoHessianConfig(x)\n\nGenerate a Autodiff.AutoHessianConfig instance based on the type and shape of the  input vector x. \n\nThe returned AutoHessianConfig instance contains all the work buffers required by  Autodiff.hessian! when the target function takes the form f(x). The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers. \n\nwarning: Warning\nThe dual numbers that are generated from this instance all share the  'Autodiff.JSMDDiffTag` tag, which could lead to perturbation confusion if the  hessian operation is not used with care.\n\nSee Also\n\nSee also Autodiff.hessian!.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.JSMDDiffTag","page":"API","title":"JSMDUtils.Autodiff.JSMDDiffTag","text":"JSMDDiffTag\n\nSingleton to be used as a ForwardDiff tag for the JSMD ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Autodiff.AutoGradientConfig-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.AutoGradientConfig","text":"AutoGradientConfig(x)\n\nGenerate a ForwardDiff.GradientConfig instance based on the type and shape of the  input x. \n\nThe returned GradientConfig instance contains all the work buffers required by  Autodiff.gradient!. The chunk size is automatically set to 1 since it is part of  the type. Having a larger chunk-size improves performance but would require a greater  number of dispatches for the function wrappers. \n\nwarning: Warning\nThe dual numbers that are generated from this instance all share the  'Autodiff.JSMDDiffTag` tag, which could lead to perturbation confusion if the  gradient operation is not used with care.\n\nSee also\n\nSee also Autodiff.gradient!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.AutoJacobianConfig-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.AutoJacobianConfig","text":"AutoJacobianConfig(x)\n\nGenerate a ForwardDiff.JacobianConfig instance based on the type and shape of the  input vector x. \n\nThe returned JacobianConfig instance contains all the work buffers required by  Autodiff.jacobian! when the target function takes the form f(x). The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers. \n\n\n\nAutoJacobianConfig(y, x)\n\nGenerate a ForwardDiff.JacobianConfig instance based on the type and shape of the  input vector x and the output vector y. \n\nThe returned JacobianConfig instance contains all the work buffers required by  Autodiff.jacobian! when the target function takes the in-place form f!(y, x). \n\nwarning: Warning\nThe dual numbers that are generated from this instance all share the  'Autodiff.JSMDDiffTag` tag, which could lead to perturbation confusion if the  gradient operation is not used with care.\n\nSee Also\n\nSee also Autodiff.jacobian!.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.derivative-Tuple{Any, Number}","page":"API","title":"JSMDUtils.Autodiff.derivative","text":"derivative(f, x::Number)\n\nReturn df/dx evaluated at x, assuming f is called as f(x). \n\nnote: Note\nThis function assumes that isa(f(x), Union{Real, AbstractArray}).\n\nwarning: Warning\nThe dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag which could lead to perturbation confusion in certain  scenarios. Hence, this derivative operation should be used with care.\n\nSee also\n\nSee also Autodiff.gradient! and Autodiff.hessian!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.gentag-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.gentag","text":"gentag(x)\n\nGenerate a dual tag for the element type of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.gradient!-Tuple{Any, Any, Any}","page":"API","title":"JSMDUtils.Autodiff.gradient!","text":"gradient!(res, f, x)\ngradient!(res, f, x, cfg::GradientConfig)\n\nCompute ∇f evaluated at x' and store the output in res, assuming f is called as  f(x). To avoid runtime allocations, a GradientConfig instance must be provided. \n\nnote: Note\nThis function assumes that isa(f(x), Real).\n\nwarning: Warning\nIf the gradient config has been setup with Autodiff.AutoGradientConfig,  the dual numbers generated by this function are tagged with the Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain scenarios. Hence, this gradient  operation should be used with care.\n\nSee Also\n\nSee also Autodiff.AutoGradientConfig\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.hessian!-Tuple{Any, Any, Any}","page":"API","title":"JSMDUtils.Autodiff.hessian!","text":"hessian!(res, f, x)\nhessian!(res, f, x, ahc::AutoHessianConfig)\n\nCompute H(f) (i.e., J(∇(f))) evaluated at x' and store the output in res, assuming  f is called as f(x). To avoid runtime allocations, an Autodiff.AutoHessianConfig  instance must be provided. \n\nnote: Note\nThis function assumes that isa(f(x), Real).\n\nwarning: Warning\nThe dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag which could lead to perturbation confusion in certain  scenarios. Hence, this hessian operation should be used with care.\n\nSee Also\n\nSee also Autodiff.AutoHessianConfig. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.jacobian!-Tuple{Any, Any, Any}","page":"API","title":"JSMDUtils.Autodiff.jacobian!","text":"jacobian!(res, f, x)\njacobian!(res, f, x, cfg::JacobianConfig)\n\nCompute J(f) evaluated at the input vector x and store the result in res, assuming  f is called as f(x). To avoid runtime allocations, a JacobianConfig instance must be  provided. \n\nnote: Note\nThis function assumes that isa(f(x), Union{AbstractArray}).\n\n\n\njacobian!(res, f!, y, x) jacobian!(res, f!, y, x, cfg::JacobianConfig)\n\nCompute J(f) evaluated at the input vector x and store the result in res, assuming  f is called as f!(y, x), where the result is stored in y. To avoid runtime allocations, a JacobianConfig instance must be  provided. \n\nwarning: Warning\nIf the jacobian config has been setup with Autodiff.AutoJacobianConfig,  the dual numbers generated by this function are tagged with the Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain scenarios. Hence, this jacobian  operation should be used with care.\n\nSee Also\n\nSee also Autodiff.AutoJacobianConfig\n\n\n\n\n\n","category":"method"},{"location":"api/#FileUtils","page":"API","title":"FileUtils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils.FileUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.FileUtils.JSON","page":"API","title":"JSMDUtils.FileUtils.JSON","text":"JSMDUtils.FileUtils.JSON <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing JSMDUtils.FileUtils.JSON files.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.FileUtils.TXT","page":"API","title":"JSMDUtils.FileUtils.TXT","text":"JSMDUtils.FileUtils.TXT <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing JSMDUtils.FileUtils.TXT files.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.FileUtils.YAML","page":"API","title":"JSMDUtils.FileUtils.YAML","text":"JSMDUtils.FileUtils.YAML <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing JSMDUtils.FileUtils.YAML files.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.JSON{1}}","page":"API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::JSON{1})\n\nOpen a JSON file and parse its data in a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.TXT{1}}","page":"API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::TXT{1})\n\nOpen a TEXT file and parse its data in a list of strings.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.YAML{1}}","page":"API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::YAML{1})\n\nOpen a YAML file and parse its data in a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Miscellaneous","page":"API","title":"Miscellaneous","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.NullEphemerisProvider","page":"API","title":"JSMDUtils.NullEphemerisProvider","text":"EmptyEphemerisProvider <: AbstractEphemerisProvider\n\nEmpty provider to initialise the frame system without loading  ephemeris files. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.format_camelcase-Tuple{S} where S<:AbstractString","page":"API","title":"JSMDUtils.format_camelcase","text":"format_camelcase(str::AbstractString)\n\nFormat str in CamelCase, such that the first letter of each word  in the sentence is capitalized and spaces are removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.format_snakecase-Tuple{S} where S<:AbstractString","page":"API","title":"JSMDUtils.format_snakecase","text":"format_snakecase(str::AbstractString)\n\nFormat str in SnakeCase, such that all the letters are in lower case and  spaces are replaced with underscores.\n\n\n\n\n\n","category":"method"},{"location":"#JSMDUtils.jl","page":"Home","title":"JSMDUtils.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A utily package for the JSMD ecosystem","category":"page"},{"location":"","page":"Home","title":"Home","text":"JSMDUtils.jl is a low-level package holding different utility functions and type definitions that are reused by many packages within the JSMD ecosystem. ","category":"page"}]
}
