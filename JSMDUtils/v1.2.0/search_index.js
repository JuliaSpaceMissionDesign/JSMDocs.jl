var documenterSearchIndex = {"docs":
[{"location":"api/#JSMDUtils-API","page":"API","title":"JSMDUtils API","text":"","category":"section"},{"location":"api/#Math","page":"API","title":"Math","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils.Math]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.Math.InterpAkima","page":"API","title":"JSMDUtils.Math.InterpAkima","text":"InterpAkima{T, N} <: AbstractInterpolationMethod\n\nType storing an Akima spline nodes and coefficient. T is the interpolation data type  and N is the spline dimension (i.e., the number of interpolated functions).\n\nFields\n\nn – Number of node points.\nxn – Interpolated node points. \nyn – Node points function values \nc – Akima polynomial coefficients. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Math.InterpAkima-Tuple{AbstractVector, AbstractArray}","page":"API","title":"JSMDUtils.Math.InterpAkima","text":"InterpAkima(x::AbstractVector, y::AbstractArray)\n\nConstruct an Akima spline interpolant from a set of data points x and their values y.  Multi-dimensional splines can be constructed passing y as a subtype of AbstractMatrix such  that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points.\n\nReferences\n\nAkima, H. (1970),  A New Method of Interpolation and Smooth Curve Fitting Based on Local   Procedures, Journal of the ACM, DOI: \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.InterpCubicSplines","page":"API","title":"JSMDUtils.Math.InterpCubicSplines","text":"InterpCubicSplines(x::AbstractVector, y::AbstractArray, type::Symbol=:Natural)\n\nConstruct a cubic spline interpolant from a set of data points x and their values y.  Multi-dimensional splines can be constructed by passing y as a subtype of AbstractMatrix,  such that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points.\n\nDifferent boundary conditions can be applied based on the specified type: \n\n:Natural: the second derivative of the first and the last polynomial are equal to    zero at the boundary points. \n:NotAKnot: the third derivatives of the first and last two polynomials are    equal in the points where they meet each other.\n:Periodic: the first and second derivatives at the initial and final points are equal.\n:Quadratic: the first and the last polynomial are quadratic. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Math.InterpCubicSplines-2","page":"API","title":"JSMDUtils.Math.InterpCubicSplines","text":"InterpCubicSplines{T, N} <: AbstractInterpolationMethod\n\nType storing a cubic spline nodes and coefficients. T is the spline data type and  N is the spline dimension (i.e., the number of interpolated functions). \n\nFields\n\nn – Number of node points.\nxn – Interpolated node points.\nyn – Node points function values. \nc –  Spline polynomials coefficients. \ntype – Boundary conditions type.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number, Bool}} where T","page":"API","title":"JSMDInterfaces.Math.interpolate","text":"interpolate(ak::InterpAkima, x::Number, flat::Bool=true)\n\nInterpolate the Akima spline ak at point x. If the spline has a single  dimension (e.g., InterpAkima{T, 1}), a scalar value is returned. Otherwise, an SVector is computed. \n\nIf x is outside the boundary range of sp a flat extrapolation is used by default.  If the flat argument is false, the first and last polynomials will be used to  compute all the outside values.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number, Bool}} where T","page":"API","title":"JSMDInterfaces.Math.interpolate","text":"interpolate(sp::InterpCubicSplines, x::Number, flat::Bool=true)\n\nInterpolate the cubic spline sp at point x. If the spline has a single  dimension (e.g., InterpCubicSpline{T, 1}), a scalar value is returned. Otherwise, an SVector is computed. \n\nIf x is outside the boundary range of sp a flat extrapolation is used by default.  If the flat argument is false, the first and last polynomials will be used to  compute all the outside values.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.D²-Tuple{Any, Any}","page":"API","title":"JSMDUtils.Math.D²","text":"D²(f, x::Real)\n\nReturn d²f/dx² evaluated at x using ForwardDiff, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Union{Real, AbstractArray}).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.D³-Tuple{Any, Any}","page":"API","title":"JSMDUtils.Math.D³","text":"D³(f, x::Real)\n\nReturn d³f/dx³ evaluated at x using ForwardDiff, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Union{Real, AbstractArray}).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.D¹-Tuple{Any, Any}","page":"API","title":"JSMDUtils.Math.D¹","text":"D¹(f, x::Real)\n\nReturn df/dx evaluated at x using ForwardDiff, assuming f is called as f(x).\n\nThis method assumes that isa(f(x), Union{Real, AbstractArray}).\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math._3angles_to_δdcm-Tuple{Any, Symbol}","page":"API","title":"JSMDUtils.Math._3angles_to_δdcm","text":"_3angles_to_δdcm(θ, rot_seq::Symbol)\n\nCompute the time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math._3angles_to_δ²dcm-Tuple{Any, Symbol}","page":"API","title":"JSMDUtils.Math._3angles_to_δ²dcm","text":"_3angles_to_δ²dcm(θ, rot_seq::Symbol)\n\nCompute the 2nd time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math._3angles_to_δ³dcm-Tuple{Any, Symbol}","page":"API","title":"JSMDUtils.Math._3angles_to_δ³dcm","text":"_3angles_to_δ³dcm(θ, rot_seq::Symbol)\n\nCompute the 3rd order time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.angle_to_δdcm","page":"API","title":"JSMDUtils.Math.angle_to_δdcm","text":"angle_to_δdcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX)\n\nCompute the derivative of the direction cosine matrix that perform a set of rotations (θ,  ϕ, γ) about the coordinate axes in rot_seq. Each rotation input must be an indexable  objected which includes the angle and its first time derivative.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δ²dcm\n\n\n\n\n\n","category":"function"},{"location":"api/#JSMDUtils.Math.angle_to_δ²dcm","page":"API","title":"JSMDUtils.Math.angle_to_δ²dcm","text":"angle_to_δ²dcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX)\n\nCompute the second order time derivative of the direction cosine matrix that perform  a set of rotations (θ, ϕ, γ) about the coordinate axes in rot_seq. Each rotation  input must be an indexable objected which includes the angle and its first and second order  time derivatives.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δdcm\n\n\n\n\n\n","category":"function"},{"location":"api/#JSMDUtils.Math.angle_to_δ³dcm","page":"API","title":"JSMDUtils.Math.angle_to_δ³dcm","text":"angle_to_δ³dcm(θ::Number[, ϕ::Number[, γ::Number]], rot_seq::Symbol = :Z)\n\nCompute the second order time derivative of the direction cosine matrix that perform  a set of rotations (θ, ϕ, γ) about the coordinate axes in rot_seq. Each rotation  input must be an indexable objected which includes the angle and its time derivatives up to  order 3 (jerk).\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δdcm\n\n\n\n\n\n","category":"function"},{"location":"api/#JSMDUtils.Math.angleplane-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.angleplane","text":"angleplane(v1::AbstractArray, n::AbstractArray)\n\nCompute the angle between a vector v1 and (its projection on) a plane with normal n, in rad. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.angleplaned-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.angleplaned","text":"angleplaned(v1::AbstractArray, n::AbstractArray)\n\nCompute the angle between a vector v1 and (its projection on) a plane with normal n, in deg. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.anglevec-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.anglevec","text":"anglevec(v1::AbstractArray, v2::AbstractArray)\n\nCompute the angle between two vectors v1 and v2, in rad.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.anglevecd-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.anglevecd","text":"anglevecd(v1::AbstractArray, v2::AbstractArray)\n\nCompute the angle between two vectors v1 and v2, in deg.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.cross12-Tuple{AbstractVector, AbstractVector}","page":"API","title":"JSMDUtils.Math.cross12","text":"cross12(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its 1st, 2nd and 3rd order time derivatives. \n\nnote: Note\nx and y must be 12-elements state vectors (position, velocity and acceleration)\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.cross3-Tuple{AbstractVector, AbstractVector}","page":"API","title":"JSMDUtils.Math.cross3","text":"cross3(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y, considering only their first 3 elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.cross6-Tuple{AbstractVector, AbstractVector}","page":"API","title":"JSMDUtils.Math.cross6","text":"cross6(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its time derivative. \n\nnote: Note\nx and y must be 6-elements state vectors, with the last elements of each vector  representing the time derivatives of the first three.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.cross9-Tuple{AbstractVector, AbstractVector}","page":"API","title":"JSMDUtils.Math.cross9","text":"cross9(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its 1st and 2nd-order time derivatives. \n\nnote: Note\nx and y must be 9-elements state vectors (position, velocity and acceleration)\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.projplane-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.projplane","text":"projplane(v1::AbstractArray, n::AbstractArray)\n\nCompute the orthogonal projection of a vector v1 on a plane with normal n.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.projvec-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.projvec","text":"projvec(v1::AbstractArray, v2::AbstractArray)\n\nCompute the orthogonal projection of a vector v1 on a vector v2.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.skew-Tuple{AbstractArray}","page":"API","title":"JSMDUtils.Math.skew","text":"skew(a)\n\nCreate a skew matrix from the vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.unitcross-Tuple{AbstractArray, AbstractArray}","page":"API","title":"JSMDUtils.Math.unitcross","text":"unitcross(v1::AbstractArray, v2::AbstractArray)\n\nCompute the normalized cross product of v1 and v2.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.unitvec-Tuple{AbstractVector}","page":"API","title":"JSMDUtils.Math.unitvec","text":"unitvec(v::AbstractVector)\n\nNormalise the vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.δunitvec-Tuple{AbstractVector}","page":"API","title":"JSMDUtils.Math.δunitvec","text":"δunitvec(v::AbstractVector)\n\nCompute the time derivative of a unit vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.δ²unitvec-Tuple{AbstractVector}","page":"API","title":"JSMDUtils.Math.δ²unitvec","text":"δ²unitvec(v::AbstractVector)\n\nCompute the 2nd-order time derivative of a unit vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Math.δ³unitvec-Tuple{AbstractVector}","page":"API","title":"JSMDUtils.Math.δ³unitvec","text":"δ³unitvec(v::AbstractVector)\n\nCompute the 3rd-order time derivative of a unit vector v.\n\n\n\n\n\n","category":"method"},{"location":"api/#Autodiff","page":"API","title":"Autodiff","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils.Autodiff]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.Autodiff.AutoHessianConfig","page":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","text":"AutoHessianConfig\n\nWrapper object around a ForwardDiff.HessianConfig type. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Autodiff.AutoHessianConfig-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","text":"AutoHessianConfig(x)\n\nGenerate a Autodiff.AutoHessianConfig instance based on the type and shape of the  input vector x. \n\nThe returned AutoHessianConfig instance contains all the work buffers required by  Autodiff.hessian! when the target function takes the form f(x). The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers. \n\nwarning: Warning\nThe dual numbers that are generated from this instance all share the  Autodiff.JSMDDiffTag tag, which could lead to perturbation confusion if the  hessian operation is not used with care.\n\nSee Also\n\nSee also Autodiff.hessian!.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.JSMDDiffTag","page":"API","title":"JSMDUtils.Autodiff.JSMDDiffTag","text":"JSMDDiffTag\n\nSingleton to be used as a ForwardDiff tag for the JSMD ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.Autodiff.AutoGradientConfig-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.AutoGradientConfig","text":"AutoGradientConfig(x)\n\nGenerate a ForwardDiff.GradientConfig instance based on the type and shape of the  input x. \n\nThe returned GradientConfig instance contains all the work buffers required by  Autodiff.gradient!. The chunk size is automatically set to 1 since it is part of  the type. Having a larger chunk-size improves performance but would require a greater  number of dispatches for the function wrappers. \n\nwarning: Warning\nThe dual numbers that are generated from this instance all share the  Autodiff.JSMDDiffTag tag, which could lead to perturbation confusion if the  gradient operation is not used with care.\n\nSee also\n\nSee also Autodiff.gradient!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.AutoJacobianConfig-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.AutoJacobianConfig","text":"AutoJacobianConfig(x)\n\nGenerate a ForwardDiff.JacobianConfig instance based on the type and shape of the  input vector x. \n\nThe returned JacobianConfig instance contains all the work buffers required by  Autodiff.jacobian! when the target function takes the form f(x). The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers. \n\n\n\nAutoJacobianConfig(y, x)\n\nGenerate a ForwardDiff.JacobianConfig instance based on the type and shape of the  input vector x and the output vector y. \n\nThe returned JacobianConfig instance contains all the work buffers required by  Autodiff.jacobian! when the target function takes the in-place form f!(y, x). \n\nwarning: Warning\nThe dual numbers that are generated from this instance all share the  Autodiff.JSMDDiffTag tag, which could lead to perturbation confusion if the  gradient operation is not used with care.\n\nSee Also\n\nSee also Autodiff.jacobian!.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.derivative-Tuple{Any, Number}","page":"API","title":"JSMDUtils.Autodiff.derivative","text":"derivative(f, x::Number)\n\nReturn df/dx evaluated at x, assuming f is called as f(x). \n\nnote: Note\nThis function assumes that isa(f(x), Union{Real, AbstractArray}).\n\nwarning: Warning\nThe dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag which could lead to perturbation confusion in certain  scenarios. Hence, this derivative operation should be used with care.\n\nSee also\n\nSee also Autodiff.gradient! and Autodiff.hessian!\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.gentag-Tuple{Any}","page":"API","title":"JSMDUtils.Autodiff.gentag","text":"gentag(x)\n\nGenerate a dual tag for the element type of x.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.gradient!-Tuple{Any, Any, Any}","page":"API","title":"JSMDUtils.Autodiff.gradient!","text":"gradient!(res, f, x)\ngradient!(res, f, x, cfg::GradientConfig)\n\nCompute ∇f evaluated at x and store the output in res, assuming f is called as  f(x). To avoid runtime allocations, a GradientConfig instance must be provided. \n\nnote: Note\nThis function assumes that isa(f(x), Real).\n\nwarning: Warning\nIf the gradient config has been setup with Autodiff.AutoGradientConfig,  the dual numbers generated by this function are tagged with the Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain scenarios. Hence, this gradient  operation should be used with care.\n\nSee Also\n\nSee also Autodiff.AutoGradientConfig\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.hessian!-Tuple{Any, Any, Any}","page":"API","title":"JSMDUtils.Autodiff.hessian!","text":"hessian!(res, f, x)\nhessian!(res, f, x, ahc::AutoHessianConfig)\n\nCompute H(f) (i.e., J(∇(f))) evaluated at x and store the output in res, assuming  f is called as f(x). To avoid runtime allocations, an Autodiff.AutoHessianConfig  instance must be provided. \n\nnote: Note\nThis function assumes that isa(f(x), Real).\n\nwarning: Warning\nThe dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag which could lead to perturbation confusion in certain  scenarios. Hence, this hessian operation should be used with care.\n\nSee Also\n\nSee also Autodiff.AutoHessianConfig. \n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.Autodiff.jacobian!-Tuple{Any, Any, Any}","page":"API","title":"JSMDUtils.Autodiff.jacobian!","text":"jacobian!(res, f, x)\njacobian!(res, f, x, cfg::JacobianConfig)\n\nCompute J(f) evaluated at the input vector x and store the result in res, assuming  f is called as f(x). To avoid runtime allocations, a JacobianConfig instance must be  provided. \n\nnote: Note\nThis function assumes that isa(f(x), Union{AbstractArray}).\n\n\n\njacobian!(res, f!, y, x) jacobian!(res, f!, y, x, cfg::JacobianConfig)\n\nCompute J(f) evaluated at the input vector x and store the result in res, assuming  f is called as f!(y, x), where the result is stored in y. To avoid runtime allocations, a JacobianConfig instance must be  provided. \n\nwarning: Warning\nIf the jacobian config has been setup with Autodiff.AutoJacobianConfig,  the dual numbers generated by this function are tagged with the Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain scenarios. Hence, this jacobian  operation should be used with care.\n\nSee Also\n\nSee also Autodiff.AutoJacobianConfig\n\n\n\n\n\n","category":"method"},{"location":"api/#FileUtils","page":"API","title":"FileUtils","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils.FileUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.FileUtils.JSON","page":"API","title":"JSMDUtils.FileUtils.JSON","text":"JSMDUtils.FileUtils.JSON <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing JSMDUtils.FileUtils.JSON files.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.FileUtils.TXT","page":"API","title":"JSMDUtils.FileUtils.TXT","text":"JSMDUtils.FileUtils.TXT <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing JSMDUtils.FileUtils.TXT files.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.FileUtils.YAML","page":"API","title":"JSMDUtils.FileUtils.YAML","text":"JSMDUtils.FileUtils.YAML <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing JSMDUtils.FileUtils.YAML files.\n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.JSON{1}}","page":"API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::JSON{1})\n\nOpen a JSON file and parse its data in a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.TXT{1}}","page":"API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::TXT{1})\n\nOpen a TEXT file and parse its data in a list of strings.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.YAML{1}}","page":"API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::YAML{1})\n\nOpen a YAML file and parse its data in a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#Miscellaneous","page":"API","title":"Miscellaneous","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [JSMDUtils]\nOrder = [:type, :function]","category":"page"},{"location":"api/#JSMDUtils.NullEphemerisProvider","page":"API","title":"JSMDUtils.NullEphemerisProvider","text":"EmptyEphemerisProvider <: AbstractEphemerisProvider\n\nEmpty provider to initialise the frame system without loading  ephemeris files. \n\n\n\n\n\n","category":"type"},{"location":"api/#JSMDUtils.format_camelcase-Tuple{S} where S<:AbstractString","page":"API","title":"JSMDUtils.format_camelcase","text":"format_camelcase(str::AbstractString)\n\nFormat str in CamelCase, such that the first letter of each word  in the sentence is capitalized and spaces are removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#JSMDUtils.format_snakecase-Tuple{S} where S<:AbstractString","page":"API","title":"JSMDUtils.format_snakecase","text":"format_snakecase(str::AbstractString)\n\nFormat str in SnakeCase, such that all the letters are in lower case and  spaces are replaced with underscores.\n\n\n\n\n\n","category":"method"},{"location":"#JSMDUtils.jl","page":"Home","title":"JSMDUtils.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A utily package for the JSMD ecosystem","category":"page"},{"location":"","page":"Home","title":"Home","text":"JSMDUtils.jl is a low-level package holding different utility functions and type definitions that are reused by many packages within the JSMD ecosystem. ","category":"page"}]
}
