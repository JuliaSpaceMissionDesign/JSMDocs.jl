var documenterSearchIndex = {"docs":
[{"location":"Modules/orient/#basic_orient","page":"Orient","title":"Orient","text":"","category":"section"},{"location":"Modules/orient/#basic_orient_api","page":"Orient","title":"API","text":"","category":"section"},{"location":"Modules/orient/#Types","page":"Orient","title":"Types","text":"","category":"section"},{"location":"Modules/orient/","page":"Orient","title":"Orient","text":"Modules = [Orient]\nOrder = [:type]","category":"page"},{"location":"Modules/orient/#FrameTransformations.Orient.EOPData","page":"Orient","title":"FrameTransformations.Orient.EOPData","text":"EOPData{T}\n\nEOP Data for IAU 2000A.\n\nnote: Note\nEach field will be an AbstractInterpolation indexed by the Julian Day.\n\nFields\n\nx, y: Polar motion with respect to the crust [arcsec].\nUT1_UTC: Irregularities of the rotation angle [s].\nLOD: Length of day offset [ms].\ndX, dY: Celestial pole offsets referred to the model IAU2000A [milliarcsec].\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient/#FrameTransformations.Orient.FundamentalArguments","page":"Orient","title":"FrameTransformations.Orient.FundamentalArguments","text":"FundamentalArguments(t::Number, m::IAUModel=iau2006a)\n\nCompute the fundamental luni-solar and planetary arguments, in radians, associated to the  given IAU model m, at time t expressed in TDB Julian centuries since J2000.\n\nThe available IAU model options are: iau2006a and iau2000b.\n\nnote: Note\nOnly the planetary arguments are affected by the IAU Model choice.\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient/#FrameTransformations.Orient.FundamentalArguments-2","page":"Orient","title":"FrameTransformations.Orient.FundamentalArguments","text":"FundamentalArguments{N <: Number}\n\nType storing the fundamental luni-solar and planetary arguments.\n\nFields\n\nMₐ – Mean anomaly of the Moon \nSₐ – Mean anomaly of the Sun\nuₘ – Mean longitude of the Moon minus mean longitude of the ascending node F\nDₛ – Mean elongation of the Moon from the Sun \nΩₘ – Mean longitude of the Moon's ascending node\nλ_Me – Mercury's mean heliocentric longitude\nλ_Ve – Venus's mean heliocentric longitude\nλ_Ea – Earth's mean heliocentric longitude\nλ_Ma – Mars's mean heliocentric longitude\nλ_Ju – Jupiter's mean heliocentric longitude\nλ_Sa – Saturn's mean heliocentric longitude\nλ_Ur – Uranus's mean heliocentric longitude\nλ_Ne – Neptune's mean heliocentric longitude\npₐ – General precession in longitude\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient/#Functions","page":"Orient","title":"Functions","text":"","category":"section"},{"location":"Modules/orient/","page":"Orient","title":"Orient","text":"Modules = [Orient]\nOrder = [:function]","category":"page"},{"location":"Modules/orient/#FrameTransformations.Orient.LuniSolarArguments-Tuple{Number, Union{FrameTransformations.Orient.IAU2000A, FrameTransformations.Orient.IAU2006A}}","page":"Orient","title":"FrameTransformations.Orient.LuniSolarArguments","text":"LuniSolarArguments(t::Number, m::IAUModel)\n\nCompute the fundamental (Delaunay) Luni-Solar arguments, in radians, associated to the  desired IAU model m, at time t expressed in TDB Julian centuries since J2000.\n\nThe returned values depend on the input model as follows: \n\nIAU2006A: the Delaunay expressions are taken from the IERS 2010 Conventions.\nIAU2000B: the expressions are taken from Simon et al. (1994), following ERFA's   implementation of nut00b.c\n\nOutputs\n\nMₐ – Mean anomaly of the Moon\nSₐ – Mean anomaly of the Sun\nuₘ – Mean longitude of the Moon minus mean longitude of the         ascending node F\nDₛ – Mean elongation of the Moon from the Sun\nΩₘ – Mean longitude of the Moon's ascending node\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nSimon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets.\nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.PlanetaryArguments-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.PlanetaryArguments","text":"PlanetaryArguments(t::Number)\n\nCompute the fundamental planetary arguments and the general precession, in radians,  at time t expressed in TDB Julian centuries since J2000.\n\nOutputs\n\nλ☿ – Mercury's mean heliocentric longitude.\nλ♀ – Venus's mean heliocentric longitude.\nλe – Earth's mean heliocentric longitude.\nλ♂ – Mars's mean heliocentric longitude.\nλ♃ – Jupiter's mean heliocentric longitude.\nλ♄ – Saturn's mean heliocentric longitude.\nλ⛢ – Uranus's mean heliocentric longitude.\nλ♆ – Neptune's mean heliocentric longitude.\npλ – General precession in longitude.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.bpn2xy-Tuple{AbstractMatrix}","page":"Orient","title":"FrameTransformations.Orient.bpn2xy","text":"bpn2xy(A::AbstractMatrix)\n\nCompute the CIP X and Y coordinates from the bias-precession-nutation matrix, in radians.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.cio_locator-Tuple{FrameTransformations.Orient.IAUModel, Number, Number, Number}","page":"Orient","title":"FrameTransformations.Orient.cio_locator","text":"cio_locator(m::IAUModel, t::Number, x::Number, y::Number)\n\nCompute the CIO Locator s in radians, according to the IAU Model m, given the CIP  coordinates X and Y at time t expressed in TT Julian centuries since J2000\n\nThe function has been implemented for the IAU2000, IAU2006 and the CPN models.\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\nERFA library\nERFA library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.cip_coords-Tuple{FrameTransformations.Orient.IAU2006Model, Number}","page":"Orient","title":"FrameTransformations.Orient.cip_coords","text":"cip_coords(m::IAUModel, t::Number)\n\nComputes the CIP X, Y coordinates, in radians, according to the IAU model m at time t  expressed in TT Julian Centuries since J2000.\n\nThis function has been implemented for the IAU2000, IAU2006 and the CPN models.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.cip_motion","page":"Orient","title":"FrameTransformations.Orient.cip_motion","text":"cip_motion(m::IAUModel, t::Number, dx::Number=0.0, dy::Number=0.0)\n\nCompute the CIRS to GCRS rotation matrix, according to the IAU Model m, at time t expressed in TT Julian centuries since J2000. Optional IERS corrections for  free-core nutation and time depedented effects can be provided through dx and dy. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.earth_rotation_angle-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.earth_rotation_angle","text":"earth_rotation_angle(t::Number)\n\nCompute the Earth Rotation Angle (ERA) in radians, i.e., the angle between the Celestial  Intermediate Origin (CIO) and the Terrestrial Intermediate Origin (TIO) at time t  expressed as UT1 days since J2000.\n\nnote: Note\nThe function uses the fractional UT1 date to gain additional precision in the  computations (0.002737.. instead of 1.002737..)\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.earth_rotation_rate-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.earth_rotation_rate","text":"earth_rotation_rate(LOD::Number)\n\nCompute the true angular velocity of the Earth accounting for the Length of the Day, i.e.,  the instantaneous rate of change of UT1 with respect to a uniform time scale. \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.earth_rotation_rate-Tuple{}","page":"Orient","title":"FrameTransformations.Orient.earth_rotation_rate","text":"earth_rotation_rate()\n\nCompute the nominal Earth angular velocity. \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.era_rotm-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.era_rotm","text":"era_rotm(t::Number)\n\nCompute the TIRS to CIRS Earth Rotation matrix, according to the IERS 2010  conventions at time t expressed as UT1 days since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mano_moon-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mano_moon","text":"fa_mano_moon(t::Number)\n\nReturn the mean anomaly of the Moon Mₐ, in radians, at time t expressed in TDB Julian  centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mano_sun-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mano_sun","text":"fa_mano_sun(t::Number)\n\nReturn the mean anomaly of the Sun Sₐ in radians, at time t expressed in TDB Julian  centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_melo_moon-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_melo_moon","text":"fa_melo_moon(t::Number)\n\nReturn the mean elongation of the Moon from the Sun D in radians, at time t expressed in  TDB Julian centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlat_moon-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlat_moon","text":"fa_mlat_moon(t::Number)\n\nReturn the mean longitude of the Moon minus the mean longitude of the ascending node F in radians, at time t expressed in TDB Julian centuries since J2000.  \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_earth-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_earth","text":"fa_mlon_earth(t::Number)\n\nReturn the mean heliocentric longitude of Earth in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_jupiter-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_jupiter","text":"fa_mlon_jupiter(t::Number)\n\nReturn the mean heliocentric longitude of Jupiter in radians, at time t expressed in TDB Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_mars-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_mars","text":"fa_mlon_mars(t::Number)\n\nReturn the mean heliocentric longitude of Mars in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_mercury-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_mercury","text":"fa_mlon_mercury(t::Number)\n\nReturn the mean heliocentric longitude of Mercury in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_moon-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_moon","text":"fa_mlon_moon(t::Number)\n\nReturn the mean longitude of the Moon's ascending node Ω in radians, at time t expressed in TDB Julian centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_neptune-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_neptune","text":"fa_mlon_neptune(t::Number)\n\nReturn the mean heliocentric longitude of Neptune in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_saturn-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_saturn","text":"fa_mlon_saturn(t::Number)\n\nReturn the mean heliocentric longitude of Saturn in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_uranus-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_uranus","text":"fa_mlon_uranus(t::Number)\n\nReturn the mean heliocentric longitude of Uranus in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_mlon_venus-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_mlon_venus","text":"fa_mlon_venus(t::Number)\n\nReturn the mean heliocentric longitude of Venus in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fa_precession-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.fa_precession","text":"fa_precession(t::Number) \n\nReturn the general accumulated precession in longitude pₐ in radians, at time t  expressed in TDB Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.frame_bias-Tuple{FrameTransformations.Orient.IAU2000Model}","page":"Orient","title":"FrameTransformations.Orient.frame_bias","text":"frame_bias(::IAU2000Model)\n\nCompute the frame bias components of the IAU 2000 precession-nutation models, in radians.\n\nNotes\n\nThe frame bias corrections in longitude and obliquity are required to correct for the  offset between the GCRS pole and the mean J2000 pole. They define, with respect  to the GCRS axes, a J2000 mean pole that is consistent with teh IAU 2000A precession-nutation  model. \nThe function also returns an offset in right ascension taken from Chapront et al. (2002), necessary to completely describe the frame bias, but that is not part of the original IAU  2000A model.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fw2xy-NTuple{4, Number}","page":"Orient","title":"FrameTransformations.Orient.fw2xy","text":"fw2xy(ϵ::Number, ψ::Number, γ::Number, φ::Number)\n\nCompute the CIP X and Y coordinates from Fukushima-Williams bias-precession-nutation  angles, in radians.\n\nInputs\n\nϵ – F-W angle with IAU 2006A/B nutation corrections. \nψ – F-W angle with IAU 2006A/B nutation corrections.\nγ – F-W angle  \nϕ – F-W angle\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fw_angles-Tuple{FrameTransformations.Orient.IAU2006Model, Number}","page":"Orient","title":"FrameTransformations.Orient.fw_angles","text":"fw_angles(m::IAU2006Model, t::Number)\n\nCompute the precession angles in radians, following the IAU 2006 Fukushima-Williams 4-angle  formulation at time t expressed in TT Julian centuries since J2000.\n\nOutputs\n\nγ – F-W 1st angle\nϕ – F-W 2nd angle\nψ – F-W 3rd angle   \nε – F-W 4th angle\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.fw_matrix-NTuple{4, Any}","page":"Orient","title":"FrameTransformations.Orient.fw_matrix","text":"fw_matrix(γ, ϕ, ψ, ε)\n\nForm the Nutation-Precession-Bias (NPB) rotation matrix given the Fukushima-Williams angles,  expressed in radians.\n\nThe present function can construct three different matrices depending on which angles are  supplied as arguments: \n\nNPB: To obtain the Nutation-Precession-Bias matrix, generate the four standard FW    precession angles (̄γ, ̄ϕ, ̄ψ, ϵₐ) then generate the nutation components Δψ and Δϵ and add them    to ̄ψ, ϵₐ. Finally, call the present functions using those four angles as arguments. \nPB: To obtain the precession-frame bias matrix, generate the four standard FW precession    angles and call the present function. \nB: To obtain the frame bias matrix, generate the four standard FW precession angles at    date J2000.0 and call this function.\n\nThe remaining nutation-only and precession only matrices can be obtained by combining these  three appropriately. \n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.get_iers_eop-Tuple{}","page":"Orient","title":"FrameTransformations.Orient.get_iers_eop","text":"get_iers_eop(; force_download = false)\n\nDownload and parse the IERS EOP C04 data. \n\nThe files are downloaded using the RemoteFile package with weekly updates. Hence, if one  desires to force a download before the scheduled time, then set the keyword force_download   to true.\n\nnote: Note\nThe files will be downloaded from the default URL. If the user want to use another one, then use the specialized function get_iers_eop_IAU2000ASee also: get_iers_eop_IAU2000A\n\nReturns\n\nA structure EOPData with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to Julian days since J2000.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.get_iers_eop_IAU2000A","page":"Orient","title":"FrameTransformations.Orient.get_iers_eop_IAU2000A","text":"get_iers_eop_iau_2000A(url::String=\"https://datacenter.iers.org/data/csv/finals2000A.all.csv\"; \n    force_download = false)\n\nGet the IERS EOP C04 IAU2000A data from the URL url.\n\nIf url is omitted, then it defaults to https://datacenter.iers.org/data/csv/finals2000A.all.csv. The file is downloaded using the RemoteFile package with weekly updates. Hence, if one desires  to force a download before the scheduled time, then set the keyword force_download to true.\n\nnote: Note\nThe interpolation of every field in EOPData between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).\n\nSee also: get_iers_eop\n\nReturns\n\nThe structure EOPData with the interpolations of the EOP parameters. Notice that the  interpolation indexing is set to Julian days since J2000.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.offset_utc2ut1-Tuple{Any}","page":"Orient","title":"FrameTransformations.Orient.offset_utc2ut1","text":"offset_utc2ut1(seconds)\n\nReturn the offset between UTC and UT1 in seconds.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_bias_precession-Tuple{FrameTransformations.Orient.IAU2006Model, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_bias_precession","text":"orient_bias_precession(m::IAUModel, t::Number)\n\nForm the precession-frame bias (PB) matrix that transforms vectors from the GCRS to the  mean of date, following the IAU Model m at time t expressed as TT Julian centuries  since J2000.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nReferences:\n\nIAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc. 24th General Assembly,  Manchester, UK.  Resolutions B1.3, B1.6. (2000)\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with IAU  2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA pmat06 function.\nERFA pmat00 function.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_bias_precession_nutation-Tuple{FrameTransformations.Orient.IAU2006Model, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_bias_precession_nutation","text":"orient_bias_precession_nutation(m::IAUModel, t::Number)\n\nCompute the equinox-based bias-precession-nutation matrix using the IAU Model m procedures  at time t expressed in TT Julian centuries since J2000.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nnote: Note\nThe computed matrix rotates a vector from the GCRS to the true equatorial triad of date.\n\nReferences\n\nERFA pn06 function\nERFA pn00 function\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_nutation-Tuple{FrameTransformations.Orient.IAU2006A, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_nutation","text":"orient_nutation(m::IAUModel, t::Number)\n\nCompute the nutation components in longitude and obliquity for the IAU Model m, in radians,  at time t expressed in TT Julian Centuries since J2000.\n\nNotes\n\nDue to their theoretical basis, the original developments required t expressed as TDB.  However, in practice, it is usually more convenient to use Terrestrial Time (TT) as it makes  no significant differences (< 0.01 μas) in the final result.\nFor the IAU 2006A model, the function strictly follows the SOFA implementation. It first  computes the IAU 2000A nutation, then applies adjustments for the consequences of the change  in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) for the secular  variation in the Earth's dynamical form factor J2. These corrections ensure that the IAU  2000A nutation is consistent with the IAU 2006 precession model. Please note that the  coefficients available on the IERS tables already include those corrections, and are  retrieved by multiplying the amplitudes of the SOFA nutation in longitude coefficients by  1.00000047. \nThe computation of the free-core nutation and time dependent effects are excluded from this  model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation models,  such effects must be included a-posteriori (through dX and dY) using the IERS EOP data.\nFor the IAU 2000B model, the nutation series is truncated from nearly 1400 terms to only 77,  yet it still delivers results of 1 mas accuracy at present epochs. In particular, it delivers  a pole accurate to 1 mas from 1900 to 2100 (only very occasionally just outside 1 mas).  The coefficients are taken from SOFA's implementation, which slighlty differ from those  reported in McCarthy and Luzum (2003). Comparisons with IAU 2006A show that the SOFA version  between 1995 and 2050 delivers 0.283 mas RMSE (0.994 mas in the worst case), whereas the  IERS Conventions website version delivers 0.312 RMSE (1.125 mas in the worst case).\nThe IAU 2000B model includes constant planetary bias terms that compensate for long-period  nutations. These amplitudes used in this implementation are optimised for a rigorous method,  where frame bias, precession and nutation are applied separately and in that order  (see SOFA's documentation for further insights).\nA simplified version of the Fundamental Arguments, taken from Simon et al (1994) is exploited  for IAU2000B as the error introduced is below the model accuracy ( ~0.1 mas).\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nSimon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets.\nERFA nut06a and  nut00b functions \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_obliquity-Tuple{FrameTransformations.Orient.IAU2006Model, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_obliquity","text":"orient_obliquity(m::IAUModel, t::Number)\n\nCompute the mean obliquity of the ecliptic at epoch, in radians, at time t expressed  in TT Julian centuries since J2000. \n\nnote: Note\nThis function is implemented only for IAU1980 and IAU2006 models. IAU 2000 Models  implement proper precession-rate corrections to the IAU1980 mean obliquity. \n\nReferences\n\nERFA obl80 and  obl06 functions.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","page":"Orient","title":"FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","text":"orient_rot12_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its time derivatives up to order 3 at  time t expressed as TT seconds since J2000, according to the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot12_itrf_to_gcrf-2","page":"Orient","title":"FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","text":"orient_rot12_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0, LOD=0.0)\n\nCompute the rotation matrix from ITRF to GCRF and its derivatives up to order 3, according  to the IAU Model m, at time tt and ut1 expressed in TT seconds and UT1 days since  J2000, respectively. \n\nThis function has been implemented for IAU2000, IAU2006 and CPN models.\n\nnote: Note\nAll the input quantities xₚ, yₚ, dX and dY must be expressed in radians\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_icrf_to_mememod-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_icrf_to_mememod","text":"orient_rot3_icrf_to_mememod(t::Number)\n\nCompute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Mean Equinox Mean Equator of Date at time t, expressed in TT seconds since J2000.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421-Tuple{SMDInterfacesUtils.Interfaces.Ephemeris.AbstractEphemerisProvider, Epoch}","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa421","text":"orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, ep::Epoch)\n\nCompute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the input  epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421-Tuple{SMDInterfacesUtils.Interfaces.Ephemeris.AbstractEphemerisProvider, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa421","text":"orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, t::Number)\n\nCompute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the given  input time t, expressed in seconds since J2000. \n\nwarning: Warning\nThis function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440-Tuple{SMDInterfacesUtils.Interfaces.Ephemeris.AbstractEphemerisProvider, Epoch}","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa440","text":"orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, ep::Epoch)\n\nCompute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the input  epoch ep.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440-Tuple{SMDInterfacesUtils.Interfaces.Ephemeris.AbstractEphemerisProvider, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa440","text":"orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, t::Number)\n\nCompute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the given  input time t, expressed in seconds since J2000. \n\nwarning: Warning\nThis function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions.\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","text":"orient_rot3_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0)\n\nCompute the rotation matrix from ITRF to GCRF according to the IAU Model m, at time tt  and ut1 expressed in TT seconds and UT1 days since J2000, respectively.  \n\nThis function has been implemented for IAU2000, IAU2006 and CPN models.\n\nnote: Note\nAll the input quantities xₚ, yₚ, dX and dY must be expressed in radians\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf-Tuple{Union{FrameTransformations.Orient.IAU2000A, FrameTransformations.Orient.IAU2006A}, Number}","page":"Orient","title":"FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","text":"orient_rot3_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF at time t expressed as  TT seconds since J2000, according to the IAU Model m, as follows:\n\nIAU2000A: the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2000A model.\nIAU2000B: only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation    matrix is computed following the IAU 2000 model but with truncated expressions for the    nutation corrections. \nIAU2006A: the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2006/2000A model.\nIAU2006B: only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation   matrix is computed following the IAU 2006A model but with truncated expressions for the    nutation corrections. \nCPNc: a concise model with a cut-off at 2.5 mas of the X and Y series, delivering a    worst-case accuracy of about 15 mas between 1995-2050. It does not take into account the    Free Core Nutation (~0.2 mas). \nCPNd: an extremely concise formulation with an accuracy of about 1 arcsec between 1995    and 2050. It neglects polar-motion (~0.25 arcsec), the FCN corrections and the CIO locator. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","page":"Orient","title":"FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","text":"orient_rot6_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its derivative at time t  expressed as TT seconds since J2000, according to the the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot6_itrf_to_gcrf-2","page":"Orient","title":"FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","text":"orient_rot6_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0, LOD=0.0)\n\nCompute the rotation matrix from ITRF to GCRF and its derivative, according to the IAU Model  m, at time tt and ut1 expressed in TT seconds and UT1 days since J2000,  respectively. \n\nThis function has been implemented for IAU2000, IAU2006 and CPN models.\n\nnote: Note\nAll the input quantities xₚ, yₚ, dX and dY must be expressed in radians\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","page":"Orient","title":"FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","text":"orient_rot9_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its time derivatives up to order 2 at  time t expressed as TT seconds since J2000, according to the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.orient_rot9_itrf_to_gcrf-2","page":"Orient","title":"FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","text":"orient_rot9_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0, LOD=0.0)\n\nCompute the rotation matrix from ITRF to GCRF and its derivatives up to order 2, according  to the IAU Model m, at time tt and ut1 expressed in TT seconds and UT1 days since  J2000, respectively. \n\nThis function has been implemented for IAU2000, IAU2006 and CPN models.\n\nnote: Note\nAll the input quantities xₚ, yₚ, dX and dY must be expressed in radians\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient/#FrameTransformations.Orient.polar_motion-Tuple{Number, Number, Number}","page":"Orient","title":"FrameTransformations.Orient.polar_motion","text":"polar_motion(t::Number, xₚ::Number, yₚ::Number)\n\nCompute the Polar Motion rotation matrix from ITRF to TIRS, according to the  IERS 2010 Conventions, at time t expressed in TT Julian centuries since J2000.  The function requires xp and yp, the Celestial Intermediate Pole (CIP) coordinates with  respect to the International Celestial Reference Frame (ITFR).\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.precession_angles-Tuple{FrameTransformations.Orient.IAU1980Model, Number}","page":"Orient","title":"FrameTransformations.Orient.precession_angles","text":"precession_angles(m::IAU1980Model, t::Number)\n\nCompute the precession angles from Lieske et al. 1977 model, in radians, at time t  expressed in TT Julian centuries since J2000.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.precession_rate-Tuple{FrameTransformations.Orient.IAU2000Model, Number}","page":"Orient","title":"FrameTransformations.Orient.precession_rate","text":"precession_rate(m::IAU2000Model, t::Number)\n\nCompute the precession-rate part of the IAU 2000 precession-nutation models, in radians, at  time t expressed as TT Julian centuries since J2000.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.tio_locator-Tuple{Number}","page":"Orient","title":"FrameTransformations.Orient.tio_locator","text":"tio_locator(t::Number)\n\nCompute the TIO locator s' at date, positioning the Terrestrial Intermediate Origin on  the equator of the Celestial Intermediate Pole (CIP) at time t expressed as TT Julian  centuries since J2000. \n\nThis function approximates the unpredictable motion of the TIO locator s' with its secular  drift of ~0.47 μas/century. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nLambert, S. and Bizouard C. (2002), Positioning the Terrestrial Ephemeris Origin in the  Terrestrial Reference Frame, DOI: 10.1051/0004-6361:20021139\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#FrameTransformations.Orient.xys2m-Tuple{Number, Number, Number}","page":"Orient","title":"FrameTransformations.Orient.xys2m","text":"xys2m(x::Number, y::Number, s::Number)\n\nCompute the Intermediate-to-Celestial matrix given the CIP x, y' coordinates and the CIO  locators`, all in radians.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"method"},{"location":"Modules/orient/#Macros","page":"Orient","title":"Macros","text":"","category":"section"},{"location":"Modules/orient/","page":"Orient","title":"Orient","text":"Modules = [Orient]\nOrder = [:macro]","category":"page"},{"location":"Modules/orient/#Constants","page":"Orient","title":"Constants","text":"","category":"section"},{"location":"Modules/orient/","page":"Orient","title":"Orient","text":"Modules = [Orient]\nOrder = [:constant]","category":"page"},{"location":"Modules/orient/#FrameTransformations.Orient.AXESID_ECLIPJ2000","page":"Orient","title":"FrameTransformations.Orient.AXESID_ECLIPJ2000","text":"AXESID_ECLIPJ2000\n\nNAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECLIPJ2000) \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.AXESID_ICRF","page":"Orient","title":"FrameTransformations.Orient.AXESID_ICRF","text":"AXESID_ICRF\n\nNAIF Axes ID for the International Celestial Reference Frame (ICRF)\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.AXESID_MEME2000","page":"Orient","title":"FrameTransformations.Orient.AXESID_MEME2000","text":"AXESID_MEME2000\n\nAxes ID for the Mean Dynamical Equator and Equinox of J2000.0. \n\nnote: Note\nIn SPICE the J2000 and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the MEME2000 axes. 22 has been chosen because it is the  first unassigned axes ID among the built-in SPICE frames. \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.AXESID_MOONME_DE421","page":"Orient","title":"FrameTransformations.Orient.AXESID_MOONME_DE421","text":"AXESID_MOONME_DE421\n\nNAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.AXESID_MOONPA_DE421","page":"Orient","title":"FrameTransformations.Orient.AXESID_MOONPA_DE421","text":"AXESID_MOONPA_DE421\n\nNAIF axes id for the DE421 Moon Principal Axes (PA421).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.AXESID_MOONPA_DE440","page":"Orient","title":"FrameTransformations.Orient.AXESID_MOONPA_DE440","text":"AXESID_MOONPA_DE440\n\nNAIF Axes id for the DE440 Moon Principal Axes (PA440).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.CPNc","page":"Orient","title":"FrameTransformations.Orient.CPNc","text":"CPNc\n\nThe singleton instance of type CPNC, representing the concise CPNc from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few mas.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.CPNd","page":"Orient","title":"FrameTransformations.Orient.CPNd","text":"CPNd\n\nThe singleton instance of type CPND, representing the concise CPNd from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few arcseconds.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","page":"Orient","title":"FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","text":"DCM_ICRF_TO_ECLIPJ2000\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) to the  Mean Ecliptic Equinox of J2000 (ECLIPJ2000).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS","page":"Orient","title":"FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS","text":"DCM_ICRF_TO_J2000_BIAS\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) and the  Mean Dynamical Equator and Equinox of J2000.0 (MEME2000).\n\nnote: Note\nThe frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond.\n\nReferences\n\nHilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI: 10.1051/0004-6361:20031552\nSOFA docs\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000","page":"Orient","title":"FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000","text":"DCM_J2000_TO_ECLIPJ2000\n\nDCM for the rotation from the Mean Dynamical Equator of J2000 (MEME2000) to the  Mean Ecliptic Equinox. This corresponds to the transformation J2000 -> ECLIPJ2000  in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","page":"Orient","title":"FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","text":"DCM_MOON_PA421_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 421 (PA421) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nJ. G. Williams et al. (2008), DE421 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE421 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","page":"Orient","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","text":"DCM_MOON_PA430_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nFolkner M. William et al. (2014), The Planetary and Lunar EphemeridesDE430 and DE431\nJ. G. Williams et al. (2013), DE430 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE430 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","page":"Orient","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","text":"DCM_MOON_PA430_TO_ME430\n\nDCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE430 (ME430) axes.\n\nReferences\n\nFolkner M. William et al. (2014), The Planetary and Lunar EphemeridesDE430 and DE431\nJ. G. Williams et al. (2013), DE430 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE430 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","page":"Orient","title":"FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","text":"DCM_MOON_PA440_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 440 (PA440) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nPark, S. R. et al. (2021), The JPL Planetary and Lunar Ephemerides DE440 and DE441,  DOI: 10.3847/1538-3881/abd414 \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.IERS_EOP","page":"Orient","title":"FrameTransformations.Orient.IERS_EOP","text":"IERS_EOP\n\nEarth orientation parameters: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values at 1-day intervals)  with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014.\n\nEOP 14 C04 is updated two times per week.\n\nHere the files are downloaded using the RemoteFile package with weekly updates.\n\nSee also: get_iers_eop\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.iau1980","page":"Orient","title":"FrameTransformations.Orient.iau1980","text":"iau1980\n\nThe singleton instance of type IAU1980, representing the IAU 1980 family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.iau2000a","page":"Orient","title":"FrameTransformations.Orient.iau2000a","text":"iau2000a\n\nThe singleton instance of type IAU2006a, representing the IAU 2000B family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.iau2000b","page":"Orient","title":"FrameTransformations.Orient.iau2000b","text":"iau2000b\n\nThe singleton instance of type IAU2006a, representing the IAU 2000B family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.iau2006a","page":"Orient","title":"FrameTransformations.Orient.iau2006a","text":"iau2006a\n\nThe singleton instance of type IAU2006a, representing the IAU 2006A family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient/#FrameTransformations.Orient.iau2006b","page":"Orient","title":"FrameTransformations.Orient.iau2006b","text":"iau2006b\n\nThe singleton instance of type IAU2006B, representing the IAU 2006B family of models.\n\nnote: Note\nThis is not an official IERS model.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/frames/#basic_frames_api","page":"Frames","title":"API","text":"","category":"section"},{"location":"Modules/frames/#Types","page":"Frames","title":"Types","text":"","category":"section"},{"location":"Modules/frames/","page":"Frames","title":"Frames","text":"Modules = [Frames]\nOrder = [:type]","category":"page"},{"location":"Modules/frames/#FrameTransformations.Frames.AbstractFrameAxes","page":"Frames","title":"FrameTransformations.Frames.AbstractFrameAxes","text":"AbstractFrameAxes\n\nAbstract type for all reference frames axes.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.AbstractFramePoint","page":"Frames","title":"FrameTransformations.Frames.AbstractFramePoint","text":"AbstractFramePoint\n\nAbstract type for all reference frames points.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.ComputableAxesProperties","page":"Frames","title":"FrameTransformations.Frames.ComputableAxesProperties","text":"ComputableAxesProperties\n\nStore the properties required to retrieve all the vectors required by   a computable set of axes. \n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.ComputableAxesVector","page":"Frames","title":"FrameTransformations.Frames.ComputableAxesVector","text":"ComputableAxesVector(from, to, order::Int)\n\nStore the properties required to retrieve the i-th order components of a  desired vector. Arguments from and to are the NAIFIDs or AbstractFramePoint instances  that define the observer and target points.\n\nOnly orders between 1 and 3 are supported.\n\nExample\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> ComputableAxesVector(SSB, Sun, 1)\nComputableAxesVector(0, 10, 1)\n\njulia> ComputableAxesVector(0, 10, 1)\nComputableAxesVector(0, 10, 1)\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.FrameAxesNode","page":"Frames","title":"FrameTransformations.Frames.FrameAxesNode","text":"FrameAxesNode{O, T, N} <: AbstractGraphNode\n\nDefine a set of axes.\n\nFields\n\nname – axes name \nclass – Symbol representing the class of the axes \nid – axes ID (equivalent of NAIFId for axes)\nparentid – ID of the parent axes \ncomp – properties for computable axes \nR – vector storing rotation matrices \nepochs – vector storing the epochs associated to R\nnzo – last order at which R has been computed \nf – FrameAxesFunctions container \nangles – vector storing the libration angles retrived from ephemerides\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.FramePointNode","page":"Frames","title":"FrameTransformations.Frames.FramePointNode","text":"FramePointNode{O, T, N} <: AbstractGraphNode\n\nDefine a frame system point.\n\nFields\n\nname – point name \nclass – Symbol representing the class of the point \naxesid – ID of the axes in which the point coordinates are expressed \nparentid – NAIF ID of the parent point \nNAIFId – NAIF ID of the point\nstv – vector storing the point state vectors\nepochs – vector storing the epochs associated to stv\nnzo – last order at which stv has been computed \nf – FramePointFunctions container \n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.FrameSystem","page":"Frames","title":"FrameTransformations.Frames.FrameSystem","text":"FrameSystem{O, T, S, E}\n\nA FrameSystem instance manages a collection of user-defined FramePointNode and  FrameAxesNode objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order O, the outputs  datatype T and an AbstractTimeScale instance S. Additionally, an AbstractEphemerisProvider  instance E can be provided to compute transformations that require ephemeris data. \n\nThe following transformation orders are accepted: \n\n1: position \n2: position and velocity \n3: position, velocity and acceleration\n4: position, velocity, acceleration and jerk\n\nBy specifying the maximum transformation the FrameSystem memory usage and performance can  be optimised and tailored to the user's needs.\n\n\n\nFrameSystem{O, T}()\n\nCreate a FrameSystem object of order O and datatype T. The BarycentricDynamicalTime  is automatically assigned as the default time scale. The resulting object is constructed  with a NullEphemerisProvider, which does not allow the computation of transformation that  involve ephemeris files.\n\nExamples\n\njulia> F = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> rotation6(F, ICRF, ECLIPJ2000, 0.0)\nRotation{2, Float64}\n[...]\n\njulia> rotation9(F, ICRF, ECLIPJ2000, 0.0)\nERROR: Insufficient frame system order: transformation requires at least order 3.\n\n\n\n\nFrameSystem{O, T, S}()\n\nCreate a FrameSystem object of order O, datatype T and time scale S. The resulting  object is constructed with a NullEphemerisProvider, which does not allow the computation  of transformation that involve ephemeris files.\n\nExamples\n\njulia> F = FrameSystem{1, Float64, TerrestrialTime}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> ep_tt = Epoch(\"2023-02-10T12:00:00 TT\")\n2023-02-10T12:00:00.000 TT\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tt)\nRotation{1,Float64}([...])\n\njulia> ep_tdb = Epoch(\"2023-02-10T12:00:00 TDB\")\n2023-02-10T12:00:00.000 TDB\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tdb)\nERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.\n[...]\n\n\n\nFrameSystem{O, T}(eph::AbstractEphemerisProvider)\n\nCreate a FrameSystem object of order O and datatype T by providing an instance of an  AbstractEphemerisProvider subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in eph. This constructor shall be used when the user desires  to compute transformations that involve ephemeris data. \n\nnote: Note\nAll the kernels that will be used must be loaded within eph. Once the FrameSystem  has been created, no additional kernel can be added nor removed.\n\nExamples\n\njulia> eph = CalcephProvider(DE440_KERNEL_PATH)\nCalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0))\n\njulia> F = FrameSystem{2, Float64}(eph)\nFrameSystem{2, Float64, BarycentricDynamicalTime, CalcephProvider}(\n  eph: CalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0)),\n  points: EMPTY\n  axes: EMPTY\n)\n\nSee also\n\nSee also add_axes_inertial!, add_point_root!, vector3 and rotation3\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#FrameTransformations.Frames.Rotation","page":"Frames","title":"FrameTransformations.Frames.Rotation","text":"Rotation{S, N}\n\nA container to efficiently compute S-th order rotation matrices of type N between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the (S-1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later.\n\nThe rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object R, constructed from the  DCM A and its time derivatives δA and δ²A rotates a vector v = [p, v, a] as: \n\n̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a]\n\nA Rotation object R call always be converted to a SMatrix or a MMatrix by invoking  the proper constructor. \n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\n\n\nRotation(dcms::DCM...)\n\nCreate a Rotation object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64}\n\n\n\nRotation{S}(u::UniformScaling{N}) where {S, N}\nRotation{S, N}(u::UniformScaling) where {S, N}\n\nCreate an S-order identity Rotation object of type N with identity position rotation  and null time derivatives.\n\nExamples\n\njulia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],))\n\n\n\nRotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\n\nTransform a Rotation object of order S2 to order S1. This conversion is only possible  if S1 < S2.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1)\nERROR: DimensionMismatch: Cannot convert a `Rotation` of order 2 to order 3\n[...]\n\n\n\nRotation(m::DCM{N}, ω::AbstractVector) where N\n\nCreate a 2nd order Rotation object of type N to rotate between two set of axes a and  b from a Direction Cosine Matrix (DCM) and the angular velocity vector ω of b with  respect to a, expressed in b\n\n\n\nRotation{S}(dcms::DCM...) where S\n\nCreate a Rotation object of order S. If the number of dcms is smaller than S, the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than  S, only the first S DCMs are used. \n\nwarning: Warning\nUsage of this constructor is not recommended as it may yield unexpected results to  unexperienced users. \n\nSee also\n\nSee also rotation3, rotation6 and rotation9.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames/#Functions","page":"Frames","title":"Functions","text":"","category":"section"},{"location":"Modules/frames/","page":"Frames","title":"Frames","text":"Modules = [Frames]\nOrder = [:function]","category":"page"},{"location":"Modules/frames/#Base.inv-Tuple{Rotation}","page":"Frames","title":"Base.inv","text":"inv(rot::Rotation)\n\nCompute the invese of the rotation object rot. The operation is efficiently performed by  taking the transpose of each rotation matrix within rot.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames._get_comp_axes_vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, ComputableAxesVector, Int64, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames._get_comp_axes_vector3","text":"_get_comp_axes_vector3(frame, v, axesid, t)\n\nCompute a 3-elements vector in the desired axes at the given time  between two points of the frame system \n\nThe returned vector depends on the order in v as follows: \n\n1: position\n2: velocity\n3: acceleration \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames._two_vectors_basis-Tuple{AbstractVector, AbstractVector, Symbol, Function}","page":"Frames","title":"FrameTransformations.Frames._two_vectors_basis","text":"_two_vectors_basis(a, b, seq::Symbol, fc::Function)\n\nGenerate a 3D right-handed orthogonal vector basis and/or its time derivatives from the  vectors a and b, according to the directions specified in seq and the input cross  function fc.\n\nThe accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\nThe standard basis, its 1st, 2nd-order and 3rd order time derivatives can be computed by  passing cross, cross6, cross9 or cross12 to fc. The returned vectors will have  a length of 3, 6 or 9, respectively.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames._two_vectors_to_rot12-Tuple{AbstractVector, AbstractVector, Symbol}","page":"Frames","title":"FrameTransformations.Frames._two_vectors_to_rot12","text":"_two_vectors_to_rot12(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and its 1st, 2nd and 3r-order time-derivatives, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δdcm for more information. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames._two_vectors_to_rot9-Tuple{AbstractVector, AbstractVector, Symbol}","page":"Frames","title":"FrameTransformations.Frames._two_vectors_to_rot9","text":"_two_vectors_to_rot9(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and its 1st and 2nd-order time-derivatives, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δdcm for more information. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames._twovectors_to_dcm-Tuple{AbstractVector, AbstractVector, Symbol, Function, Function}","page":"Frames","title":"FrameTransformations.Frames._twovectors_to_dcm","text":"_twovectors_to_dcm(a, b, seq::Symbol, fc::Function, fn::Function)\n\nGenerate a direction cosine matrix and/or its time derivatives from the vectors a and b,  according to the directions specifeid in seq. \n\nNotes\n\nfc and fn are used to control the derivative order. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_bci2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, AbstractDict, FrameTransformations.Frames.AbstractFramePoint, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}","page":"Frames","title":"FrameTransformations.Frames.add_axes_bci2000!","text":"add_axes_bci2000!(frames::FrameSystem{O, T}, \n    data::AbstractDict, center::AbstractFramePoint, \n    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O}\n\nInsert Body-Centered Inertial (BCI) axes at J2000 relative to the body center to the  frames system.\n\nInput/s\n\nframes - The frame system to which the new frame will be added.\ndata - A dictionary containing a parsed TPC file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data.\ncenter: The center point of the new axes.\naxes: The new axes to be added to the frame system.\nparent: The parent axes of the new ones.\n\nwarning: Warning\nThe parent set of axes must be the International Celestial Reference Frame (ICRF).  If the parent set of axes is not ICRF, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_bcrtod!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, AbstractDict, FrameTransformations.Frames.AbstractFramePoint, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}","page":"Frames","title":"FrameTransformations.Frames.add_axes_bcrtod!","text":"add_axes_bcrtod!(frames::FrameSystem{O, T}, \n    data::AbstractDict, center::AbstractFramePoint, \n    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O}\n\nInsert a Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the frames system.\n\nInput/s\n\nframes - The frame system to which the new frame will be added.\ndata - A dictionary containing a parsed TPC file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data.\ncenter: The center point of the new axes.\naxes: The new axes to be added to the frame system.\nparent: The parent axes of the new ones.\n\nnote: Note\nThe axes constructed here corresponds to the SPICE IAU_<BODY_NAME> frames. \n\nwarning: Warning\nThe parent set of axes must be the International Celestial Reference Frame (ICRF).  If the parent set of axes is not ICRF, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_computable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, ComputableAxesVector, ComputableAxesVector, Symbol}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_axes_computable!","text":"add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol)\n\nAdd axes as a set of computable axes to frames. Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE's parameterized two-vector frames. \n\nThese axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis. \n\nThe primary and secondary vectors, v1 and v2 are instances of ComputableAxesVector,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration). \n\nFor example, to define a primary vector that is parallel to the Sun's (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0), v1 must be set as:  v1 = ComputableAxesVector(10, 0, 1).\n\nseq is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are: :XY, :YX, :XZ, :ZX, :YZ and :ZY. \n\nGiven a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf's nadir direction and  velocity direction define the axes orientation.  \n\nnote: Note\nRegardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to parent.\n\nExamples\n\njulia> eph = CalcephProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{4, Float64}(eph);\n\njulia> @point SSB 0 SolarySystemBarycenter \n\njulia> @point Sun 10 \n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun, SSB)\n\njulia> @axes SunFrame 2\n\njulia> v1 = ComputableAxesVector(10, 0, 1)\nComputableAxesVector(10, 0, 1)\n\njulia> v2 = ComputableAxesVector(10, 0, 2)\nComputableAxesVector(10, 0, 2)\n\njulia> add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY)\n\nSee also\n\nSee also ComputableAxesVector, add_axes_fixedoffset!, add_axes_inertial!  and add_axes_computable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_eclipj2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Orient.IAUModel}} where {T, O}","page":"Frames","title":"FrameTransformations.Frames.add_axes_eclipj2000!","text":"add_axes_eclipj2000!(frames, axes, parent::AbstractFrameAxes, iau_model::IAUModel=iau1980)\n\nAdd axes as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to frames. The obliquity of the ecliptic is computed using the IAU Model iau_model.\n\nThe admissed parent set of axes are the following: \n\nICRF: for the International Celestial Reference Frame, with ID = 1\nMEME2000: the Mean Earth/Moon Ephemeris of J2000, with ID = 22\n\nwarning: Warning\nIf the name (or the axes ID) of the parent set of axes is neither ICRF (ID = 1) nor  MEME2000 (ID = 22), an error is thrown. \n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes ECLIPJ2000 17 EclipticEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF)\n\nSee also\n\nSee also add_axes_inertial! and Orient.DCM_ICRF_TO_J2000_BIAS\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Symbol}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_axes_ephemeris!","text":"add_axes_ephemeris!(frames, axes, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd axes as a set of ephemeris axes to frames. The orientation of these axes is computed  with a series of 3 rotations specified by rot_seq. The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in frames. The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. This function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation.  The possible rot_seq values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX,  :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ.\n\nAlternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives. \n\nThis operation is only possible if the ephemeris kernels loaded within frames contain  orientation data for the AXES ID associated to axes. An error is returned if the parent  axes ID is yet to be added to frames.\n\nwarning: Warning\nIt is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels.\n\nSee also\n\nSee also ComputableAxesVector, add_axes_fixedoffset!, add_axes_inertial!  and add_axes_computable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_fixedoffset!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, Any, ReferenceFrameRotations.DCM{T}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_axes_fixedoffset!","text":"add_axes_fixedoffset!(frames::FrameSystem{T}, axes, parent, dcm::DCM{T}) where T\n\nAdd axes as a set of fixed offset axes to frames. Fixed offset axes have a constant  orientation with respect to their parent axes, represented by dcm, a Direction Cosine Matrix (DCM).\n\n\n\nadd_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DMC{T}) where {T}\n\nAdd new axes name with id axesid to frames with a fixed-offset from parentid.  Low-level function.\n\nnote: Note\nWhile inertial axes do not rotate with respect to the star background, fixed offset axes are only  constant with respect to their parent axes, but might be rotating with respect to some other  inertial axes.\n\nExamples\n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z))\n\nSee also\n\nSee also add_axes_rotating!, add_axes_inertial! and add_axes_computable! \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_inertial!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_axes_inertial!","text":"add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing)\n\nAdd axes as a set of inertial axes to frames. Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added, parent and dcm  become mandatory fields.\n\n\n\nadd_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing)\n\nAdd new axes name with id axesid to frames. Low-level function.\n\nnote: Note\nThe parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000)\nERROR: A set of parent axes for ECLIPJ2000 is required\n[...]\n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z))\n\nSee also\n\nSee also add_axes_rotating!, add_axes_fixedoffset! and add_axes_computable! \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_itrf!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Orient.IAUModel}} where {T, O}","page":"Frames","title":"FrameTransformations.Frames.add_axes_itrf!","text":"add_axes_itrf!(frames, axes, parent, model::Orient.IAU2006Model=Orient.iau2006b)\n\nAdd axes as a set of axes representing the International Terrestrial Reference Frame (ITRF) to frames. Only the :ICRF and :GCRF are accepted as parent axes. Use the model argument  to specify which IAU model model should be used for the computations. The default is set to  iau2006b.\n\nSee also\n\nSee also orient_rot3_itrf_to_gcrf\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_me421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.add_axes_me421!","text":"add_axes_me421!(frames, axes, parent)\n\nAdd axes as fixed offset axes representing the DE421 Moon's Mean Earth/Mean Rotation (ME)  to frames.\n\nThe parent set of axes can be either the DE440 Principal Axes (PA440) or the DE421  Principal Axes (PA421), otherwise an error is thrown. Depending on that, the relative axes  orientation will be automatically selected by this function. \n\nSee also\n\nSee also [`add_axes_pa440!`](@ref), and [`add_axes_pa421!`](@ref), \n[`Orient.DCM_MOON_PA421_TO_ME421`](@ref) and [`Orient.DCM_MOON_PA421_TO_ME421`](@ref),\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_meme2000!-Union{Tuple{O}, Tuple{T}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}} where {T, O}","page":"Frames","title":"FrameTransformations.Frames.add_axes_meme2000!","text":"add_axes_meme2000!(frames::, axes, parent::AbstractFrameAxes)\n\nAdd axes as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to frames. \n\nwarning: Warning\nThe name (or the axes ID) of the parent set of axes must be ICRF (i.e., the International  Celestial Reference Frame, ID = 1), or the ECLIPJ2000 (i.e., the Ecliptic Equinox of 7 J2000, ID = 17), otherwise and error is thrown.\n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_meme2000!(FRAMES, MEME2000, ICRF)\n\nSee also\n\nSee also add_axes_inertial! and Orient.DCM_ICRF_TO_J2000_BIAS\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_mememod!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.add_axes_mememod!","text":"add_axes_mememod!(frames, axes, parent::AbstractFrameAxes, model::IAU2006Model=iau2006b)\n\nAdd axes as a set of projected axes representing the Mean of Date Ecliptic Equinox to  frames. \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe name of the parent set of axes must be the ICRF or have ID = 1 (i.e., the  International Celestial Reference Frame), otherwise an error is thrown. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_pa421!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.add_axes_pa421!","text":"add_axes_pa421!(frames, axes, parent)\n\nAdd axes as a set of ephemeris axes representing the DE421 Moon's Principal Axes (PA) to  frames. The libration angles are extracted from the ephemeris kernels loaded within frames,  an error is thrown if such orientation data is not available. \n\nThe parent set of axes must be named ICRF or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006).\n\nSee also\n\nSee also [`Orient.AXESID_MOONPA_DE421`](@ref), [`Orient.orient_icrf_to_pa421`](@ref), \n[`add_axes_pa440!`](@ref), and [`add_axes_me421!`](@ref)\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_pa440!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.add_axes_pa440!","text":"add_axes_pa440!(frames, axes, parent)\n\nAdd axes as a set of ephemeris axes representing the DE440 Moon's Principal Axes (PA) to  frames. The libration angles are extracted from the ephemeris kernels loaded within frames,  an error is thrown if such orientation data is not available. \n\nThe parent set of axes must be named ICRF or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008).\n\nSee also\n\nSee also Orient.AXESID_MOONPA_DE440, Orient.orient_rot3_icrf_to_pa440,  add_axes_pa421!, and add_axes_me421!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_projected!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_axes_projected!","text":"add_axes_projected!(frames, axes, parent, fun)\n\nAdd axes as a set of projected axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nProjected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time).\n\nwarning: Warning\nIt is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_rotating!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Vararg{Any, 5}}, Tuple{FrameSystem{O, T}, Vararg{Any, 6}}, Tuple{FrameSystem{O, T}, Vararg{Any, 7}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_axes_rotating!","text":"add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) where T\n\nAdd axes as a set of rotating axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a Direction Cosine Matrix (DCM).\nδfun: return the DCM and its 1st order time derivative.\nδ²fun: return the DCM and its 1st and 2nd order time derivatives\nδ³fun: return the DCM and its 1st, 2nd and 3rd order time derivatives\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed via automatic differentiation.\n\nwarning: Warning\nIt is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\nExamples\n\njulia> FRAMES = FrameSystem{3, Float64}();\n\njulia> @axes Inertial 1\n\njulia> add_axes_inertial!(FRAMES, Inertial)\n\njulia> @axes Synodic 2 \n\njulia> fun(t) = angle_to_dcm(t, :Z);\n\njulia> add_axes_rotating!(FRAMES, Synodic, Inertial, fun)\n\njulia> R = rotation6(FRAMES, Inertial, Synodic, π/6);\n\njulia> R[1]\nDCM{Float64}:\n  0.866025  0.5       0.0\n -0.5       0.866025  0.0\n  0.0       0.0       1.0\n\njulia> R[2]\nDCM{Float64}:\n -0.5        0.866025  0.0\n -0.866025  -0.5       0.0\n  0.0        0.0       0.0\n\nSee also\n\nSee also add_axes_fixedoffset!, add_axes_inertial! and add_axes_computable! \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_axes_topocentric!-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes, Number, Number, Symbol, Any}","page":"Frames","title":"FrameTransformations.Frames.add_axes_topocentric!","text":"add_axes_topocentric!(frames, axes, λ::Number, ϕ::Number, type::Symbol, parent)\n\nAdd axes as a set of fixed-offset topocentric axes to frames. The orientation relative  to the parent axes parent is defined throuh the longitude λ, the geodetic latitude ϕ  and the type type, which may be any of the following: \n\n:NED (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir.\n:SEZ (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith.\n:ENU (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith. \n\nwarning: Warning\nThe parent axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong. \n\nSee also\n\nSee also add_axes_fixedoffset! and add_point_surface!.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_dynamical!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, Any, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 4}}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Vararg{Any, 5}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_point_dynamical!","text":"add_point_dynamical!(frames, point, parent, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd point as a time point to frames. The state vector for these points depends only on  time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a 3-elements vector: position\nδfun: return a 6-elements vector: position and velocity\nδ²fun: return a 9-elements vector: position, velocity and acceleration\nδ³fun: return a 12-elements vector: position, velocity, acceleration and jerk\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed with automatic differentiation. \n\nwarning: Warning\nIt is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions. \n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}()\n\njulia> @axes ICRF 1 \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> @point Satellite 1 \n\njulia> satellite_pos(t::T) where T = [cos(t), sin(t), 0]\n\njulia> add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, π/6)\n6-element SVector{6, Float64} with indices SOneTo(6):\n  0.8660254037844387\n  0.49999999999999994\n  0.0\n -0.49999999999999994\n  0.8660254037844387\n  0.0\n\nSee also\n\nSee also add_point_root!, add_point_ephemeris!,add_point_fixed! and add_point_updatable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_ephemeris!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any, Any}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_point_ephemeris!","text":"add_point_ephemeris!(frames, point, parent=nothing)\n\nAdd point as an ephemeris point to frames. This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). If a parent point is not specified, it will automatically be assigned to the point with respect to which the ephemeris  data is written in the kernels.\n\nInputs\n\nframes – FrameSystem object \npoint – FramePointNode instance \nparent – FramePointNode parent instance \n\n\n\nadd_point_ephemeris!(frames, name::Symbol, naifid::Int, parentid::Int=nothing, axes=nothing)\n\nAdd a new point called name and with id naifid to frames. If a parentid is not specified, it will be automatically assigned depending on the ephemeris kernels.\n\nInputs\n\nframes – FrameSystem object \nname::Symbol – name of the point \nnaifid::Int – NAIFId associated to the point \nparentid::Int – NAIFId associated to the parent point, default is nothing\naxes – Id associated to the axes in which the states are expressed, default nothing    (taken automatically from the ephemeris files).\n\nEphemeris points only accept as parent points root-points or other ephemeris points.\n\nNotes\n\nThis operation is only possible if the ephemeris kernels loaded within frames contain  data for the NAIF ID associated to point and to its parent. \n\nThe axes in which the state-vector is expressed are taken from the ephemeris data: an error  is returned if the axes ID is yet to be added to frames.\n\nwarning: Warning\nIt is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels.\n\nExamples\n\njulia> eph = CalcephProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{2, Float64}(eph);\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @point Jupiter 599\n\njulia> add_point_ephemeris!(FRAMES, Jupiter)\nERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.\n[...]\n\nSee also\n\nSee also add_point_root!, add_point_fixed!, add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_fixed!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Int64, Any, AbstractVector{T}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_point_fixed!","text":"add_point_fixed!(frames, point, parent, axes, offset::AbstractVector)\n\nAdd point as a fixed point to frames. Fixed points are those whose positions have a  constant offset with respect their parent points in the given set of axes. Thus, points  eligible for this class must have null velocity and acceleration with respect to parent.\n\nInputs\n\nframes – FrameSystem object \npoint – FramePointNode instance \nparent – FramePointNode parent instance \naxes – FrameAxesNode instance \noffset – Offset with respect to the parent\n\n\n\nadd_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector)\n\nAdd a new fixed point called name with id pointid and parent parentid in the axes  axesid to frames.\n\nframes – FrameSystem object \nname::Symbol – name of the point \nnaifid::Int – NAIFId associated to the point \nparentid::Int – NAIFId associated to the parent point, default is nothing\naxesid::Int – Id associated to the axes in which the states are expressed, default nothing    (taken automatically from the ephemeris files).\noffset – Offset with respect to the parent\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes SF -3000 SatelliteFrame\n\njulia> add_axes_inertial!(FRAMES, SF)\n\njulia> @point SC -10000 Spacecraft\n\njulia> @point SolarArrayCenter -10001\n\njulia> add_point_root!(FRAMES, SC, SF)\n\njulia> sa_offset = [0.10, 0.15, 0.30];\n\njulia> add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset)\n\nSee also\n\nSee also add_point_root!, add_point_ephemeris!,  add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_root!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Any}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_point_root!","text":"add_point_root!(frames, point, axes)\n\nAdd point as a root point to frames to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.).\n\nInputs\n\nframes – FrameSystem object \npoint – Target point instance\naxes – Id or instance of the axes where the point state-vector is expressed. \n\n\n\nadd_point_root!(frames, name, id, axes)\n\nAdd a root point fo frames to initialize the points graphs. \n\nInputs\n\nframes – FrameSystem object \nname – Name of the root point \nid – Id (NAIFId) of the root point \naxes – Id or instance of the axes where the point state-vector is expressed.\n\nnote: Note\nThis operation can be performed only once per FrameSystem object: multiple root  points in the same graph are both inadmissible and meaningless.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> @point Sun 10\n\njulia> add_point_root!(FRAMES, Sun, ICRF)\nERROR: ArgumentError: A root-point is already registed in the given FrameSystem.\n[...]\n\nSee also\n\nSee also add_point_ephemeris!, add_point_fixed!, add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_surface!","page":"Frames","title":"FrameTransformations.Frames.add_point_surface!","text":"add_point_surface!(frames, point, parent, axes, pck, λ, ϕ, h::Number=0.0)\n\nAdd point to frames as a fixed point on the surface of the parent point. The  relative position is specified by the longitude λ, the geodetic latitude ϕ and the altitude  over the surface of the reference ellipsoid h, which defaults to 0.0. The ellipsoid  parameters are extracted from the input TPC kernel pck using the NAIFId associated to the  parent point.\n\nwarning: Warning\naxes must be a set of body-fixed reference axes for the body represented by parent.  When this constraint is not satisfied, the results may be fundamentally wrong. \n\nSee also\n\nSee also add_point_fixed!, add_axes_topocentric! and geod2pos.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_surface!-2","page":"Frames","title":"FrameTransformations.Frames.add_point_surface!","text":"add_point_surface!(frames, point, parent, axes, λ, ϕ, R, f::Number=0.0, h::Number=0.0)\n\nAdd point to frames as a fixed point on the surface of the parent point body. The relative  position is specified by the longitude λ, the geodetic latitude ϕ, the reference radius  of the ellipsoid R and its flattening f. The altitude over the reference surface of the  ellipsoid h defaults to 0. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames/#FrameTransformations.Frames.add_point_updatable!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, FrameTransformations.Frames.AbstractFramePoint, Any, Any}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.add_point_updatable!","text":"add_point_updatable!(frames, point, parent, axes)\n\nAdd point as an updatable point to frames. Differently from all the other classes, the  state vector for updatable points (expressed in the set of input axes) must be manually  updated before being used for other computations.  \n\n\n\nadd_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes)\n\nAdd a point called name with id pointid to frames as a state vector with respect to  parentid in the axes axes.\n\nnote: Note\nThis class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.]\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2\n[...]\n\nSee also\n\nSee also update_point!, add_point_root!, add_point_ephemeris!,  add_point_dynamical! and add_point_fixed!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.axes_alias-Tuple{FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.axes_alias","text":"axes_alias(ax::AbstractFrameAxes)\n\nReturn the axes ID. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.axes_id","page":"Frames","title":"FrameTransformations.Frames.axes_id","text":"axes_id(axes::AbstractFrameAxes)\n\nReturn the ID associated to axes.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames/#FrameTransformations.Frames.axes_name","page":"Frames","title":"FrameTransformations.Frames.axes_name","text":"axes_name(axes::AbstractFrameAxes)\n\nReturn the name of axes.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames/#FrameTransformations.Frames.build_axes-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Symbol, FrameTransformations.Frames.FrameAxesFunctions{T, O}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.build_axes","text":"build_axes(frames, name, id, class, funs; parentid, dcm, cax_prop)\n\nCreate and add a FrameAxesNode to frames based on the input parameters. Current  supported classes are: :InertialAxes, :FixedOffsetAxes, :RotatingAxes, :ProjectedAxes,  :EphemerisAxes and :ComputableAxes.\n\nInputs\n\nframes – Target frame system \nname – Axes name, must be unique within frames \nid – Axes ID, must be unique within frames\nclass – Axes class.  \nfuns – FrameAxesFunctions object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of frames.\n\nKeywords\n\nparentid – Axes ID of the parent axes. Not required only for the root axes.\ndcm – DCM with respect to the parent axes. Required only for FixedOffsetAxes. \ncax_prop – ComputableAxesProperties, required only by ComputableAxes.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see add_axes_inertial!, add_axes_rotating!,  add_axes_computable!, add_axes_fixedoffset! and add_axes_projected!.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.build_point-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Symbol, Int64, Symbol, Int64, FrameTransformations.Frames.FramePointFunctions{T, O}}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.build_point","text":"build_point(frames, name, NAIFId, class, axesid, funs; parentid, offset)\n\nCreate and add a FramePointNode to frames based on the input parameters.  Current supported point classes are: :RootPoint, :TimePoint, :EphemerisPoint, :FixedPoint and :UpdatablePoint.\n\nInputs\n\nframes – Target frame system \nname – Point name, must be unique within frames \nNAIFId – Point NAIF ID, must be unique within frames\nclass – Point class. \naxesid – ID of the axes in which the state vector of the point is expressed. \nfuns – FramePointFunctions object storing the functions to update the state            vectors of the point. It must match the type and order of frames\n\nKeywords\n\nparentid – NAIF ID of the parent point. Not required only for the root point.\noffset – Position offset with respect to a parent point. Required only for FixedPoints.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see add_point_ephemeris!, add_point_fixed!, etc...\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.is_inertial-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.is_inertial","text":"is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)\nis_inertial(frame::FrameSystem, axesid::Int)\n\nReturn true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes.\n\nnote: Note\nFixedOffsetAxes with respect to an inertial set of axes, are also consired inertial.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.is_timefixed-Tuple{FrameSystem, FrameTransformations.Frames.AbstractFrameAxes}","page":"Frames","title":"FrameTransformations.Frames.is_timefixed","text":"is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)\nis_timefixed(frame::FrameSystem, axesid::Int)\n\nReturn true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes. \n\nnote: Note\nOnly :InertialAxes and :FixedOffsetAxes defined with respect to other inertial axes  are here considered as time fixed. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.order-Union{Tuple{Rotation{S}}, Tuple{S}} where S","page":"Frames","title":"FrameTransformations.Frames.order","text":"order(R::Rotation{S}) where S\n\nReturn the rotation order S.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.point_alias-Tuple{FrameTransformations.Frames.AbstractFramePoint}","page":"Frames","title":"FrameTransformations.Frames.point_alias","text":"point_alias(ax::AbstractFramePoint)\n\nReturn the NAIF ID associated to the input point. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.point_id","page":"Frames","title":"FrameTransformations.Frames.point_id","text":"point_id(point::AbstractFramePoint)\n\nReturn the NAIF ID associated to point.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames/#FrameTransformations.Frames.point_name","page":"Frames","title":"FrameTransformations.Frames.point_name","text":"point_name(point::AbstractFramePoint)\n\nReturn the name of point.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation12-Union{Tuple{S}, Tuple{FrameSystem{<:Any, <:Any, S}, Any, Any, Epoch{S}}} where S","page":"Frames","title":"FrameTransformations.Frames.rotation12","text":"rotation12(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 4.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation12-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.rotation12","text":"rotation12(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation3-Union{Tuple{S}, Tuple{FrameSystem{<:Any, <:Any, S}, Any, Any, Epoch{S}}} where S","page":"Frames","title":"FrameTransformations.Frames.rotation3","text":"rotation3(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 1.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.rotation3","text":"rotation3(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation6-Union{Tuple{S}, Tuple{FrameSystem{<:Any, <:Any, S}, Any, Any, Epoch{S}}} where S","page":"Frames","title":"FrameTransformations.Frames.rotation6","text":"rotation6(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 2.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.rotation6","text":"rotation6(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation9-Union{Tuple{S}, Tuple{FrameSystem{<:Any, <:Any, S}, Any, Any, Epoch{S}}} where S","page":"Frames","title":"FrameTransformations.Frames.rotation9","text":"rotation9(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 3.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.rotation9-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.rotation9","text":"rotation9(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.twovectors_to_dcm-Tuple{Any, Any, Any}","page":"Frames","title":"FrameTransformations.Frames.twovectors_to_dcm","text":"twovectors_to_dcm(a, b, seq)\n\nGenerate a direction cosine matrix from two time-dependent vectors a and b,  following the directions specified in seq. \n\nInputs\n\na – The primary vector that will be aligned with the first directions specified in seq. \nb – The secondary vector. The component of this vector that is orthogonal to the         primary vector is aligned with the second direction specified in the sequence seq.\nseq – Accepted sequence directions are:       :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\nwarning: Warning\nThe primary and secondary vectors do not have to be orthogonal. However, a great loss of precision happens when the two vectors are almost aligned. This function does not perform  any check on the angular separation of the two vectors. The user should ensure that the  primary and secondary vector differ of at least 1 milliradian.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.twovectors_to_δdcm-Tuple{Any, Any, Any}","page":"Frames","title":"FrameTransformations.Frames.twovectors_to_δdcm","text":"twovectors_to_δdcm(a, b, seq)\n\nCompute the time derivative of a direction cosine matrix generated from two time-dependent  state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 6-elements state vectors (position and velocity).\nseq – Accepted sequence directions are:       :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.twovectors_to_δ²dcm-Tuple{Any, Any, Any}","page":"Frames","title":"FrameTransformations.Frames.twovectors_to_δ²dcm","text":"twovectors_to_δ²dcm(a, b, seq)\n\nCompute the 2nd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 9-elements state vectors (position velocity and acceleration).\nseq – Accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.twovectors_to_δ³dcm-Tuple{Any, Any, Any}","page":"Frames","title":"FrameTransformations.Frames.twovectors_to_δ³dcm","text":"twovectors_to_δ³dcm(a, b, seq)\n\nCompute the 3rd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 12-elements state vectors (position, velocity, acceleration and jerk).\nseq – Accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.update_point!-Union{Tuple{S}, Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T, S}, Any, AbstractVector{T}, Epoch{S}}} where {O, T, S}","page":"Frames","title":"FrameTransformations.Frames.update_point!","text":"update_point!(frames, point, stv::AbstractVector, epoch::Epoch)\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.update_point!-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, AbstractVector{T}, T}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.update_point!","text":"update_point!(frames::FrameSystem, point, stv::AbstractVector, time)\n\nUpdate the state vector of point at the input time in frames. The only  accepted length for the input vector stv are 3, 6, 9 or 12. The order is automatically  inferred from the vector length.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n  \njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.];\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 \n[...]\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 \n[...] \n\nSee also\n\nSee also add_point_updatable!\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector12-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{<:Any, <:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}","page":"Frames","title":"FrameTransformations.Frames.vector12","text":"vector12(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector12-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.vector12","text":"vector12(frame, from, to, axes, t::Number)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector3-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{<:Any, <:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}","page":"Frames","title":"FrameTransformations.Frames.vector3","text":"vector3(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector3-Union{Tuple{S}, Tuple{FrameSystem{<:Any, <:Any, S}, Any, Any, Any, Epoch{S}, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where S","page":"Frames","title":"FrameTransformations.Frames.vector3","text":"vector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch ep,  using the aberration flag ltcorr, which may be any of the following AbstractLightTimeCorrection:\n\nLightTimeCorrection: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. \nPlanetaryAberrationCorrection: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the LightTimeCorrection option to account for the observer velocity    with respect to the Solar System Barycenter. \n\nThe integer argument dir is used to specify the correction direction, as follows:\n\n-1: for Reception, in which photons depart from the target's location at the    light-time corrected epoch ep-lt and arrive at the observer's location at ep.\n+1: for Transmission, in which photons depart from the observer's location at   ep and arrive at the target's location at the light-time corrected epoch ep+lt.\n\nKeyword Arguments\n\niters::Int=1: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.\naxescenter: ID or instance of the center point for axes. This parameter is used        only when axes have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to from.\n\nnote: Note\nIf the PlanetaryAberrationCorrection is applied, the frame system must be at  least one order higher than that of the requested transformation.\n\nSee also\n\nSee also LightTime, PlanetaryAberration and vector6.\n\nReferences\n\nCSPICE Library\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.vector3","text":"vector3(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time t,   expressed in seconds since J2000, using the aberration flag ltcorr and  the direction dir.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector3-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.vector3","text":"vector3(frame, from, to, axes, t::Number)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector6-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{<:Any, <:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}","page":"Frames","title":"FrameTransformations.Frames.vector6","text":"vector6(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector6-Union{Tuple{S}, Tuple{FrameSystem{<:Any, <:Any, S}, Any, Any, Any, Epoch{S}, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where S","page":"Frames","title":"FrameTransformations.Frames.vector6","text":"vector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch ep,  using the aberration flag ltcorr, which may be any of the following AbstractLightTimeCorrection:\n\nLightTimeCorrection: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. \nPlanetaryAberrationCorrection: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the LightTimeCorrection option to account for the observer velocity    with respect to the Solar System Barycenter. \n\nThe integer argument dir is used to specify the correction direction, as follows:\n\n-1: for Reception, in which photons depart from the target's location at the    light-time corrected epoch ep-lt and arrive at the observer's location at ep.\n+1: for Transmission, in which photons depart from the observer's location at   ep and arrive at the target's location at the light-time corrected epoch ep+lt.\n\nKeyword Arguments\n\niters::Int=1: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.\naxescenter: ID or instance of the center point for axes. This parameter is used        only when axes have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to from.\n\nnote: Note\nIf the PlanetaryAberrationCorrection is applied, the frame system must be at  least one order higher than that of the requested transformation.\n\nSee also\n\nSee also LightTime, PlanetaryAberration and vector6.\n\nReferences\n\nCSPICE Library\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number, FrameTransformations.Frames.AbstractLightTimeCorrection, Int64}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.vector6","text":"vector6(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time t,   expressed in seconds since J2000, using the aberration flag ltcorr and  the direction dir.\n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector6-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.vector6","text":"vector6(frame, from, to, axes, t::Number)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector9-Union{Tuple{S2}, Tuple{S1}, Tuple{FrameSystem{<:Any, <:Any, S1}, Any, Any, Any, Epoch{S2}}} where {S1, S2}","page":"Frames","title":"FrameTransformations.Frames.vector9","text":"vector9(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#FrameTransformations.Frames.vector9-Union{Tuple{T}, Tuple{O}, Tuple{FrameSystem{O, T}, Any, Any, Any, Number}} where {O, T}","page":"Frames","title":"FrameTransformations.Frames.vector9","text":"vector9(frame, from, to, axes, t::Number)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"method"},{"location":"Modules/frames/#Macros","page":"Frames","title":"Macros","text":"","category":"section"},{"location":"Modules/frames/","page":"Frames","title":"Frames","text":"Modules = [Frames]\nOrder = [:macro]","category":"page"},{"location":"Modules/frames/#FrameTransformations.Frames.@axes","page":"Frames","title":"FrameTransformations.Frames.@axes","text":"@axes(name, id, type=nothing)\n\nDefine a new axes instance to alias the given id. This macro creates an  AbstractFrameAxes subtype and its singleton instance callen name. Its type name  is obtained by appending Axes to either name or type (if provided). \n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> typeof(ICRF)\nInternationalCelestialReferenceFrameAxes\n\njulia> axes_alias(ICRF) \n1\n\njulia> @axes IAU_EARTH 10013\n\njulia> typeof(IAU_EARTH)\nIauEarthAxes\n\nSee also\n\nSee also @point and axes_alias.\n\n\n\n\n\n","category":"macro"},{"location":"Modules/frames/#FrameTransformations.Frames.@point","page":"Frames","title":"FrameTransformations.Frames.@point","text":"@point(name, id, type=nothing)\n\nDefine a new point instance to alias the given NAIFID id. This macro creates an  AbstractFramePoint subtype and its singleton instance called name. Its type name  is obtained by appending Point to either name or type (if provided).\n\nExamples\n\njulia> @point Venus 299\n\njulia> typeof(Venus)\nVenusPoint \n\njulia> point_alias(Venus)\n299\n\njulia> @point EMB 3 EarthMoonBarycenter\n\njulia> typeof(EMB) \nEarthMoonBarycenterPoint\n\njulia> point_alias(EMB) \n3 \n\nSee also\n\nSee also @axes and point_alias.\n\n\n\n\n\n","category":"macro"},{"location":"Modules/frames/#Constants","page":"Frames","title":"Constants","text":"","category":"section"},{"location":"Modules/frames/","page":"Frames","title":"Frames","text":"Modules = [Frames]\nOrder = [:constant]","category":"page"},{"location":"Modules/frames/#FrameTransformations.Frames.LightTime","page":"Frames","title":"FrameTransformations.Frames.LightTime","text":"LightTime\n\nThe singleton instance of type LightTimeCorrection, used to apply light-time (planetary  aberration) corrections when computing vectors from the FrameSystem.\n\nSee also\n\nSee also vector3 and vector6.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/frames/#FrameTransformations.Frames.PlanetaryAberration","page":"Frames","title":"FrameTransformations.Frames.PlanetaryAberration","text":"PlanetaryAberration\n\nThe singleton instance of type PlanetaryAberrationCorrection, used to apply one-way  light-time and stellar aberration corrections when computing vectors from the FrameSystem.\n\nSee also\n\nSee also vector3 and vector6.\n\n\n\n\n\n","category":"constant"},{"location":"todos/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"Although Basic already implements may of its required functionalities, there is still  a lot to do to finish it. ","category":"page"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\">ID</th>\n    <th class=\"tg-fymr\">Feature to develop</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">AD1</td>\n    <td class=\"tg-0pky\">\n        <b>Ephemeris</b>: the actual default ephemeris provider for Basic is Calceph. \n        While it is a very versatile library, there is a inherent issue in that: the \n        impossibility to perform AD over it. Therefore, within the context of development \n        of Basic a (full) julia reader for JPL/INPOP ephemeris is foreseen. This package\n        is actually at the early stage of the development at the moment, thus any \n        contribution would be highly appreciated.\n\n        This is being performed in a separate package called `Ephemeris` within the JSMD\n        environment.\n    </td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">AD2</td>\n    <td class=\"tg-0pky\">\n        <b>Caching</b>: if you have a deep look into the FrameSystem structure, you'll \n        see that some frames have a dedicated cache. This goes in contrast with the use \n        of ForwardDiff, since it would require a Dual's compatible cache: there is, then,\n        the need of replacing those caches with a PreallocationTools.DiffCache or something\n        similar.\n    </td>\n  </tr>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">AD3</td>\n    <td class=\"tg-0pky\">\n        <b>FunctionWrappers</b>: if you have a deep look into the FrameSystem structure, you'll \n        see that the actual transformations are stored by means of FunctionWrapper. Again,\n        this goes against the AD integration but was choosen for efficiency reasons.\n        In this case there is the need to introduct FunctionWrappersWrappers dependency to\n        solve the issue. \n    </td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"Write down an email if your are interested in  contributing to one of those, we'll be for welcoming you with some additional guidelines. ","category":"page"},{"location":"todos/#Guidelines","page":"Contributing","title":"Guidelines","text":"","category":"section"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"This section details the some of the guidelines that should be followed when contributing  to this package.","category":"page"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"Since the package is not consolidated yet, the most straight forward way to contribute is  by creating a branch of the master and develop there the desired feature. To this step,  follows the creation of a PR that will be accepted only if the new feature are validated  by tests.","category":"page"},{"location":"#Welcome-to-FrameTransformations.jl!","page":"Home","title":"Welcome to FrameTransformations.jl!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, FrameTransformations is the ideal starting point. The package is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert between different time scales (via Tempo.jl);\nConvert between different time representations (via Tempo.jl);\nRead binary ephemeris files;\nCreate a custom reference frame systems with user-defined points and axes.\nTransform states between different frames.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of this seamlessly integrated with ForwardDiff.jl.","category":"page"},{"location":"#Mission","page":"Home","title":"Mission","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this package has been performed with the following design goals in mind:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Efficiency: being a base package a particular attention has been   given to the execution time of the different routines as well as most/all of  them have been optimised and deeply benchmarked.\nExtensibility: attention has been given also to the definition of the   interfaces, which have been kept the most essential possible, in such a way   their extension can be performed very easily (also thanks to Julia language itself).\nSingle Responsability Principle: The different modules in this package   have been organized in such a way they are responsible of bringing only one   of the desired features. This results in the possibility to extend and maybe,   in future, detatch some modules to a different package.\nAutomatic Differentiation: seamless integration with ForwardDiff.jl is targetted   to fully exploit its power in higher-level packages constructed on top of Basic.","category":"page"},{"location":"#basic_design_req","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following table reports the desired list of features considered in the development of  this package, together with their development status. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\">RID</th>\n    <th class=\"tg-fymr\">Feature</th>\n    <th class=\"tg-fymr\">Module</th>\n    <th class=\"tg-fymr\">Status</th>\n    <th class=\"tg-fymr\">Comment</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">REQ1</td>\n    <td class=\"tg-0pky\">Read binary JPL/INPOP ephemeris files. At least type 1, 2, 3, 21 shall be available.</td>\n    <td class=\"tg-0pky\">Ephemeris</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">\n        The possibility to read binary SPK files is implemented through CALCEPH S/W. \n    </td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ2</td>\n    <td class=\"tg-0pky\">Read JPL ASCII PCK files (constants).</td>\n    <td class=\"tg-0pky\">Utils</td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\">Fully implemented in Basic. Tested on NAIF's pck00010 and pck00011 files.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ3</td>\n    <td class=\"tg-0pky\">Read NASA JPL frame kernels.</td>\n    <td class=\"tg-0pky\">Utils</td>\n    <td class=\"tg-0pky\">🔴</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ4</td>\n    <td class=\"tg-0pky\">Write NASA JPL frame kernels</td>\n    <td class=\"tg-0pky\">Utils</td>\n    <td class=\"tg-0pky\">🔴</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">REQ5</td>\n    <td class=\"tg-0pky\">\n        Fetch automatically IERS EOP.\n    </td>\n    <td class=\"tg-0pky\">Orient</td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ6</td>\n    <td class=\"tg-0pky\">\n        Fetch leapseconds files automatically.\n    </td>\n    <td class=\"tg-0pky\">Orient</td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ7</td>\n    <td class=\"tg-0pky\">Parse epochs in different formats. Shall include ISO and days or seconds since J2000.</td>\n    <td class=\"tg-0pky\">Tempo</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">\n        Deeply tested against other S/W results.\n    </td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ8</td>\n    <td class=\"tg-0pky\">\n        Transform epochs between different timescales, supporting at least: TDB,\n        TCB, TT, TAI, TCG, UTC, UT1, GPS.\n    </td>\n    <td class=\"tg-0pky\">Tempo</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">\n        Deeply tested against ERFA. Extensible structure.\n    </td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ9</td>\n    <td class=\"tg-0pky\">\n        Create IAU standard-based body-fixed rotation matrices.\n    </td>\n    <td class=\"tg-0pky\">Orient</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against NAIF's SPICE.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ10</td>\n    <td class=\"tg-0pky\">\n        Create ITRF (IERS-based) rotation matrices.\n    </td>\n    <td class=\"tg-0pky\">Orient</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against ERFA. Models with different precisions are available.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ11</td>\n    <td class=\"tg-0pky\">\n        Create a graph of custom points.\n    </td>\n    <td class=\"tg-0pky\">Frames</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Points could be defined in different ways (not only associated to ephemeris).</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ12</td>\n    <td class=\"tg-0pky\">\n        Create a graph of custom axes.\n    </td>\n    <td class=\"tg-0pky\">Frames</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Axes models for MEME2000, ITRF, IAU models and many others are already implemented and tested within Basic.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ13</td>\n    <td class=\"tg-0pky\">\n        Get a state of a point relative to another in a custom frame.\n    </td>\n    <td class=\"tg-0pky\">Frames</td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against NAIF's SPICE.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">REQ14</td>\n    <td class=\"tg-0pky\">\n        Full compatibility with ForwardDiff.jl shall be assured.\n    </td>\n    <td class=\"tg-0pky\">Basic</td>\n    <td class=\"tg-0pky\">🟡</td>\n    <td class=\"tg-0pky\">Partial compatibility is already available (see dedicated section in \"Contributing\" for details)</td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where the color legend used is described afterwards:","category":"page"},{"location":"","page":"Home","title":"Home","text":" Description\n🔵 Stable, deeply tested\n🟢 Developed, working, partially tested\n🟡 In development\n🔴 Development not started but planned\n⚪ Outdated/no more supported","category":"page"},{"location":"Modules/utils/#basic_utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"Modules/utils/#basic_utils_api","page":"Utils","title":"API","text":"","category":"section"},{"location":"Modules/utils/#Types","page":"Utils","title":"Types","text":"","category":"section"},{"location":"Modules/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nOrder = [:type]","category":"page"},{"location":"Modules/utils/#FrameTransformations.Utils.TPC","page":"Utils","title":"FrameTransformations.Utils.TPC","text":"TPC <: supertype\n\nA type representing TPC files.\n\n\n\n\n\n","category":"type"},{"location":"Modules/utils/#Functions","page":"Utils","title":"Functions","text":"","category":"section"},{"location":"Modules/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nOrder = [:function]","category":"page"},{"location":"Modules/utils/#FrameTransformations.Utils._3angles_to_δdcm-Tuple{Any, Symbol}","page":"Utils","title":"FrameTransformations.Utils._3angles_to_δdcm","text":"_3angles_to_δdcm(θ, rot_seq::Symbol)\n\nCompute the time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils._3angles_to_δ²dcm-Tuple{Any, Symbol}","page":"Utils","title":"FrameTransformations.Utils._3angles_to_δ²dcm","text":"_3angles_to_δ²dcm(θ, rot_seq::Symbol)\n\nCompute the 2nd time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.angle_to_δdcm","page":"Utils","title":"FrameTransformations.Utils.angle_to_δdcm","text":"angle_to_δdcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX)\n\nCompute the derivative of the direction cosine matrix that perform a set of rotations (θ,  ϕ, γ) about the coordinate axes in rot_seq. Each rotation input must be an indexable  objected which includes the angle and its first time derivative.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δ²dcm\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils/#FrameTransformations.Utils.angle_to_δ²dcm","page":"Utils","title":"FrameTransformations.Utils.angle_to_δ²dcm","text":"angle_to_δ²dcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX)\n\nCompute the second order time derivative of the direction cosine matrix that perform  a set of rotations (θ, ϕ, γ) about the coordinate axes in rot_seq. Each rotation  input must be an indexable objected which includes the angle and its first and second order  time derivatives.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δdcm\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils/#FrameTransformations.Utils.angle_to_δ³dcm","page":"Utils","title":"FrameTransformations.Utils.angle_to_δ³dcm","text":"angle_to_δ³dcm(θ::Number[, ϕ::Number[, γ::Number]], rot_seq::Symbol = :Z)\n\nCompute the second order time derivative of the direction cosine matrix that perform  a set of rotations (θ, ϕ, γ) about the coordinate axes in rot_seq. Each rotation  input must be an indexable objected which includes the angle and its time derivatives up to  order 3 (jerk).\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δdcm\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils/#FrameTransformations.Utils.cross12-Tuple{AbstractVector, AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.cross12","text":"cross12(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its 1st, 2nd and 3rd order time derivatives. \n\nNotes\n\nx and y must be 12-elements state vectors (position, velocity and acceleration)\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.cross3-Tuple{AbstractVector, AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.cross3","text":"cross3(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y, considering only their first 3 elements.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.cross6-Tuple{AbstractVector, AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.cross6","text":"cross6(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its time derivative. \n\nNotes\n\nx and y must be 6-elements state vectors, with the last elements of each vector  representing the time derivatives of the first three.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.cross9-Tuple{AbstractVector, AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.cross9","text":"cross9(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its 1st and 2nd-order time derivatives. \n\nNotes\n\nx and y must be 9-elements state vectors (position, velocity and acceleration)\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.geoc2pos-Tuple{Number, Number, Number}","page":"Utils","title":"FrameTransformations.Utils.geoc2pos","text":"geoc2pos(r::Number, λ::Number, ϕ::Number)\ngeoc2pos(geoc::AbstractArray)\n\nTransform geocentric coordinates in a cartesian position vector, given the longitude λ,  the geocentric latitude ϕ and the radius r.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.geoc2pv-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.geoc2pv","text":"geoc2pv(geoc::AbstractVector)\n\nTransform a spherical geocentric 6-elements state vector (radius, longitude, geocentric  latitude and their derivatives) into a cartesian 6-elements vector (position and velocity).\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.geod2pos-NTuple{5, Number}","page":"Utils","title":"FrameTransformations.Utils.geod2pos","text":"geod2pos(h::Number, λ::Number, ϕ::Number, R::Number, f::Number)\n\nTransform longitude λ, geodetic latitude ϕ and altitude over the reference ellipsoid to  a cartesian position vector, given the reference radius R and the flattening f.\n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.normalize-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.normalize","text":"normalize(v::AbstractVector)\n\nNormalise the vector v.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.pos2geoc-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.pos2geoc","text":"pos2geoc(pos::AbstractVector)\n\nTransform a cartesian 3-elements position vector pos into radius, longitude and geocentric  latitude, respectively.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.pos2geod","page":"Utils","title":"FrameTransformations.Utils.pos2geod","text":"pos2geod(pos::AbstratVector, R::Number, f::Number, toll::Number=1e-12)\n\nTransform a cartesian 3-elements position vector pos into longitude, geodetic latitude  and altitude over the reference ellipsoid with radius R and flattening f. \n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils/#FrameTransformations.Utils.pv2geoc-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.pv2geoc","text":"pv2geoc(pv::AbstractVector)\n\nTransform a cartesian 6-elements state vector (position and velocity) into radius, longitude,  geocentric latitude and their derivatives, respectively.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.skew-Tuple{Any}","page":"Utils","title":"FrameTransformations.Utils.skew","text":"skew(a)\n\nCreate a skew matrix from the first three elements of a.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.δnormalize-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.δnormalize","text":"δnormalize(v::AbstractVector)\n\nCompute the time derivative of a unit vector v.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.δ²normalize-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.δ²normalize","text":"δ²normalize(v::AbstractVector)\n\nCompute the 2nd-order time derivative of a unit vector v.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#FrameTransformations.Utils.δ³normalize-Tuple{AbstractVector}","page":"Utils","title":"FrameTransformations.Utils.δ³normalize","text":"δ³normalize(v::AbstractVector)\n\nCompute the 3rd-order time derivative of a unit vector v.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#SMDInterfacesUtils.IO.load-Tuple{TPC{1}}","page":"Utils","title":"SMDInterfacesUtils.IO.load","text":"load(file::TPC{1})\n\nOpen a JPL ASCII .tpc file and parse its data in a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#SMDInterfacesUtils.IO.load-Tuple{TPC}","page":"Utils","title":"SMDInterfacesUtils.IO.load","text":"load(files::TPC)\n\nOpen a group of JPL ASCII .tpc files and parse their data in a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"Modules/utils/#Macros","page":"Utils","title":"Macros","text":"","category":"section"},{"location":"Modules/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nOrder = [:macro]","category":"page"},{"location":"Modules/utils/#Constants","page":"Utils","title":"Constants","text":"","category":"section"},{"location":"Modules/utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nOrder = [:constant]","category":"page"},{"location":"Modules/utils/#FrameTransformations.Utils.light_speed","page":"Utils","title":"FrameTransformations.Utils.light_speed","text":"light_speed\n\nOfficial light speed constant value used in CSPICE \n\n\n\n\n\n","category":"constant"}]
}
