var documenterSearchIndex = {"docs":
[{"location":"Tutorials/t03_cr3bp/#tutorial_03_cr3bp","page":"04 - Use Case: CR3BP","title":"Use Case: CR3BP","text":"","category":"section"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"The power of the FrameSystem is its capability to handle axes transformations and point translations of both high-accuracy and simplified models. The use-case here presented includes the case of the Circular-Restricted Three-Body Problem (CR3BP) rotating frame transformation handling.","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"In particular, when dealing with the CR3BP, mission analysis are used to exploit non-dimensional, rotating coordinates to express the equations of motion and perform the computations. ","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"In this tutorial, we create a FrameSystem to handle transformations within the Earth-Moon  CR3BP, which is characterized by a mass ratio of approximately μ = 0.012. We start off by creating a frame system without any ephemeris provider, since we are using a simplified model.","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using FrameTransformations","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"CR3BP = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"As always, the first step requires the definition of the root axes and points. In this case, we use the a generic set of inertial axes and the Earth-Moon Barycenter (EMB).","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using FrameTransformations \nCR3BP = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"@axes InertialAx 1 InertialFrame \n\nadd_axes_inertial!(CR3BP, InertialAx)\n\n@point EMBc 1 EarthMoonBarycenterCr3bp\n\nadd_point_root!(CR3BP, EMBc, InertialAx)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"We now proceed to add our synodic axes: in the CR3BP these are uniformly rotating with respect to the InertialAx about the Z-axis. Therefore, we leverage the rotating axes type: ","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using FrameTransformations \n\n@axes InertialAx 1 InertialFrame \n@point EMBc 1 EarthMoonBarycenterCr3bp\n\nCR3BP = FrameSystem{2, Float64}()\n\nadd_axes_inertial!(CR3BP, InertialAx)\nadd_point_root!(CR3BP, EMBc, InertialAx)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using ReferenceFrameRotations\n\nf(t) = angle_to_dcm(t, :Z) \n\n@axes SynodicAx 2 SynodicFrame \n\nadd_axes_rotating!(CR3BP, SynodicAx, InertialAx, f)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"Note that there is no need to specify the rotation derivatives, as they'll be computed by  automatic differentiation via the ForwardDiff package. For performace-critical transformations, however, it is reccomended to manually define these derivatives.","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"Now, let's assume we have our spacecraft. Most likely, its states will be expressed in the synodic frame. In this case, we leverage updatable points, since we desire to manually update its state at each time.","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using FrameTransformations \nusing ReferenceFrameRotations\n\n@axes InertialAx 1 InertialFrame \n@axes SynodicAx 2 SynodicFrame \n@point EMBc 1 EarthMoonBarycenterCr3bp\n\nCR3BP = FrameSystem{2, Float64}()\n\nadd_axes_inertial!(CR3BP, InertialAx)\nadd_point_root!(CR3BP, EMBc, InertialAx)\n\nf(t) = angle_to_dcm(t, :Z) \n\nadd_axes_rotating!(CR3BP, SynodicAx, InertialAx, f)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"@point Spacecraft -1_900_000\n\nadd_point_updatable!(CR3BP, Spacecraft, EMBc, SynodicAx)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"We know assume that at t = 0.8 our spacecraft is at L4, therefore we update its state accordingly:","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using FrameTransformations \nusing ReferenceFrameRotations\n\n@axes InertialAx 1 InertialFrame \n@axes SynodicAx 2 SynodicFrame \n@point EMBc 1 EarthMoonBarycenterCr3bp\n@point Spacecraft -1_900_000\nCR3BP = FrameSystem{2, Float64}()\n\nf(t) = angle_to_dcm(t, :Z) \n\nadd_axes_inertial!(CR3BP, InertialAx)\nadd_point_root!(CR3BP, EMBc, InertialAx)\n\nadd_axes_rotating!(CR3BP, SynodicAx, InertialAx, f)\nadd_point_updatable!(CR3BP, Spacecraft, EMBc, SynodicAx)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"μ = 0.012\nxL4 = [1/2-μ, sqrt(3)/2, 0.0, 0.0, 0.0, 0.0]\nt = 0.8\n\nupdate_point!(CR3BP, Spacecraft, xL4, t)","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"Finally we can retrieve the spacecraft state in both the synodic as well as the inertial axes: ","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"using FrameTransformations \nusing ReferenceFrameRotations\n\n@axes InertialAx 1 InertialFrame \n@axes SynodicAx 2 SynodicFrame \n@point EMBc 1 EarthMoonBarycenterCr3bp\n@point Spacecraft -1_900_000\nCR3BP = FrameSystem{2, Float64}()\n\nf(t) = angle_to_dcm(t, :Z) \n\nadd_axes_inertial!(CR3BP, InertialAx)\nadd_point_root!(CR3BP, EMBc, InertialAx)\n\nadd_axes_rotating!(CR3BP, SynodicAx, InertialAx, f)\nadd_point_updatable!(CR3BP, Spacecraft, EMBc, SynodicAx)\n\nμ = 0.012\nxL4 = [1/2-μ, sqrt(3)/2, 0.0, 0.0, 0.0, 0.0]\nt = 0.8\n\nupdate_point!(CR3BP, Spacecraft, xL4, t)\n\nt = 0.8","category":"page"},{"location":"Tutorials/t03_cr3bp/","page":"04 - Use Case: CR3BP","title":"04 - Use Case: CR3BP","text":"vector6(CR3BP, EMBc, Spacecraft, SynodicAx, t)\nvector6(CR3BP, EMBc, Spacecraft, InertialAx, t)","category":"page"},{"location":"Tutorials/t05_multithread/#tutorial_05_threads","page":"06 - Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"Tutorials/t05_multithread/","page":"06 - Multithreading","title":"06 - Multithreading","text":"note: Note\nWork in progress","category":"page"},{"location":"Modules/frames_lapi/#low_frames_api","page":"Low-level API","title":"Frames's Low-level API","text":"","category":"section"},{"location":"Modules/frames_lapi/#Axes","page":"Low-level API","title":"Axes","text":"","category":"section"},{"location":"Modules/frames_lapi/","page":"Low-level API","title":"Low-level API","text":"Frames.AbstractFrameAxes\nFrames.FrameAxesNode\nFrames.axes_name\nFrames.axes_id\n\nFrames.build_axes\n\nFrames.ComputableAxesProperties\n\n","category":"page"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes","page":"Low-level API","title":"FrameTransformations.Frames.AbstractFrameAxes","text":"AbstractFrameAxes\n\nAbstract type for all reference frames axes.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.FrameAxesNode","page":"Low-level API","title":"FrameTransformations.Frames.FrameAxesNode","text":"FrameAxesNode{O, T, N} <: AbstractGraphNode\n\nDefine a set of axes.\n\nFields\n\nname – axes name \nclass – Symbol representing the class of the axes \nid – axes ID (equivalent of NAIFId for axes)\nparentid – ID of the parent axes \ncomp – properties for computable axes \nR – rotation matrix for fixed relative axes \nf – FrameAxesFunctions container \nangles – vector storing the libration angles retrived from ephemerides\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.axes_name","page":"Low-level API","title":"FrameTransformations.Frames.axes_name","text":"axes_name(axes::AbstractFrameAxes)\n\nReturn the name of axes.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.axes_id","page":"Low-level API","title":"FrameTransformations.Frames.axes_id","text":"axes_id(axes::AbstractFrameAxes)\n\nReturn the ID associated to axes.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.build_axes","page":"Low-level API","title":"FrameTransformations.Frames.build_axes","text":"build_axes(frames, name, id, class, funs; parentid, dcm, cax_prop)\n\nCreate and add a FrameAxesNode to frames based on the input parameters. Current  supported classes are: :InertialAxes, :FixedOffsetAxes, :RotatingAxes, :ProjectedAxes,  :EphemerisAxes and :ComputableAxes.\n\nInputs\n\nframes – Target frame system \nname – Axes name, must be unique within frames \nid – Axes ID, must be unique within frames\nclass – Axes class.  \nfuns – FrameAxesFunctions object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of frames.\n\nKeywords\n\nparentid – Axes ID of the parent axes. Not required only for the root axes.\ndcm – DCM with respect to the parent axes. Required only for FixedOffsetAxes. \ncax_prop – ComputableAxesProperties, required only by ComputableAxes.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see add_axes_inertial!, add_axes_rotating!,  add_axes_computable!, add_axes_fixedoffset! and add_axes_projected!.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.ComputableAxesProperties","page":"Low-level API","title":"FrameTransformations.Frames.ComputableAxesProperties","text":"ComputableAxesProperties\n\nStore the properties required to retrieve all the vectors required by   a computable set of axes. \n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#Points","page":"Low-level API","title":"Points","text":"","category":"section"},{"location":"Modules/frames_lapi/","page":"Low-level API","title":"Low-level API","text":"Frames.AbstractFramePoint\nFrames.FramePointNode\n\nFrames.point_name\nFrames.point_id \n\nFrames.build_point\n\nFrames._get_comp_axes_vector3\nFrames._get_comp_axes_vector6\nFrames._get_comp_axes_vector9\nFrames._get_comp_axes_vector12\n\n","category":"page"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.AbstractFramePoint","page":"Low-level API","title":"FrameTransformations.Frames.AbstractFramePoint","text":"AbstractFramePoint\n\nAbstract type for all reference frames points.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.FramePointNode","page":"Low-level API","title":"FrameTransformations.Frames.FramePointNode","text":"FramePointNode{O, T, N} <: AbstractGraphNode\n\nDefine a frame system point.\n\nFields\n\nname – point name \nclass – Symbol representing the class of the point \naxesid – ID of the axes in which the point coordinates are expressed \nparentid – NAIF ID of the parent point \nNAIFId – NAIF ID of the point\nstv – vector storing the point state vectors\nepochs – vector storing the epochs associated to stv\nnzo – last order at which stv has been computed \nf – FramePointFunctions container \n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.point_name","page":"Low-level API","title":"FrameTransformations.Frames.point_name","text":"point_name(point::AbstractFramePoint)\n\nReturn the name of point.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.point_id","page":"Low-level API","title":"FrameTransformations.Frames.point_id","text":"point_id(point::AbstractFramePoint)\n\nReturn the NAIF ID associated to point.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.build_point","page":"Low-level API","title":"FrameTransformations.Frames.build_point","text":"build_point(frames, name, NAIFId, class, axesid, funs; parentid, offset)\n\nCreate and add a FramePointNode to frames based on the input parameters.  Current supported point classes are: :RootPoint, :TimePoint, :EphemerisPoint, :FixedPoint and :UpdatablePoint.\n\nInputs\n\nframes – Target frame system \nname – Point name, must be unique within frames \nNAIFId – Point NAIF ID, must be unique within frames\nclass – Point class. \naxesid – ID of the axes in which the state vector of the point is expressed. \nfuns – FramePointFunctions object storing the functions to update the state            vectors of the point. It must match the type and order of frames\n\nKeywords\n\nparentid – NAIF ID of the parent point. Not required only for the root point.\noffset – Position offset with respect to a parent point. Required only for FixedPoints.\n\nwarning: Warning\nThis is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see add_point_ephemeris!, add_point_fixed!, etc...\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector3","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector3","text":"_get_comp_axes_vector3(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 3-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position\n2: velocity\n3: acceleration \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector6","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector6","text":"_get_comp_axes_vector6(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 6-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position, velocity\n2: velocity, acceleration\n3: acceleration, jerk\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector9","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector9","text":"_get_comp_axes_vector9(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 9-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position, velocity, acceleration\n2: velocity, acceleration, jerk\n\nwarning: Warning\nThis function does not support orders of `v' higher than 2, because it would  require the computation of vectors of order 5, which is currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector12","page":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector12","text":"_get_comp_axes_vector12(frame, v::ComputableAxesVector, axesid, t)\n\nCompute a 12-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in v as follows: \n\n1: position, velocity, acceleration, jerk\n\nwarning: Warning\nThis function does not support orders of `v' higher than 1, because it would  require the computation of vectors of order 5 and 6, which are currently not supported.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#Two-Vectors","page":"Low-level API","title":"Two Vectors","text":"","category":"section"},{"location":"Modules/frames_lapi/","page":"Low-level API","title":"Low-level API","text":"Frames.twovectors_to_dcm \nFrames.twovectors_to_δdcm \nFrames.twovectors_to_δ³dcm \nFrames.twovectors_to_δ²dcm\n\nFrames._twovectors_to_dcm \nFrames._two_vectors_to_rot6\nFrames._two_vectors_to_rot9\nFrames._two_vectors_to_rot12\nFrames._two_vectors_basis","category":"page"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_dcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_dcm","text":"twovectors_to_dcm(a, b, seq)\n\nGenerate a direction cosine matrix from two time-dependent vectors a and b,  following the directions specified in seq. \n\nInputs\n\na – The primary vector that will be aligned with the first directions specified in seq. \nb – The secondary vector. The component of this vector that is orthogonal to the         primary vector is aligned with the second direction specified in the sequence seq.\nseq – Accepted sequence directions are:       :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\nwarning: Warning\nThe primary and secondary vectors do not have to be orthogonal. However, a great loss of precision happens when the two vectors are almost aligned. This function does not perform  any check on the angular separation of the two vectors. The user should ensure that the  primary and secondary vector differ of at least 1 milliradian.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δdcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δdcm","text":"twovectors_to_δdcm(a, b, seq)\n\nCompute the time derivative of a direction cosine matrix generated from two time-dependent  state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 6-elements state vectors (position and velocity).\nseq – Accepted sequence directions are:       :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ³dcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ³dcm","text":"twovectors_to_δ³dcm(a, b, seq)\n\nCompute the 3rd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 12-elements state vectors (position, velocity, acceleration and jerk).\nseq – Accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ²dcm","page":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ²dcm","text":"twovectors_to_δ²dcm(a, b, seq)\n\nCompute the 2nd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors a and b, following the directions specified in seq. \n\nInputs\n\na and b – 9-elements state vectors (position velocity and acceleration).\nseq – Accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._twovectors_to_dcm","page":"Low-level API","title":"FrameTransformations.Frames._twovectors_to_dcm","text":"_twovectors_to_dcm(a, b, seq::Symbol, fc::Function, fn::Function, fk::Function)\n\nGenerate a direction cosine matrix and/or its time derivatives from the vectors a and b,  according to the directions specifeid in seq. \n\nNotes\n\nfc and fn are used to control the derivative order. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot6","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot6","text":"_two_vectors_to_rot6(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and time-derivative, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δdcm for more information. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot9","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot9","text":"_two_vectors_to_rot9(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and its 1st and 2nd-order time-derivatives, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δ²dcm for more information. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot12","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot12","text":"_two_vectors_to_rot12(a, b, seq::Symbol)\n\nGenerate a direction cosine matrix and its 1st, 2nd and 3r-order time-derivatives, minimising  the number of repeated computations. \n\nSee also\n\nSee twovectors_to_dcm and twovectors_to_δdcm for more information. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_basis","page":"Low-level API","title":"FrameTransformations.Frames._two_vectors_basis","text":"_two_vectors_basis(a, b, seq::Symbol, fc::Function, fk::Function)\n\nGenerate a 3D right-handed orthogonal vector basis and/or its time derivatives from the  vectors a and b, according to the directions specified in seq and the input cross  function fc. fk is a function that filters a to guarantee type-stability.\n\nThe accepted sequence directions are: :XY, :YX, :XZ, :ZX, :YZ, :ZY\n\nThe standard basis, its 1st, 2nd-order and 3rd order time derivatives can be computed by  passing cross, cross6, cross9 or cross12 to fc. The returned vectors will have  a length of 3, 6 or 9, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#low_orient_api","page":"Low-level API","title":"Orient's Low-level API","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Although this routines are not meant to be used outside of the package, they are here documented to aid future developments or to help users that require specific computations.","category":"page"},{"location":"Modules/orient_lapi/#Outdated-IAU-Models","page":"Low-level API","title":"Outdated IAU Models","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.iau1980","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.iau1980","page":"Low-level API","title":"FrameTransformations.Orient.iau1980","text":"iau1980\n\nThe singleton instance of type IAU1980, representing the IAU 1980 family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_lapi/#Fundamental-Arguments","page":"Low-level API","title":"Fundamental Arguments","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.FundamentalArguments\nOrient.LuniSolarArguments\nOrient.PlanetaryArguments\nOrient.fa_mano_moon\nOrient.fa_mano_sun\nOrient.fa_mlon_moon\nOrient.fa_mlat_moon\nOrient.fa_melo_moon\nOrient.fa_precession\nOrient.fa_mlon_mercury\nOrient.fa_mlon_venus\nOrient.fa_mlon_earth\nOrient.fa_mlon_mars\nOrient.fa_mlon_jupiter\nOrient.fa_mlon_saturn\nOrient.fa_mlon_uranus\nOrient.fa_mlon_neptune","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.FundamentalArguments","page":"Low-level API","title":"FrameTransformations.Orient.FundamentalArguments","text":"FundamentalArguments{N <: Number}\n\nType storing the fundamental luni-solar and planetary arguments.\n\nFields\n\nMₐ – Mean anomaly of the Moon \nSₐ – Mean anomaly of the Sun\nuₘ – Mean longitude of the Moon minus mean longitude of the ascending node F\nDₛ – Mean elongation of the Moon from the Sun \nΩₘ – Mean longitude of the Moon's ascending node\nλ_Me – Mercury's mean heliocentric longitude\nλ_Ve – Venus's mean heliocentric longitude\nλ_Ea – Earth's mean heliocentric longitude\nλ_Ma – Mars's mean heliocentric longitude\nλ_Ju – Jupiter's mean heliocentric longitude\nλ_Sa – Saturn's mean heliocentric longitude\nλ_Ur – Uranus's mean heliocentric longitude\nλ_Ne – Neptune's mean heliocentric longitude\npₐ – General precession in longitude\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.LuniSolarArguments","page":"Low-level API","title":"FrameTransformations.Orient.LuniSolarArguments","text":"LuniSolarArguments(t::Number, m::IAUModel)\n\nCompute the fundamental (Delaunay) Luni-Solar arguments, in radians, associated to the  desired IAU model m, at time t expressed in TDB Julian centuries since J2000.\n\nThe returned values depend on the input model as follows: \n\nIAU2006A: the Delaunay expressions are taken from the IERS 2010 Conventions.\nIAU2000B: the expressions are taken from Simon et al. (1994), following ERFA's   implementation of nut00b.c\n\nOutputs\n\nMₐ – Mean anomaly of the Moon\nSₐ – Mean anomaly of the Sun\nuₘ – Mean longitude of the Moon minus mean longitude of the         ascending node F\nDₛ – Mean elongation of the Moon from the Sun\nΩₘ – Mean longitude of the Moon's ascending node\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nSimon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets.\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.PlanetaryArguments","page":"Low-level API","title":"FrameTransformations.Orient.PlanetaryArguments","text":"PlanetaryArguments(t::Number)\n\nCompute the fundamental planetary arguments and the general precession, in radians,  at time t expressed in TDB Julian centuries since J2000.\n\nOutputs\n\nλ☿ – Mercury's mean heliocentric longitude.\nλ♀ – Venus's mean heliocentric longitude.\nλe – Earth's mean heliocentric longitude.\nλ♂ – Mars's mean heliocentric longitude.\nλ♃ – Jupiter's mean heliocentric longitude.\nλ♄ – Saturn's mean heliocentric longitude.\nλ⛢ – Uranus's mean heliocentric longitude.\nλ♆ – Neptune's mean heliocentric longitude.\npλ – General precession in longitude.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_mano_moon","text":"fa_mano_moon(t::Number)\n\nReturn the mean anomaly of the Moon Mₐ, in radians, at time t expressed in TDB Julian  centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_sun","page":"Low-level API","title":"FrameTransformations.Orient.fa_mano_sun","text":"fa_mano_sun(t::Number)\n\nReturn the mean anomaly of the Sun Sₐ in radians, at time t expressed in TDB Julian  centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_moon","text":"fa_mlon_moon(t::Number)\n\nReturn the mean longitude of the Moon's ascending node Ω in radians, at time t expressed in TDB Julian centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlat_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlat_moon","text":"fa_mlat_moon(t::Number)\n\nReturn the mean longitude of the Moon minus the mean longitude of the ascending node F in radians, at time t expressed in TDB Julian centuries since J2000.  \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_melo_moon","page":"Low-level API","title":"FrameTransformations.Orient.fa_melo_moon","text":"fa_melo_moon(t::Number)\n\nReturn the mean elongation of the Moon from the Sun D in radians, at time t expressed in  TDB Julian centuries since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_precession","page":"Low-level API","title":"FrameTransformations.Orient.fa_precession","text":"fa_precession(t::Number) \n\nReturn the general accumulated precession in longitude pₐ in radians, at time t  expressed in TDB Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mercury","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mercury","text":"fa_mlon_mercury(t::Number)\n\nReturn the mean heliocentric longitude of Mercury in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_venus","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_venus","text":"fa_mlon_venus(t::Number)\n\nReturn the mean heliocentric longitude of Venus in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_earth","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_earth","text":"fa_mlon_earth(t::Number)\n\nReturn the mean heliocentric longitude of Earth in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mars","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mars","text":"fa_mlon_mars(t::Number)\n\nReturn the mean heliocentric longitude of Mars in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_jupiter","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_jupiter","text":"fa_mlon_jupiter(t::Number)\n\nReturn the mean heliocentric longitude of Jupiter in radians, at time t expressed in TDB Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_saturn","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_saturn","text":"fa_mlon_saturn(t::Number)\n\nReturn the mean heliocentric longitude of Saturn in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_uranus","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_uranus","text":"fa_mlon_uranus(t::Number)\n\nReturn the mean heliocentric longitude of Uranus in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_neptune","page":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_neptune","text":"fa_mlon_neptune(t::Number)\n\nReturn the mean heliocentric longitude of Neptune in radians, at time t expressed in TDB  Julian centuries since J2000. \n\nReferences\n\nLuzum, B. and Petit G. (2012). The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#Precession","page":"Low-level API","title":"Precession","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.frame_bias\nOrient.fw_angles\nOrient.fw_matrix\nOrient.precession_angles\nOrient.precession_rate","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.frame_bias","page":"Low-level API","title":"FrameTransformations.Orient.frame_bias","text":"frame_bias(::IAU2000Model)\n\nCompute the frame bias components of the IAU 2000 precession-nutation models, in radians.\n\nNotes\n\nThe frame bias corrections in longitude and obliquity are required to correct for the  offset between the GCRS pole and the mean J2000 pole. They define, with respect  to the GCRS axes, a J2000 mean pole that is consistent with teh IAU 2000A precession-nutation  model. \nThe function also returns an offset in right ascension taken from Chapront et al. (2002), necessary to completely describe the frame bias, but that is not part of the original IAU  2000A model.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fw_angles","page":"Low-level API","title":"FrameTransformations.Orient.fw_angles","text":"fw_angles(m::IAU2006Model, t::Number)\n\nCompute the precession angles in radians, following the IAU 2006 Fukushima-Williams 4-angle  formulation at time t expressed in TT Julian centuries since J2000.\n\nOutputs\n\nγ – F-W 1st angle\nϕ – F-W 2nd angle\nψ – F-W 3rd angle   \nε – F-W 4th angle\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fw_matrix","page":"Low-level API","title":"FrameTransformations.Orient.fw_matrix","text":"fw_matrix(γ, ϕ, ψ, ε)\n\nForm the Nutation-Precession-Bias (NPB) rotation matrix given the Fukushima-Williams angles,  expressed in radians.\n\nThe present function can construct three different matrices depending on which angles are  supplied as arguments: \n\nNPB: To obtain the Nutation-Precession-Bias matrix, generate the four standard FW    precession angles (̄γ, ̄ϕ, ̄ψ, ϵₐ) then generate the nutation components Δψ and Δϵ and add them    to ̄ψ, ϵₐ. Finally, call the present functions using those four angles as arguments. \nPB: To obtain the precession-frame bias matrix, generate the four standard FW precession    angles and call the present function. \nB: To obtain the frame bias matrix, generate the four standard FW precession angles at    date J2000.0 and call this function.\n\nThe remaining nutation-only and precession only matrices can be obtained by combining these  three appropriately. \n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.precession_angles","page":"Low-level API","title":"FrameTransformations.Orient.precession_angles","text":"precession_angles(m::IAU1980Model, t::Number)\n\nCompute the precession angles from Lieske et al. 1977 model, in radians, at time t  expressed in TT Julian centuries since J2000.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.precession_rate","page":"Low-level API","title":"FrameTransformations.Orient.precession_rate","text":"precession_rate(m::IAU2000Model, t::Number)\n\nCompute the precession-rate part of the IAU 2000 precession-nutation models, in radians, at  time t expressed as TT Julian centuries since J2000.\n\nReferences\n\nERFA software library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#IERS-Routines","page":"Low-level API","title":"IERS Routines","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.bpn2xy\nOrient.cip_coords\nOrient.cio_locator\nOrient.cip_motion\nOrient.earth_rotation_angle\nOrient.earth_rotation_rate \nOrient.era_rotm\nOrient.fw2xy\nOrient.tio_locator\nOrient.polar_motion\nOrient.xys2m","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.bpn2xy","page":"Low-level API","title":"FrameTransformations.Orient.bpn2xy","text":"bpn2xy(A::AbstractMatrix)\n\nCompute the CIP X and Y coordinates from the bias-precession-nutation matrix, in radians.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cip_coords","page":"Low-level API","title":"FrameTransformations.Orient.cip_coords","text":"cip_coords(m::IAUModel, t::Number)\n\nComputes the CIP X, Y coordinates, in radians, according to the IAU model m at time t  expressed in TT Julian Centuries since J2000.\n\nThis function has been implemented for the IAU2000, IAU2006 and the CPN models.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cio_locator","page":"Low-level API","title":"FrameTransformations.Orient.cio_locator","text":"cio_locator(m::IAUModel, t::Number, x::Number, y::Number)\n\nCompute the CIO Locator s in radians, according to the IAU Model m, given the CIP  coordinates X and Y at time t expressed in TT Julian centuries since J2000\n\nThe function has been implemented for the IAU2000, IAU2006 and the CPN models.\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\nERFA library\nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.cip_motion","page":"Low-level API","title":"FrameTransformations.Orient.cip_motion","text":"cip_motion(m::IAUModel, t::Number, dx::Number=0.0, dy::Number=0.0)\n\nCompute the CIRS to GCRS rotation matrix, according to the IAU Model m, at time t expressed in TT Julian centuries since J2000. Optional IERS corrections for  free-core nutation and time depedented effects can be provided through dx and dy. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_angle","page":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_angle","text":"earth_rotation_angle(t::Number)\n\nCompute the Earth Rotation Angle (ERA) in radians, i.e., the angle between the Celestial  Intermediate Origin (CIO) and the Terrestrial Intermediate Origin (TIO) at time t  expressed as UT1 days since J2000.\n\nnote: Note\nThe function uses the fractional UT1 date to gain additional precision in the  computations (0.002737.. instead of 1.002737..)\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_rate","page":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_rate","text":"earth_rotation_rate()\n\nCompute the nominal Earth angular velocity. \n\n\n\n\n\nearth_rotation_rate(LOD::Number)\n\nCompute the true angular velocity of the Earth accounting for the Length of the Day, i.e.,  the instantaneous rate of change of UT1 with respect to a uniform time scale. \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.era_rotm","page":"Low-level API","title":"FrameTransformations.Orient.era_rotm","text":"era_rotm(t::Number)\n\nCompute the TIRS to CIRS Earth Rotation matrix, according to the IERS 2010  conventions at time t expressed as UT1 days since J2000.\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.fw2xy","page":"Low-level API","title":"FrameTransformations.Orient.fw2xy","text":"fw2xy(ϵ::Number, ψ::Number, γ::Number, φ::Number)\n\nCompute the CIP X and Y coordinates from Fukushima-Williams bias-precession-nutation  angles, in radians.\n\nInputs\n\nϵ – F-W angle with IAU 2006A/B nutation corrections. \nψ – F-W angle with IAU 2006A/B nutation corrections.\nγ – F-W angle  \nϕ – F-W angle\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.tio_locator","page":"Low-level API","title":"FrameTransformations.Orient.tio_locator","text":"tio_locator(t::Number)\n\nCompute the TIO locator s' at date, positioning the Terrestrial Intermediate Origin on  the equator of the Celestial Intermediate Pole (CIP) at time t expressed as TT Julian  centuries since J2000. \n\nThis function approximates the unpredictable motion of the TIO locator s' with its secular  drift of ~0.47 μas/century. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nLambert, S. and Bizouard C. (2002), Positioning the Terrestrial Ephemeris Origin in the  Terrestrial Reference Frame, DOI: 10.1051/0004-6361:20021139\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.polar_motion","page":"Low-level API","title":"FrameTransformations.Orient.polar_motion","text":"polar_motion(t::Number, xₚ::Number, yₚ::Number)\n\nCompute the Polar Motion rotation matrix from ITRF to TIRS, according to the  IERS 2010 Conventions, at time t expressed in TT Julian centuries since J2000.  The function requires xp and yp, the Celestial Intermediate Pole (CIP) coordinates with  respect to the International Celestial Reference Frame (ITFR).\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.xys2m","page":"Low-level API","title":"FrameTransformations.Orient.xys2m","text":"xys2m(x::Number, y::Number, s::Number)\n\nCompute the Intermediate-to-Celestial matrix given the CIP x, y' coordinates and the CIO  locators`, all in radians.\n\nReferences\n\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA library\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#EOP-Data","page":"Low-level API","title":"EOP Data","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.EOPData\nOrient.get_iers_eop\nOrient.get_iers_eop_IAU2000A\nOrient.offset_utc2ut1","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.EOPData","page":"Low-level API","title":"FrameTransformations.Orient.EOPData","text":"EOPData{T}\n\nEOP Data for IAU 2000A.\n\nnote: Note\nEach field will be an AbstractInterpolation indexed by the Julian Day.\n\nFields\n\nx, y: Polar motion with respect to the crust [arcsec].\nUT1_UTC: Irregularities of the rotation angle [s].\nLOD: Length of day offset [ms].\ndX, dY: Celestial pole offsets referred to the model IAU2000A [milliarcsec].\n\n\n\n\n\n","category":"type"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.get_iers_eop","page":"Low-level API","title":"FrameTransformations.Orient.get_iers_eop","text":"get_iers_eop(; force_download = false)\n\nDownload and parse the IERS EOP C04 data. \n\nThe files are downloaded using the RemoteFile package with weekly updates. Hence, if one  desires to force a download before the scheduled time, then set the keyword force_download   to true.\n\nnote: Note\nThe files will be downloaded from the default URL. If the user want to use another one, then use the specialized function get_iers_eop_IAU2000ASee also: get_iers_eop_IAU2000A\n\nReturns\n\nA structure EOPData with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to Julian days since J2000.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.get_iers_eop_IAU2000A","page":"Low-level API","title":"FrameTransformations.Orient.get_iers_eop_IAU2000A","text":"get_iers_eop_iau_2000A(url::String=\"https://datacenter.iers.org/data/csv/finals2000A.all.csv\"; \n    force_download = false)\n\nGet the IERS EOP C04 IAU2000A data from the URL url.\n\nIf url is omitted, then it defaults to https://datacenter.iers.org/data/csv/finals2000A.all.csv. The file is downloaded using the RemoteFile package with weekly updates. Hence, if one desires  to force a download before the scheduled time, then set the keyword force_download to true.\n\nnote: Note\nThe interpolation of every field in EOPData between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation).\n\nSee also: get_iers_eop\n\nReturns\n\nThe structure EOPData with the interpolations of the EOP parameters. Notice that the  interpolation indexing is set to Julian days since J2000.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.offset_utc2ut1","page":"Low-level API","title":"FrameTransformations.Orient.offset_utc2ut1","text":"offset_utc2ut1(seconds)\n\nReturn the offset between UTC and UT1 in seconds.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_lapi/#Transformations","page":"Low-level API","title":"Transformations","text":"","category":"section"},{"location":"Modules/orient_lapi/","page":"Low-level API","title":"Low-level API","text":"Orient.orient_rot3_icrf_to_mememod","category":"page"},{"location":"Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_mememod","page":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_mememod","text":"orient_rot3_icrf_to_mememod(t::Number)\n\nCompute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Mean Equinox Mean Equator of Date at time t, expressed in TT seconds since J2000.\n\n\n\n\n\n","category":"function"},{"location":"benchmarks/#Performance-Benchmarks","page":"Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"A comparative analysis of the execution times of various routines of this package against  other state-of-the-art packages and libraries is here reported. ","category":"page"},{"location":"benchmarks/#IERS-Rotation-Models","page":"Benchmarks","title":"IERS Rotation Models","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The Orient sub-module provides the capability to compute high-accuracy Earth rotation models based on the IERS 2010 conventions. However, differently from traditional packages, it leverages Julia's metaprogramming capabilities to generate optimised functions for the computation of the lengthy 2000A/B nutation series. A comparison against both ERFA.jl and SatelliteToolbox.jl is here reported.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/assets/85893254/1bbd17b6-c487-487a-8f24-99bc671eeabf\" width = \"512\" /> \n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: Details\nThese time benchmarks have been obtained on an Intel Core i7-6700 @ 3.4 GHz with 16 GB of RAM","category":"page"},{"location":"benchmarks/#Relative-Orientation","page":"Benchmarks","title":"Relative Orientation","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Frames' performance have been tested against both GODOT and SPICE.jl, two of the most-popular packages that can be used to define a system of reference axes and points and to compute the transformations between them. In particular, a comparative analysis of the execution times for computing the relative orientation between different reference axes has been carried out across four distinct scenarios: ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Case 1: From ICRF to the ECLIPJ2000 frame, a time-fixed rotation. \nCase 2: From the IAU-MOON to the ICRF, a time-dependent rotation. \nCase 3: From the IAU-MOON to the ICRF and subsequently to the IAU_EARTH. \nCase 4: From the IAU-MOON, to the ICRF, to the ECLIPJ2000 and finally a shift to the Sun-Earth rotating two-vector frame. Notice that the Sun and Earth positions are retrieved from binary ephemeris kernels.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"<p align=\"center\">\n<img src=\"https://github.com/JuliaSpaceMissionDesign/FrameTransformations.jl/assets/85893254/c8688165-728b-4053-9912-f5ac973e892d\" width = \"512\" /> \n</p>","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"details: Details\nThese time benchmarks have been obtained on an Intel Core i7-12700 @ 4.7 GHz with 32 GB of RAM","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This figure also underlines the capability of FrameTransformations (here referred to as Multiverse) to use different ephemeris readers as backends within the computational graph.","category":"page"},{"location":"benchmarks/#Relative-States","page":"Benchmarks","title":"Relative States","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"note: Note\nWork in progress","category":"page"},{"location":"Modules/utils_api/#basic_utils_api","page":"Public API","title":"Utils's Public Documentation","text":"","category":"section"},{"location":"Modules/utils_api/#TPC","page":"Public API","title":"TPC","text":"","category":"section"},{"location":"Modules/utils_api/","page":"Public API","title":"Public API","text":"TPC \nload","category":"page"},{"location":"Modules/utils_api/#FrameTransformations.Utils.TPC","page":"Public API","title":"FrameTransformations.Utils.TPC","text":"TPC <: JSMDInterfaces.FilesIO.AbstractFile\n\nA type representing TPC files.\n\n\n\n\n\n","category":"type"},{"location":"Modules/utils_api/#JSMDInterfaces.FilesIO.load","page":"Public API","title":"JSMDInterfaces.FilesIO.load","text":"load(file::TPC{1})\n\nOpen a JPL ASCII .tpc file and parse its data in a dictionary.\n\n\n\n\n\nload(files::TPC)\n\nOpen a group of JPL ASCII .tpc files and parse their data in a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_api/#Math","page":"Public API","title":"Math","text":"","category":"section"},{"location":"Modules/utils_api/","page":"Public API","title":"Public API","text":"skew","category":"page"},{"location":"Modules/utils_api/#FrameTransformations.Utils.skew","page":"Public API","title":"FrameTransformations.Utils.skew","text":"skew(a)\n\nCreate a skew matrix from the first three elements of a.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_api/#Geodesy","page":"Public API","title":"Geodesy","text":"","category":"section"},{"location":"Modules/utils_api/","page":"Public API","title":"Public API","text":"geoc2pos\npos2geoc\ngeod2pos\npos2geod","category":"page"},{"location":"Modules/utils_api/#FrameTransformations.Utils.geoc2pos","page":"Public API","title":"FrameTransformations.Utils.geoc2pos","text":"geoc2pos(r::Number, λ::Number, ϕ::Number)\ngeoc2pos(geoc::AbstractArray)\n\nTransform geocentric coordinates in a cartesian position vector, given the longitude λ,  the geocentric latitude ϕ and the radius r.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_api/#FrameTransformations.Utils.pos2geoc","page":"Public API","title":"FrameTransformations.Utils.pos2geoc","text":"pos2geoc(pos::AbstractVector)\n\nTransform a cartesian 3-elements position vector pos into radius, longitude and geocentric  latitude, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_api/#FrameTransformations.Utils.geod2pos","page":"Public API","title":"FrameTransformations.Utils.geod2pos","text":"geod2pos(h::Number, λ::Number, ϕ::Number, R::Number, f::Number)\n\nTransform longitude λ, geodetic latitude ϕ and altitude over the reference ellipsoid to  a cartesian position vector, given the reference radius R and the flattening f.\n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_api/#FrameTransformations.Utils.pos2geod","page":"Public API","title":"FrameTransformations.Utils.pos2geod","text":"pos2geod(pos::AbstratVector, R::Number, f::Number, toll::Number=1e-12)\n\nTransform a cartesian 3-elements position vector pos into longitude, geodetic latitude  and altitude over the reference ellipsoid with radius R and flattening f. \n\nReferences\n\nVallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA.\n\n\n\n\n\n","category":"function"},{"location":"roadmap/#Development-Roadmap","page":"Roadmap","title":"Development Roadmap","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"The following table reports the desired list of features considered in the development of  this package, together with their development status. The following color legend is used: ","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":" Description\n🔵 Stable, deeply tested\n🟢 Developed, working, partially tested\n🟡 In development\n🔴 Development not started but planned\n⚪ Outdated/no more supported","category":"page"},{"location":"roadmap/#Frames","page":"Roadmap","title":"Frames","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"All the initially desired features of Frames have been implemented. We are currently working  to avoid undesired allocations when using dual numbers.","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\" style=\"width:40%\">Feature</th>\n    <th class=\"tg-fymr\" style=\"width:10%\">Status</th>\n    <th class=\"tg-fymr\" style=\"width:50%\">Comment</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create a graph of custom points.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Points could be defined in different ways (not only associated to ephemeris).</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create a graph of custom axes.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Axes models for MEME2000, ITRF, IAU models and many others are already implemented and tested within FrameTransformationsFrameTransformations.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Get a state of a point relative to another in a custom frame.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against NAIF's SPICE.</td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">\n        Full compatibility with ForwardDiff.jl shall be assured.\n    </td>\n    <td class=\"tg-0pky\">🟡</td>\n    <td class=\"tg-0pky\">Partial compatibility is already available. We are resolving the \n    last issues related to undesired allocations when using dual numbers. </td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"roadmap/#Orient","page":"Roadmap","title":"Orient","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"All the features of the Orient submodule have been developed and tested. No major updates are currently foreseen.","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\" style=\"width:40%\">Feature</th>\n    <th class=\"tg-fymr\" style=\"width:10%\">Status</th>\n    <th class=\"tg-fymr\" style=\"width:50%\">Comment</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create IAU standard-based body-fixed rotation matrices.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against NAIF's SPICE.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Create ITRF (IERS-based) rotation matrices.\n    </td>\n    <td class=\"tg-0pky\">🔵</td>\n    <td class=\"tg-0pky\">Deeply tested against ERFA. Models with different precisions are available.</td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">\n        Fetch automatically IERS EOP.\n    </td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">\n        Fetch leapseconds files automatically.\n    </td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\"></td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"roadmap/#Utils","page":"Roadmap","title":"Utils","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"The initial development plan foresaw the possibility to automatically generate a frame system by parsing NASA JPL frame kernels. Although this capability is still desired within the JSMD ecosystem, we are currently re-evaluating whether it should be implemented within this package. Additionally, part of the math routines that are here available will be moved in the dedicated JSMDUtils.jl package.","category":"page"},{"location":"roadmap/","page":"Roadmap","title":"Roadmap","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\" style=\"width:40%\">Feature</th>\n    <th class=\"tg-fymr\" style=\"width:10%\">Status</th>\n    <th class=\"tg-fymr\" style=\"width:50%\">Comment</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">Read JPL ASCII PCK files (constants).</td>\n    <td class=\"tg-0pky\">🟢</td>\n    <td class=\"tg-0pky\">Fully implemented in FrameTransformations. Tested on NAIF's pck00010 and pck00011 files.</td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">Refactor math functions in JSMDUtils.</td>\n    <td class=\"tg-0pky\">🔴</td>\n    <td class=\"tg-0pky\">Soon planned.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Read NASA JPL frame kernels.</td>\n    <td class=\"tg-0pky\">⚪</td>\n    <td class=\"tg-0pky\">Might be implemented in a different package.</td>\n  </tr>\n  <tr>\n    <td class=\"tg-0pky\">Write NASA JPL frame kernels</td>\n    <td class=\"tg-0pky\">⚪</td>\n    <td class=\"tg-0pky\">Might be implemented in a different package.</td>\n  </tr>\n\n</tbody>\n</table>","category":"page"},{"location":"Tutorials/t04_hifi/#tutorial_04_hifi","page":"05 - Use Case: High Fidelity","title":"Use Case: High Fidelity","text":"","category":"section"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"Once the general structure of the FrameSystem is understood, we can pass to a use case in which we want to build and exploit our frame system to perform computations in a high-fidelity environment. ","category":"page"},{"location":"Tutorials/t04_hifi/#Frame-system-setup","page":"05 - Use Case: High Fidelity","title":"Frame system setup","text":"","category":"section"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"In this example, we plan on using ephemeris data to retrieve accurate positions of the planets and the orientation of certain reference frames. Therefore, we create an ephemeris provider object leveraging our own Ephemerides.jl package and use it to generate a frame system instance:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using FrameTransformations\nusing Downloads","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using Ephemerides, Downloads\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)])\n\nFRAMES = FrameSystem{3, Float64}(eph)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"Once the graph is created, we assign the GCRF (Geocentric Celestial Reference Frame) as our set of inertial root-axes:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using FrameTransformations\n\nFRAMES = FrameSystem{3, Float64}()","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@axes GCRF 1 GeocentricCelestialReferenceFrame\nadd_axes_inertial!(FRAMES, GCRF)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"These axes are practically coincident with the ICRF. To do so, we can leverage the possibility to define multiple aliases that are associated to the same integer ID. Thus let's create an alias of the GCRF and call it ICRF: ","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@axes ICRF 1 InternationalCelestialReferenceFrame","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"In this scenario, we will be working within the Cislunar environment, therefore we will need the major bodies that influence this dynamic regime, i..e, the Earth, the Moon and the Sun. To do so, we also define the Solar System Barycenter (SSB) and the Earth-Moon Barycenter (EMB) as the ephemeris data of the remaining bodies is expressed with respect to those. ","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"For this example, we will assume the SSB is our root point:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using FrameTransformations\nusing Ephemerides, Downloads\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)])\n\nFRAMES = FrameSystem{3, Float64}(eph)\n\n@axes GCRF 1 GeocentricCelestialReferenceFrame\n@axes ICRF 1 InternationalCelestialReferenceFrame\nadd_axes_inertial!(FRAMES, GCRF)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@point SSB 0 \n@point EMB 3\n@point Sun 10 \n@point Earth 399 \n@point Moon 301 \n\nadd_point_root!(FRAMES, SSB, GCRF)\nadd_point_ephemeris!(FRAMES, EMB)\nadd_point_ephemeris!(FRAMES, Earth)\nadd_point_ephemeris!(FRAMES, Moon)\nadd_point_ephemeris!(FRAMES, Sun)","category":"page"},{"location":"Tutorials/t04_hifi/#Registering-body-fixed-axes","page":"05 - Use Case: High Fidelity","title":"Registering body-fixed axes","text":"","category":"section"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"At this point, we want to be able to transform back and forth from body-fixed axes of the Earth  and the Moon to the GCRF. The Earth and the Moon cases are actually special cases because  they have both high-accuracy and low-precision body-fixed rotation models. ","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"Let's start with the low precision ones: IAU_EARTH and IAU_MOON. To register such frames,  we first need to parse a TPC file with the required constants:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"tpc = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/pck00011.tpc\";\niau = load(TPC(Downloads.download(tpc)));","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"At this point, we leverage the high-level interface provided by this package to automatically  generates ad-hoc functions from the IAU Rotational Elements via the add_axes_bcrtod! function. In particular, these axes are Body-Centric Rotating, True-of-Date axes, or BCR-TOD (which  are the FrameTransformations way of representing SPICE IAU_XXX axes).","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using FrameTransformations, Downloads\ntpc = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/pck00011.tpc\"\niau = load(TPC(Downloads.download(tpc)));\n\n@axes GCRF 1 \n@axes ICRF 1\n@point Earth 399 \n@point Moon 301\n\nFRAMES = FrameSystem{2, Float64}()\n\nadd_axes_inertial!(FRAMES, ICRF)\n\nadd_point_root!(FRAMES, Earth, ICRF)\nadd_point_fixed!(FRAMES, Moon, Earth, ICRF, [0.0, 0.0, 0.0])","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@axes IAU_EARTH 3 \n@axes IAU_MOON 4\n\nadd_axes_bcrtod!(FRAMES, iau, Earth, IAU_EARTH, ICRF);\nadd_axes_bcrtod!(FRAMES, iau, Moon, IAU_MOON, ICRF);","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"The registration of this type of axes requires either an alias or the ID of the point associated to the body.","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"For convenience, let us also insert a set of inertial axes for the Moon. This can be done using the IAU-based Body-Centric Inertial J2000 axes available through the add_axes_bci2000! function, which defines a rotation from the ICRF to the local equatorial plane of the body at the J2000 epoch.","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@axes LME2000 5\n\nadd_axes_bci2000!(FRAMES, iau, Moon, LME2000, ICRF);","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"Finally, we complete the axes definition by inserting the high-precision Earth and Lunar body-fixed rotation models.  For this purpose, FrameTransformations provides two high-level functions that can be used to ease these definitions:  add_axes_itrf! and add_axes_pa421!.","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@axes ITRF 6 \n@axes MOONPA_DE421 31006 \n\nadd_axes_itrf!(FRAMES, ITRF, GCRF)\nadd_axes_pa421!(FRAMES, MOONPA_DE421, ICRF)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"The default ITRF model is the iau2006b, but other approximations are also available. If one was interested in the Moon's PA440 axes, a similar function named add_axes_pa440! is available.","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"note: Note\nTo correctly use the add_axes_pa421! function, the frame system must contain an ephemeris provider that has loaded the necessary PCK kernels with the DE421 data.","category":"page"},{"location":"Tutorials/t04_hifi/#Using-the-FrameSystem","page":"05 - Use Case: High Fidelity","title":"Using the FrameSystem","text":"","category":"section"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"Now let's assume we have a spacecraft in orbit about the Moon in the LME2000 axes, and we want to compute its position in the GCRF and with respect to both the Moon and the Earth surface. We then start by registering our spacecraft as an updatable point:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using FrameTransformations \n@point Moon 301 \n@axes LME2000 5\n\nFRAMES = FrameSystem{2, Float64}()\n\nadd_axes_inertial!(FRAMES, LME2000)\nadd_point_root!(FRAMES, Moon, LME2000)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"@point SC -1_900_000\nadd_point_updatable!(FRAMES, SC, Moon, LME2000)\n","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"Therefore our final FrameSystem results in:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"using FrameTransformations\nusing Ephemerides, Downloads\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)])\n\ntpc = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/pck00011.tpc\"\niau = load(TPC(Downloads.download(tpc)));\n\n@axes GCRF 1 GeocentricCelestialReferenceFrame\n@axes ICRF 1 InternationalCelestialReferenceFrame\n\n@axes IAU_EARTH 3 \n@axes IAU_MOON 4\n@axes LME2000 5\n@axes ITRF 6 \n@axes MOONPA_DE421 31006 \n\n@point SSB 0 \n@point EMB 3\n@point Sun 10 \n@point Earth 399 \n@point Moon 301 \n\n@point SC -1_900_000\n\nFRAMES = FrameSystem{3, Float64}(eph)\n\nadd_axes_inertial!(FRAMES, GCRF)\n\nadd_point_root!(FRAMES, SSB, GCRF)\nadd_point_ephemeris!(FRAMES, EMB)\nadd_point_ephemeris!(FRAMES, Earth)\nadd_point_ephemeris!(FRAMES, Moon)\nadd_point_ephemeris!(FRAMES, Sun)\n\nadd_axes_bcrtod!(FRAMES, iau, Earth, IAU_EARTH, ICRF);\nadd_axes_bcrtod!(FRAMES, iau, Moon, IAU_MOON, ICRF);\nadd_axes_bci2000!(FRAMES, iau, Moon, LME2000, ICRF);\n\nadd_axes_itrf!(FRAMES, ITRF, GCRF)\nadd_axes_pa421!(FRAMES, MOONPA_DE421, ICRF)\n\nadd_point_updatable!(FRAMES, SC, Moon, LME2000)\n\ne = Epoch(\"2020-01-01T12:45:30.0 TDB\");\nx = [2274.0, 0.0, 0.0, 0.0, sqrt(4904.87/2274.0), 0.0];\nupdate_point!(FRAMES, SC, x, e)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"FRAMES ","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"To begin exploiting our newly completed frame system, we assumed that our SC is on a circular equatorial orbit around the Moon at an altitude of 500 km, so that at the epoch e, the spacecraft state vector is updated as:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"e = Epoch(\"2020-01-01T12:45:30.0 TDB\");\nx = [2274.0, 0.0, 0.0, 0.0, sqrt(4904.87/2274.0), 0.0];\n\nupdate_point!(FRAMES, SC, x, e)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"note: Note\nThe timescale used for the Epoch must be the same used in the FrameSystem.","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"At this point, we are completely free to compute the state of the spacecraft with respect to any other point registered in the frame system with respect to any known set of axes at the epoch e. For example, the state in the LME2000 is: ","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"vector6(FRAMES, Moon, SC, LME2000, e)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"The spacecraft state with respect to the Earth in the GCRF, IAU_EARTH and ITRF is instead:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"vector6(FRAMES, Earth, SC, GCRF, e)\nvector6(FRAMES, Earth, SC, IAU_EARTH, e)\nvector6(FRAMES, Earth, SC, ITRF, e)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"while the position with respect to the Moon in the IAU_MOON and PA421 axes:","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"vector3(FRAMES, Moon, SC, IAU_MOON, e)\nvector3(FRAMES, Moon, SC, MOONPA_DE440, e)","category":"page"},{"location":"Tutorials/t04_hifi/","page":"05 - Use Case: High Fidelity","title":"05 - Use Case: High Fidelity","text":"These last examples are intended to show how easily the state of a spacecraft with respect to any other body can be retrieved by properly leveraging the [FrameSystem] and the high-level routines provided by this package. ","category":"page"},{"location":"Modules/frames_api/#basic_frames_api","page":"Public API","title":"Frames's Public Documentation","text":"","category":"section"},{"location":"Modules/frames_api/#Frame-System","page":"Public API","title":"Frame System","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"FrameSystem","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.FrameSystem","page":"Public API","title":"FrameTransformations.Frames.FrameSystem","text":"FrameSystem{O, T, S, E}\n\nA FrameSystem instance manages a collection of user-defined FramePointNode and  FrameAxesNode objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order O, the outputs  datatype T and an AbstractTimeScale instance S. Additionally, an AbstractEphemerisProvider  instance E can be provided to compute transformations that require ephemeris data. \n\nThe following transformation orders are accepted: \n\n1: position \n2: position and velocity \n3: position, velocity and acceleration\n4: position, velocity, acceleration and jerk\n\nBy specifying the maximum transformation the FrameSystem memory usage and performance can  be optimised and tailored to the user's needs.\n\n\n\nFrameSystem{O, T}()\n\nCreate a FrameSystem object of order O and datatype T. The BarycentricDynamicalTime  is automatically assigned as the default time scale. The resulting object is constructed  with a NullEphemerisProvider, which does not allow the computation of transformation that  involve ephemeris files.\n\nExamples\n\njulia> F = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> rotation6(F, ICRF, ECLIPJ2000, 0.0)\nRotation{2, Float64}\n[...]\n\njulia> rotation9(F, ICRF, ECLIPJ2000, 0.0)\nERROR: Insufficient frame system order: transformation requires at least order 3.\n\n\n\n\nFrameSystem{O, T, S}()\n\nCreate a FrameSystem object of order O, datatype T and time scale S. The resulting  object is constructed with a NullEphemerisProvider, which does not allow the computation  of transformation that involve ephemeris files.\n\nExamples\n\njulia> F = FrameSystem{1, Float64, TerrestrialTime}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> ep_tt = Epoch(\"2023-02-10T12:00:00 TT\")\n2023-02-10T12:00:00.000 TT\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tt)\nRotation{1,Float64}([...])\n\njulia> ep_tdb = Epoch(\"2023-02-10T12:00:00 TDB\")\n2023-02-10T12:00:00.000 TDB\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tdb)\nERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.\n[...]\n\n\n\nFrameSystem{O, T}(eph::AbstractEphemerisProvider)\n\nCreate a FrameSystem object of order O and datatype T by providing an instance of an  AbstractEphemerisProvider subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in eph. This constructor shall be used when the user desires  to compute transformations that involve ephemeris data. \n\nnote: Note\nAll the kernels that will be used must be loaded within eph. Once the FrameSystem  has been created, no additional kernel can be added nor removed.\n\nExamples\n\njulia> eph = CalcephProvider(DE440_KERNEL_PATH)\nCalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0))\n\njulia> F = FrameSystem{2, Float64}(eph)\nFrameSystem{2, Float64, BarycentricDynamicalTime, CalcephProvider}(\n  eph: CalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0)),\n  points: EMPTY\n  axes: EMPTY\n)\n\nSee also\n\nSee also add_axes_inertial!, add_point_root!, vector3 and rotation3\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_api/#Axes","page":"Public API","title":"Axes","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"@axes\naxes_alias\n\nis_inertial\nis_timefixed\n\nComputableAxesVector\n\nadd_axes_bci2000!\nadd_axes_bcrtod!\nadd_axes_computable!\nadd_axes_eclipj2000!\nadd_axes_ephemeris!\nadd_axes_fixedoffset!\nadd_axes_inertial!\nadd_axes_itrf!\nadd_axes_me421!\nadd_axes_meme2000!\nadd_axes_mememod!\nadd_axes_pa421!\nadd_axes_pa440!\nadd_axes_projected!\nadd_axes_rotating!\nadd_axes_topocentric!\n","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.@axes","page":"Public API","title":"FrameTransformations.Frames.@axes","text":"@axes(name, id, type=nothing)\n\nDefine a new axes instance to alias the given id. This macro creates an  AbstractFrameAxes subtype and its singleton instance callen name. Its type name  is obtained by appending Axes to either name or type (if provided). \n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> typeof(ICRF)\nInternationalCelestialReferenceFrameAxes\n\njulia> axes_alias(ICRF) \n1\n\njulia> @axes IAU_EARTH 10013\n\njulia> typeof(IAU_EARTH)\nIauEarthAxes\n\nSee also\n\nSee also @point and axes_alias.\n\n\n\n\n\n","category":"macro"},{"location":"Modules/frames_api/#FrameTransformations.Frames.axes_alias","page":"Public API","title":"FrameTransformations.Frames.axes_alias","text":"axes_alias(ax::AbstractFrameAxes)\n\nReturn the axes ID. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.is_inertial","page":"Public API","title":"FrameTransformations.Frames.is_inertial","text":"is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)\nis_inertial(frame::FrameSystem, axesid::Int)\n\nReturn true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes.\n\nnote: Note\nFixedOffsetAxes with respect to an inertial set of axes, are also consired inertial.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.is_timefixed","page":"Public API","title":"FrameTransformations.Frames.is_timefixed","text":"is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)\nis_timefixed(frame::FrameSystem, axesid::Int)\n\nReturn true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes. \n\nnote: Note\nOnly :InertialAxes and :FixedOffsetAxes defined with respect to other inertial axes  are here considered as time fixed. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.ComputableAxesVector","page":"Public API","title":"FrameTransformations.Frames.ComputableAxesVector","text":"ComputableAxesVector(from, to, order::Int)\n\nStore the properties required to retrieve the i-th order components of a  desired vector. Arguments from and to are the NAIFIDs or AbstractFramePoint instances  that define the observer and target points.\n\nOnly orders between 1 and 3 are supported.\n\nExample\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> ComputableAxesVector(SSB, Sun, 1)\nComputableAxesVector(0, 10, 1)\n\njulia> ComputableAxesVector(0, 10, 1)\nComputableAxesVector(0, 10, 1)\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_bci2000!","page":"Public API","title":"FrameTransformations.Frames.add_axes_bci2000!","text":"add_axes_bci2000!(frames::FrameSystem{O, T}, \n    data::AbstractDict, center::AbstractFramePoint, \n    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O}\n\nInsert Body-Centered Inertial (BCI) axes at J2000 relative to the body center to the  frames system.\n\nInput/s\n\nframes - The frame system to which the new frame will be added.\ndata - A dictionary containing a parsed TPC file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data.\ncenter: The center point of the new axes.\naxes: The new axes to be added to the frame system.\nparent: The parent axes of the new ones.\n\nwarning: Warning\nThe parent set of axes must be the International Celestial Reference Frame (ICRF).  If the parent set of axes is not ICRF, an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_bcrtod!","page":"Public API","title":"FrameTransformations.Frames.add_axes_bcrtod!","text":"add_axes_bcrtod!(frames::FrameSystem{O, T}, \n    data::AbstractDict, center::AbstractFramePoint, \n    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O}\n\nInsert a Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the frames system.\n\nInput/s\n\nframes - The frame system to which the new frame will be added.\ndata - A dictionary containing a parsed TPC file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data.\ncenter: The center point of the new axes.\naxes: The new axes to be added to the frame system.\nparent: The parent axes of the new ones.\n\nnote: Note\nThe axes constructed here corresponds to the SPICE IAU_<BODY_NAME> frames. \n\nwarning: Warning\nThe parent set of axes must be the International Celestial Reference Frame (ICRF).  If the parent set of axes is not ICRF, an error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_computable!","page":"Public API","title":"FrameTransformations.Frames.add_axes_computable!","text":"add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol)\n\nAdd axes as a set of computable axes to frames. Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE's parameterized two-vector frames. \n\nThese axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis. \n\nThe primary and secondary vectors, v1 and v2 are instances of ComputableAxesVector,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration). \n\nFor example, to define a primary vector that is parallel to the Sun's (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0), v1 must be set as:  v1 = ComputableAxesVector(10, 0, 1).\n\nseq is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are: :XY, :YX, :XZ, :ZX, :YZ and :ZY. \n\nGiven a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf's nadir direction and  velocity direction define the axes orientation.  \n\nnote: Note\nRegardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to parent.\n\nExamples\n\njulia> eph = CalcephProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{4, Float64}(eph);\n\njulia> @point SSB 0 SolarySystemBarycenter \n\njulia> @point Sun 10 \n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun, SSB)\n\njulia> @axes SunFrame 2\n\njulia> v1 = ComputableAxesVector(10, 0, 1)\nComputableAxesVector(10, 0, 1)\n\njulia> v2 = ComputableAxesVector(10, 0, 2)\nComputableAxesVector(10, 0, 2)\n\njulia> add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY)\n\nSee also\n\nSee also ComputableAxesVector, add_axes_fixedoffset!, add_axes_inertial!  and add_axes_computable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_eclipj2000!","page":"Public API","title":"FrameTransformations.Frames.add_axes_eclipj2000!","text":"add_axes_eclipj2000!(frames, axes, parent::AbstractFrameAxes, iau_model::IAUModel=iau1980)\n\nAdd axes as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to frames. The obliquity of the ecliptic is computed using the IAU Model iau_model.\n\nThe admissed parent set of axes are the following: \n\nICRF: for the International Celestial Reference Frame, with ID = 1\nMEME2000: the Mean Earth/Moon Ephemeris of J2000, with ID = 22\n\nwarning: Warning\nIf the name (or the axes ID) of the parent set of axes is neither ICRF (ID = 1) nor  MEME2000 (ID = 22), an error is thrown. \n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes ECLIPJ2000 17 EclipticEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF)\n\nSee also\n\nSee also add_axes_inertial! and Orient.DCM_ICRF_TO_J2000_BIAS\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_ephemeris!","page":"Public API","title":"FrameTransformations.Frames.add_axes_ephemeris!","text":"add_axes_ephemeris!(frames, axes, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd axes as a set of ephemeris axes to frames. The orientation of these axes is computed  with a series of 3 rotations specified by rot_seq. The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in frames. The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. This function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation.  The possible rot_seq values are: :XYX, XYZ, :XZX, :XZY, :YXY, :YXZ, :YZX,  :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ.\n\nAlternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives. \n\nThis operation is only possible if the ephemeris kernels loaded within frames contain  orientation data for the AXES ID associated to axes. An error is returned if the parent  axes ID is yet to be added to frames.\n\nwarning: Warning\nIt is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels.\n\nSee also\n\nSee also ComputableAxesVector, add_axes_fixedoffset!, add_axes_inertial!  and add_axes_computable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_fixedoffset!","page":"Public API","title":"FrameTransformations.Frames.add_axes_fixedoffset!","text":"add_axes_fixedoffset!(frames::FrameSystem{T}, axes, parent, dcm::DCM{T}) where T\n\nAdd axes as a set of fixed offset axes to frames. Fixed offset axes have a constant  orientation with respect to their parent axes, represented by dcm, a Direction Cosine Matrix (DCM).\n\n\n\nadd_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DMC{T}) where {T}\n\nAdd new axes name with id axesid to frames with a fixed-offset from parentid.  Low-level function.\n\nnote: Note\nWhile inertial axes do not rotate with respect to the star background, fixed offset axes are only  constant with respect to their parent axes, but might be rotating with respect to some other  inertial axes.\n\nExamples\n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z))\n\nSee also\n\nSee also add_axes_rotating!, add_axes_inertial! and add_axes_computable! \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_inertial!","page":"Public API","title":"FrameTransformations.Frames.add_axes_inertial!","text":"add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing)\n\nAdd axes as a set of inertial axes to frames. Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added, parent and dcm  become mandatory fields.\n\n\n\nadd_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing)\n\nAdd new axes name with id axesid to frames. Low-level function.\n\nnote: Note\nThe parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000)\nERROR: A set of parent axes for ECLIPJ2000 is required\n[...]\n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z))\n\nSee also\n\nSee also add_axes_rotating!, add_axes_fixedoffset! and add_axes_computable! \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_itrf!","page":"Public API","title":"FrameTransformations.Frames.add_axes_itrf!","text":"add_axes_itrf!(frames, axes, parent, model::Orient.IAU2006Model=Orient.iau2006b)\n\nAdd axes as a set of axes representing the International Terrestrial Reference Frame (ITRF) to frames. Only the :ICRF and :GCRF are accepted as parent axes. Use the model argument  to specify which IAU model model should be used for the computations. The default is set to  iau2006b.\n\nSee also\n\nSee also orient_rot3_itrf_to_gcrf\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_me421!","page":"Public API","title":"FrameTransformations.Frames.add_axes_me421!","text":"add_axes_me421!(frames, axes, parent)\n\nAdd axes as fixed offset axes representing the DE421 Moon's Mean Earth/Mean Rotation (ME)  to frames.\n\nThe parent set of axes can be either the DE440 Principal Axes (PA440) or the DE421  Principal Axes (PA421), otherwise an error is thrown. Depending on that, the relative axes  orientation will be automatically selected by this function. \n\nSee also\n\nSee also [`add_axes_pa440!`](@ref), and [`add_axes_pa421!`](@ref), \n[`Orient.DCM_MOON_PA421_TO_ME421`](@ref) and [`Orient.DCM_MOON_PA421_TO_ME421`](@ref),\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_meme2000!","page":"Public API","title":"FrameTransformations.Frames.add_axes_meme2000!","text":"add_axes_meme2000!(frames::, axes, parent::AbstractFrameAxes)\n\nAdd axes as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to frames. \n\nwarning: Warning\nThe name (or the axes ID) of the parent set of axes must be ICRF (i.e., the International  Celestial Reference Frame, ID = 1), or the ECLIPJ2000 (i.e., the Ecliptic Equinox of 7 J2000, ID = 17), otherwise and error is thrown.\n\nExamples\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_meme2000!(FRAMES, MEME2000, ICRF)\n\nSee also\n\nSee also add_axes_inertial! and Orient.DCM_ICRF_TO_J2000_BIAS\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_mememod!","page":"Public API","title":"FrameTransformations.Frames.add_axes_mememod!","text":"add_axes_mememod!(frames, axes, parent::AbstractFrameAxes, model::IAU2006Model=iau2006b)\n\nAdd axes as a set of projected axes representing the Mean of Date Ecliptic Equinox to  frames. \n\nnote: Note\nDespite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null.\n\nwarning: Warning\nThe name of the parent set of axes must be the ICRF or have ID = 1 (i.e., the  International Celestial Reference Frame), otherwise an error is thrown. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_pa421!","page":"Public API","title":"FrameTransformations.Frames.add_axes_pa421!","text":"add_axes_pa421!(frames, axes, parent)\n\nAdd axes as a set of ephemeris axes representing the DE421 Moon's Principal Axes (PA) to  frames. The libration angles are extracted from the ephemeris kernels loaded within frames,  an error is thrown if such orientation data is not available. \n\nThe parent set of axes must be named ICRF or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006).\n\nSee also\n\nSee also [`Orient.AXESID_MOONPA_DE421`](@ref), [`Orient.orient_icrf_to_pa421`](@ref), \n[`add_axes_pa440!`](@ref), and [`add_axes_me421!`](@ref)\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_pa440!","page":"Public API","title":"FrameTransformations.Frames.add_axes_pa440!","text":"add_axes_pa440!(frames, axes, parent)\n\nAdd axes as a set of ephemeris axes representing the DE440 Moon's Principal Axes (PA) to  frames. The libration angles are extracted from the ephemeris kernels loaded within frames,  an error is thrown if such orientation data is not available. \n\nThe parent set of axes must be named ICRF or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown.\n\nwarning: Warning\nTo properly read the ephemeris kernels, the ID associated to the input axes must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008).\n\nSee also\n\nSee also Orient.AXESID_MOONPA_DE440, Orient.orient_rot3_icrf_to_pa440,  add_axes_pa421!, and add_axes_me421!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_projected!","page":"Public API","title":"FrameTransformations.Frames.add_axes_projected!","text":"add_axes_projected!(frames, axes, parent, fun)\n\nAdd axes as a set of projected axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nProjected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time).\n\nwarning: Warning\nIt is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_rotating!","page":"Public API","title":"FrameTransformations.Frames.add_axes_rotating!","text":"add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) where T\n\nAdd axes as a set of rotating axes to frames. The orientation of these axes depends only  on time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a Direction Cosine Matrix (DCM).\nδfun: return the DCM and its 1st order time derivative.\nδ²fun: return the DCM and its 1st and 2nd order time derivatives\nδ³fun: return the DCM and its 1st, 2nd and 3rd order time derivatives\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed via automatic differentiation.\n\nwarning: Warning\nIt is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types. \n\nExamples\n\njulia> FRAMES = FrameSystem{3, Float64}();\n\njulia> @axes Inertial 1\n\njulia> add_axes_inertial!(FRAMES, Inertial)\n\njulia> @axes Synodic 2 \n\njulia> fun(t) = angle_to_dcm(t, :Z);\n\njulia> add_axes_rotating!(FRAMES, Synodic, Inertial, fun)\n\njulia> R = rotation6(FRAMES, Inertial, Synodic, π/6);\n\njulia> R[1]\nDCM{Float64}:\n  0.866025  0.5       0.0\n -0.5       0.866025  0.0\n  0.0       0.0       1.0\n\njulia> R[2]\nDCM{Float64}:\n -0.5        0.866025  0.0\n -0.866025  -0.5       0.0\n  0.0        0.0       0.0\n\nSee also\n\nSee also add_axes_fixedoffset!, add_axes_inertial! and add_axes_computable! \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_axes_topocentric!","page":"Public API","title":"FrameTransformations.Frames.add_axes_topocentric!","text":"add_axes_topocentric!(frames, axes, λ::Number, ϕ::Number, type::Symbol, parent)\n\nAdd axes as a set of fixed-offset topocentric axes to frames. The orientation relative  to the parent axes parent is defined throuh the longitude λ, the geodetic latitude ϕ  and the type type, which may be any of the following: \n\n:NED (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir.\n:SEZ (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith.\n:ENU (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith. \n\nwarning: Warning\nThe parent axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong. \n\nSee also\n\nSee also add_axes_fixedoffset! and add_point_surface!.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#Points","page":"Public API","title":"Points","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"@point\npoint_alias\n\nadd_point_dynamical!\nadd_point_ephemeris!\nadd_point_fixed!\nadd_point_root!\nadd_point_surface!\nadd_point_updatable!\n\nupdate_point!","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.@point","page":"Public API","title":"FrameTransformations.Frames.@point","text":"@point(name, id, type=nothing)\n\nDefine a new point instance to alias the given NAIFID id. This macro creates an  AbstractFramePoint subtype and its singleton instance called name. Its type name  is obtained by appending Point to either name or type (if provided).\n\nExamples\n\njulia> @point Venus 299\n\njulia> typeof(Venus)\nVenusPoint \n\njulia> point_alias(Venus)\n299\n\njulia> @point EMB 3 EarthMoonBarycenter\n\njulia> typeof(EMB) \nEarthMoonBarycenterPoint\n\njulia> point_alias(EMB) \n3 \n\nSee also\n\nSee also @axes and point_alias.\n\n\n\n\n\n","category":"macro"},{"location":"Modules/frames_api/#FrameTransformations.Frames.point_alias","page":"Public API","title":"FrameTransformations.Frames.point_alias","text":"point_alias(ax::AbstractFramePoint)\n\nReturn the NAIF ID associated to the input point. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_dynamical!","page":"Public API","title":"FrameTransformations.Frames.add_point_dynamical!","text":"add_point_dynamical!(frames, point, parent, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing)\n\nAdd point as a time point to frames. The state vector for these points depends only on  time and is computed through the custom functions provided by the user. \n\nThe input functions must accept only time as argument and their outputs must be as follows: \n\nfun: return a 3-elements vector: position\nδfun: return a 6-elements vector: position and velocity\nδ²fun: return a 9-elements vector: position, velocity and acceleration\nδ³fun: return a 12-elements vector: position, velocity, acceleration and jerk\n\nIf δfun, δ²fun or δ³fun are not provided, they are computed with automatic differentiation. \n\nwarning: Warning\nIt is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions. \n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}()\n\njulia> @axes ICRF 1 \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> @point Satellite 1 \n\njulia> satellite_pos(t::T) where T = [cos(t), sin(t), 0]\n\njulia> add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, π/6)\n6-element SVector{6, Float64} with indices SOneTo(6):\n  0.8660254037844387\n  0.49999999999999994\n  0.0\n -0.49999999999999994\n  0.8660254037844387\n  0.0\n\nSee also\n\nSee also add_point_root!, add_point_ephemeris!,add_point_fixed! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_ephemeris!","page":"Public API","title":"FrameTransformations.Frames.add_point_ephemeris!","text":"add_point_ephemeris!(frames, point, parent=nothing)\n\nAdd point as an ephemeris point to frames. This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). If a parent point is not specified, it will automatically be assigned to the point with respect to which the ephemeris  data is written in the kernels.\n\nInputs\n\nframes – FrameSystem object \npoint – FramePointNode instance \nparent – FramePointNode parent instance \n\n\n\nadd_point_ephemeris!(frames, name::Symbol, naifid::Int, parentid::Int=nothing, axes=nothing)\n\nAdd a new point called name and with id naifid to frames. If a parentid is not specified, it will be automatically assigned depending on the ephemeris kernels.\n\nInputs\n\nframes – FrameSystem object \nname::Symbol – name of the point \nnaifid::Int – NAIFId associated to the point \nparentid::Int – NAIFId associated to the parent point, default is nothing\naxes – Id associated to the axes in which the states are expressed, default nothing    (taken automatically from the ephemeris files).\n\nEphemeris points only accept as parent points root-points or other ephemeris points.\n\nNotes\n\nThis operation is only possible if the ephemeris kernels loaded within frames contain  data for the NAIF ID associated to point and to its parent. \n\nThe axes in which the state-vector is expressed are taken from the ephemeris data: an error  is returned if the axes ID is yet to be added to frames.\n\nwarning: Warning\nIt is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels.\n\nExamples\n\njulia> eph = CalcephProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{2, Float64}(eph);\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @point Jupiter 599\n\njulia> add_point_ephemeris!(FRAMES, Jupiter)\nERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.\n[...]\n\nSee also\n\nSee also add_point_root!, add_point_fixed!, add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_fixed!","page":"Public API","title":"FrameTransformations.Frames.add_point_fixed!","text":"add_point_fixed!(frames, point, parent, axes, offset::AbstractVector)\n\nAdd point as a fixed point to frames. Fixed points are those whose positions have a  constant offset with respect their parent points in the given set of axes. Thus, points  eligible for this class must have null velocity and acceleration with respect to parent.\n\nInputs\n\nframes – FrameSystem object \npoint – FramePointNode instance \nparent – FramePointNode parent instance \naxes – FrameAxesNode instance \noffset – Offset with respect to the parent\n\n\n\nadd_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector)\n\nAdd a new fixed point called name with id pointid and parent parentid in the axes  axesid to frames.\n\nframes – FrameSystem object \nname::Symbol – name of the point \nnaifid::Int – NAIFId associated to the point \nparentid::Int – NAIFId associated to the parent point, default is nothing\naxesid::Int – Id associated to the axes in which the states are expressed, default nothing    (taken automatically from the ephemeris files).\noffset – Offset with respect to the parent\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes SF -3000 SatelliteFrame\n\njulia> add_axes_inertial!(FRAMES, SF)\n\njulia> @point SC -10000 Spacecraft\n\njulia> @point SolarArrayCenter -10001\n\njulia> add_point_root!(FRAMES, SC, SF)\n\njulia> sa_offset = [0.10, 0.15, 0.30];\n\njulia> add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset)\n\nSee also\n\nSee also add_point_root!, add_point_ephemeris!,  add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_root!","page":"Public API","title":"FrameTransformations.Frames.add_point_root!","text":"add_point_root!(frames, point, axes)\n\nAdd point as a root point to frames to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.).\n\nInputs\n\nframes – FrameSystem object \npoint – Target point instance\naxes – Id or instance of the axes where the point state-vector is expressed. \n\n\n\nadd_point_root!(frames, name, id, axes)\n\nAdd a root point fo frames to initialize the points graphs. \n\nInputs\n\nframes – FrameSystem object \nname – Name of the root point \nid – Id (NAIFId) of the root point \naxes – Id or instance of the axes where the point state-vector is expressed.\n\nnote: Note\nThis operation can be performed only once per FrameSystem object: multiple root  points in the same graph are both inadmissible and meaningless.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> @point Sun 10\n\njulia> add_point_root!(FRAMES, Sun, ICRF)\nERROR: ArgumentError: A root-point is already registed in the given FrameSystem.\n[...]\n\nSee also\n\nSee also add_point_ephemeris!, add_point_fixed!, add_point_dynamical! and add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_surface!","page":"Public API","title":"FrameTransformations.Frames.add_point_surface!","text":"add_point_surface!(frames, point, parent, axes, pck, λ, ϕ, h::Number=0.0)\n\nAdd point to frames as a fixed point on the surface of the parent point. The  relative position is specified by the longitude λ, the geodetic latitude ϕ and the altitude  over the surface of the reference ellipsoid h, which defaults to 0.0. The ellipsoid  parameters are extracted from the input TPC kernel pck using the NAIFId associated to the  parent point.\n\nwarning: Warning\naxes must be a set of body-fixed reference axes for the body represented by parent.  When this constraint is not satisfied, the results may be fundamentally wrong. \n\nSee also\n\nSee also add_point_fixed!, add_axes_topocentric! and geod2pos.\n\n\n\n\n\nadd_point_surface!(frames, point, parent, axes, λ, ϕ, R, f::Number=0.0, h::Number=0.0)\n\nAdd point to frames as a fixed point on the surface of the parent point body. The relative  position is specified by the longitude λ, the geodetic latitude ϕ, the reference radius  of the ellipsoid R and its flattening f. The altitude over the reference surface of the  ellipsoid h defaults to 0. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.add_point_updatable!","page":"Public API","title":"FrameTransformations.Frames.add_point_updatable!","text":"add_point_updatable!(frames, point, parent, axes)\n\nAdd point as an updatable point to frames. Differently from all the other classes, the  state vector for updatable points (expressed in the set of input axes) must be manually  updated before being used for other computations.  \n\n\n\nadd_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes)\n\nAdd a point called name with id pointid to frames as a state vector with respect to  parentid in the axes axes.\n\nnote: Note\nThis class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.]\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2\n[...]\n\nSee also\n\nSee also update_point!, add_point_root!, add_point_ephemeris!,  add_point_dynamical! and add_point_fixed!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.update_point!","page":"Public API","title":"FrameTransformations.Frames.update_point!","text":"update_point!(frames, point, stv::AbstractVector, epoch::Epoch)\n\n\n\n\n\nupdate_point!(frames::FrameSystem, point, stv::AbstractVector, time)\n\nUpdate the state vector of point at the input time in frames. The only  accepted length for the input vector stv are 3, 6, 9 or 12. The order is automatically  inferred from the vector length.\n\nExamples\n\njulia> FRAMES = FrameSystem{2, Float64}();\n  \njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.];\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 \n[...]\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 \n[...] \n\nSee also\n\nSee also add_point_updatable!\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#rotation_api","page":"Public API","title":"Rotations","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"Rotation\nFrames.order\nBase.inv\n\nrotation3\nrotation6\nrotation9\nrotation12","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.Rotation","page":"Public API","title":"FrameTransformations.Frames.Rotation","text":"Rotation{S, N}\n\nA container to efficiently compute S-th order rotation matrices of type N between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the (S-1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later.\n\nThe rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object R, constructed from the  DCM A and its time derivatives δA and δ²A rotates a vector v = [p, v, a] as: \n\n̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a]\n\nA Rotation object R call always be converted to a SMatrix or a MMatrix by invoking  the proper constructor. \n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\n\n\nRotation(dcms::DCM...)\n\nCreate a Rotation object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64}\n\n\n\nRotation{S}(dcms::DCM...) where S\n\nCreate a Rotation object of order S. If the number of dcms is smaller than S, the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than  S, only the first S DCMs are used. \n\nwarning: Warning\nUsage of this constructor is not recommended as it may yield unexpected results to  unexperienced users. \n\n\n\nRotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N}\n\nCreate a Rotation object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If S1 < S2, only the first S1 DCMs are considered, otherwise the  remaining orders are filled with null DCMs.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R3 = Rotation{3}((A,B));\n\njulia> R3[1] == A\ntrue \n\njulia> R3[3] \nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\nRotation{S}(u::UniformScaling{N}) where {S, N}\nRotation{S, N}(u::UniformScaling) where {S, N}\n\nCreate an S-order identity Rotation object of type N with identity position rotation  and null time derivatives.\n\nExamples\n\njulia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],))\n\n\n\nRotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\nRotation{S1, N}(R::Rotation{S2}) where {S1, S2, N}\n\nTransform a Rotation object of order S2 to order S1 and type N. The behaviour of  these functions depends on the values of S1 and S2: \n\nS1 < S2: Only the first S1 components of rot are considered.\nS1 > S2: The missing orders are filled with null DCMs.\n\nExamples\n\njulia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1);\n\njulia> R3[3]\nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\nRotation(m::DCM{N}, ω::AbstractVector) where N\n\nCreate a 2nd order Rotation object of type N to rotate between two set of axes a and  b from a Direction Cosine Matrix (DCM) and the angular velocity vector ω of b with  respect to a, expressed in b\n\nSee also\n\nSee also rotation3, rotation6 and rotation9.\n\n\n\n\n\n","category":"type"},{"location":"Modules/frames_api/#FrameTransformations.Frames.order","page":"Public API","title":"FrameTransformations.Frames.order","text":"order(R::Rotation{S}) where S\n\nReturn the rotation order S.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#Base.inv","page":"Public API","title":"Base.inv","text":"inv(rot::Rotation)\n\nCompute the invese of the rotation object rot. The operation is efficiently performed by  taking the transpose of each rotation matrix within rot.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation3","page":"Public API","title":"FrameTransformations.Frames.rotation3","text":"rotation3(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 1.\n\n\n\n\n\nrotation3(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation6","page":"Public API","title":"FrameTransformations.Frames.rotation6","text":"rotation6(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 2.\n\n\n\n\n\nrotation6(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation9","page":"Public API","title":"FrameTransformations.Frames.rotation9","text":"rotation9(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 3.\n\n\n\n\n\nrotation9(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.rotation12","page":"Public API","title":"FrameTransformations.Frames.rotation12","text":"rotation12(frame::FrameSystem, from, to, ep::Epoch)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch. \n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the axes to transform from \nto – ID or instance of the axes to transform to \nep – Epoch of the rotation. Its timescale must match that of the frame system. \n\nOutput\n\nA Rotation object of order 4.\n\n\n\n\n\nrotation12(frame::FrameSystem, from, to, t::Number)\n\nCompute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time t, expressed in seconds since  J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#Transformations","page":"Public API","title":"Transformations","text":"","category":"section"},{"location":"Modules/frames_api/","page":"Public API","title":"Public API","text":"\nLightTime\nPlanetaryAberration\n\nvector3\nvector6\nvector9 \nvector12 ","category":"page"},{"location":"Modules/frames_api/#FrameTransformations.Frames.LightTime","page":"Public API","title":"FrameTransformations.Frames.LightTime","text":"LightTime\n\nThe singleton instance of type LightTimeCorrection, used to apply light-time (planetary  aberration) corrections when computing vectors from the FrameSystem.\n\nSee also\n\nSee also vector3 and vector6.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/frames_api/#FrameTransformations.Frames.PlanetaryAberration","page":"Public API","title":"FrameTransformations.Frames.PlanetaryAberration","text":"PlanetaryAberration\n\nThe singleton instance of type PlanetaryAberrationCorrection, used to apply one-way  light-time and stellar aberration corrections when computing vectors from the FrameSystem.\n\nSee also\n\nSee also vector3 and vector6.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector3","page":"Public API","title":"FrameTransformations.Frames.vector3","text":"vector3(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 1.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector3(frame, from, to, axes, t::Number)\n\nCompute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\nvector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch ep,  using the aberration flag ltcorr, which may be any of the following AbstractLightTimeCorrection:\n\nLightTimeCorrection: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. \nPlanetaryAberrationCorrection: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the LightTimeCorrection option to account for the observer velocity    with respect to the Solar System Barycenter. \n\nThe integer argument dir is used to specify the correction direction, as follows:\n\n-1: for Reception, in which photons depart from the target's location at the    light-time corrected epoch ep-lt and arrive at the observer's location at ep.\n+1: for Transmission, in which photons depart from the observer's location at   ep and arrive at the target's location at the light-time corrected epoch ep+lt.\n\nKeyword Arguments\n\niters::Int=1: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.\naxescenter: ID or instance of the center point for axes. This parameter is used        only when axes have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to from.\n\nnote: Note\nIf the PlanetaryAberrationCorrection is applied, the frame system must be at  least one order higher than that of the requested transformation.\n\nSee also\n\nSee also LightTime, PlanetaryAberration and vector6.\n\nReferences\n\nCSPICE Library\n\n\n\n\n\nvector3(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time t,   expressed in seconds since J2000, using the aberration flag ltcorr and  the direction dir.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector6","page":"Public API","title":"FrameTransformations.Frames.vector6","text":"vector6(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 2.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector6(frame, from, to, axes, t::Number)\n\nCompute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\nvector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch ep,  using the aberration flag ltcorr, which may be any of the following AbstractLightTimeCorrection:\n\nLightTimeCorrection: it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation. \nPlanetaryAberrationCorrection: it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the LightTimeCorrection option to account for the observer velocity    with respect to the Solar System Barycenter. \n\nThe integer argument dir is used to specify the correction direction, as follows:\n\n-1: for Reception, in which photons depart from the target's location at the    light-time corrected epoch ep-lt and arrive at the observer's location at ep.\n+1: for Transmission, in which photons depart from the observer's location at   ep and arrive at the target's location at the light-time corrected epoch ep+lt.\n\nKeyword Arguments\n\niters::Int=1: the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations.\naxescenter: ID or instance of the center point for axes. This parameter is used        only when axes have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to from.\n\nnote: Note\nIf the PlanetaryAberrationCorrection is applied, the frame system must be at  least one order higher than that of the requested transformation.\n\nSee also\n\nSee also LightTime, PlanetaryAberration and vector6.\n\nReferences\n\nCSPICE Library\n\n\n\n\n\nvector6(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>)\n\nCompute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time t,   expressed in seconds since J2000, using the aberration flag ltcorr and  the direction dir.\n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector9","page":"Public API","title":"FrameTransformations.Frames.vector9","text":"vector9(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 3.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector9(frame, from, to, axes, t::Number)\n\nCompute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Modules/frames_api/#FrameTransformations.Frames.vector12","page":"Public API","title":"FrameTransformations.Frames.vector12","text":"vector12(frame::FrameSystem, from, to, axes, ep::Epoch)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch ep.\n\nRequires a frame system of order ≥ 4.\n\nInputs\n\nframe – The FrameSystem container object \nfrom – ID or instance of the observing point\nto – ID or instance of the target point \naxes – ID or instance of the output state vector axes \nep – Epoch of the observer. Its timescale must match that of the frame system. \n\n\n\n\n\nvector12(frame, from, to, axes, t::Number)\n\nCompute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time t expressed in  seconds since J2000 if ephemerides are used. \n\n\n\n\n\n","category":"function"},{"location":"Tutorials/t00_frames/#tutorial_00_frames","page":"01 - Frame System","title":"Frame System Overview","text":"","category":"section"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"The core object of FrameTransformations is the FrameSystem, which provides the capability to compute relative position, orientation and their time derivatives up to order 3 (jerk), between standard and user-defined point and axes. It works by creating two separate graphs that silently store and manage all the parent-child relationships between the user-registered axes and points, in the form of Frames.FramePointNode and Frames.FrameAxesNode. ","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"These two objects define two precise entities: ","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Axes: defines an orientation in space. These are related each other by means of a Rotation transformation which relate one axes to a parent axes in a certain time interval.\nPoints: defines a location in space. These are related each other by means of a Translation   transformation which relate one point to a parent point in a particular axes in a certain    time interval.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"note: Note\nA single FrameSystem instance simultaneously handles both the axes and point graphs, regardless of what the user registers in it. For instance, if no points are added, the point graph will remain empty.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Additionally, any node can have several childs, each with different transformations with respect to the parent node. Moreover, nodes can be created independenlty of each other (by means of the @axes, and @point macros). However, they shall be registered within the FrameSystem before being used in a transformation or as parents of other nodes.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"using FrameTransformations","category":"page"},{"location":"Tutorials/t00_frames/#Basic-Constructors","page":"01 - Frame System","title":"Basic Constructors","text":"","category":"section"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"The creation of a generic FrameSystem requires the definition of the maximum desired transformation order and of its DataType, which in most applications is a Float64. The transformation order is always one greater than the maximum desired time derivative. For instance,  if the user only desires to compute position and velocity components (i.e., order 1 time-derivative), the transformation order to be used is 2. Thus, the maximum allowed transformation order is 4. ","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"In this example, we highlight the most basic way to initialise a FrameSystem:","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"F = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"From this example, you can see that within the frame system there are both point and axes graphs. However, at the moment they are completely empty since the graph was just created.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Each FrameSystem object is assigned a reference timescale that is used to perform  computations with epochs and to parse ephemeris files. The default timescale is the BarycentricDynamicalTime, however, the user is free to select the most suited timescale for his applications. In this example, we set the InternationalAtomicTime as the reference scale.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"F = FrameSystem{2, Float64, InternationalAtomicTime}()","category":"page"},{"location":"Tutorials/t00_frames/#Ephemerides-Support","page":"01 - Frame System","title":"Ephemerides Support","text":"","category":"section"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"In certain scenarios, the transformations require usage of binary ephemeris kernels, e.g., the JPL's DE440 files. To support this applications, an ephemeris provider can be associated to a FrameSystem. Since this package leverages a set of standard interfaces, any ephemeris reader that exposes JSMD-compatible interfaces can be used as a backend in FrameTransformations. Currently, the only two supported readers are our own Ephemerides.jl or CalcephEphemeris.jl. Although the former only can only parse binary PCK/SPK kernels, it seamlessly integrates with ForwardDiff since it is completely written in Julia.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"Once the desired ephemeris provider is created, it can be associated to the frame system object. However, in this case the reference timescale is retrieved from the ephemeris kernels and cannot be specified by the user. In this example we begin loading an old DE421 kernerl to pass to the  ephemeris reader.","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"<!– ```@repl frames using Ephemerides, Downloads","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"url = \"https://naif.jpl.nasa.gov/pub/naif/generickernels/spk/planets/aold_versions/de421.bsp\"; eph = EphemerisProvider(Downloads.download(url))","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"F = FrameSystem{2, Float64}(eph) ``` –>","category":"page"},{"location":"Tutorials/t00_frames/","page":"01 - Frame System","title":"01 - Frame System","text":"As you can see, the default NullEphemerisProvider has been replaced by the user-constructed one. ","category":"page"},{"location":"Tutorials/t02_points/#tutorial_02_points","page":"03 - Points","title":"Points Creation and Translations","text":"","category":"section"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Similarly to axes, FrameTransformations also provides the capability to define custom and standard reference points (e.g., the Solar System Barycenter) and arbitrarily connect them through the FrameSystem In turn, this allows the computation of the relative position and its derivatives (up to order 3) between any two registered points and express it in any known set of axes. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"At the time being, the following types of points are supported:","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Root point: it is the root of the point graph.\nFixed points: are those whose positions have a constant offset with respect their parent point in a given set of axes.\nDynamical points: the position of these points depends only on time and is computed through custom user-defined functions.\nEphemeris points: are those whose state-vector is retrieved from binary SPK kernels (e.g., DE440) that are loaded within the FrameSystem.\nUpdatable points: differently from all the other classes, the state vector for updatable points must be manually updated at a given epoch before it can be used in any transformation at the same epoch.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nThis package provides a dedicated function to register each type of supported points.","category":"page"},{"location":"Tutorials/t02_points/#Graph-Initialisation","page":"03 - Points","title":"Graph Initialisation","text":"","category":"section"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"In this section we will display how to create a frame system to compute generic points transformation. Differently from the axes graph, each register point is also associated to a set of axes. Hence, this tutorial assumes the reader to already be familiar with the different types of axes and their definitions. First of all, we need to load both this package and an ephemeris reader. The latter will be used to retrieve the positions of the planets from the binary SPK kernels. In this example, we will use our own Ephemerides.jl package and download the kernels from NAIF's website.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"G = FrameSystem{2, Float64}()","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"To initialise the point graph, we first need to define a root point. This, in turn, must be associated to an arbitrary set of axes. Therefore, we begin by definining a generic SatelliteFrame, here considered as inertial, and then register a root point, called SpacecraftCenter in our graph. Similarly, to axes, the @point macro is used to define an acronym, an ID and a name of each point that we wish to register in the system. If a name is not provided, a default one is used. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations \n\nG = FrameSystem{2, Float64}()\n","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"A root point can be registered using the add_point_root! function: ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"@axes SATF 1 SatelliteFrame \n\nadd_axes_inertial!(G, SATF)\n\n@point SC -10000 SpacecraftCenter\n\nadd_point_root!(G, SC, SATF)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nFor standard applications, it is good practice that the points's IDs are as in agreement with NAIF's numbering system. This becomes mandatory to properly read JPL's SPK kernels.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nThe frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the point are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"We can now see that our axes and point graphs are populating themselves:","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations \n\nG = FrameSystem{2, Float64}()\n@axes SATF 1 SatelliteFrame \n@point SC -10000 SpacecraftCenter\n\nadd_axes_inertial!(G, SATF)\nadd_point_root!(G, SC, SATF)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"G","category":"page"},{"location":"Tutorials/t02_points/#Fixed-Points","page":"03 - Points","title":"Fixed Points","text":"","category":"section"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Fixed points have a constant relative position vector with respect to their parent points in a given set of axes. Similarly to fixed-offset axes, these points are fixed w.r.t. their parents but might be moving with respect to others. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"In this example, we use the add_point_fixed! function to register the location of an antenna and two solar panels, which are generally fixed in the satellite body-fixed frame. To do so, we define a position offset in the form of a 3-elements vector with respect to the SpacecraftCenter.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"\n@point SACL -10101 SolarArrayCenterLeft\n@point SACR -10102 SolarArrayCenterRight\n@point Antenna -10001\n\nsa_offset_left = [1.0, 0.0, 0.0]\nsa_offset_right = [-1.0, 0.0, 0.0]\nan_offset = [0.0, 0.0, -1.0]\n\nadd_point_fixed!(G, SACL, SC, SATF, sa_offset_left)\nadd_point_fixed!(G, SACR, SC, SATF, sa_offset_right)\nadd_point_fixed!(G, Antenna, SC, SATF, an_offset)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"As a result the graph is now populated with the new points and we can finally compute their relative positions and velocities with the proper transformation functions: ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations \n\nG = FrameSystem{2, Float64}()\n\n@axes SATF 1 SatelliteFrame \n@point SC -10000 SpacecraftCenter\n@point SACL -10101 SolarArrayCenterLeft\n@point SACR -10102 SolarArrayCenterRight\n@point Antenna -10001\n\nadd_axes_inertial!(G, SATF)\nadd_point_root!(G, SC, SATF)\n\nsa_offset_left = [1.0, 0.0, 0.0]\nsa_offset_right = [-1.0, 0.0, 0.0]\nan_offset = [0.0, 0.0, -1.0]\n\nadd_point_fixed!(G, SACL, SC, SATF, sa_offset_left)\nadd_point_fixed!(G, SACR, SC, SATF, sa_offset_right)\nadd_point_fixed!(G, Antenna, SC, SATF, an_offset)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"vector3(G, SACL, SC, SATF, 0.0)\nvector6(G, Antenna, SACR, SATF, 10.0)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"As expected, since these points are fixed, the relative velocity vector is null.","category":"page"},{"location":"Tutorials/t02_points/#Dynamical-Points","page":"03 - Points","title":"Dynamical Points","text":"","category":"section"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Dynamical points are generic time-dependent points whose position vector (and optionally its derivatives) are only function of time. However, differently from ephemeris points, their position is computed through  user-defined functions.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point TimeDependantAppendage -10003\n\nfun(t) = [cos(t), sin(t), 0]\n\nadd_point_dynamical!(G, TimeDependantAppendage, SACL, SATF, fun)\n\nvector6(G, TimeDependantAppendage, SC, SATF, π/3)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nTo avoid allocations, fun should return a static array.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Similarly to rotating-axes, if the user only provides the function to compute the relative position, the remaining derivatives are automatically retrievied via automatic differentiation of fun. On the other hand, if those functions are specified, they must return a single vector that stacks all the components. For instance, for the second order derivative of fun, the function should return a 9-elements vector containing the relative position, velocity and acceleration. For example: ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point TimeDependantAppendage2 -10004\n\nfun(t) = [cos(t), sin(t), 0]\ndfun(t) = [cos(t), sin(t), 0, -sin(t), cos(t), 0]\n\nadd_point_dynamical!(G, TimeDependantAppendage2, SACL, SATF, fun, dfun)\n\nvector6(G, TimeDependantAppendage2, SC, SATF, π/3)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"We can again see that the results are in agreement with the previous example. For more details, consult the add_point_dynamical! documentation.","category":"page"},{"location":"Tutorials/t02_points/#updatable_points","page":"03 - Points","title":"Updatable Points","text":"","category":"section"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Updatable points are a class of point whose states at a given epoch must be manually updated  before any other computation at the same epoch can occur. They can be inserted in the  computational graphs as follows:","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"@point UA -10002 UpdatableAppendage\n\nadd_point_updatable!(G, UA, SC, SATF)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"If we now call a transformation involving this point, an error will be thrown because we have  not registered any state for this point. To do so, we use the update_point! function and then  evaluate the relative position: ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations \n\nG = FrameSystem{2, Float64}()\n\n@axes SATF 1 SatelliteFrame \n@point SC -10000 SpacecraftCenter\n@point SACL -10101 SolarArrayCenterLeft\n@point SACR -10102 SolarArrayCenterRight\n@point Antenna -10001\n@point UA -10002 UpdatableAppendage\n\nadd_axes_inertial!(G, SATF)\nadd_point_root!(G, SC, SATF)\n\nsa_offset_left = [1.0, 0.0, 0.0]\nsa_offset_right = [-1.0, 0.0, 0.0]\nan_offset = [0.0, 0.0, -1.0]\n\nadd_point_fixed!(G, SACL, SC, SATF, sa_offset_left)\nadd_point_fixed!(G, SACR, SC, SATF, sa_offset_right)\nadd_point_fixed!(G, Antenna, SC, SATF, an_offset)\nadd_point_updatable!(G, UA, SC, SATF)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"ua_pos = [0.0, -1.0, 0.0]\nupdate_point!(G, UA, ua_pos, 0.0)\nvector3(G, Antenna, UA, SATF, 0.0)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Note that in the previous example, only the position has been updated but the current frame system is of order two! Therefore, in this case, calling vector6 will give an error since  the computational graph is order-sentitive.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"To correct that behaviour, also the higher order shall be updated:","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"update_point!(G, UA, [1.0, -1.0, 0.0, 0.0, 0.0, 0.0], .0)\nvector6(G, Antenna, UA, SATF, 0.0)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nUpdatable points do not store any history of the updated states. Meaning that each time  a state is updated at a different epoch, the information of the older epochs is completely lost.","category":"page"},{"location":"Tutorials/t02_points/#Ephemeris-Points","page":"03 - Points","title":"Ephemeris Points","text":"","category":"section"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Ephemeris points are a type of time-dependent points whose position and higher-order derivatives are retrieved from a binary SPK ephemeris kernel. However, differently from all other points, in this case the set of axes is automatically inferred from those contained in the ephemeris kernels. In case such set is not yet registered in the frame system, an error will be thrown. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nTo properly compute the position of these points, the FrameSystem object must contain an ephemeris provider that has loaded the necessary kernels. Additionally, in this case the ID of the registered points must match the ID contained in the SPK kernels. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"In this example, we define a new frame system F and give it an ephemeris provider that has loaded the DE421 SPK kernel, containing the position of the major planets and/or their barycenters of the Solar System.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using Ephemerides, Downloads\nspk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(Downloads.download(spk))\nF = FrameSystem{2, Float64}(eph)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations\nusing Ephemerides, Downloads\nspk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(Downloads.download(spk))\nF = FrameSystem{2, Float64}(eph)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"We now register some points that are stored in the kernels using the add_point_ephemeris! function: ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"@axes ICRF 1\n\n@point SSB 0 \n@point Sun 10 \n@point EMB 3\n@point Earth 399\n\nadd_axes_inertial!(F, ICRF)\nadd_point_root!(F, SSB, ICRF)\nadd_point_ephemeris!(F, Sun, SSB)\nadd_point_ephemeris!(F, EMB)\nadd_point_ephemeris!(F, Earth)\n\nF","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Notice that this function does not necessarily requires the parent point. Indeed, if no point is specified, the parent is automatically set to those contained in the descriptors of the ephemeris kernels. For instance, in the DE421, the Earth-Moon Barycenter (EMB) is defined with respect to the SSB, which the frame system automatically uses as parent for the EMB. Similarly, the EMB is the default parent point for the Earth.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"note: Note\nIt is always recommended to use as parent of ephemeris points, the point with respect to which its ephemeris data is written in the binary kernels. This becomes mandatory if Ephemerides.jl is used as an ephemeris provider.","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"warning: Warning\nIf a parent point is not specified and the point in the kernels has not yet been registered, an error is thrown. ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"Finally, we can retrieve the transformation data as usual: ","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"using FrameTransformations\nusing Ephemerides, Downloads\nspk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(Downloads.download(spk))\nF = FrameSystem{2, Float64}(eph)\n\n@axes ICRF 1\n\n@point SSB 0 \n@point Sun 10 \n@point EMB 3\n@point Earth 399 \n\nadd_axes_inertial!(F, ICRF)\nadd_point_root!(F, SSB, ICRF)\nadd_point_ephemeris!(F, Sun, SSB)\nadd_point_ephemeris!(F, EMB)\nadd_point_ephemeris!(F, Earth)","category":"page"},{"location":"Tutorials/t02_points/","page":"03 - Points","title":"03 - Points","text":"vector6(F, EMB, SSB, ICRF, 1000.0)\n\nvector3(F, Earth, SSB, ICRF, 0.0)","category":"page"},{"location":"todos/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"Although Basic already implements may of its required functionalities, there is still  a lot to do to finish it. ","category":"page"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"<style type=\"text/css\">\n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n</style>\n<table class=\"tg\">\n<thead>\n  <tr>\n    <th class=\"tg-fymr\">ID</th>\n    <th class=\"tg-fymr\">Feature to develop</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td class=\"tg-0pky\">AD1</td>\n    <td class=\"tg-0pky\">\n        <b>Ephemeris</b>: the actual default ephemeris provider for Basic is Calceph. \n        While it is a very versatile library, there is a inherent issue in that: the \n        impossibility to perform AD over it. Therefore, within the context of development \n        of Basic a (full) julia reader for JPL/INPOP ephemeris is foreseen. This package\n        is actually at the early stage of the development at the moment, thus any \n        contribution would be highly appreciated.\n\n        This is being performed in a separate package called `Ephemeris` within the JSMD\n        environment.\n    </td>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">AD2</td>\n    <td class=\"tg-0pky\">\n        <b>Caching</b>: if you have a deep look into the FrameSystem structure, you'll \n        see that some frames have a dedicated cache. This goes in contrast with the use \n        of ForwardDiff, since it would require a Dual's compatible cache: there is, then,\n        the need of replacing those caches with a PreallocationTools.DiffCache or something\n        similar.\n    </td>\n  </tr>\n  </tr>\n    <tr>\n    <td class=\"tg-0pky\">AD3</td>\n    <td class=\"tg-0pky\">\n        <b>FunctionWrappers</b>: if you have a deep look into the FrameSystem structure, you'll \n        see that the actual transformations are stored by means of FunctionWrapper. Again,\n        this goes against the AD integration but was choosen for efficiency reasons.\n        In this case there is the need to introduct FunctionWrappersWrappers dependency to\n        solve the issue. \n    </td>\n  </tr>\n</tbody>\n</table>","category":"page"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"Write down an email if your are interested in  contributing to one of those, we'll be for welcoming you with some additional guidelines. ","category":"page"},{"location":"todos/#Guidelines","page":"Contributing","title":"Guidelines","text":"","category":"section"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"This section details the some of the guidelines that should be followed when contributing  to this package.","category":"page"},{"location":"todos/","page":"Contributing","title":"Contributing","text":"Since the package is not consolidated yet, the most straight forward way to contribute is  by creating a branch of the master and develop there the desired feature. To this step,  follows the creation of a PR that will be accepted only if the new feature are validated  by tests.","category":"page"},{"location":"Tutorials/t01_axes/#tutorial_01_axes","page":"02 - Axes","title":"Axes Creation and Rotations","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"To compute relative orientations, FrameTransformations provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the FrameSystem In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"At the time being, the following types of axes are supported:","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Inertial axes: these are the only ones which can be used as root axes to initialise the axes graph. \nFixed offset axes: they have a constant orientation with respect to their parent axes.\nRotating axes: the orientation of these axes depends only on time and is computed through the custom functions provided by the user\nComputable axes: they are computed through two vectors that are defined within the frame system itself. Computable axes are the equivalent of SPICE's parameterized two-vector frames.\nProjected axes: the orientation of these axes depends only on time and is computed through the custom functions provided by the user. Projected axes are similar to rotating axis, except that all the positions, velocity, etc ... are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null, despite the rotation depends on time).\nEphemeris axes: these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the FrameSystem.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nThis package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g., add_axes_eclipj2000!.","category":"page"},{"location":"Tutorials/t01_axes/#Rotations","page":"02 - Axes","title":"Rotations","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Before diving into the creation of the axes graph, it is worth highlighting that transformations that express the relative orientation or its time-derivatives between two generic set of axes are represented by a Rotation object, which stores a Direction Cosine Matrix (DCM) and its derivatives. This package leverages the already available ReferenceFrameRotations.jl to define the DCM objects. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"A time-fixed rotation between two axes and its derivative can then be expressed as follows: ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using ReferenceFrameRotations\n\ndcm  = angle_to_dcm(π/3, :Z)\nδdcm = DCM(0I)\n\nR = Rotation(dcm, δdcm)\n\nR[1]\n\nR[2]","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"A rotation object is returned by all the rotation functions that are applied to the frame system. It provide overloads to the basic algebraic operations so that multiplication and inversions can be efficiently computed leveraging the properties of rotation matrixes. For example, to rotate a generic vector v, we can simply do: ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nusing ReferenceFrameRotations\n\ndcm  = angle_to_dcm(π/3, :Z)\nδdcm = DCM(0I)\n\nR = Rotation(dcm, δdcm)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"v = [1., -6., 3., 0., 5., 0]\nR*v","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"The inverse can instead be taken as: ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"inv(R)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"See the Rotation API for more information on this object.","category":"page"},{"location":"Tutorials/t01_axes/#Graph-Initialisation","page":"02 - Axes","title":"Graph Initialisation","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon's Principal Axes (PA) 440, whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, we will use our own Ephemerides.jl package and download the kernels from NAIF's website.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using Ephemerides, Downloads\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)])\n\nG = FrameSystem{3, Float64}(eph)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"To initialise the axes computational graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the FrameSystem. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Before registering the axes, the @axes macro is used to define an acronym, an ID and a name of each set of axes that we wish to register in the system. If a name is not provided, a default one is used. In this example, we will use the ICRF as our base root inertial axes.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nG = FrameSystem{3, Float64}()","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes ICRF 1 InternationalCelestialReferenceFrame\n\nadd_axes_inertial!(G, ICRF)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Once a set of root axes has been registered, any other type of axes can be added to the system.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nFor standard applications, it is good practice that the axes's IDs are as in agreement with NAIF's numbering system. A list of IDs for the most common axes is provided in the Orient submodule.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nThe frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the axes are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. For instance, one could register a set of rotating axes named ICRF.","category":"page"},{"location":"Tutorials/t01_axes/#Inertial-Axes","page":"02 - Axes","title":"Inertial Axes","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we register the ECLIPJ2000 as a set of inertial axes with respect to the ICRF. Since the set of root axes has already been defined, all the future usages of the add_axes_inertial! function require a parent set of axes and a DCM with the relative orientation.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations \nG = FrameSystem{3, Float64}()\n@axes ICRF 1 InternationalCelestialReferenceFrame\nadd_axes_inertial!(G, ICRF)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"\n@axes ECLIPJ2000 17\n\nadd_axes_inertial!(G, ECLIPJ2000; parent=ICRF, dcm=DCM_ICRF_TO_ECLIPJ2000)\n\nR = rotation6(G, ICRF, ECLIPJ2000, 10.0)\nR[1]\nR[2]","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Notice that we leveraged the default DCM provided by Orient's to express the relative orientation between the ICRF and the ECLIPJ2000. For a set of default DCM exported by Orient, check the API documentation. Additionally, since it is an inertial frame, the time derivative of the rotation is null. ","category":"page"},{"location":"Tutorials/t01_axes/#Fixed-offset-Axes","page":"02 - Axes","title":"Fixed-offset Axes","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we register FO1 as a set of axes with a fixed rotation of π/4 around the Z-axis with respect to the ICRF.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nusing ReferenceFrameRotations\nG = FrameSystem{3, Float64}()\n\n@axes ICRF 1 InternationalCelestialReferenceFrame\nadd_axes_inertial!(G, ICRF)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes FO1 2\n\nrot = angle_to_dcm(π/4, :Z)\n\nadd_axes_fixedoffset!(G, FO1, ICRF, rot)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nusing ReferenceFrameRotations\nG = FrameSystem{3, Float64}()\n\n@axes ICRF 1 InternationalCelestialReferenceFrame\nadd_axes_inertial!(G, ICRF)\n\n@axes FO1 2\n\nrot = angle_to_dcm(π/4, :Z)\n\nadd_axes_fixedoffset!(G, FO1, ICRF, rot)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"The state rotation matrix can then be obtained as: ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R = rotation6(G, ICRF, FO1, 86400)\n\nR[1]\n\nR[2]","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Since FO1 has a constant orientation with respect to the ICRF, the time derivative of the rotation matrix R[2] is infact null. For further information see the add_axes_fixedoffset! documentation.","category":"page"},{"location":"Tutorials/t01_axes/#rot_axes","page":"02 - Axes","title":"Rotating Axes","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from the ReferenceFrameRotations.jl package.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes RotAx 3 \n\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(G, RotAx, FO1, fun)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nusing ReferenceFrameRotations\nG = FrameSystem{3, Float64}()\n\n@axes ICRF 1 InternationalCelestialReferenceFrame\n@axes FO1 2\n@axes RotAx 3 \n\nrot = angle_to_dcm(π/4, :Z)\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_inertial!(G, ICRF)\nadd_axes_fixedoffset!(G, FO1, ICRF, rot)\nadd_axes_rotating!(G, RotAx, FO1, fun)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"If we now compute the orientation between the ICRF and RotAx at π/4 we obtain an identity rotation, since the orientation of RotAx is directed in the opposite direction of FO1.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"R1 = rotation6(G, ICRF, RotAx, π/4)\n\nR1[1]\n\nR2 = rotation6(G, ICRF, RotAx, π/2)\n\nR2[2]","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of fun. This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example: ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes RotAx2 4\n\nfun(t) = angle_to_dcm(-t, :Z)\ndfun(t) = (angle_to_dcm(-t, :Z), Utils.angle_to_δdcm([-t, -1], :Z))\n\nadd_axes_rotating!(G, RotAx2, FO1, fun, dfun)\n\nR2 = rotation6(G, ICRF, RotAx2, π/2)\n\nR2[2]","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"We can see the results are in agreement with the previous example. For more details, consult the add_axes_rotating! documentation.","category":"page"},{"location":"Tutorials/t01_axes/#Projected-Axes","page":"02 - Axes","title":"Projected Axes","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Projected axes are a particular type of inertial axes. In this case the rotation is built by means of a time dependant function f(t). However, all the derivatives of f(t) are assumed to be zero. This axes type is usually used to build True-of-Date (TOD) axes sets. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we illustrate this difference by registering two new set of axes with the same relative orientation with respect to the ICRF, one rotating and one projected. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes ProjAx 500\n@axes RotAx3 501\n\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(G, RotAx3, ICRF, fun)\nadd_axes_projected!(G, ProjAx, ICRF, fun)\n\nR1 = rotation6(G, ICRF, RotAx3, 50.0)\nR2 = rotation6(G, ICRF, ProjAx, 50.0)\n\nR1[1] - R2[1]\n\nR1[2]\nR2[2]","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"As you can see, while the relative orientation R[1] is equal, the time-derivative of the projected-axes orientation is null. For further information see the add_axes_projected! documentation.","category":"page"},{"location":"Tutorials/t01_axes/#Computable-Axes","page":"02 - Axes","title":"Computable Axes","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Computable axes are a kind of time-dependant axes. In this case, differently from the rotating axes, the axes and their derivatives are computed through two time-dependant vectors which are expressed using any type of point that is registered in the system. These axes are the equivalent of SPICE's two-vector frames.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, we will register two ephemeris points, the Solar system barycenter and the Sun. For more information on how this operation is performed, see the points tutorial. The two vectors that generate the set of computable axes are defined with the ComputableAxesVector object, by specifing the vector center and target point and its order, i.e., whether we are interested in the position, velocity or acceleration of that vector. A symbol is used to specify which direction the vectors have to align with. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, the axes are constructed with the X-axis parallel to the instantaneous SSB to Sun direction, whereas the secondary vector is chosen parallel to the SSB to Sun velocity vector (order 2). Then, the component of this vector orthogonal to the X-axis is used to create the Y-axis. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"using FrameTransformations\nusing Ephemerides, Downloads\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)])\n\nG = FrameSystem{3, Float64}(eph)\n\n@axes ICRF 1 InternationalCelestialReferenceFrame\nadd_axes_inertial!(G, ICRF)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes SunFrame 600\n\n@point SSB 0 SolarSystemBarycenter \n@point Sun 10 SunPoint \n\nadd_point_root!(G, SSB, ICRF)\nadd_point_ephemeris!(G, Sun, SSB)\n\nv1 = ComputableAxesVector(Sun, SSB, 1)\nv2 = ComputableAxesVector(Sun, SSB, 2)\n\nadd_axes_computable!(G, SunFrame, ICRF, v1, v2, :XY)\n\nR = rotation6(G, ICRF, SunFrame, 0.0)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"For further information see the add_axes_computable! documentation.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nThe center and target point can either be specified with their integer IDs or their name aliases. ","category":"page"},{"location":"Tutorials/t01_axes/#Ephemeris-Axes","page":"02 - Axes","title":"Ephemeris Axes","text":"","category":"section"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth's ITRF.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"note: Note\nTo properly compute the orientation of these axes, the FrameSystem object must contain an ephemeris provider that has loaded the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels. ","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"In this example, the ephemeris provider eph in the frame system G has loaded the DE421 PCK kernel containing the orientation of the Moon's Principal Axes (PA421). NAIF's system has assigned to such set of axes the ID 31006. If a different ID was assigned to the MoonPA, the function would have thrown an error. A set of default axes IDs is also defined within the Orient's submodule for ease of use.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix.","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"@axes MoonPA 31006\n\nadd_axes_ephemeris!(G, MoonPA, :ZXZ)\n\nR = rotation9(G, ICRF, MoonPA, 86400.0)","category":"page"},{"location":"Tutorials/t01_axes/","page":"02 - Axes","title":"02 - Axes","text":"For further information see the add_axes_ephemeris! documentation.","category":"page"},{"location":"#Welcome-to-FrameTransformations.jl!","page":"Home","title":"Welcome to FrameTransformations.jl!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, this package is the ideal starting point. FrameTransformations.jl is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. ","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Convert between different time scales and representations (via Tempo.jl);\nRead binary ephemeris files (via Ephemerides.jl or CalcephEphemeris.jl)\nCreate custom reference frame systems with both standard and user-defined points and axes.\nTransform states and their higher-order derivatives between different frames (up to jerk)","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of this seamlessly integrated with ForwardDiff.jl.","category":"page"},{"location":"Modules/orient_api/#basic_orient_api","page":"Public API","title":"Orient's Public Documentation","text":"","category":"section"},{"location":"Modules/orient_api/#iers_models","page":"Public API","title":"IAU Models","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"This is a list of the supported IAU models and their approximations that can be used to select the desired procedure for the computation of the ITRF to GCRF rotation.","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"\niau2000a\niau2000b\n\niau2006a\niau2006b \n\nCPNc\nCPNd","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2000a","page":"Public API","title":"FrameTransformations.Orient.iau2000a","text":"iau2000a\n\nThe singleton instance of type IAU2006a, representing the IAU 2000B family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2000b","page":"Public API","title":"FrameTransformations.Orient.iau2000b","text":"iau2000b\n\nThe singleton instance of type IAU2006a, representing the IAU 2000B family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2006a","page":"Public API","title":"FrameTransformations.Orient.iau2006a","text":"iau2006a\n\nThe singleton instance of type IAU2006a, representing the IAU 2006A family of models.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.iau2006b","page":"Public API","title":"FrameTransformations.Orient.iau2006b","text":"iau2006b\n\nThe singleton instance of type IAU2006B, representing the IAU 2006B family of models.\n\nnote: Note\nThis is not an official IERS model.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.CPNc","page":"Public API","title":"FrameTransformations.Orient.CPNc","text":"CPNc\n\nThe singleton instance of type CPNC, representing the concise CPNc from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few mas.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.CPNd","page":"Public API","title":"FrameTransformations.Orient.CPNd","text":"CPNd\n\nThe singleton instance of type CPND, representing the concise CPNd from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few arcseconds.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#IERS-Transformations","page":"Public API","title":"IERS Transformations","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"IERS_EOP\norient_rot3_itrf_to_gcrf\norient_rot6_itrf_to_gcrf\norient_rot9_itrf_to_gcrf\norient_rot12_itrf_to_gcrf\norient_bias_precession\norient_bias_precession_nutation\norient_nutation\norient_obliquity","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.IERS_EOP","page":"Public API","title":"FrameTransformations.Orient.IERS_EOP","text":"IERS_EOP\n\nEarth orientation parameters: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values at 1-day intervals)  with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014.\n\nEOP 14 C04 is updated two times per week.\n\nHere the files are downloaded using the RemoteFile package with weekly updates.\n\nSee also: get_iers_eop\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","text":"orient_rot3_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF at time t expressed as  TT seconds since J2000, according to the IAU Model m, as follows:\n\nIAU2000A: the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2000A model.\nIAU2000B: only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation    matrix is computed following the IAU 2000 model but with truncated expressions for the    nutation corrections. \nIAU2006A: the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2006/2000A model.\nIAU2006B: only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation   matrix is computed following the IAU 2006A model but with truncated expressions for the    nutation corrections. \nCPNc: a concise model with a cut-off at 2.5 mas of the X and Y series, delivering a    worst-case accuracy of about 15 mas between 1995-2050. It does not take into account the    Free Core Nutation (~0.2 mas). \nCPNd: an extremely concise formulation with an accuracy of about 1 arcsec between 1995    and 2050. It neglects polar-motion (~0.25 arcsec), the FCN corrections and the CIO locator. \n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nCapitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations\n\n\n\n\n\norient_rot3_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0)\n\nCompute the rotation matrix from ITRF to GCRF according to the IAU Model m, at time tt  and ut1 expressed in TT seconds and UT1 days since J2000, respectively.  \n\nThis function has been implemented for IAU2000, IAU2006 and CPN models.\n\nnote: Note\nAll the input quantities xₚ, yₚ, dX and dY must be expressed in radians\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","text":"orient_rot6_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its derivative at time t  expressed as TT seconds since J2000, according to the the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","text":"orient_rot9_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its time derivatives up to order 2 at  time t expressed as TT seconds since J2000, according to the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","page":"Public API","title":"FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","text":"orient_rot12_itrf_to_gcrf(m::IAUModel, t::Number)\n\nCompute the rotation matrix from ITRF to GCRF and its time derivatives up to order 3 at  time t expressed as TT seconds since J2000, according to the IAU Model m.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession","page":"Public API","title":"FrameTransformations.Orient.orient_bias_precession","text":"orient_bias_precession(m::IAUModel, t::Number)\n\nForm the precession-frame bias (PB) matrix that transforms vectors from the GCRS to the  mean of date, following the IAU Model m at time t expressed as TT Julian centuries  since J2000.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nReferences:\n\nIAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc. 24th General Assembly,  Manchester, UK.  Resolutions B1.3, B1.6. (2000)\nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with IAU  2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nERFA pmat06 function.\nERFA pmat00 function.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession_nutation","page":"Public API","title":"FrameTransformations.Orient.orient_bias_precession_nutation","text":"orient_bias_precession_nutation(m::IAUModel, t::Number)\n\nCompute the equinox-based bias-precession-nutation matrix using the IAU Model m procedures  at time t expressed in TT Julian centuries since J2000.\n\nThe function has been implemented for the IAU2000 and IAU2006 models.\n\nnote: Note\nThe computed matrix rotates a vector from the GCRS to the true equatorial triad of date.\n\nReferences\n\nERFA pn06 function\nERFA pn00 function\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_nutation","page":"Public API","title":"FrameTransformations.Orient.orient_nutation","text":"orient_nutation(m::IAUModel, t::Number)\n\nCompute the nutation components in longitude and obliquity for the IAU Model m, in radians,  at time t expressed in TT Julian Centuries since J2000.\n\nNotes\n\nDue to their theoretical basis, the original developments required t expressed as TDB.  However, in practice, it is usually more convenient to use Terrestrial Time (TT) as it makes  no significant differences (< 0.01 μas) in the final result.\nFor the IAU 2006A model, the function strictly follows the SOFA implementation. It first  computes the IAU 2000A nutation, then applies adjustments for the consequences of the change  in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) for the secular  variation in the Earth's dynamical form factor J2. These corrections ensure that the IAU  2000A nutation is consistent with the IAU 2006 precession model. Please note that the  coefficients available on the IERS tables already include those corrections, and are  retrieved by multiplying the amplitudes of the SOFA nutation in longitude coefficients by  1.00000047. \nThe computation of the free-core nutation and time dependent effects are excluded from this  model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation models,  such effects must be included a-posteriori (through dX and dY) using the IERS EOP data.\nFor the IAU 2000B model, the nutation series is truncated from nearly 1400 terms to only 77,  yet it still delivers results of 1 mas accuracy at present epochs. In particular, it delivers  a pole accurate to 1 mas from 1900 to 2100 (only very occasionally just outside 1 mas).  The coefficients are taken from SOFA's implementation, which slighlty differ from those  reported in McCarthy and Luzum (2003). Comparisons with IAU 2006A show that the SOFA version  between 1995 and 2050 delivers 0.283 mas RMSE (0.994 mas in the worst case), whereas the  IERS Conventions website version delivers 0.312 RMSE (1.125 mas in the worst case).\nThe IAU 2000B model includes constant planetary bias terms that compensate for long-period  nutations. These amplitudes used in this implementation are optimised for a rigorous method,  where frame bias, precession and nutation are applied separately and in that order  (see SOFA's documentation for further insights).\nA simplified version of the Fundamental Arguments, taken from Simon et al (1994) is exploited  for IAU2000B as the error introduced is below the model accuracy ( ~0.1 mas).\n\nReferences\n\nLuzum, B. and Petit G. (2012), The IERS Conventions (2010),  IERS Technical Note No. 36 \nWallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions, DOI: 10.1051/0004-6361:20065897 \nSimon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets.\nERFA nut06a and  nut00b functions \n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_obliquity","page":"Public API","title":"FrameTransformations.Orient.orient_obliquity","text":"orient_obliquity(m::IAUModel, t::Number)\n\nCompute the mean obliquity of the ecliptic at epoch, in radians, at time t expressed  in TT Julian centuries since J2000. \n\nnote: Note\nThis function is implemented only for IAU1980 and IAU2006 models. IAU 2000 Models  implement proper precession-rate corrections to the IAU1980 mean obliquity. \n\nReferences\n\nERFA obl80 and  obl06 functions.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#Moon-Transformations","page":"Public API","title":"Moon Transformations","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"orient_rot3_icrf_to_pa421\norient_rot3_icrf_to_pa440","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421","page":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa421","text":"orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, t::Number)\n\nCompute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the given  input time t, expressed in seconds since J2000. \n\nwarning: Warning\nThis function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions.\n\n\n\n\n\norient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, ep::Epoch)\n\nCompute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the input  epoch ep.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440","page":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa440","text":"orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, t::Number)\n\nCompute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the given  input time t, expressed in seconds since J2000. \n\nwarning: Warning\nThis function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions.\n\n\n\n\n\norient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, ep::Epoch)\n\nCompute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the input  epoch ep.\n\n\n\n\n\n","category":"function"},{"location":"Modules/orient_api/#orient_axesid","page":"Public API","title":"Axes ID","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"This is a list of NAIF IDs for standard axes that are used in astrodynamic applications. ","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"note: Note\nAlthough they are listed in the public documentation section, these IDs are not directly exported by the package.","category":"page"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"Orient.AXESID_ICRF\nOrient.AXESID_ECLIPJ2000\nOrient.AXESID_MEME2000\nOrient.AXESID_MOONME_DE421\nOrient.AXESID_MOONPA_DE421\nOrient.AXESID_MOONPA_DE440","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_ICRF","page":"Public API","title":"FrameTransformations.Orient.AXESID_ICRF","text":"AXESID_ICRF\n\nNAIF Axes ID for the International Celestial Reference Frame (ICRF)\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_ECLIPJ2000","page":"Public API","title":"FrameTransformations.Orient.AXESID_ECLIPJ2000","text":"AXESID_ECLIPJ2000\n\nNAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECLIPJ2000) \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MEME2000","page":"Public API","title":"FrameTransformations.Orient.AXESID_MEME2000","text":"AXESID_MEME2000\n\nAxes ID for the Mean Dynamical Equator and Equinox of J2000.0. \n\nnote: Note\nIn SPICE the J2000 and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the MEME2000 axes. 22 has been chosen because it is the  first unassigned axes ID among the built-in SPICE frames. \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONME_DE421","page":"Public API","title":"FrameTransformations.Orient.AXESID_MOONME_DE421","text":"AXESID_MOONME_DE421\n\nNAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE421","page":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE421","text":"AXESID_MOONPA_DE421\n\nNAIF axes id for the DE421 Moon Principal Axes (PA421).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE440","page":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE440","text":"AXESID_MOONPA_DE440\n\nNAIF Axes id for the DE440 Moon Principal Axes (PA440).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#orient_dcms","page":"Public API","title":"Default Rotation Matrices","text":"","category":"section"},{"location":"Modules/orient_api/","page":"Public API","title":"Public API","text":"Orient.DCM_ICRF_TO_J2000_BIAS\nOrient.DCM_ICRF_TO_ECLIPJ2000\nOrient.DCM_J2000_TO_ECLIPJ2000\nOrient.DCM_MOON_PA421_TO_ME421\nOrient.DCM_MOON_PA430_TO_ME421\nOrient.DCM_MOON_PA430_TO_ME430\nOrient.DCM_MOON_PA440_TO_ME421","category":"page"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS","page":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS","text":"DCM_ICRF_TO_J2000_BIAS\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) and the  Mean Dynamical Equator and Equinox of J2000.0 (MEME2000).\n\nnote: Note\nThe frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond.\n\nReferences\n\nHilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI: 10.1051/0004-6361:20031552\nSOFA docs\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","page":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","text":"DCM_ICRF_TO_ECLIPJ2000\n\nDCM for the rotation from the International Celestial Reference Frame (ICRF) to the  Mean Ecliptic Equinox of J2000 (ECLIPJ2000).\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000","page":"Public API","title":"FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000","text":"DCM_J2000_TO_ECLIPJ2000\n\nDCM for the rotation from the Mean Dynamical Equator of J2000 (MEME2000) to the  Mean Ecliptic Equinox. This corresponds to the transformation J2000 -> ECLIPJ2000  in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory.\n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","text":"DCM_MOON_PA421_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 421 (PA421) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nJ. G. Williams et al. (2008), DE421 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE421 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","text":"DCM_MOON_PA430_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nFolkner M. William et al. (2014), The Planetary and Lunar EphemeridesDE430 and DE431\nJ. G. Williams et al. (2013), DE430 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE430 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","text":"DCM_MOON_PA430_TO_ME430\n\nDCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE430 (ME430) axes.\n\nReferences\n\nFolkner M. William et al. (2014), The Planetary and Lunar EphemeridesDE430 and DE431\nJ. G. Williams et al. (2013), DE430 Lunar Orbit, Physical Librations, and Surface Coordinates,   DE430 Lunar Ephemeris and Orientation \n\n\n\n\n\n","category":"constant"},{"location":"Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","page":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","text":"DCM_MOON_PA440_TO_ME421\n\nDCM for the rotation from the Moon Principal Axis 440 (PA440) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes.\n\nReferences\n\nPark, S. R. et al. (2021), The JPL Planetary and Lunar Ephemerides DE440 and DE441,  DOI: 10.3847/1538-3881/abd414 \n\n\n\n\n\n","category":"constant"},{"location":"Modules/utils_lapi/#low_utils_api","page":"Low-level API","title":"Utils's Low-level API","text":"","category":"section"},{"location":"Modules/utils_lapi/#Geodesy","page":"Low-level API","title":"Geodesy","text":"","category":"section"},{"location":"Modules/utils_lapi/","page":"Low-level API","title":"Low-level API","text":"Utils.pv2geoc \nUtils.geoc2pv","category":"page"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.pv2geoc","page":"Low-level API","title":"FrameTransformations.Utils.pv2geoc","text":"pv2geoc(pv::AbstractVector)\n\nTransform a cartesian 6-elements state vector (position and velocity) into radius, longitude,  geocentric latitude and their derivatives, respectively.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.geoc2pv","page":"Low-level API","title":"FrameTransformations.Utils.geoc2pv","text":"geoc2pv(geoc::AbstractVector)\n\nTransform a spherical geocentric 6-elements state vector (radius, longitude, geocentric  latitude and their derivatives) into a cartesian 6-elements vector (position and velocity).\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#Vectors","page":"Low-level API","title":"Vectors","text":"","category":"section"},{"location":"Modules/utils_lapi/","page":"Low-level API","title":"Low-level API","text":"Utils.cross3\nUtils.cross6\nUtils.cross9\nUtils.cross12\n\nUtils.normalize\nUtils.δnormalize\nUtils.δ²normalize\nUtils.δ³normalize","category":"page"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.cross3","page":"Low-level API","title":"FrameTransformations.Utils.cross3","text":"cross3(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y, considering only their first 3 elements.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.cross6","page":"Low-level API","title":"FrameTransformations.Utils.cross6","text":"cross6(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its time derivative. \n\nNotes\n\nx and y must be 6-elements state vectors, with the last elements of each vector  representing the time derivatives of the first three.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.cross9","page":"Low-level API","title":"FrameTransformations.Utils.cross9","text":"cross9(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its 1st and 2nd-order time derivatives. \n\nNotes\n\nx and y must be 9-elements state vectors (position, velocity and acceleration)\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.cross12","page":"Low-level API","title":"FrameTransformations.Utils.cross12","text":"cross12(x::AbstractVector, y::AbstractVector)\n\nCompute the cross product between x and y and its 1st, 2nd and 3rd order time derivatives. \n\nNotes\n\nx and y must be 12-elements state vectors (position, velocity and acceleration)\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.normalize","page":"Low-level API","title":"FrameTransformations.Utils.normalize","text":"normalize(v::AbstractVector)\n\nNormalise the vector v.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.δnormalize","page":"Low-level API","title":"FrameTransformations.Utils.δnormalize","text":"δnormalize(v::AbstractVector)\n\nCompute the time derivative of a unit vector v.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.δ²normalize","page":"Low-level API","title":"FrameTransformations.Utils.δ²normalize","text":"δ²normalize(v::AbstractVector)\n\nCompute the 2nd-order time derivative of a unit vector v.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.δ³normalize","page":"Low-level API","title":"FrameTransformations.Utils.δ³normalize","text":"δ³normalize(v::AbstractVector)\n\nCompute the 3rd-order time derivative of a unit vector v.\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#Rotations","page":"Low-level API","title":"Rotations","text":"","category":"section"},{"location":"Modules/utils_lapi/","page":"Low-level API","title":"Low-level API","text":"Utils.angle_to_δdcm\nUtils.angle_to_δ²dcm\nUtils.angle_to_δ³dcm\n\nUtils._3angles_to_δdcm\nUtils._3angles_to_δ²dcm\nUtils._3angles_to_δ³dcm","category":"page"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.angle_to_δdcm","page":"Low-level API","title":"FrameTransformations.Utils.angle_to_δdcm","text":"angle_to_δdcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX)\n\nCompute the derivative of the direction cosine matrix that perform a set of rotations (θ,  ϕ, γ) about the coordinate axes in rot_seq. Each rotation input must be an indexable  objected which includes the angle and its first time derivative.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δ²dcm\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.angle_to_δ²dcm","page":"Low-level API","title":"FrameTransformations.Utils.angle_to_δ²dcm","text":"angle_to_δ²dcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX)\n\nCompute the second order time derivative of the direction cosine matrix that perform  a set of rotations (θ, ϕ, γ) about the coordinate axes in rot_seq. Each rotation  input must be an indexable objected which includes the angle and its first and second order  time derivatives.\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δdcm\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.angle_to_δ³dcm","page":"Low-level API","title":"FrameTransformations.Utils.angle_to_δ³dcm","text":"angle_to_δ³dcm(θ::Number[, ϕ::Number[, γ::Number]], rot_seq::Symbol = :Z)\n\nCompute the second order time derivative of the direction cosine matrix that perform  a set of rotations (θ, ϕ, γ) about the coordinate axes in rot_seq. Each rotation  input must be an indexable objected which includes the angle and its time derivatives up to  order 3 (jerk).\n\nThe rotation sequence is defined by a Symbol specifing the rotation axes. The possible  values depend on the number of rotations as follows: \n\n1 rotation (θ₁): :X, :Y, or :Z.\n2 rotations (θ₁, θ₂): :XY, :XZ, :YX, :YZ, :ZX, or :ZY.\n3 rotations (θ₁, θ₂, θ₃): :XYX, XYZ, :XZX, :XZY, :YXY,   :YXZ, :YZX, :YZY, :ZXY, :ZXZ, :ZYX, or :ZYZ\n\nnote: Note\nThis function assigns dcm = A3 * A2 * A1 in which Ai is the DCM related with the i-th rotation, i Є [1,2,3]. If the i-th rotation is not specified, then Ai = I.\n\nSee also\n\nSee also angle_to_δdcm\n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils._3angles_to_δdcm","page":"Low-level API","title":"FrameTransformations.Utils._3angles_to_δdcm","text":"_3angles_to_δdcm(θ, rot_seq::Symbol)\n\nCompute the time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils._3angles_to_δ²dcm","page":"Low-level API","title":"FrameTransformations.Utils._3angles_to_δ²dcm","text":"_3angles_to_δ²dcm(θ, rot_seq::Symbol)\n\nCompute the 2nd time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils._3angles_to_δ³dcm","page":"Low-level API","title":"FrameTransformations.Utils._3angles_to_δ³dcm","text":"_3angles_to_δ³dcm(θ, rot_seq::Symbol)\n\nCompute the 3rd order time derivative of the DCM with all the angles stored in a single vector  to optimise computations. \n\n\n\n\n\n","category":"function"},{"location":"Modules/utils_lapi/#Constants","page":"Low-level API","title":"Constants","text":"","category":"section"},{"location":"Modules/utils_lapi/","page":"Low-level API","title":"Low-level API","text":"Utils.light_speed","category":"page"},{"location":"Modules/utils_lapi/#FrameTransformations.Utils.light_speed","page":"Low-level API","title":"FrameTransformations.Utils.light_speed","text":"light_speed\n\nOfficial light speed constant value used in CSPICE \n\n\n\n\n\n","category":"constant"}]
}
