[{"id":3,"pagetitle":"Home","title":"Welcome to Tempo.jl!","ref":"/Tempo/stable/#Welcome-to-Tempo.jl!","content":" Welcome to Tempo.jl! Efficient Astronomical Time transformations in Julia. Tempo.jl is an astronomical library that enables fast, efficient and high-accuracy time transformations between common and user-defined time scales and time representations."},{"id":4,"pagetitle":"Home","title":"Installation","ref":"/Tempo/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg\n\njulia> Pkg.add(\"Tempo.jl\");"},{"id":5,"pagetitle":"Home","title":"Quickstart","ref":"/Tempo/stable/#Quickstart","content":" Quickstart Create an  Epoch :  # Create an Epoch from an ISO-formatted string\ntai = Epoch(\"2022-10-02T12:04:23.043 TAI\")\n\n# Create an Epoch from a Julian Date\njd = Epoch(\"JD 2451545.0\")\n\n# Create an Epoch from a DateTime object and a timescale\ndt = DateTime(2001, 6, 15, 0, 0, 0, 0.0)\ne = Epoch(dt, TT) Efficiently transform epochs between various timescales: # Convert an Epoch from TAI to TDB \ntai = Epoch(\"2022-10-02T12:04:23.043 TAI\")\ntdb = convert(TDB, tai)\n\n# Convert an Epoch from TAI to UTC automatically handling leapseconds \nutc = convert(UTC, tai)"},{"id":6,"pagetitle":"Home","title":"Tempo.jl vs AstroTime.jl","ref":"/Tempo/stable/#Tempo.jl-vs-AstroTime.jl","content":" Tempo.jl vs AstroTime.jl Tempo.jl and  AstroTime.jl  are very similar libraries that allow transformations between various astronomical time representations. The major differences are: AstroTime.jl supports accurate Epoch transformations by leveraging high    precision arithmetics. Tempo.jl is more efficient when multiple timescales conversions must be    performed to convert a given Epoch (e.g., it does not allocate memory)."},{"id":9,"pagetitle":"Public API","title":"Public Documentation","ref":"/Tempo/stable/api/#tempo_api","content":" Public Documentation"},{"id":10,"pagetitle":"Public API","title":"Datetime","ref":"/Tempo/stable/api/#Datetime","content":" Datetime"},{"id":11,"pagetitle":"Public API","title":"Tempo.Date","ref":"/Tempo/stable/api/#Tempo.Date","content":" Tempo.Date  —  Type Date A type to represent a calendar date by storing the year, month and day. Date(year::Int, month::Int, day::Int) Construct a  Date  object given the  year ,  month  and  day . Date(offset::Integer) Create a  Date  object given an integer number of days since  2000-01-01 . Date(year::Integer, dayinyear::Integer) Create a  Date  object given the  year  and the day of the year  dayinyear . Examples julia> Date(2020, 1)\n2020-01-01\n\njulia> Date(2020, 300)\n2020-10-26 Date(dt::DateTime) Extract the  Date  object from a  DateTime  structure.  See also See also  Time  and  DateTime . source"},{"id":12,"pagetitle":"Public API","title":"Tempo.Time","ref":"/Tempo/stable/api/#Tempo.Time","content":" Tempo.Time  —  Type Time{T} A type representing the time of the day storing the hour, minute, seconds and fraction  of seconds. Time(hour::Int, minute::Int, second::Int, fraction::T) where {T <: Number} Create a  Time  object of type  T . Time(hour::Int, minute::Int, second::Number) Construct a  Time  object given the  hour ,  minute  and  seconds . In this case, the  seconds can either be an integer or a floating point number. The fraction of seconds will be computed under the hood. Time(secondinday::Int, fraction::Number)\nTime(secondinday::Number) Create a  Time  object given the seconds of the day  secondinday  and/or the fraction of  seconds.  Time(dt::DateTime) Extract the  Time  object from a  DateTime  structure.  See also See also  Date  and  DateTime . source"},{"id":13,"pagetitle":"Public API","title":"Tempo.DateTime","ref":"/Tempo/stable/api/#Tempo.DateTime","content":" Tempo.DateTime  —  Type DateTime{T} A type wrapping a  Date  and a  Time  object. DateTime(date::Date, time::Time{T}) Construct a  DateTime  object of type  T  from its  Date  and  Time  components. DateTime(year::Int, month::Int, day::Int, hour::Int, min::Int, sec::Int, frac::Number) Create a  DateTime  object by parts.  DateTime(iso::AbstractString) Create a  DateTime  object from by parsing an ISO datetime string  iso , in the format   YYYY-MM-DDThh:mm:ss.ffffffff . The DateTime parts not provided in the string will be  assigned default values. Examples julia> DateTime(\"2023-05-18T20:14:55.02\")\n2023-05-18T20:14:55.020\n\njulia> Tempo.DateTime(\"2022-05-12\")\n2022-05-12T00:00:00.00 DateTime(seconds::Number) Create a  DateTime  object given the number of seconds elapsed since  J2000 . DateTime(d::Date, sec::Number) Create a  DateTime  object given a  Date  and the number of seconds since midnight. Examples julia> d = Date(2023, 5, 18)\n2023-05-18\n\njulia> DateTime(d, 0)\n2023-05-18T12:00:00.000\n\njulia> DateTime(d, 1)\n2023-05-18T12:00:01.000 See also See also  Date ,  Time  and  Epoch . source"},{"id":14,"pagetitle":"Public API","title":"Tempo.year","ref":"/Tempo/stable/api/#Tempo.year","content":" Tempo.year  —  Function year(d::Date) Get year associated to a  Date . source year(d::DateTime) Get year associated to a  DateTime  type. source"},{"id":15,"pagetitle":"Public API","title":"Tempo.month","ref":"/Tempo/stable/api/#Tempo.month","content":" Tempo.month  —  Function month(d::Date) Get month associated to a  Date . source month(d::DateTime) Get month associated to a  DateTime  type. source"},{"id":16,"pagetitle":"Public API","title":"Tempo.day","ref":"/Tempo/stable/api/#Tempo.day","content":" Tempo.day  —  Function day(d::Date) Get day associated to a  Date . source day(d::DateTime) Get day associated to a  DateTime  type. source"},{"id":17,"pagetitle":"Public API","title":"Tempo.hour","ref":"/Tempo/stable/api/#Tempo.hour","content":" Tempo.hour  —  Function hour(t::Time) Get the current hour. source hour(d::DateTime) Get hour associated to a  DateTime  type. source"},{"id":18,"pagetitle":"Public API","title":"Tempo.minute","ref":"/Tempo/stable/api/#Tempo.minute","content":" Tempo.minute  —  Function minute(t::Time) Get the current minute. source minute(d::DateTime) Get minute associated to a  DateTime  type. source"},{"id":19,"pagetitle":"Public API","title":"Tempo.second","ref":"/Tempo/stable/api/#Tempo.second","content":" Tempo.second  —  Function second(::Type{<:AbstractFloat}, t::Time)\nsecond(::Type{<:Integer}, t::Time)\nsecond(t::Time) Get the current second. source second(::Type{<:AbstractFloat}, t::Time)\nsecond(d::DateTime) Get the seconds associated to a  DateTime  type. If a floating-point type is given  as first argument, the returned value will also account for the fraction of seconds. source"},{"id":20,"pagetitle":"Public API","title":"Tempo.find_dayinyear","ref":"/Tempo/stable/api/#Tempo.find_dayinyear","content":" Tempo.find_dayinyear  —  Function find_dayinyear(month::Integer, day::Integer, isleap::Bool) Find the day of the year given the month, the day of the month and whether the year  is leap or not. source find_dayinyear(d::Date) Find the day in the year. source"},{"id":21,"pagetitle":"Public API","title":"Epochs","ref":"/Tempo/stable/api/#Epochs","content":" Epochs"},{"id":22,"pagetitle":"Public API","title":"Duration","ref":"/Tempo/stable/api/#Duration","content":" Duration"},{"id":23,"pagetitle":"Public API","title":"Tempo.Duration","ref":"/Tempo/stable/api/#Tempo.Duration","content":" Tempo.Duration  —  Type Duration{T} A  Duration  represents a period of time, split into an integer number of seconds and a  fractional part. Fields seconds : The integer number of seconds. fraction : The fractional part of the duration, where  T  is a subtype of  Number . source"},{"id":24,"pagetitle":"Public API","title":"Types","ref":"/Tempo/stable/api/#Types","content":" Types"},{"id":25,"pagetitle":"Public API","title":"Tempo.Epoch","ref":"/Tempo/stable/api/#Tempo.Epoch","content":" Tempo.Epoch  —  Type Epoch{S, T} A type to represent Epoch-like data. Epochs are internally represented as seconds + fraction of  seconds since a reference epoch, which is considered to be  2000-01-01T12:00:00 ,  i.e.  J2000 . Epoch(sec::Number, scale::AbstractTimeScale)\nEpoch(sec::Number, scale::Type{<:AbstractTimeScale})\nEpoch{S}(seconds::Number) where {S <: AbstractTimeScale} Create an  Epoch  object from the number of seconds since  J2000  with the  timescale  S . Epoch(dt::DateTime, scale::AbstractTimeScale)\nEpoch(dt::DateTime, scale::Type{<:AbstractTimeScale}) Create an  Epoch  object from a  DateTime  structure with timescale  scale . Epoch(str::AbstractString, scale::AbstractTimeScale)\nEpoch(str::AbstractString) Create an  Epoch  object from an ISO-formatted string. The timescale can either be  specified as a second argument or written at the end of the string.  This constructor requires that the  str  is in the format: ISO  –  yyyy-mm-ddTHH:MM:SS.ffff  : assume J2000 as origin J2000  –  DDDD.ffff  : parse Julian Date since J2000, in days JD  –  JD DDDDDDDDD.ffffff  : parse Julian Date, in days MJD  –  MJD DDDDDDDDD.ffffff  : parse a Modified Julian Date, in days A  TimeScale  can be added at the end of the string, separated by a whitespace.  If it is not declared,  TDB  will be used as a default timescale.  Examples julia> Epoch(\"2050-01-01T12:35:15.0000 TT\")\n2050-01-01T12:35:14.9999 TT\n\njulia> Epoch(\"2050-01-01T12:35:15.0000\")\n2050-01-01T12:35:14.9999 TDB\n\njulia> Epoch(\"JD 2400000.5\")\n1858-11-17T00:00:00.0000 TDB\n\njulia> Epoch(\"MJD 51544.5\")\n2000-01-01T12:00:00.0000 TDB\n\njulia> Epoch(\"12.0\")\n2000-01-13T12:00:00.0000 TDB\n\njulia> Epoch(\"12.0 TT\")\n2000-01-13T12:00:00.0000 TT source"},{"id":26,"pagetitle":"Public API","title":"Tempo.timescale","ref":"/Tempo/stable/api/#Tempo.timescale","content":" Tempo.timescale  —  Function timescale(e::Epoch) Epoch timescale. source"},{"id":27,"pagetitle":"Public API","title":"Tempo.value","ref":"/Tempo/stable/api/#Tempo.value","content":" Tempo.value  —  Function value(e::Epoch) Full  Epoch  value. source"},{"id":28,"pagetitle":"Public API","title":"Origins","ref":"/Tempo/stable/api/#Origins","content":" Origins"},{"id":29,"pagetitle":"Public API","title":"Tempo.JD","ref":"/Tempo/stable/api/#Tempo.JD","content":" Tempo.JD  —  Constant JD The singleton instance of the  JulianDate  epoch origin.  With this origin, Epoch reference is  -4712-01-01T12:00 . source"},{"id":30,"pagetitle":"Public API","title":"Tempo.J2000","ref":"/Tempo/stable/api/#Tempo.J2000","content":" Tempo.J2000  —  Constant J2000 The singleton instance of the  JulianDate2000  epoch origin.  With this origin, Epoch reference is  2000-01-01T12:00 . source"},{"id":31,"pagetitle":"Public API","title":"Tempo.MJD","ref":"/Tempo/stable/api/#Tempo.MJD","content":" Tempo.MJD  —  Constant MJD The singleton instance of the  ModifiedJulianDate  epoch origin.  With this origin, Epoch reference is  1858-11-17T00:00 . source"},{"id":32,"pagetitle":"Public API","title":"Tempo.MJD2000","ref":"/Tempo/stable/api/#Tempo.MJD2000","content":" Tempo.MJD2000  —  Constant MJD2000 The singleton instance of the  ModifiedJulianDate2000  epoch origin.  With this origin, Epoch reference is  2000-01-01T00:00 . source"},{"id":33,"pagetitle":"Public API","title":"Conversions","ref":"/Tempo/stable/api/#Conversions","content":" Conversions"},{"id":34,"pagetitle":"Public API","title":"Tempo.j2000","ref":"/Tempo/stable/api/#Tempo.j2000","content":" Tempo.j2000  —  Function j2000(jd)\nj2000(jd1, jd2) Convert Julian Date in days since J2000 source j2000(d::Date) Convert Gregorian calendar date  Date  to a Julian Date since  J2000 ,  in days. source j2000(dt::DateTime) Convert a  DateTime dt  in Julian days since  J2000 . source j2000(e::Epoch) Convert  Epoch  in Julian Date days since  J2000 . source"},{"id":35,"pagetitle":"Public API","title":"Tempo.j2000s","ref":"/Tempo/stable/api/#Tempo.j2000s","content":" Tempo.j2000s  —  Function j2000s(jd)\nj2000s(jd1, jd2) Convert Julian Date (in days) in seconds past J2000  source j2000s(dt::DateTime) Convert a  DateTime dt  to seconds since  J2000 . source j2000s(e::Epoch) Convert  Epoch  in Julian Date seconds since  J2000 . source"},{"id":36,"pagetitle":"Public API","title":"Tempo.j2000c","ref":"/Tempo/stable/api/#Tempo.j2000c","content":" Tempo.j2000c  —  Function j2000c(jd)\nj2000c(jd1, jd2) Convert Julian Date (in days) to Julian Centuries source j2000c(dt::DateTime) Convert  a  DateTime dt  in a Julian Date since  J2000 , in centuries. source j2000c(e::Epoch) Convert  Epoch  in Julian Date centuries since  J2000 . source"},{"id":37,"pagetitle":"Public API","title":"Timescales","ref":"/Tempo/stable/api/#Timescales","content":" Timescales"},{"id":38,"pagetitle":"Public API","title":"Time System","ref":"/Tempo/stable/api/#Time-System","content":" Time System"},{"id":39,"pagetitle":"Public API","title":"Tempo.@timescale","ref":"/Tempo/stable/api/#Tempo.@timescale","content":" Tempo.@timescale  —  Macro @timescale(name, id, type) Create a new timescale instance to alias the given  id . This macro creates an   AbstractTimeScale  subtype and its singleton instance called  name . Its  type   is obtained by appending  TimeScale  to  name  if it was not provided. Examples julia> @timescale NTS 100 NewTimeScale \n\njulia> typeof(NTS)\nNewTimeScale \n\njulia> timescale_alias(NTS)\n100\n\njulia> @timescale TBH 200\n\njulia> typeof(TBH)\nTBHTimeScale\n\njulia> timescale_alias(TBH)\n200 See also See also  timescale_alias  and  add_timescale! . source"},{"id":40,"pagetitle":"Public API","title":"Tempo.timescale_alias","ref":"/Tempo/stable/api/#Tempo.timescale_alias","content":" Tempo.timescale_alias  —  Function timescale_alias(scale::AbstractTimeScale) Return the ID associated to  scale . source"},{"id":41,"pagetitle":"Public API","title":"Tempo.timescale_name","ref":"/Tempo/stable/api/#Tempo.timescale_name","content":" Tempo.timescale_name  —  Function timescale_name(scale::AbstractTimeScale) Return the name of  scale . source"},{"id":42,"pagetitle":"Public API","title":"Tempo.timescale_id","ref":"/Tempo/stable/api/#Tempo.timescale_id","content":" Tempo.timescale_id  —  Function timescale_id(scale::AbstractTimeScale) Return the ID of  scale . source"},{"id":43,"pagetitle":"Public API","title":"Tempo.TimeSystem","ref":"/Tempo/stable/api/#Tempo.TimeSystem","content":" Tempo.TimeSystem  —  Type TimeSystem{T} A  TimeSystem  object manages a collection of default and user-defined  TimeScaleNode  objects, enabling efficient time transformations between them. It leverages a   MappedDiGraph  to keep track of the relationships between the timescales. TimeSystem{T}() Create a empty  TimeSystem  object with datatype  T . Examples julia> ts = TimeSystem{Float64}();\n\njulia> @timescale TSA 100 TimeScaleA\n\njulia> @timescale TSB 200 TimeScaleB\n\njulia> add_timescale!(ts, TSA)\n\njulia> offset_tsa2tsb(seconds) = 1.0\n\njulia> offset_tsb2tsa(seconds) = -1.0\n\njulia> add_timescale!(ts, TSB, offset_tsa2tsb; parent=TSA, ftp=offset_tsb2tsa) See also See also  @timescale  and  add_timescale! . source"},{"id":44,"pagetitle":"Public API","title":"Tempo.add_timescale!","ref":"/Tempo/stable/api/#Tempo.add_timescale!","content":" Tempo.add_timescale!  —  Function add_timescale!(s::TimeSystem, ts::TimeScaleNode) Register a new node in the  TimeSystem . Warning This is a low-level function and should not be called by the user. source add_timescale!(system::TimeSystem, scale::AbstractTimeScale, ffp::Function; ftp, parent) Add  scale  as a timescale to  system . A custom function  ffp  providing the time offset,  in seconds, between the  parent  scale and the current scale must be provided by the user.  The  parent  and  ffp  arguments are unneeded only for the root timescale. If the user  wishes to add a scale to a non-empty timesystem, this argument becomes mandatory. The input functions must accept only the seconds in the parent scale as argument and must  return a single numerical output. An optional function  ftp , with a similar interface, returning the offset from the current to the parent scale may also be provided.  Note If  ftp  is not provided, the reverse timescale transformation will not be possible.  Examples julia> SYSTEM = TimeSystem{Float64}();\n\njulia> @timescale RTS 102 RootTimeScale\n\njulia> @timescale CTS 103 ChildTimeScale\n\njulia> root_to_child(x::Number) = 13.3;\n\njulia> child_to_root(x::Number) = -13.3;\n\njulia> add_timescale!(SYSTEM, RTS)\n\njulia> add_timescale!(SYSTEM, CTS, root_to_child; parent=RTS, ftp=child_to_root) See also See also  @timescale  and  TimeSystem . source"},{"id":45,"pagetitle":"Public API","title":"Tempo.TIMESCALES","ref":"/Tempo/stable/api/#Tempo.TIMESCALES","content":" Tempo.TIMESCALES  —  Constant TIMESCALES Default time scales graph, containing at least: (\"TT\", \"TAI\", \"UTC\", \"TCG\", \"TCB\", \"TDB\", \"UT1\", \"TDBH\", \"GPS\") It can be easily extended using the  @timescale  to create new  TimeScaleNode   aliases and  add_timescale!  method to define its relation with the other nodes  in the graph.  Example # Define a new timescale type alias\n@timescale NTS 100 NewTimeScale\n\n# Define offset to and from another timescale in the graph \noffset_ffp(seconds) = 1.0\noffset_ftp(seconds) = -1.0\n\n# Connect to the graph, with the parent node (TDB in this example)\nadd_timescale!(TIMESCALES, NTS, offset_ffp, parent=TDB, ftp=offset_ftp) See also See also  @timescale  and  add_timescale! . source"},{"id":46,"pagetitle":"Public API","title":"Default Timescales","ref":"/Tempo/stable/api/#Default-Timescales","content":" Default Timescales"},{"id":47,"pagetitle":"Public API","title":"Tempo.GPS","ref":"/Tempo/stable/api/#Tempo.GPS","content":" Tempo.GPS  —  Constant GPS The singleton instance of the  GlobalPositioningSystemTime  type representing the Global Positioning System Time (GPS) time scale. source"},{"id":48,"pagetitle":"Public API","title":"Tempo.TAI","ref":"/Tempo/stable/api/#Tempo.TAI","content":" Tempo.TAI  —  Constant TAI The singleton instance of the  InternationalAtomicTime  type representing the International Atomic Time (TAI) time scale. source"},{"id":49,"pagetitle":"Public API","title":"Tempo.TCB","ref":"/Tempo/stable/api/#Tempo.TCB","content":" Tempo.TCB  —  Constant TCB The singleton instance of the  BarycentricCoordinateTime  type representing the Barycentric Coordinate Time (TCB) time scale. source"},{"id":50,"pagetitle":"Public API","title":"Tempo.TCG","ref":"/Tempo/stable/api/#Tempo.TCG","content":" Tempo.TCG  —  Constant TCG The singleton instance of the  GeocentricCoordinateTime  type representing the Geocentric Coordinate Time (TCG) time scale. source"},{"id":51,"pagetitle":"Public API","title":"Tempo.TDB","ref":"/Tempo/stable/api/#Tempo.TDB","content":" Tempo.TDB  —  Constant TDB The singleton instance of the  BarycentricDynamicalTime  type representing the Barycentric Dynamical Time (TDB) time scale. source"},{"id":52,"pagetitle":"Public API","title":"Tempo.TDBH","ref":"/Tempo/stable/api/#Tempo.TDBH","content":" Tempo.TDBH  —  Constant TDBH The singleton instance of the  HighPrecisionBarycentricDynamicalTime  type representing the High Precision Barycentric Dynamical Time (TDBH) time scale. source"},{"id":53,"pagetitle":"Public API","title":"Tempo.TT","ref":"/Tempo/stable/api/#Tempo.TT","content":" Tempo.TT  —  Constant TT The singleton instance of the  TerrestrialTime  type representing the Terrestrial Time (TT) time scale. source"},{"id":54,"pagetitle":"Public API","title":"Tempo.UT1","ref":"/Tempo/stable/api/#Tempo.UT1","content":" Tempo.UT1  —  Constant UT1 The singleton instance of the  UniversalTime  type representing the Universal Time (UT1) time scale. source"},{"id":55,"pagetitle":"Public API","title":"Tempo.UTC","ref":"/Tempo/stable/api/#Tempo.UTC","content":" Tempo.UTC  —  Constant UTC The singleton instance of the  CoordinatedUniversalTime  type representing the Coordinated Universal Time (UTC) time scale. source"},{"id":56,"pagetitle":"Public API","title":"Constants","ref":"/Tempo/stable/api/#Constants","content":" Constants"},{"id":57,"pagetitle":"Public API","title":"Tempo.DJ2000","ref":"/Tempo/stable/api/#Tempo.DJ2000","content":" Tempo.DJ2000  —  Constant DJ2000 Reference epoch  J2000 , Julian Date ( 2451545.0 ).  It is  12:00 01-01-2000 . source"},{"id":58,"pagetitle":"Public API","title":"Tempo.DMJD","ref":"/Tempo/stable/api/#Tempo.DMJD","content":" Tempo.DMJD  —  Constant DMJD Reference epoch  J2000 , Modified Julian Date ( 51544.5 ). source"},{"id":59,"pagetitle":"Public API","title":"Tempo.DJM0","ref":"/Tempo/stable/api/#Tempo.DJM0","content":" Tempo.DJM0  —  Constant DJM0 Julian Date of Modified Julian Date zero point ( 2400000.5 ). It is  00:00 17-11-1858 . source"},{"id":62,"pagetitle":"Low-level API","title":"Low-level API","ref":"/Tempo/stable/lapi/#tempo_lapi","content":" Low-level API These functions are not meant to be used outside of the package. They are documented only to aid future developments of the package."},{"id":63,"pagetitle":"Low-level API","title":"Epochs","ref":"/Tempo/stable/lapi/#Epochs","content":" Epochs"},{"id":64,"pagetitle":"Low-level API","title":"Tempo.AbstractEpochOrigin","ref":"/Tempo/stable/lapi/#Tempo.AbstractEpochOrigin","content":" Tempo.AbstractEpochOrigin  —  Type AbstractEpochOrigin Abstract type for all epoch origins. source"},{"id":65,"pagetitle":"Low-level API","title":"Tempo.JulianDate","ref":"/Tempo/stable/lapi/#Tempo.JulianDate","content":" Tempo.JulianDate  —  Type JulianDate A type representing the JulianDate (JD) epoch origin.  With this origin, Epoch reference is  -4712-01-01T12:00 . source"},{"id":66,"pagetitle":"Low-level API","title":"Tempo.JulianDate2000","ref":"/Tempo/stable/lapi/#Tempo.JulianDate2000","content":" Tempo.JulianDate2000  —  Type JulianDate2000 A type representing the JulianDate2000 (J2000) epoch origin.  With this origin, Epoch reference is  2000-01-01T12:00 . source"},{"id":67,"pagetitle":"Low-level API","title":"Tempo.ModifiedJulianDate","ref":"/Tempo/stable/lapi/#Tempo.ModifiedJulianDate","content":" Tempo.ModifiedJulianDate  —  Type ModifiedJulianDate A type representing the ModifiedJulianDate (MJD) epoch origin.  With this origin, Epoch reference is  1858-11-17T00:00 . source"},{"id":68,"pagetitle":"Low-level API","title":"Tempo.ModifiedJulianDate2000","ref":"/Tempo/stable/lapi/#Tempo.ModifiedJulianDate2000","content":" Tempo.ModifiedJulianDate2000  —  Type ModifiedJulianDate2000 A type representing the ModifiedJulianDate2000 (MJD2000) epoch origin.  With this origin, Epoch reference is  2000-01-01T00:00 . source"},{"id":69,"pagetitle":"Low-level API","title":"Tempo.EpochConversionError","ref":"/Tempo/stable/lapi/#Tempo.EpochConversionError","content":" Tempo.EpochConversionError  —  Type EpochConversionError A type representing epoch conversion errors. source"},{"id":70,"pagetitle":"Low-level API","title":"Tempo.parse_iso","ref":"/Tempo/stable/lapi/#Tempo.parse_iso","content":" Tempo.parse_iso  —  Function parse_iso(s::AbstractString) Parse an ISO datetime string, in the format  YYYY-MM-DDThh:mm:ss.ffffffff  and return  a  Tuple  containing the year, month, day , hour, minute, second and milliseconds. If the  string format is not recognised as ISO, an  ArgumentError  is thrown. source"},{"id":71,"pagetitle":"Low-level API","title":"Timescale Offsets","ref":"/Tempo/stable/lapi/#Timescale-Offsets","content":" Timescale Offsets"},{"id":72,"pagetitle":"Low-level API","title":"Tempo.offset","ref":"/Tempo/stable/lapi/#Tempo.offset","content":" Tempo.offset  —  Function offset(::Tempo.JulianDate) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  JulianDate  (with origin at  -4712-01-01T12:00 ) source offset(::Tempo.ModifiedJulianDate) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  ModifiedJulianDate  (with origin at  1858-11-17T00:00 ) source offset(::Tempo.JulianDate2000) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  JulianDate2000  (with origin at  2000-01-01T12:00 ) source offset(::Tempo.ModifiedJulianDate2000) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  ModifiedJulianDate2000  (with origin at  2000-01-01T00:00 ) source"},{"id":73,"pagetitle":"Low-level API","title":"Tempo.offset_gps2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_gps2tai","content":" Tempo.offset_gps2tai  —  Function offset_gps2tai(seconds) Return the fixed offset between  GPS  and  TAI  in seconds. source"},{"id":74,"pagetitle":"Low-level API","title":"Tempo.offset_tai2gps","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2gps","content":" Tempo.offset_tai2gps  —  Function offset_tai2gps(seconds) Return the fixed offset between  TAI  and  GPS  in seconds. source"},{"id":75,"pagetitle":"Low-level API","title":"Tempo.offset_tai2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2tt","content":" Tempo.offset_tai2tt  —  Function offset_tai2tt(seconds) Return the fixed offset between  TAI  and  TT  in seconds. source"},{"id":76,"pagetitle":"Low-level API","title":"Tempo.offset_tai2utc","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2utc","content":" Tempo.offset_tai2utc  —  Function offset_tai2utc(seconds) Return the offset between  TAI  and  UTC  in seconds. source"},{"id":77,"pagetitle":"Low-level API","title":"Tempo.offset_tcb2tdb","ref":"/Tempo/stable/lapi/#Tempo.offset_tcb2tdb","content":" Tempo.offset_tcb2tdb  —  Function offset_tcb2tdb(seconds) Return the linear offset between  TCB  and  TDB  in seconds. source"},{"id":78,"pagetitle":"Low-level API","title":"Tempo.offset_tcg2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tcg2tt","content":" Tempo.offset_tcg2tt  —  Function offset_tcg2tt(seconds) Return the linear offset between  TCG  and  TT  in seconds. source"},{"id":79,"pagetitle":"Low-level API","title":"Tempo.offset_tdb2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tdb2tt","content":" Tempo.offset_tdb2tt  —  Function offset_tdb2tt(seconds) Return the offset between  TDB  and  TT  in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer.  For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much  as ~4 microseconds. References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":80,"pagetitle":"Low-level API","title":"Tempo.offset_tdb2tcb","ref":"/Tempo/stable/lapi/#Tempo.offset_tdb2tcb","content":" Tempo.offset_tdb2tcb  —  Function offset_tdb2tcb(seconds) Return the linear offset between  TDB  and  TCB  in seconds. source"},{"id":81,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tai","content":" Tempo.offset_tt2tai  —  Function offset_tt2tai(seconds) Return the fixed offset between  TT  and  TAI  in seconds. source"},{"id":82,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tcg","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tcg","content":" Tempo.offset_tt2tcg  —  Function offset_tt2tcg(seconds) Return the linear offset between  TT  and  TCG  in seconds. source"},{"id":83,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tdb","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tdb","content":" Tempo.offset_tt2tdb  —  Function offset_tt2tdb(seconds) Return the offset between  TT  and  TDB  in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer.  For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much  as ~4 microseconds. References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":84,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tdbh","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tdbh","content":" Tempo.offset_tt2tdbh  —  Function offset_tt2tdbh(seconds) Return the offset between  TT  and  TDBH  in seconds. The maximum error in using the above formula is about 10 µs from 1600 to 2200. For even more precise applications, the series expansion by   Harada & Fukushima (2003)  is recommended. References The IAU Resolutions on Astronomical Reference Systems, Time Scales, and Earth Rotation Models,   United States Naval Observatory, https://arxiv.org/pdf/astro-ph/0602086.pdf source"},{"id":85,"pagetitle":"Low-level API","title":"Tempo.offset_utc2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_utc2tai","content":" Tempo.offset_utc2tai  —  Function offset_utc2tai(seconds) Return the offset between  UTC  and  TAI  in seconds. source"},{"id":86,"pagetitle":"Low-level API","title":"Timescale Types","ref":"/Tempo/stable/lapi/#Timescale-Types","content":" Timescale Types"},{"id":87,"pagetitle":"Low-level API","title":"Tempo.TimeScaleNode","ref":"/Tempo/stable/lapi/#Tempo.TimeScaleNode","content":" Tempo.TimeScaleNode  —  Type TimeScaleNode{T} <: AbstractGraphNode Define a timescale. Fields name  – timescale name id  – timescale identification number (ID) parentid  – ID of the parent timescale ffp  – offest function from the parent timescale ftp  – offset function to the parent timescale source"},{"id":88,"pagetitle":"Low-level API","title":"Tempo.AbstractTimeScale","ref":"/Tempo/stable/lapi/#Tempo.AbstractTimeScale","content":" Tempo.AbstractTimeScale  —  Type AbstractTimeScale All timescales are subtypes of the abstract type  AbstractTimeScale . source"},{"id":89,"pagetitle":"Low-level API","title":"Tempo.GlobalPositioningSystemTime","ref":"/Tempo/stable/lapi/#Tempo.GlobalPositioningSystemTime","content":" Tempo.GlobalPositioningSystemTime  —  Type GlobalPositioningSystemTime <: AbstractTimeScale A type representing the Global Positioning System Time (GPS) time scale. source"},{"id":90,"pagetitle":"Low-level API","title":"Tempo.BarycentricDynamicalTime","ref":"/Tempo/stable/lapi/#Tempo.BarycentricDynamicalTime","content":" Tempo.BarycentricDynamicalTime  —  Type BarycentricDynamicalTime <: AbstractTimeScale A type representing the Barycentric Dynamical Time (TDB) time scale. source"},{"id":91,"pagetitle":"Low-level API","title":"Tempo.HighPrecisionBarycentricDynamicalTime","ref":"/Tempo/stable/lapi/#Tempo.HighPrecisionBarycentricDynamicalTime","content":" Tempo.HighPrecisionBarycentricDynamicalTime  —  Type HighPrecisionBarycentricDynamicalTime <: AbstractTimeScale A type representing the High Precision Barycentric Dynamical Time (TDBH) time scale. source"},{"id":92,"pagetitle":"Low-level API","title":"Tempo.BarycentricCoordinateTime","ref":"/Tempo/stable/lapi/#Tempo.BarycentricCoordinateTime","content":" Tempo.BarycentricCoordinateTime  —  Type BarycentricCoordinateTime <: AbstractTimeScale A type representing the Barycentric Coordinate Time (TCB) time scale. source"},{"id":93,"pagetitle":"Low-level API","title":"Tempo.TerrestrialTime","ref":"/Tempo/stable/lapi/#Tempo.TerrestrialTime","content":" Tempo.TerrestrialTime  —  Type TerrestrialTime <: AbstractTimeScale A type representing the Terrestrial Time (TT) time scale. source"},{"id":94,"pagetitle":"Low-level API","title":"Tempo.InternationalAtomicTime","ref":"/Tempo/stable/lapi/#Tempo.InternationalAtomicTime","content":" Tempo.InternationalAtomicTime  —  Type InternationalAtomicTime <: AbstractTimeScale A type representing the International Atomic Time (TAI) time scale. source"},{"id":95,"pagetitle":"Low-level API","title":"Tempo.UniversalTime","ref":"/Tempo/stable/lapi/#Tempo.UniversalTime","content":" Tempo.UniversalTime  —  Type UniversalTime <: AbstractTimeScale A type representing the Universal Time (UT1) time scale. source"},{"id":96,"pagetitle":"Low-level API","title":"Tempo.CoordinatedUniversalTime","ref":"/Tempo/stable/lapi/#Tempo.CoordinatedUniversalTime","content":" Tempo.CoordinatedUniversalTime  —  Type CoordinatedUniversalTime <: AbstractTimeScale A type representing the Coordinated Universal Time (UTC) time scale. source"},{"id":97,"pagetitle":"Low-level API","title":"Tempo.GeocentricCoordinateTime","ref":"/Tempo/stable/lapi/#Tempo.GeocentricCoordinateTime","content":" Tempo.GeocentricCoordinateTime  —  Type GeocentricCoordinateTime <: AbstractTimeScale A type representing the Geocentric Coordinate Time (TCG) time scale. source"},{"id":98,"pagetitle":"Low-level API","title":"Conversions","ref":"/Tempo/stable/lapi/#Conversions","content":" Conversions"},{"id":99,"pagetitle":"Low-level API","title":"Base.convert","ref":"/Tempo/stable/lapi/#Base.convert","content":" Base.convert  —  Function convert(to::S2, e::Epoch{S1}; system::TimeSystem=TIMESCALES) Convert  Epoch  with timescale  S1  to  S2 . Allows to use the default  TimeSystem  or  a custom constructed one.  source"},{"id":100,"pagetitle":"Low-level API","title":"Tempo.cal2jd","ref":"/Tempo/stable/lapi/#Tempo.cal2jd","content":" Tempo.cal2jd  —  Function cal2jd(year::Integer, month::Integer, day::Integer) This function converts a given date in the Gregorian calendar (year, month, day) to the  corresponding two-parts Julian Date. The first part is the  DJ2000 , while the  second output is the number of days since  J2000 . The year must be greater than 1583, and the month must be between 1 and 12. The day must  also be valid, taking into account whether the year is a leap year. If the input year or  month or day are invalid, a  DomainError  is thrown. Examples julia> Tempo.cal2jd(2021, 1, 1)\n(2.4000005e6, 59215.0)\n\njulia> Tempo.cal2jd(2022, 2, 28)\n(2.4000005e6, 59638.0)\n\njulia> Tempo.cal2jd(2019, 2, 29)\nERROR: DomainError with 29:\nthe day shall be between 1 and 28. References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). Klein, A., (2006), A Generalized Kahan-Babuska-Summation-Algorithm.   Computing, 76, 279-293, Section 3. ERFA software library source cal2jd(d::Date) Convert Gregorian calendar  Date  to a Julian Date, in days. Outputs j2000  – J2000 zero point: always 2451545 d  – J2000 Date for 12 hrs source"},{"id":101,"pagetitle":"Low-level API","title":"Tempo.calhms2jd","ref":"/Tempo/stable/lapi/#Tempo.calhms2jd","content":" Tempo.calhms2jd  —  Function calhms2jd(year, month, day, hour, minute, seconds) Convert Gregorian Calendar date and time to a two-parts Julian Date. The first part  is the  DJ2000 , while the second output is the number of days since  J2000 . Examples julia> Tempo.calhms2jd(2000, 1, 1, 12, 0, 0)\n(2.451545e6, 0.0)\n\njulia> Tempo.calhms2jd(2022, 1, 1, 0, 0, 0)\n(2.451545e6, 8035.5) source"},{"id":102,"pagetitle":"Low-level API","title":"Tempo.fd2hms","ref":"/Tempo/stable/lapi/#Tempo.fd2hms","content":" Tempo.fd2hms  —  Function fd2hms(fd::Number) Convert the day fraction  fd  to hour, minute and seconds. source"},{"id":103,"pagetitle":"Low-level API","title":"Tempo.fd2hmsf","ref":"/Tempo/stable/lapi/#Tempo.fd2hmsf","content":" Tempo.fd2hmsf  —  Function fd2hmsf(fd::Number) Convert the day fraction  fd  to hour, minute, second and fraction of seconds. Examples julia> Tempo.fd2hms(0.5)\n(12, 0, 0.0) source"},{"id":104,"pagetitle":"Low-level API","title":"Tempo.hms2fd","ref":"/Tempo/stable/lapi/#Tempo.hms2fd","content":" Tempo.hms2fd  —  Function hms2fd(hour::Integer, minute::Integer, second::Number) Convert hours, minutes and seconds to day fraction. Examples julia> Tempo.hms2fd(12, 0, 0.0)\n0.5 source"},{"id":105,"pagetitle":"Low-level API","title":"Tempo.jd2cal","ref":"/Tempo/stable/lapi/#Tempo.jd2cal","content":" Tempo.jd2cal  —  Function jd2cal(dj1::Number, dj2::Number) This function converts a given Julian Date (JD) to a Gregorian calendar date  (year, month, day, and fraction of a day). Examples julia> Tempo.jd2cal(DJ2000, 0.0)\n(2000, 1, 1, 0.5)\n\njulia> Tempo.jd2cal(DJ2000, 365.5)\n(2001, 1, 1, 0.0)\n\njulia> Tempo.jd2cal(DJ2000 + 365, 0.5)\n(2001, 1, 1, 0.0) Note The Julian Date is apportioned in any convenient way between the arguments   dj1  and  dj2 . For example,  JD = 2450123.7  could be expressed in any of these  ways, among others: dj1 dj2 2450123.7 0.0 (JD method) 2451545.0 -1421.3 (J2000 method) 2400000.5 50123.2 (MJD method) 2450123.5 0.2 (date & time method) Warning The earliest valid date is -68569.5 (-4713 Jan 1). The largest value accepted is 1e9. References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). Klein, A., (2006), A Generalized Kahan-Babuska-Summation-Algorithm.   Computing, 76, 279-293, Section 3. ERFA software library source"},{"id":106,"pagetitle":"Low-level API","title":"Tempo.jd2calhms","ref":"/Tempo/stable/lapi/#Tempo.jd2calhms","content":" Tempo.jd2calhms  —  Function jd2calhms(dj1::Number, dj2::Number) Convert a two-parts Julian Date to Gregorian year, month, day, hour, minute, seconds. See   jd2cal  for more information on the Julian Date composition.  julia> Tempo.jd2calhms(DJ2000, 0.0)\n(2000, 1, 1, 12, 0, 0.0)\n\njulia> Tempo.jd2calhms(DJ2000 + 1, 0.25)\n(2000, 1, 2, 18, 0, 0.0)\n\njulia> Tempo.jd2calhms(DJ2000, 1.25)\n(2000, 1, 2, 18, 0, 0.0) source"},{"id":107,"pagetitle":"Low-level API","title":"Tempo.tai2utc","ref":"/Tempo/stable/lapi/#Tempo.tai2utc","content":" Tempo.tai2utc  —  Function tai2utc(tai1, tai2) Transform a 2-part (quasi) Julian Date, in days, in International Atomic Time,  TAI   to a 2-part Julian Date in the Coordinated Universal Time,  UTC , scale. Note tai1 + tai2  is Julian Date, apportioned in any convenient way between the two arguments, for example such that  tai1  is the Julian Day Number and  tai2  is the fraction of a day.  The returned  utc1   and  utc2  form an analogous pair. Note JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.   References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) ERFA software library source"},{"id":108,"pagetitle":"Low-level API","title":"Tempo.utc2tai","ref":"/Tempo/stable/lapi/#Tempo.utc2tai","content":" Tempo.utc2tai  —  Function utc2tai(utc1, utc2) Transform a 2-part (quasi) Julian Date, in days, in Coordinate Universal Time,  UTC   to a 2-part Julian Date in the International Atomic Time,  TAI  scale. Note utc1 + utc2  is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example such that  utc1  is the Julian Day Number and  utc2  is the fraction of a day. Note JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.   References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) ERFA software library source"},{"id":109,"pagetitle":"Low-level API","title":"Leapseconds","ref":"/Tempo/stable/lapi/#Leapseconds","content":" Leapseconds"},{"id":110,"pagetitle":"Low-level API","title":"Tempo.Leapseconds","ref":"/Tempo/stable/lapi/#Tempo.Leapseconds","content":" Tempo.Leapseconds  —  Type Leapseconds{T} Stores information about the leap seconds that have been added to Coordinated Universal Time  (UTC). Fields jd2000 : a vector storing the Julian Date, in days since J2000, of each leap second. leap : a vector storing the number of leap seconds at each corresponding entry of the         jd2000  field. source"},{"id":111,"pagetitle":"Low-level API","title":"Tempo.LEAPSECONDS","ref":"/Tempo/stable/lapi/#Tempo.LEAPSECONDS","content":" Tempo.LEAPSECONDS  —  Constant LEAPSECONDS Leapseconds data. source"},{"id":112,"pagetitle":"Low-level API","title":"Tempo.leapseconds","ref":"/Tempo/stable/lapi/#Tempo.leapseconds","content":" Tempo.leapseconds  —  Function leapseconds(jd2000::Number) For a given UTC date, in Julian days since  J2000 , calculate Delta(AT) = TAI - UTC. source"},{"id":113,"pagetitle":"Low-level API","title":"Miscellaneous","ref":"/Tempo/stable/lapi/#Miscellaneous","content":" Miscellaneous"},{"id":114,"pagetitle":"Low-level API","title":"Tempo.find_year","ref":"/Tempo/stable/lapi/#Tempo.find_year","content":" Tempo.find_year  —  Function find_year(d::Integer) Return the Gregorian year associated to the given Julian Date day  d  since  J2000 . source"},{"id":115,"pagetitle":"Low-level API","title":"Tempo.find_month","ref":"/Tempo/stable/lapi/#Tempo.find_month","content":" Tempo.find_month  —  Function find_month(dayinyear::Integer, isleap::Bool) Find the month from the day of the year, depending on whether the year is leap or not. source"},{"id":116,"pagetitle":"Low-level API","title":"Tempo.find_day","ref":"/Tempo/stable/lapi/#Tempo.find_day","content":" Tempo.find_day  —  Function find_day(dayinyear::Integer, month::Integer, isleap::Bool) Find the day of the month from the day in the year and the month, depending on whether the  year is leap or not. source"},{"id":117,"pagetitle":"Low-level API","title":"Tempo.fraction_of_day","ref":"/Tempo/stable/lapi/#Tempo.fraction_of_day","content":" Tempo.fraction_of_day  —  Function fraction_of_day(t::Time)\nhms2fd(t::Time) Find the fraction of the day. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.fraction_of_day(t)\n0.5213002592592593 source"},{"id":118,"pagetitle":"Low-level API","title":"Tempo.fraction_of_second","ref":"/Tempo/stable/lapi/#Tempo.fraction_of_second","content":" Tempo.fraction_of_second  —  Function fraction_of_second(t::Time) Find the fraction of seconds. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.fraction_of_second(t)\n0.3423999999999978 source fraction_of_second(d::DateTime) Get the fraction of seconds associated to a  DateTime  object. source"},{"id":119,"pagetitle":"Low-level API","title":"Tempo.isleapyear","ref":"/Tempo/stable/lapi/#Tempo.isleapyear","content":" Tempo.isleapyear  —  Function isleapyear(year::Integer) Return  true  if the given Gregorian year is leap. source isleapyear(d::Date) True if  Date  is within a leap year. source"},{"id":120,"pagetitle":"Low-level API","title":"Tempo.lastj2000dayofyear","ref":"/Tempo/stable/lapi/#Tempo.lastj2000dayofyear","content":" Tempo.lastj2000dayofyear  —  Function lastj2000dayofyear(year::Integer) source"},{"id":121,"pagetitle":"Low-level API","title":"Tempo.second_in_day","ref":"/Tempo/stable/lapi/#Tempo.second_in_day","content":" Tempo.second_in_day  —  Function second_in_day(t::Time) Find the second in the day. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.second_in_day(t)\n45040.3424 source"},{"id":124,"pagetitle":"-","title":"Overview","ref":"/Tempo/stable/tmp/#Overview","content":" Overview There are different ways to represent an epoch within  Tempo , depending on the specific application. This section is here to help you choose the proper time representation and to present the capabilities of the module in transforming time between different representations. First of all, there is a deep difference in the way time is thought in the everyday life and  when dealing with space-related applications.  Whenever we say  the 12:35 of the 1st of January 2023 , we are merging three concepts:  the  calendar  ( 1st January 2023 ) and the  time representation  ( 12:35 ) together with its  scale . Calculations in any scientific discipline may involve precise time, but what  sets astronomy apart is the number and variety of  time scales  that have to be used. In fact, in astronomical applications the physical context of the “clock” matters, whether it is on Earth, moving or stationary, or on a spacecraft.  Time Conversions - The difference in each timescale is shown with \n    respect to TAI.  The most relevant time scales for these applications are: UT1  (Universal Time 1): UT1 is a time scale based on the rotation of the Earth.    It is used to measure the positions of celestial objects relative to the Earth's    surface. UT1 is closely related to  Greenwich Mean Time (GMT) , and the two time    scales are often used interchangeably. TAI  (International Atomic Time): TAI is a time scale based on the average    frequency of a set of atomic clocks. It is used to measure the positions of    celestial objects relative to the Earth's surface. TT  (Terrestrial Time): TT is a time scale based on the motion of celestial    objects around the solar system barycenter (the center of mass of the solar system).    It is used to measure the positions of celestial objects relative to the Earth's surface. TDB  (Barycentric Dynamical Time): TDB is a time scale based on the motion of    celestial objects around the solar system barycenter (the center of mass of the    solar system). It is used to measure the positions of celestial objects relative    to the solar system barycenter. TCB  (Barycentric Coordinate Time): TCB is a time scale based on the motion of    celestial objects around the solar system barycenter (the center of mass of the    solar system). It is used to measure the positions of celestial objects relative    to the solar system barycenter. TCG  (Geocentric Coordinate Time): TCG is a time scale based on the rotation of    the Earth. It is used to measure the positions of celestial objects relative to the    Earth's surface. Teph  (Ephemeris Time): Teph is a time scale based on the motion of celestial    objects around the solar system barycenter (the center of mass of the solar    system). It is used to measure the positions of celestial objects relative to    the solar system barycenter – here considered equivalent of  TDB . Of the seven time scales to be described here, one is atomic time (TAI),  one is solar time (UT1), one is an atomic/solar hybrid (UTC) and four are  dynamical times (TT, TCG, TCB, TDB). Other time scales of interest may also be the  ones associated to the different positioning systems. In particular:  GPS  (Global  Positioning System),  GLONASS  (Global Navigation Satellite System) and  GALILEO   (Global Navigation Satellite System) times could be defined as a constant offset with respect to TAI."},{"id":125,"pagetitle":"-","title":"Time in  JSMD","ref":"/Tempo/stable/tmp/#Time-in-JSMD","content":" Time in  JSMD Within  Tempo , the way in which time is represented in  Tempo  is through the use of   Epoch s.  Epoch s are an efficient, differentiable and precise way to represent  astronomical time. To parse an epoch object, two parameters shall be assigned: Timescale : This parameter determines the timescale that the epoch is based on.    For example, it can be set to UTC, TAI, TDB, or TCB. This allows the user to convert    the epoch between different timescales if necessary. Origin : This parameter determines the origin of the epoch, which is the point in time    from which the epoch is measured. This can be in the form of a Julian date, a   Modified Julian date or any user-defined origin.    The origin can also be set to a specific event, such as J2000.0 or B1950.0. By assigning these two parameters,  Epoch s can be used to represent time in a precise  manner, which is crucial for accurate timekeeping and coordination of events in a universe model."},{"id":128,"pagetitle":"Epochs","title":"Epochs Handling and Conversions","ref":"/Tempo/stable/tutorials/t01_epochs/#tutorial_01_epochs","content":" Epochs Handling and Conversions In this tutorial, the general workflow to be followed when dealing with time representations and their transformations is presented. In particular, most of the features of this package are designed around the  Epoch  data type, which differently from the  DateTime  object, provides the capability to represent time in different standard and user-define time scales."},{"id":129,"pagetitle":"Epochs","title":"Creating Epochs","ref":"/Tempo/stable/tutorials/t01_epochs/#Creating-Epochs","content":" Creating Epochs Time representions for space applications embed three different concepts:  The representation type (e.g. Gregorian or Julian calendar representation) The origin (e.g. J2000, JD, MJD, ...) The time scale (e.g. TAI, TT, TDB, UTC, UT, ...) All three infromation are considered when building an  Epoch . In particular, within  Tempo , the (interal) time representation is always based upon the Julian calendar, with the origin fixed at  J2000 , i.e., the 1st of January 2000 at noon. Different timescales are instead available, with the default one being the  TDB . The set of pre-defined time scales supported by this package is:  TT :  Terrestrial Time , is a time scale that is used for the prediction or recording of the positions of celestial bodies as measured by an observer on Earth.  TDB :  Barycentric Dynamical Time  is a relativistic time scale that is used for the prediction or recording of the positions of celestial bodies relative to the solar system's barycenter. TAI :  International Atomic Time  is a time scale based on the average frequency of a set of atomic clocks. TCG :  Geocentric Coordinate Time  is a relativistic coordinate time scale that is used for precise calculations of objects relative to the Earth.  TCB :  Barycentric Coordinate Time  is a relativistic coordinate time scale that is used for precise calculations of objects in the Solar System. UTC :  Coordinated Universal Time  is the primary civil time standard which is kept within one second from the mean solar time (UT1). However, since the rotation of the Earth is irregular, leap seconds are periodically inserted to keep UTC within 0.9 seconds of UT1.  TDBH : Although TDBH is not an official time scale, it is here used to provide a more accurate transformation between  TT  and  TDB , with a maximum error fo about 10 μs between 1600 and 2200. See  Tempo.offset_tt2tdbh  for more details.  GPS :  GPS Time  is a continuous time scale defined by the GPS Control segment defined as a constant offset of 19s from  TAI ."},{"id":130,"pagetitle":"Epochs","title":"ISO Strings","ref":"/Tempo/stable/tutorials/t01_epochs/#ISO-Strings","content":" ISO Strings With this in mind, many different ways are available to create a new  Epoch  object. The first is based upon the  ISO 8601  concept, an international standard to represent dates and times. The desired timescale can be either specified by appending its acronym to the string or as a second argument, as follows: julia> e = Epoch(\"2022-01-02T06:30:00.0 TT\") 2022-01-02T06:29:59.9999 TT julia> e = Epoch(\"2022-01-02T06:30:00.0\") 2022-01-02T06:29:59.9999 TDB julia> e = Epoch(\"2022-01-02T06:30:00.0\", TAI) 2022-01-02T06:29:59.9999 TAI As you can see, when we did not specify a timescale,  TDB  has been used by default. The usage of partial ISO strings is also supported: julia> e = Epoch(\"2020-01-01\") 2020-01-01T00:00:00.0000 TDB julia> e = Epoch(\"2021-01-30T01\") 2021-01-30T01:00:00.0000 TDB julia> e = Epoch(\"2022-06-12 UTC\") 2022-06-12T00:00:00.0000 UTC"},{"id":131,"pagetitle":"Epochs","title":"Julian Dates","ref":"/Tempo/stable/tutorials/t01_epochs/#Julian-Dates","content":" Julian Dates Epoch  objects can also be created from Julian Dates, Modified Julian Dates as well as Julian days or seconds since  J2000 . To parse a Julian Date, in days, the input string must be in the format  JD DDDDDDDDD.ffffff : julia> e = Epoch(\"JD 2451545.04\") 2000-01-01T12:57:36.0000 TDB julia> e = Epoch(\"JD 2451545.04 TT\") 2000-01-01T12:57:36.0000 TT Similarly, for Modified Julian Dates, the string format is  MJD DDDDDDDDD.ffffff : julia> e = Epoch(\"MJD 51544.54\") 2000-01-01T12:57:36.0000 TDB julia> e = Epoch(\"MJD 51544.54 TT\") 2000-01-01T12:57:36.0000 TT When a prefix is not specified, the epoch constructor assumes the input is expressed as Julian days since  J2000 : julia> e = Epoch(\"9.0\") 2000-01-10T12:00:00.0000 TDB julia> e = Epoch(\"9.0 TT\") 2000-01-10T12:00:00.0000 TT As you can see, the timescale acronym can always be appended to the predefined string format to override the default time scale. Finally, it is also possible to create an epoch by specifing the number of seconds since  J2000 . In the latter case, the constructor has a slightly different form and always requires the timescale argument: julia> e = Epoch(60.0, TT) 2000-01-01T12:01:00.0000 TT julia> e = Epoch(60.0, TerrestrialTime) 2000-01-01T12:01:00.0000 TT julia> e = Epoch{TerrestrialTime}(60.0) 2000-01-01T12:01:00.0000 TT"},{"id":132,"pagetitle":"Epochs","title":"DateTime","ref":"/Tempo/stable/tutorials/t01_epochs/#DateTime","content":" DateTime Finally, an  Epoch  can also be constructed from the  DateTime  object defined within this package: julia> dt = DateTime(2001, 6, 15, 0, 0, 0, 0.0) 2001-06-15T00:00:00.0000 julia> e = Epoch(dt, TT) 2001-06-15T00:00:00.0000 TT julia> e = Epoch(dt, TerrestrialTime) 2001-06-15T00:00:00.0000 TT"},{"id":133,"pagetitle":"Epochs","title":"Working with Epochs","ref":"/Tempo/stable/tutorials/t01_epochs/#Working-with-Epochs","content":" Working with Epochs"},{"id":134,"pagetitle":"Epochs","title":"Basic Operations","ref":"/Tempo/stable/tutorials/t01_epochs/#Basic-Operations","content":" Basic Operations The  Epoch  type supports a limited subset of basic mathematical and logical operations on it. For example, the offset, in seconds, between two epochs can be computed by subtracting them:  julia> e1 = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> e2 = Epoch(50.0, TT) 2000-01-01T12:00:50.0000 TT julia> e1 - e2 Duration{Float64}(40, 0.0) julia> e3 = Epoch(40, TAI) 2000-01-01T12:00:40.0000 TAI julia> e1 - e3 ERROR: only epochs defined in the same timescale can be subtracted. Notice that this operation can be performed only if the two epochs are defined on the same timescale. Epochs can also be shifted forward and backwards in time by adding or subtracting an arbitrary number of seconds:  julia> e1 = Epoch(30.0, TDB) 2000-01-01T12:00:30.0000 TDB julia> e1 += 50 2000-01-01T12:01:20.0000 TDB julia> e1 -= 30.42 2000-01-01T12:00:49.5800 TDB You can check whether an epoch is greater than an other with the logical operators: julia> e1 = Epoch(50.0, UTC) 2000-01-01T12:00:50.0000 UTC julia> e2 = Epoch(50.0, UTC) 2000-01-01T12:00:50.0000 UTC julia> e1 > e2 false julia> e1 == e2 true Again, the operations are supported only if the two epochs belong to the same timescale. Finally, it is also possible to construct ranges with  Epoch s, with a default timestep of one Julian day. User-defined timesteps are assumed to be expressed in seconds. julia> e1 = Epoch(\"2024-01-01T12:00:00\") 2024-01-01T12:00:00.0000 TDB julia> e2 = Epoch(\"2024-01-05T12:00:00\") 2024-01-05T12:00:00.0000 TDB julia> collect(e1:e2) ERROR: MethodError: Cannot `convert` an object of type  Int64  to an object of type  Duration{Float64} \n\nClosest candidates are:\n  convert(::Type{N},  ::Epoch{S, N} ) where {S, N}\n    @   Tempo   ~/work/Tempo.jl/Tempo.jl/src/ epoch.jl:242 \n  convert(::Type{T},  ::T ) where T\n    @   Base   Base.jl:84 \n  (::Type{Duration{T}} where T)(::Any,  ::Any )\n    @   Tempo   ~/work/Tempo.jl/Tempo.jl/src/ duration.jl:13 julia> collect(e1:172800:e2) 3-element Vector{Epoch{BarycentricDynamicalTime, Float64}}:\n 2024-01-01T12:00:00.0000 TDB\n 2024-01-03T12:00:00.0000 TDB\n 2024-01-05T12:00:00.0000 TDB"},{"id":135,"pagetitle":"Epochs","title":"Julian Dates","ref":"/Tempo/stable/tutorials/t01_epochs/#Julian-Dates-2","content":" Julian Dates A predefined set of functions is also provided to easily convert [ Epoch ] objects to Julian seconds, days and centuries since  J2000 : julia> e = Epoch(\"2024-01-01T12:00:00 TAI\") 2024-01-01T12:00:00.0000 TAI julia> j2000(e) 8766.0 julia> j2000s(e) 7.573824e8 julia> j2000c(e) 0.24"},{"id":136,"pagetitle":"Epochs","title":"Converting Between Time Scales","ref":"/Tempo/stable/tutorials/t01_epochs/#Converting-Between-Time-Scales","content":" Converting Between Time Scales Epoch transformations between the standard and user-defined timescales are simply performed through the  convert  method by specifying the target time scale julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eTAI = convert(TAI, e) 2000-01-01T12:00:57.8160 TAI julia> eTCG = convert(TCG, e) 2000-01-01T12:01:30.5058 TCG These transformations are based on a  directed  graph of timescales ( TIMESCALES ) existing within  Tempo . Set of functions provide then the offsets in seconds between each pair of connected timescales, offering a simple, effective and efficient way to compute these transformations. julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eTAI = convert(TAI, e) 2000-01-01T12:00:57.8160 TAI"},{"id":137,"pagetitle":"Epochs","title":"UTC and Leap Seconds","ref":"/Tempo/stable/tutorials/t01_epochs/#UTC-and-Leap-Seconds","content":" UTC and Leap Seconds A special remark must be made on the conversion between TAI and UTC. The offset between these two timescales is defined by a leap seconds, which are introduced to keep the UTC time scale within 0.9 seconds from UT1. Since the rotation of the Earth is irregular, it is not possible to predict when a new leap second will be introduced in the future.  The latest NAIF's leap second kernel ( LSK ) is embedded within  Tempo  as a package artifact, which will be manually updated each time a new kernel is released, so that the user effort is minimised. Indeed, transforming an  Epoch  from a generic timescale to UTC is a simple as: julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eUTC = convert(UTC, e) 2000-01-01T12:00:25.8159 UTC"},{"id":138,"pagetitle":"Epochs","title":"UTC to UT1","ref":"/Tempo/stable/tutorials/t01_epochs/#UTC-to-UT1","content":" UTC to UT1 The offset between UT1 and UTC, which depends upon the rotation of the Earth, is available in the Earth Orientation Parameters (EOP) provided by the International Earth Rotation and Reference System Service ( IERS ). Since those parameters are also required to compute the orientation of the ITRF with respect to the ICRF, a decision has been made to define the UT1 timescale in  FrameTransformations.jl , a different package which enhances  Tempo  with the capability to transform from and to UT1."},{"id":141,"pagetitle":"Custom Timescales","title":"Creating Custom Timescales","ref":"/Tempo/stable/tutorials/t02_scales/#tutorial_02_scales","content":" Creating Custom Timescales In Tempo.jl, all timescales connections and epoch conversions are handled through a  directed graph .  A default graph ( TIMESCALES ), containing a set of predefined timescales is provided by this package. However, this package also provided a set of routines to either extend such graph or create a completely custom one. In this tutorial, we will explore both alternatives."},{"id":142,"pagetitle":"Custom Timescales","title":"Defining a New Timescale","ref":"/Tempo/stable/tutorials/t02_scales/#Defining-a-New-Timescale","content":" Defining a New Timescale Custom timescales can be created with the  @timescale  macro, which automatically creates the required types and structures, given the timescale acronym, an integer ID and, eventually, the full name of the timescale.  julia> @timescale ET 15 EphemerisTime The ID is an integer that is internally used to uniquely represent the timescale, whereas the acronym is used to alias such ID. It is also possible to define multiple acronyms associated to the same ID but you cannot assign multiple IDs to the same acronym. In case a full name is not provided, a default one will be built by appending  TimeScale  to the acronym. Warning The IDs from 1 to 10 are used to define the standard timescales of the package. To avoid unexpected behaviors, custom timescales should be registered with higher IDs. In the previous example, we have created a custom timescale named  EphemerisTime , with ID 15. We are now able to define epochs with respect to ET, but we cannot perform conversions towards other timescales until we register it in a graph system: julia> ep = Epoch(20.425, ET) 2000-01-01T12:00:20.4249 ET julia> convert(TT, ep) ERROR: EpochConversionError: cannot convert Epoch from the timescale Main.EphemerisTime to TerrestrialTime."},{"id":143,"pagetitle":"Custom Timescales","title":"Extending the Default Graph","ref":"/Tempo/stable/tutorials/t02_scales/#Extending-the-Default-Graph","content":" Extending the Default Graph In this section, the goal is to register ET as a zero-offset scale with respect to  TDB . To register this timescale in the default graph, we first need to define the offset functions of ET with respect to TDB:  julia> offset_tdb2et(sec::Number) = 0 offset_tdb2et (generic function with 1 method) julia> offset_et2tdb(sec::Number) = 0 offset_et2tdb (generic function with 1 method) Since we have assumed that the two scales are identical, our functions will always return a zero offset. Rememeber that timescales graph is  directed , meaning that if the user desires to go back and forth between two timescales, both transformations must be defined. The input argument of such functions is always the number of seconds since J2000 expressed in the origin timescale. Finally, the  add_timescale!  method can be used to register ET within the default graph: julia> add_timescale!(TIMESCALES, ET, offset_tdb2et, parent=TDB, ftp=offset_et2tdb) If the inverse transformation (from ET to TDB) is not provided, only one-way epoch conversions will be allowed. We can now check that the desired timescale has been properly registered and performs the same as TDB:  julia> ep = Epoch(\"200.432 TT\") 2000-07-19T22:22:04.8000 TT julia> convert(TDB, ep) 2000-07-19T22:22:04.7995 TDB julia> convert(ET, ep) 2000-07-19T22:22:04.7995 ET"},{"id":144,"pagetitle":"Custom Timescales","title":"Creating a Custom Graph","ref":"/Tempo/stable/tutorials/t02_scales/#Creating-a-Custom-Graph","content":" Creating a Custom Graph To create a custom directed graph to handle timescales, Tempo.jl provides the  TimeSystem  type. Therefore, let us define a new time transformation system called  TIMETRANSF : julia> const TIMETRANSF = TimeSystem{Float64}() TimeSystem{Float64}(SMDGraphs.MappedNodeGraph{Tempo.TimeScaleNode{Float64}, Graphs.SimpleGraphs.SimpleDiGraph{Int64}}(Graphs.SimpleGraphs.SimpleDiGraph{Int64}(0, Vector{Int64}[], Vector{Int64}[]), Dict{Int64, Int64}(), Tempo.TimeScaleNode{Float64}[], Dict{Int64, Dict{Int64, Vector{Int64}}}(), Dict{Int64, Dict{Int64, Int64}}())) This object contains a graph and the properties associated to the new time-system defined in  TIMETRANSF . At the moment, the computational graph is empty and we need to manually populate it with the new transformations. We begin by creating a new timescale:  julia> @timescale DTS 1 DefaultTimeScale Once created, the new timescale is ready to be registered. If it is the first scale registered in the computational graph, nothing else than the type alias is needed and the registration can be performed as follows: julia> add_timescale!(TIMETRANSF, DTS) julia> TIMETRANSF.scales.nodes 1-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1) Instead, in case the timescale is linked to a parent one, offset functions shall be defined. In this example, assume we want to register the timescales  NTSA  and  NTSB  such that  NTSA  has  DTS  as parent and a constant offset of 1 second, whereas NTSB  has  NTSA  as parent and a linear offset with slope of 1/86400. We begin by creating the first timescale: julia> @timescale NTSA 2 NewTimeScaleA We then define its offset functions and register it in  TIMETRANSF  via the  add_timescale!  method: julia> const OFFSET_DTS_TO_NTSA = 1.0 1.0 julia> offset_dts2ntsa(sec::Number) = OFFSET_DTS_TO_NTSA offset_dts2ntsa (generic function with 1 method) julia> offset_ntsa2dts(sec::Number) = -OFFSET_DTS_TO_NTSA offset_ntsa2dts (generic function with 1 method) julia> add_timescale!(TIMETRANSF, NTSA, offset_dts2ntsa, parent=DTS, ftp=offset_ntsa2dts) Now, if we have a look to the computational graph, we'll see that  NTSA  is registered: julia> TIMETRANSF.scales.nodes 2-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1)\n\n TimeScaleNode{Float64}(name=NTSA, id=2, parent=1) If now we create a  DTS  epoch, we can leverage our custom time transformation system to convert it to an epoch in the  NTSA  timescale: julia> e = Epoch(0.0, DTS) 2000-01-01T12:00:00.0000 DTS julia> convert(NTSA, e, system=TIMETRANSF) 2000-01-01T12:00:01.0000 NTSA Whenever the conversions are based on a custom time system, the graph must be provided as an additional argument to the  convert  method.  To conclude the example, we will now add the  NTSB  scale but only register the  NTSA -> NTSB  transformation: julia> @timescale NTSB 3 NewTimeScaleB julia> offset_ntsa2ntsb(sec::Number) = sec/86400.0 offset_ntsa2ntsb (generic function with 1 method) julia> add_timescale!(TIMETRANSF, NTSB, offset_ntsa2ntsb, parent=NTSA) Now, let's have a look to the nodes in the graph: julia> TIMETRANSF.scales.nodes 3-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1)\n\n TimeScaleNode{Float64}(name=NTSA, id=2, parent=1)\n\n TimeScaleNode{Float64}(name=NTSB, id=3, parent=2) You can see that the new timescale has been registered with the desired integer ID  3 . To test the complete system, we will translate forwad of 2 days the previous epoch  e  and transform it in both timescales:  julia> e += 2*86400 2000-01-03T12:00:00.0000 DTS julia> ea = convert(NTSA, e, system=TIMETRANSF) 2000-01-03T12:00:01.0000 NTSA julia> eb = convert(NTSB, e, system=TIMETRANSF) 2000-01-03T12:00:03.0000 NTSB As expected, we obtain translations of 1 and 3 seconds, respectively."},{"id":147,"pagetitle":"Home","title":"Welcome to Ephemerides.jl!","ref":"/Ephemerides/stable/#Welcome-to-Ephemerides.jl!","content":" Welcome to Ephemerides.jl! Ephemerides.jl is a Julia library that provides fast, thread-safe and allocation-free access to binary JPL  SPK  and  PCK  ephemeris files. Completely written in Julia, it enables Automatic-Differentiation (AD) via  ForwardDiff.jl  across all of its function calls.  It outperforms both  SPICE.jl  and  CALCEPH.jl  calls for most types of SPK segments and supports state vector and orientation angles computation up to order 3 (jerk). Note This package is meant to be used in combination with  FrameTransformations.jl , which enables transformations between different point and axes. Indeed, differently from traditional ephemeris readers such as  CALCEPH  and  SPICE , this package is only meant to read the data stored in the binary kernels. It does not perform transformations between reference frames nor concatenations of state vectors. For example, if ephemeris data for point 399 (Earth) is defined with respect to point 3 (Earth-Moon Barycenter) in the ICRF axes, with this package we will only be able to compute the state vector from 399 to 3 or viceversa.  Note All the package routines have been extensively tested against both SPICE and CALCEPH."},{"id":148,"pagetitle":"Home","title":"Installation","ref":"/Ephemerides/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg\n\njulia> Pkg.add(\"Ephemerides.jl\");"},{"id":149,"pagetitle":"Home","title":"Quickstart","ref":"/Ephemerides/stable/#Quickstart","content":" Quickstart Load SPK and PCK ephemeris kernels:  using Ephemerides \n\n# Load a single SPK kernel \neph_spk = EphemerisProvider(\"de440.bsp\")\n\n# Load a single PCK kernel\neph_pck = EphemerisProvider(\"pa440.bsp\")\n\n# Load multiple SPK and PCK kernels\neph = EphemerisProvider([\"de440.bsp\", \"pa440.bsp\"]) Inspect the kernels properties: # Retrieve the list of NAIF ID for all the available points \npoints = ephem_available_points(eph)\n\n# Retrieve the list of NAIF ID for all the available axes\naxes = ephem_available_axes(eph) Retrieve state and orientation data: # TDB seconds at 2000-01-01T12:00:00 (J2000)\ntime = 0.0\n\n# Compute the position of point 399 with respect to 3 at J2000\npos = ephem_vector3(eph, 3, 399, time)\n\n# Compute the position and its derivatives for point 299 with respect to 2\npvaj = ephem_vector12(eph, 2, 299, time)\n\n# Compute the orientation of axes 31006 (PA440) with respect to 1 (ICRF) at J2000\nangles = ephem_rotation3(eph, 1, 31006, time)"},{"id":150,"pagetitle":"Home","title":"Current Limitations","ref":"/Ephemerides/stable/#Current-Limitations","content":" Current Limitations The supported JPL binary SPK/PCK segments types are: 1, 2, 3, 5, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, 21.  Binary INPOP kernels are not supported.  Acceleration and jerk computations are unavailable for SPK segments of type 1, 5, 15, 17 and 21."},{"id":153,"pagetitle":"Public API","title":"Public Documentation","ref":"/Ephemerides/stable/api/api/#ephemerides_api","content":" Public Documentation"},{"id":154,"pagetitle":"Public API","title":"Kernels Loading and Inspection Functions","ref":"/Ephemerides/stable/api/api/#Kernels-Loading-and-Inspection-Functions","content":" Kernels Loading and Inspection Functions"},{"id":155,"pagetitle":"Public API","title":"Ephemerides.EphemerisProvider","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemerisProvider","content":" Ephemerides.EphemerisProvider  —  Type EphemerisProvider(file::String)\nEphemerisProvider(files::Vector{String}) Create an  EphemerisProvider  instance by loading a single or multiple binary ephemeris  kernel files specified by  files . Currently, only NAIF Double precision Array File (DAF) kernels (i.e., SPK and PCK) are accepted. Example julia> eph = EphemerisProvider(\"PATH_TO_KERNEL\")\nEphemerisProvider([...])\n\njulia> eph = EphemerisProvider([\"PATH_TO_KERNEL_1\", \"PATH_TO_KERNEL_2\"])\nEphemerisProvider([]) source"},{"id":156,"pagetitle":"Public API","title":"Ephemerides.EphemRecordSPK","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemRecordSPK","content":" Ephemerides.EphemRecordSPK  —  Type EphemRecordSPK <: AbstractEphemRecord Store the SPK metadata relative to a given (target, center) objects pair. Fields target  –  Int  target object NAIF ID center  –  Int  center object NAIF ID axes  –  Int  reference axes ID  t_start  – start times of each sub-window, in TDB seconds since J2000 t_end  – final times of each sub-window, in TDB seconds since J2000 source"},{"id":157,"pagetitle":"Public API","title":"Ephemerides.EphemRecordPCK","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemRecordPCK","content":" Ephemerides.EphemRecordPCK  —  Type EphemRecordPCK <: AbstractEphemRecord Store the PCK metadata relative to a given (target, center) axes pair. Fields target  –  Int  target axes NAIF ID center  –  Int  center axes NAIF ID t_start  – start times of each sub-window, in TDB seconds since J2000 t_end  – final times of each sub-window, in TDB seconds since J2000 source"},{"id":158,"pagetitle":"Public API","title":"Ephemerides.ephem_timescale_id","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_timescale_id","content":" Ephemerides.ephem_timescale_id  —  Function ephem_timescale_id(eph::EphemerisProvider) Retrieve a timescale ID associated with the ephemeris handler  eph .  It returns 1 for Barycentric Dynamical Time (TDB) and 2 for Barycentric Coordinate Time (TCB). Warning Ephemeris providers with mixed timescales are not supported. An error is thrown if in  the ephemeris handler some segments are defined in TDB and some other segments in TCB. source"},{"id":159,"pagetitle":"Public API","title":"Ephemerides.ephem_spk_timespan","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_spk_timespan","content":" Ephemerides.ephem_spk_timespan  —  Function ephem_spk_timespan(eph::EphemerisProvider) Return the minimum and maximum time available in the SPK kernels loaded within  eph , in  TDB seconds since J2000, together with a continuity parameter defined as follows:  0  no SPK data is available. 1  the quantities of all bodies are available for any time between the first and last time. 2  the quantities of some bodies are available on discontinuous time intervals between the    first and last time. 3  the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time. References CALCEPH  C++ library See Also See also  ephem_pck_timespan . source"},{"id":160,"pagetitle":"Public API","title":"Ephemerides.ephem_pck_timespan","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_pck_timespan","content":" Ephemerides.ephem_pck_timespan  —  Function ephem_pck_timespan(eph::EphemerisProvider) Return the minimum and maximum time available in the PCK kernels loaded within  eph , in  TDB seconds since J2000, together with a continuity parameter defined as follows:  0  no PCK data is available. 1  the quantities of all axes are available for any time between the first and last time. 2  the quantities of some axes are available on discontinuous time intervals between the    first and last time. 3  the quantities of each axis are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time. References CALCEPH  C++ library See Also See also  ephem_spk_timespan . source"},{"id":161,"pagetitle":"Public API","title":"Ephemerides.ephem_spk_records","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_spk_records","content":" Ephemerides.ephem_spk_records  —  Function ephem_spk_records(eph::EphemerisProvider) Return a list of  EphemRecordSPK  storing metadata relative to each (target, center) object pairs in the loaded SPK kernels.  source"},{"id":162,"pagetitle":"Public API","title":"Ephemerides.ephem_pck_records","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_pck_records","content":" Ephemerides.ephem_pck_records  —  Function ephem_pck_records(eph::EphemerisProvider) Return a list of  EphemRecordPCK  storing metadata relative to each (target, center) axes pairs in the loaded PCK kernels.  source"},{"id":163,"pagetitle":"Public API","title":"Ephemerides.ephem_get_points","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_get_points","content":" Ephemerides.ephem_get_points  —  Function ephem_get_points(eph::EphemerisProvider) Return a list of NAIFIds representing bodies with available ephemeris data.  source"},{"id":164,"pagetitle":"Public API","title":"Ephemerides.ephem_get_axes","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_get_axes","content":" Ephemerides.ephem_get_axes  —  Function ephem_get_axes(eph::EphemerisProvider) Return a list of Frame IDs representing axes with available orientation data.  source"},{"id":165,"pagetitle":"Public API","title":"Computing Positions","ref":"/Ephemerides/stable/api/api/#Computing-Positions","content":" Computing Positions"},{"id":166,"pagetitle":"Public API","title":"Ephemerides.ephem_vector3","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector3","content":" Ephemerides.ephem_vector3  —  Function ephem_vector3(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 3-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":167,"pagetitle":"Public API","title":"Ephemerides.ephem_vector6","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector6","content":" Ephemerides.ephem_vector6  —  Function ephem_vector6(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 6-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":168,"pagetitle":"Public API","title":"Ephemerides.ephem_vector9","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector9","content":" Ephemerides.ephem_vector9  —  Function ephem_vector9(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 9-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":169,"pagetitle":"Public API","title":"Ephemerides.ephem_vector12","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector12","content":" Ephemerides.ephem_vector12  —  Function ephem_vector12(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 12-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":170,"pagetitle":"Public API","title":"Computing Orientation","ref":"/Ephemerides/stable/api/api/#Computing-Orientation","content":" Computing Orientation"},{"id":171,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation3","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation3","content":" Ephemerides.ephem_rotation3  —  Function ephem_rotation3(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 3-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":172,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation6","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation6","content":" Ephemerides.ephem_rotation6  —  Function ephem_rotation6(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 6-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":173,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation9","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation9","content":" Ephemerides.ephem_rotation9  —  Function ephem_rotation9(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 9-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":174,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation12","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation12","content":" Ephemerides.ephem_rotation12  —  Function ephem_rotation12(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 12-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":177,"pagetitle":"Low-level API","title":"Low-level API","ref":"/Ephemerides/stable/api/lapi/#ephemerides_api","content":" Low-level API These functions are not meant to be used outside of the package. They are documented  only to aid future developments of the package."},{"id":178,"pagetitle":"Low-level API","title":"Ephemeris Provider","ref":"/Ephemerides/stable/api/lapi/#Ephemeris-Provider","content":" Ephemeris Provider"},{"id":179,"pagetitle":"Low-level API","title":"Ephemerides.get_daf","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_daf","content":" Ephemerides.get_daf  —  Function daf(eph::EphemerisProvider) Return the  DAF  files stored in the ephemeris provider.  source daf(eph::EphemerisProvider, id::Int) Return the  DAF  file in the ephemeris provider at index  id . source"},{"id":180,"pagetitle":"Low-level API","title":"Ephemerides.spk_links","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.spk_links","content":" Ephemerides.spk_links  —  Function spk_links(eph::EphemerisProvider) Return the [ SPKLinkTable ] for the SPK segments. source"},{"id":181,"pagetitle":"Low-level API","title":"Ephemerides.pck_links","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.pck_links","content":" Ephemerides.pck_links  —  Function pck_links(eph::EphemerisProvider) Return the  SPKLinkTable  for the PCK segments. source"},{"id":182,"pagetitle":"Low-level API","title":"DAF Routines","ref":"/Ephemerides/stable/api/lapi/#DAF-Routines","content":" DAF Routines"},{"id":183,"pagetitle":"Low-level API","title":"DAF Header","ref":"/Ephemerides/stable/api/lapi/#DAF-Header","content":" DAF Header"},{"id":184,"pagetitle":"Low-level API","title":"Ephemerides.DAFHeader","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAFHeader","content":" Ephemerides.DAFHeader  —  Type DAFHeader The DAF header, or file record, is the first physical record in a DAF and stores general  information about the content of the file.  Fields nd  –  Int32  number of double components in each array summary ni  –  Int32  number of integer components in each array summary fwd  –  Int32  record number of initial summary record bwd  –  Int32  record number of final summary record ffa  –  Int32  first free address of the file  name  –  String  internal name of the file lend  –  Bool  true if the file was generated in little endian  References DAF Required Reading See Also See also  DAF  and  EphemerisProvider source"},{"id":185,"pagetitle":"Low-level API","title":"Ephemerides.initial_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_record","content":" Ephemerides.initial_record  —  Function initial_record(head::DAFHeader) Return the record number of the initial summary record in the DAF  source initial_record(daf::DAF) Return the record number of the initial summary record in the DAF. source"},{"id":186,"pagetitle":"Low-level API","title":"Ephemerides.final_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_record","content":" Ephemerides.final_record  —  Function final_record(head::DAFHeader) Return the record number of the final summary record in the DAF  source final_record(daf::DAF) Return the record number of the final summary record in the DAF. source"},{"id":187,"pagetitle":"Low-level API","title":"Ephemerides.free_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.free_address","content":" Ephemerides.free_address  —  Function free_address(head::DAFHeader) Return the first free address in the file, i.e., the address at which the first element of  the next array is to be added. source free_address(daf::DAF) Return the first free address in the file, i.e., the address at which the first element of  the next array is to be added. source"},{"id":188,"pagetitle":"Low-level API","title":"Ephemerides.endian","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.endian","content":" Ephemerides.endian  —  Function endian(head::DAFHeader) Return  true  if the DAF file is in little-endian. source endian(daf::DAF) Return  true  if the DAF is in little-endian. source"},{"id":189,"pagetitle":"Low-level API","title":"Ephemerides.filename","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.filename","content":" Ephemerides.filename  —  Function filename(head::DAFHeader) Return the internal description of the DAF. source"},{"id":190,"pagetitle":"Low-level API","title":"Ephemerides.summary_size","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.summary_size","content":" Ephemerides.summary_size  —  Function summary_size(head::DAFHeader) Compute the size of a single summary record of a DAF file, in bytes. source"},{"id":191,"pagetitle":"Low-level API","title":"DAF Descriptor","ref":"/Ephemerides/stable/api/lapi/#DAF-Descriptor","content":" DAF Descriptor"},{"id":192,"pagetitle":"Low-level API","title":"Ephemerides.DAFSegmentDescriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAFSegmentDescriptor","content":" Ephemerides.DAFSegmentDescriptor  —  Type DAFSegmentDescriptor A container object to store both SPK and PCK descriptors information. Fields segtype  –  Int32  SPK/PCK segment type tstart  –  Float64  initial segment type, in TDB seconds since J2000.0 tend  –  Float64  final segment type, in TDB seconds since J2000.0 tid  –  Int32  target object NAIF ID cid  –  Int32  center object NAIF ID axesid  –  Int32  reference axes ID. Defaults to -1 for PCKs iaa  –  Int32  initial array address faa  –  Int32  final array address References SPK Required Reading PCK Required Reading source"},{"id":193,"pagetitle":"Low-level API","title":"Ephemerides.segment_type","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.segment_type","content":" Ephemerides.segment_type  —  Function segment_type(desc::DAFSegmentDescriptor) Return the SPK/PCK segment type. source"},{"id":194,"pagetitle":"Low-level API","title":"Ephemerides.initial_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_time","content":" Ephemerides.initial_time  —  Function initial_time(desc::DAFSegmentDescriptor) Return the initial epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0 source initial_time(link::SPKLink) Return the initial epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0 source"},{"id":195,"pagetitle":"Low-level API","title":"Ephemerides.final_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_time","content":" Ephemerides.final_time  —  Function final_time(desc::DAFSegmentDescriptor) Return the final epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0 source final_time(link::SPKLink) Return the final epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0 source"},{"id":196,"pagetitle":"Low-level API","title":"Ephemerides.center","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.center","content":" Ephemerides.center  —  Function center(desc::DAFSegmentDescriptor) Return the NAIF integer code for the reference object or axes for SPK and PCK, respectively. source"},{"id":197,"pagetitle":"Low-level API","title":"Ephemerides.target","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.target","content":" Ephemerides.target  —  Function target(desc::DAFSegmentDescriptor) Return the NAIF integer code for the target object or axes for SPK and PCK, respectively. source"},{"id":198,"pagetitle":"Low-level API","title":"Ephemerides.axes","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.axes","content":" Ephemerides.axes  —  Function axes(desc::DAFSegmentDescriptor) Return the NAIF integer code for the reference axes. It is valid only for SPK files and  defaults to -1 for PCKs.  source"},{"id":199,"pagetitle":"Low-level API","title":"Ephemerides.initial_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_address","content":" Ephemerides.initial_address  —  Function initial_address(desc::DAFSegmentDescriptor) Return the initial address of the segment array in the DAF. source"},{"id":200,"pagetitle":"Low-level API","title":"Ephemerides.final_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_address","content":" Ephemerides.final_address  —  Function final_address(desc::DAFSegmentDescriptor) Return the final address of the segment array in teh DAF. source"},{"id":201,"pagetitle":"Low-level API","title":"Ephemerides.get_segment_boundaries","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_segment_boundaries","content":" Ephemerides.get_segment_boundaries  —  Function get_segment_boundaries(desclist::Vector{DAFSegmentDescriptor}) Parse all the segment descriptors of a given (center, target) pair and return a set of  initial and final times, in TDB seconds since J2000, representing all the time  sub-windows in which the ephemeris data for this pair is defined.  source"},{"id":202,"pagetitle":"Low-level API","title":"Ephemerides.parse_spk_segment_descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_spk_segment_descriptor","content":" Ephemerides.parse_spk_segment_descriptor  —  Function parse_spk_segment_descriptor(summary::Vector{UInt8}, lend::Bool) Create a  DAFSegmentDescriptor  object by parsing a binary SPK segment descriptor. References SPK Required Reading source"},{"id":203,"pagetitle":"Low-level API","title":"Ephemerides.parse_pck_segment_descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_pck_segment_descriptor","content":" Ephemerides.parse_pck_segment_descriptor  —  Function parse_pck_segment_descriptor(summary::Vector{UInt8}, lend::Bool) Create a  DAFSegmentDescriptor  object by parsing a binary PCK segment descriptor.  A default value of -1 is used to fill the reference frame field. The target and center fields are used for the actual target and center axes. References PCK Required Reading source"},{"id":204,"pagetitle":"Low-level API","title":"DAF","ref":"/Ephemerides/stable/api/lapi/#DAF","content":" DAF"},{"id":205,"pagetitle":"Low-level API","title":"Ephemerides.DAF","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAF","content":" Ephemerides.DAF  —  Type DAF Container to hold the information of NAIF's Double precision Array File (DAF).  Fields filepath  –  String  system filepath of the DAF  array  –  Vector{UInt8}  binary content of the DAF header  –  DAFHeader  file record of the DAF comment  –  String  text within the DAF comment area  ftype  –  Int  file type, equals 1 for SPK and 2 for PCK desc  – DAF PCK/SPK segment descriptors seglist  –  SPKSegmentList  list of the SPK/PCK segments within the DAF References DAF Required Reading See Also See also  DAFHeader ,  Ephemerides.SPKSegmentList  and  EphemerisProvider source"},{"id":206,"pagetitle":"Low-level API","title":"Ephemerides.DAF_RECORD_LENGTH","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAF_RECORD_LENGTH","content":" Ephemerides.DAF_RECORD_LENGTH  —  Constant DAF_RECORD_LENGTH DAF record length, in bytes. References DAF Required Reading source"},{"id":207,"pagetitle":"Low-level API","title":"Ephemerides.FTPSTR","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.FTPSTR","content":" Ephemerides.FTPSTR  —  Constant FTPSTR Validation string that guarantees the integrity of a DAF file.  References DAF Required Reading source"},{"id":208,"pagetitle":"Low-level API","title":"Ephemerides.comment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.comment","content":" Ephemerides.comment  —  Function get_comment(daf::DAF) Return the comment written in the DAF comment section.  source"},{"id":209,"pagetitle":"Low-level API","title":"Ephemerides.header","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.header","content":" Ephemerides.header  —  Function header(spk::AbstractSPKSegment) Return the segment header. source get_header(daf::DAF) Return the  DAFHeader  header of the DAF. source"},{"id":210,"pagetitle":"Low-level API","title":"Ephemerides.array","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.array","content":" Ephemerides.array  —  Function get_array(daf::DAF) Return the byte content of the DAF file. source"},{"id":211,"pagetitle":"Low-level API","title":"Ephemerides.descriptors","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.descriptors","content":" Ephemerides.descriptors  —  Function get_descriptors(daf::DAF) Return the SPK/PCK segment descriptors contained in the DAF. source"},{"id":212,"pagetitle":"Low-level API","title":"Ephemerides.segment_list","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.segment_list","content":" Ephemerides.segment_list  —  Function get_segment_list(daf::DAF) Return the  Ephemerides.SPKSegmentList  list of segments stored in the DAF. source"},{"id":213,"pagetitle":"Low-level API","title":"Ephemerides.filepath","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.filepath","content":" Ephemerides.filepath  —  Function filepath(daf::DAF) Return the system path of the DAF. source"},{"id":214,"pagetitle":"Low-level API","title":"Ephemerides.is_spk","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_spk","content":" Ephemerides.is_spk  —  Function is_spk(daf::DAF) Return  true  if the DAF stores SPK data. source"},{"id":215,"pagetitle":"Low-level API","title":"Ephemerides.is_pck","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_pck","content":" Ephemerides.is_pck  —  Function is_pck(daf::DAF) Return  true  if the DAF stores PCK data. source"},{"id":216,"pagetitle":"Low-level API","title":"Ephemerides.parse_daf_comment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_daf_comment","content":" Ephemerides.parse_daf_comment  —  Function parse_daf_comment(array::Vector{UInt8}, header::DAFHeader) Retrieve the comment section of a binary DAF. References DAF Required Reading See Also See also  DAF ,  DAFHeader  and  parse_daf_summaries source"},{"id":217,"pagetitle":"Low-level API","title":"Ephemerides.parse_daf_summaries","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_daf_summaries","content":" Ephemerides.parse_daf_summaries  —  Function parse_daf_summaries(array::Vector{UInt8}, head::DAFHeader) Parse the DAF binary content and retrieve all the summary records. References DAF Required Reading See Also See also  DAF ,  DAFHeader  and  parse_daf_comment source"},{"id":218,"pagetitle":"Low-level API","title":"Ephemerides.initialise_segments!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initialise_segments!","content":" Ephemerides.initialise_segments!  —  Function initialise_segments!(daf::DAF) Fill the  Ephemerides.SPKSegmentList  by initialising the SPK/PCK segments associated to all  the descriptors stores within the DAF. See Also See also  DAF  and  create_spk_segment source"},{"id":219,"pagetitle":"Low-level API","title":"Ephemerides.create_spk_segment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.create_spk_segment","content":" Ephemerides.create_spk_segment  —  Function create_spk_segment(daf::DAF, desc::DAFSegmentDescriptor) Initialise an SPK segment according to the segment type defined in the   DAFSegmentDescriptor desc . source"},{"id":220,"pagetitle":"Low-level API","title":"Ephemerides.get_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_record","content":" Ephemerides.get_record  —  Function get_record(array::Vector{UInt8}, index::Integer) Retrieve a whole DAF record at position  index . source"},{"id":221,"pagetitle":"Low-level API","title":"Ephemerides.is_little_endian","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_little_endian","content":" Ephemerides.is_little_endian  —  Function is_little_endian(array::Vector{UInt8}) Return true if the array corresponds to the string indicating a little-endian format. source"},{"id":222,"pagetitle":"Low-level API","title":"SPK Links","ref":"/Ephemerides/stable/api/lapi/#SPK-Links","content":" SPK Links"},{"id":223,"pagetitle":"Low-level API","title":"Ephemerides.SPKLink","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKLink","content":" Ephemerides.SPKLink  —  Type SPKLink A link object to create a mapping between  DAFSegmentDescriptor  and its actual  location within an  EphemerisProvider  object.  Fields desc  –  DAFSegmentDescriptor  for the segment associated to this link fid  –  Int  index of the DAF containg the link data. lid  –  Int  field number in the  SPKSegmentList  for this segment type. eid  –  Int  index of the inner segment list that stores this SPK segment. fct  –  Int  1 or -1 depending on whether the (from, to) directions must be reversed. See Also See also  SPKLinkTable ,  SPKSegmentList  and  add_spklinks! . source"},{"id":224,"pagetitle":"Low-level API","title":"Ephemerides.SPKLinkTable","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKLinkTable","content":" Ephemerides.SPKLinkTable  —  Type SPKLinkTable Dictionary object providing all the  SPKLink  available between a set of (from, to) objects source"},{"id":225,"pagetitle":"Low-level API","title":"Ephemerides.descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.descriptor","content":" Ephemerides.descriptor  —  Function descriptor(link::SPKLink) Return the SPK/PCK segment descriptor associated to this link. source"},{"id":226,"pagetitle":"Low-level API","title":"Ephemerides.file_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.file_id","content":" Ephemerides.file_id  —  Function file_id(link::SPKLink) Return the DAF file index. source"},{"id":227,"pagetitle":"Low-level API","title":"Ephemerides.list_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.list_id","content":" Ephemerides.list_id  —  Function list_id(link::SPKLink) Return the index of the list containing the segments of the given SPK/PCK type. source"},{"id":228,"pagetitle":"Low-level API","title":"Ephemerides.element_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.element_id","content":" Ephemerides.element_id  —  Function element_id(link::SPKLink) Return the segment index in the inner SPK/PCK segment list. source"},{"id":229,"pagetitle":"Low-level API","title":"Ephemerides.factor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.factor","content":" Ephemerides.factor  —  Function factor(link::SPKLink) Return the direction multiplicative factor. source"},{"id":230,"pagetitle":"Low-level API","title":"Ephemerides.reverse_link","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.reverse_link","content":" Ephemerides.reverse_link  —  Function reverse_link(link::SPKLink) Reverse the sign, i.e. change the sign of the multiplicative factor, of the link. source"},{"id":231,"pagetitle":"Low-level API","title":"Ephemerides.create_linktables","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.create_linktables","content":" Ephemerides.create_linktables  —  Function create_linktables(dafs::Vector{DAF}) Create the SPK and PCK  SPKLinkTable  for all the segments stores in the input DAFs. source"},{"id":232,"pagetitle":"Low-level API","title":"Ephemerides.add_spklinks!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.add_spklinks!","content":" Ephemerides.add_spklinks!  —  Function add_spklinks!(table::SPKLinkTable, daf::DAF, fid::Int) Insert in the input  SPKLinkTable  all the SPK or PCK links associated to  the segment descriptors of the input DAF. source"},{"id":233,"pagetitle":"Low-level API","title":"SPK Segment List","ref":"/Ephemerides/stable/api/lapi/#SPK-Segment-List","content":" SPK Segment List"},{"id":234,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentList","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentList","content":" Ephemerides.SPKSegmentList  —  Type SPKSegmentList A container object to efficiently store all the different SPK segments that are contained  within a single DAF file. SPKSegmentList() Initialises an empty  SPKSegmentList  object. See also See also  Ephemerides.add_segment! source"},{"id":235,"pagetitle":"Low-level API","title":"Ephemerides.add_segment!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.add_segment!","content":" Ephemerides.add_segment!  —  Function add_segment!(list::SPKSegmentList, spk::AbstractSPKSegment) Add the SPK segment to the proper vector within the given  Ephemerides.SPKSegmentList list source"},{"id":236,"pagetitle":"Low-level API","title":"Ephemerides.get_segment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_segment","content":" Ephemerides.get_segment  —  Function get_segment(list::SPKSegmentList, lid::Int, eid::Int) Return the segment contained in the  lid  list at index  eid . source"},{"id":237,"pagetitle":"Low-level API","title":"Ephemerides.SPK_SEGMENTLIST_MAPPING","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPK_SEGMENTLIST_MAPPING","content":" Ephemerides.SPK_SEGMENTLIST_MAPPING  —  Constant SPK_SEGMENT_MAPPING A dictionary mapping SPK segment types to the field index of the  SPKSegmentList . source"},{"id":238,"pagetitle":"Low-level API","title":"Ephemerides.TCB_SEGMENTS","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TCB_SEGMENTS","content":" Ephemerides.TCB_SEGMENTS  —  Constant TCB_SEGMENTS List of the SPK/PCK segment types for which the time argument is expressed in the TCB scale. source"},{"id":239,"pagetitle":"Low-level API","title":"Ephemerides.TDB_SEGMENTS","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TDB_SEGMENTS","content":" Ephemerides.TDB_SEGMENTS  —  Constant TDB_SEGMENTS List of the SPK/PCK segment types for which the time argument is expressed in the TDB scale.  source"},{"id":240,"pagetitle":"Low-level API","title":"SPK Segment Types","ref":"/Ephemerides/stable/api/lapi/#SPK-Segment-Types","content":" SPK Segment Types"},{"id":241,"pagetitle":"Low-level API","title":"Abstract SPK Types","ref":"/Ephemerides/stable/api/lapi/#Abstract-SPK-Types","content":" Abstract SPK Types"},{"id":242,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKHeader","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKHeader","content":" Ephemerides.AbstractSPKHeader  —  Type AbstractSPKHeader Abstract type for all SPK segment type headers.  source"},{"id":243,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKCache","content":" Ephemerides.AbstractSPKCache  —  Type AbstractSPKCache Abstract type for all SPK segment type caches. source"},{"id":244,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKSegment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKSegment","content":" Ephemerides.AbstractSPKSegment  —  Type AbstractSPKSegment Abstract type for all SPK segment types. source"},{"id":245,"pagetitle":"Low-level API","title":"Ephemerides.cache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.cache","content":" Ephemerides.cache  —  Function cache(spk::AbstractSPKSegment) Return the segment cache data. source"},{"id":246,"pagetitle":"Low-level API","title":"Ephemerides.spk_field","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.spk_field","content":" Ephemerides.spk_field  —  Function spk_field(spk::AbstractSPKSegment) Return the field number in the  Ephemerides.SPKSegmentList  associated to the given SPK  segment type. source"},{"id":247,"pagetitle":"Low-level API","title":"SPK Type 1 and 21","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-1-and-21","content":" SPK Type 1 and 21"},{"id":248,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader1","content":" Ephemerides.SPKSegmentHeader1  —  Type SPKSegmentHeader1 <: AbstractSPKHeader Header instance for SPK segments of type 1 and 21. Fields n  –  Int  number of records in the segment  ndirs  –  Int  number of directory epochs epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the MDA records) recsize  -  Int  Number of double numbers stored in each MDA record maxdim  -  Int  MDA dimension (fixed to 15 for type 1) source"},{"id":249,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache1","content":" Ephemerides.SPKSegmentCache1  —  Type SPKSegmentCache1 <: AbstractSPKCache Cache instance for SPK segments of type 1 and 21. The fields contained within this cache  are taken from the FORTRAN NAIF's SPICE implementation for type 1 SPK segments.  Fields tl  – Reference epoch of the difference line. g  – Stepsize function vector. refpos  – Reference position vector. refvel  – Reference velocity vector. dt  – Modified Divided Difference arrays, with size (maxdim, 3) kqmax  – Maximum integration order plus 1. kq  – Integration order array. id  – Index of the currently loaded logical record. fc  – Buffer for the MDA computations. wc  – Buffer for the MDA computations. w  – Buffer for the MDA computations. vct  – Buffer for the MDA computations. source"},{"id":250,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType1","content":" Ephemerides.SPKSegmentType1  —  Type SPKSegmentType1 <: AbstractSPKSegment Segment instance for SPK segments of type 1 and 21, which contain Modified Difference Arrays  (MDA). This data type is normally used for spacecraft whose ephemerides are produced by JPL's  principal trajectory integrator DPTRAJ.  Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":251,"pagetitle":"Low-level API","title":"Ephemerides.compute_mda_position","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.compute_mda_position","content":" Ephemerides.compute_mda_position  —  Function compute_mda_position(cache::SPKSegmentCache1, Δ::Number) source"},{"id":252,"pagetitle":"Low-level API","title":"Ephemerides.compute_mda_velocity","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.compute_mda_velocity","content":" Ephemerides.compute_mda_velocity  —  Function compute_mda_velocity(cache::SPKSegmentCache1, Δ::Number) source"},{"id":253,"pagetitle":"Low-level API","title":"SPK Type 2 and 3","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-2-and-3","content":" SPK Type 2 and 3"},{"id":254,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader2","content":" Ephemerides.SPKSegmentHeader2  —  Type SPKSegmentHeader2 <: AbstractSPKHeader Header instance for SPK segments of type 2 and 3. Fields tstart  –  Float64  initial epoch of the first record, in seconds since J2000 tlen  –  Float64  interval length covered by each record, in seconds order  –  Int  polynomial order  N  –  Int  number of coefficients in each window n  –  Int  number of records in the segment recsize  –  Int  byte size of each logical record ncomp  –  Int  number of vector components iaa  –  Int  initial segment file address type  –  Int  SPK segment type, either 2 or 2 source"},{"id":255,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache2","content":" Ephemerides.SPKSegmentCache2  —  Type SPKSegmentCache2 <: AbstractSPKCache Cache instance for SPK segments of type 2 and 3. Fields A  – Chebyshev's polynomial coefficients, with size (ncomp, order) p  – Stores the record mid point and radius and scale factor buff  – Stores the buffers for the Chebyshev polynomials id  – Index of the currently loaded logical record source"},{"id":256,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType2","content":" Ephemerides.SPKSegmentType2  —  Type SPKSegmentType2 <: AbstractSPKSegment Segment instance for SPK segments of type 2 and 3, which contain Chebyshev polynomial  coefficients for the position and/or state of the body as function of time. This data type  is normally used for planet barycenters, and for satellites whose ephemerides are integrated. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":257,"pagetitle":"Low-level API","title":"SPK Type 5","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-5","content":" SPK Type 5"},{"id":258,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader5","content":" Ephemerides.SPKSegmentHeader5  —  Type SPKSegmentHeader5 <: AbstractSPKHeader Header instance for SPK segments of type 5. Fields GM  –  Float64  Gravitational constant  n  –  Int  number of states  ndirs  –  Int  number of epoch directories etid  –  Int  initial address for the epoch table (after all the state data) epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  source"},{"id":259,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache5","content":" Ephemerides.SPKSegmentCache5  —  Type SPKSegmentCache5 <: AbstractSPKCache Cache instance for SPK segments of type 5. Fields c1  – Twobody propagation cache for the left state. c2  – Twobody propagation cache for the right state. epochs  – Epochs associated to the two states. id  – Index of the currently loaded logical record. source"},{"id":260,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType5","content":" Ephemerides.SPKSegmentType5  —  Type SPKSegmentType5 <: AbstractSPKSegment Segment instance for SPK segments of type 5.  Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":261,"pagetitle":"Low-level API","title":"SPK Type 8 and 12","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-8-and-12","content":" SPK Type 8 and 12"},{"id":262,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader8","content":" Ephemerides.SPKSegmentHeader8  —  Type SPKSegmentHeader8 <: AbstractSPKHeader Header instance for SPK segments of type 8 and 12. Fields tstart  –  Float64  segment starting epoch, in TDB seconds since J2000  tlen  –  Float64  interval length, in seconds order  –  Int  interpolating polynomial degree N  –  Int  group size n  –  Int  number of states in the segment iaa  -  Int  initial segment file address  iseven  –  Bool  true for even group size type  –  Int  SPK type (either 8 or 12) source"},{"id":263,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache8","content":" Ephemerides.SPKSegmentCache8  —  Type SPKSegmentCache8 <: AbstractSPKCache Cache instance for SPK segments of type 8 and 12. Fields states  – Matrix storing the states of the interpolating points. buff  – Buffers to compute the interpolating polynomials. id  – Index of the currently loaded logical record. source"},{"id":264,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType8","content":" Ephemerides.SPKSegmentType8  —  Type SPKSegmentType8 <: AbstractSPKSegment Segment instance for SPK segments of type 8 and 12. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":265,"pagetitle":"Low-level API","title":"SPK Type 9 and 13","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-9-and-13","content":" SPK Type 9 and 13"},{"id":266,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader9","content":" Ephemerides.SPKSegmentHeader9  —  Type SPKSegmentHeader9 <: AbstractSPKHeader Header instance for SPK segments of type 9 and 13. Fields n  –  Int  number of states in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the state data) order  –  Int  interpolating polynomial degree N  –  Int  group size  iseven  –  Bool  true for even group size type  –  Int  SPK type (either 9 or 13) source"},{"id":267,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache9","content":" Ephemerides.SPKSegmentCache9  —  Type SPKSegmentCache9 <: AbstractSPKCache Cache instance for SPK segments of type 9 and 13. Fields epochs  – Epochs of the interpolating points.  states  – Matrix storing the states of the interpolating points.  buff  – Buffers to compute the interpolating polynomials. id  – Index of the currently loaded logical record. source"},{"id":268,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType9","content":" Ephemerides.SPKSegmentType9  —  Type SPKSegmentType9 <: AbstractSPKSegment Segment instance for SPK segments of type 9 and 13. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":269,"pagetitle":"Low-level API","title":"SPK Type 14","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-14","content":" SPK Type 14"},{"id":270,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader14","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader14","content":" Ephemerides.SPKSegmentHeader14  —  Type SPKSegmentHeader14 <: AbstractSPKHeader Header instance for SPK segments of type 14. Fields order  –  Int  interpolating polynomial degree n  –  Int  number of packets in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) etid  –  Int  initial address for the epoch table (after all the state data) ptid  –  Int  initial address for the packet table (after the constants) pktsize  –  Int  size of each data packet excluding the packet information area. pktoff  –  Int  offset of the packet data from the packet start  ncomp  –  Int  number of states coefficients (= 6 for SPK 14) N  –  Int  number of polynomial coefficients source"},{"id":271,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType14","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType14","content":" Ephemerides.SPKSegmentType14  —  Type SPKSegmentType14 <: AbstractSPKSegment Segment instance for SPK segments of type 14. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source Note SPK segments of type 14 have the same cache structure of SPK type 2 and 3."},{"id":272,"pagetitle":"Low-level API","title":"SPK Type 15","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-15","content":" SPK Type 15"},{"id":273,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader15","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader15","content":" Ephemerides.SPKSegmentHeader15  —  Type SPKSegmentHeader15 <: AbstractSPKHeader Header instance for SPK segments of type 15. Fields epoch  – Epoch of periapsis  tp  – Trajectory pole, i.e., vector parallel to the angular momentum of the orbit pv  – Central body north pole unit vector  pa  – Periapsis unit vector at epoch  p  – Semi-latus rectum  ecc  – Eccentricity  j2f  – J2 processing flag  vj2  – J2 validation flag, true if the orbit shape is compliant with J2 pertubations. GM  – Central body gravitational constant (km³/s²) J2  – Central body J2  R  – Central body radius (km) dmdt  – Mean anomaly rate of change (rad/s) kn  – Gain factor for the regression of the nodes  kp  – Gain factor for the precession of the pericenter source"},{"id":274,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType15","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType15","content":" Ephemerides.SPKSegmentType15  —  Type SPKSegmentType15 <: AbstractSPKSegment Segment instance for SPK segments of type 15. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source Note The cache of SPK Type 15 segments is made of  Ephemerides.TwoBodyUniversalCache  objects."},{"id":275,"pagetitle":"Low-level API","title":"SPK Type 17","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-17","content":" SPK Type 17"},{"id":276,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader17","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader17","content":" Ephemerides.SPKSegmentHeader17  —  Type SPKSegmentHeader17 <: AbstractSPKHeader Header instance for SPK segments of type 17. Fields epoch : epoch of periapsis (s) sma : semi-major axis (km) h : H term of the equinoctial elements k : K term of the equinoctial elements  lon : mean longitude at epoch (rad) p : P term of the equinoctial elements  q : Q term of the equinoctial elements  dlpdt : rate of longitude of the periapse (rad/s) dmldt : mean longitude rate (mean motion rate), (rad/s) dnodedt : longitude of the ascending node rate (rad/s) ra : equatorial pole right ascension (rad) de : equatorial pole declination (rad) R : Rotation matrix from planetary equator to inertial reference frame source"},{"id":277,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType17","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType17","content":" Ephemerides.SPKSegmentType17  —  Type SPKSegmentType17 <: AbstractSPKSegment Segment instance for SPK segments of type 17. Fields head  – Segment header  Note SPK segments of type 17 do not require a cache because they do not extract any  additional coefficients at runtime. References SPK Required Reading SPICE Toolkit source Note SPK segments of type 17 do not require a cache structure."},{"id":278,"pagetitle":"Low-level API","title":"SPK Type 18 and 19","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-18-and-19","content":" SPK Type 18 and 19"},{"id":279,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader18","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader18","content":" Ephemerides.SPKSegmentHeader18  —  Type SPKSegmentHeader18 <: AbstractSPKHeader Header instance for SPK segments of type 18. Fields n  –  Int  number of states in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the state data) order  –  Int  interpolating polynomial degree N  –  Int  group size  subtype  –  Int  type 18 subtype, either 0 (Hermite) or 1 (Lagrange) packetsize  –  Int  packet size for each point, either 12 (Hermite) or 6 (Lagrange) source"},{"id":280,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache18","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache18","content":" Ephemerides.SPKSegmentCache18  —  Type SPKSegmentCache18 <: AbstractSPKCache Cache instance for SPK segments of type 18. Fields p  – Vector storing indexes of the first and last points as well as the window size. epochs  – Epochs of the interpolating points.  states  – Matrix storing the states of the interpolating points.  buff  – Buffers to compute the interpolating polynomials. source"},{"id":281,"pagetitle":"Low-level API","title":"Ephemerides.reset_indexes!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.reset_indexes!","content":" Ephemerides.reset_indexes!  —  Function reset_indexes!(cache::SPKSegmentCache18) Reset the cache indexes to force the coefficients reload. source"},{"id":282,"pagetitle":"Low-level API","title":"Ephemerides.update_header!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.update_header!","content":" Ephemerides.update_header!  —  Function update_header!(head::SPKSegmentHeader18, daf::DAF, iaa, faa, type) Update the header of type 18 segments. source"},{"id":283,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader19","content":" Ephemerides.SPKSegmentHeader19  —  Type SPKSegmentHeader19 <: AbstractSPKHeader Header instance for SPK segments of type 19. Fields n  –  Int  number of states in the segment. ndirs  –  Int  number of epoch directories. times  – Storage for interval directories or start times (when ndirs = 0). iaa  -  Int  initial segment file address. etid  –  Int  byte address for the interval table (after all the minisegment data). ptid  –  Int  byte for the pointer table. usefirst  –  Bool  boundary flag, true if the preceding segment should be used. type  –  Int  either type 18 or 19. source"},{"id":284,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache19","content":" Ephemerides.SPKSegmentCache19  —  Type SPKSegmentCache19 <: AbstractSPKCache Cache instance for SPK segments of type 19. Fields minihead  – Header with the mini-segment properties. minidata  – Cache for the mini-segment. id  – Index of the currently loaded mini-segment. source"},{"id":285,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType19","content":" Ephemerides.SPKSegmentType19  —  Type SPKSegmentType19 <: AbstractSPKSegment Segment instance for SPK segments of type 18 and 19. Type 18 segments are treated as  special cases of a type 19 with a single mini-segment. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":286,"pagetitle":"Low-level API","title":"Ephemerides.find_minisegment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.find_minisegment","content":" Ephemerides.find_minisegment  —  Function find_minirecord(daf::DAF, head::SPKSegmentHeader19, time::Number) source"},{"id":287,"pagetitle":"Low-level API","title":"Ephemerides.load_minisegment!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.load_minisegment!","content":" Ephemerides.load_minisegment!  —  Function load_minisegment!(daf::DAF, head::SPKSegmentHeader19, cache::SPKSegmentCache19, index::Int) source Note SPK segments of type 18 are the only ones that do not posses a dedicated SPK segment type structure, because they are treated as special cases (i.e., single minisegments) of the type 19."},{"id":288,"pagetitle":"Low-level API","title":"SPK Type 20","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-20","content":" SPK Type 20"},{"id":289,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader20","content":" Ephemerides.SPKSegmentHeader20  —  Type SPKSegmentHeader20 <: AbstractSPKHeader Header instance for SPK segments of type 20. Fields dscale  –  Float64  length conversion factor tscale  –  Float64  time conversion factor tstart  –  Float64  initial epoch of the first record, in seconds since J2000 tlen  –  Float64  interval length covered by each record, in seconds recsize  –  Int  byte size of each logical record order  –  Int  polynomial order  N  –  Int  number of coefficients in each window n  –  Int  number of records in the segment iaa  –  Int  initial segment file address source"},{"id":290,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache20","content":" Ephemerides.SPKSegmentCache20  —  Type SPKSegmentCache20 <: AbstractSPKCache Cache instance for SPK segments of type 20. Fields id  – Index of the currently loaded logical record p  – Stores the record position constants A  – Chebyshev's polynomial coefficients, with size (ncomp, order) buff  – Stores the buffers for the Chebyshev polynomials source"},{"id":291,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType20","content":" Ephemerides.SPKSegmentType20  —  Type SPKSegmentType2 <: AbstractSPKSegment Segment instance for SPK segments of type 20, which contain Chebyshev polynomial coefficients  for the position and/or state of the body as function of time. This data type is normally  used for planet barycenters, and for satellites whose ephemerides are integrated. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":292,"pagetitle":"Low-level API","title":"SPK Utility Functions","ref":"/Ephemerides/stable/api/lapi/#SPK-Utility-Functions","content":" SPK Utility Functions"},{"id":293,"pagetitle":"Low-level API","title":"Ephemerides.normalise_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.normalise_time","content":" Ephemerides.normalise_time  —  Function normalise_time(cache::SPKSegmentCache2, time::Number) Transform  time  in an interval between [-1, 1] for compliance with Chebyshev polynomials. source normalise_time(head::SPKSegmentHeader8, time::Number, index::Int) Returned a normalised time that starts at 1 at the beginning of the interval. source normalise_time(head::SPKSegmentHeader20, time::Number, index::Int) source"},{"id":294,"pagetitle":"Low-level API","title":"Ephemerides.find_logical_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.find_logical_record","content":" Ephemerides.find_logical_record  —  Function find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number) source find_logical_record(head::SPKSegmentHeader2, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader5, time::Number) source find_logical_record(head::SPKSegmentHeader8, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader14, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader18, time::Number) source find_logical_record(head::SPKSegmentHeader20, time::Number) source"},{"id":295,"pagetitle":"Low-level API","title":"Ephemerides.get_coefficients!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_coefficients!","content":" Ephemerides.get_coefficients!  —  Function get_coefficients!(daf::DAF, head::SPKSegmentHeader1, cache::SPKSegmentCache1, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader2, cache::SPKSegmentCache2, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader5, cache::SPKSegmentCache5, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader8, cache::SPKSegmentCache8, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader9, cache::SPKSegmentCache9, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader14, cache::SPKSegmentCache14, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader18, cache::SPKSegmentCache18, first::Int, last::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader20, cache::SPKSegmentCache20, index::Int) source"},{"id":296,"pagetitle":"Low-level API","title":"Interpolating Functions","ref":"/Ephemerides/stable/api/lapi/#Interpolating-Functions","content":" Interpolating Functions"},{"id":297,"pagetitle":"Low-level API","title":"Caches","ref":"/Ephemerides/stable/api/lapi/#Caches","content":" Caches"},{"id":298,"pagetitle":"Low-level API","title":"Ephemerides.InterpCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.InterpCache","content":" Ephemerides.InterpCache  —  Type InterpCache{T} source"},{"id":299,"pagetitle":"Low-level API","title":"Ephemerides.get_buffer","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_buffer","content":" Ephemerides.get_buffer  —  Function get_buffer(c::InterpCache, idx::int, x::Number) Return the  idx -th buffer from the corresponding  DiffCache  depending on the type of  x .  source"},{"id":300,"pagetitle":"Low-level API","title":"Chebyshev Polynomials","ref":"/Ephemerides/stable/api/lapi/#Chebyshev-Polynomials","content":" Chebyshev Polynomials"},{"id":301,"pagetitle":"Low-level API","title":"Ephemerides.chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.chebyshev","content":" Ephemerides.chebyshev  —  Function chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, ibuff::Int) Evaluate a sum of Cheybyshev polynomials of the first kind at  t  using a  recursive algorithm. It simultenously evalutes the 3 state components.  idx  is the  index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  ∂chebyshev ,  ∂²chebyshev  and  ∂³chebyshev source"},{"id":302,"pagetitle":"Low-level API","title":"Ephemerides.∂chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂chebyshev","content":" Ephemerides.∂chebyshev  —  Function ∂chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its derivative at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂²chebyshev  and  ∂³chebyshev source"},{"id":303,"pagetitle":"Low-level API","title":"Ephemerides.∂²chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²chebyshev","content":" Ephemerides.∂²chebyshev  —  Function ∂²chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its two derivatives at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂chebyshev  and  ∂³chebyshev source"},{"id":304,"pagetitle":"Low-level API","title":"Ephemerides.∂³chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂³chebyshev","content":" Ephemerides.∂³chebyshev  —  Function ∂³chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its three derivatives at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂chebyshev  and  ∂²chebyshev source"},{"id":305,"pagetitle":"Low-level API","title":"Ephemerides.∫chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∫chebyshev","content":" Ephemerides.∫chebyshev  —  Function ∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀) Evaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. It assumes the Chebyshev polynomials  up to degree N have already been computed and are stored in the buffer with index  ibuff .   tlen  is the size of the record interval,  Δt  is the timescale factor, and  p₀  is a  vector containing the position coefficients at the midpoint (i.e., when the integral is  evaluated at t = 0). Note x  is a re-work of the actual ascissa value that lies between [-1, 1] source ∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀) Evaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. This function simultaneously  computes both the Chebyshev polynomials as well as their integrals. source"},{"id":306,"pagetitle":"Low-level API","title":"Lagrange Polynomials","ref":"/Ephemerides/stable/api/lapi/#Lagrange-Polynomials","content":" Lagrange Polynomials"},{"id":307,"pagetitle":"Low-level API","title":"Ephemerides.lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.lagrange","content":" Ephemerides.lagrange  —  Function lagrange(cache::InterpCache, states, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial at  x  by using Neville's algorithm. This  function is valid only for equally-spaced polynomials.  idx  is the index of the desired  state and  N  is the number of coefficients of the polynomial.  Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  ∂lagrange  and  ∂²lagrange . source lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial at  x  by using Neville's algorithm. This  function handles unequally-spaced polynomials, where the coefficients in  states  are  interpolated at  epochs . source"},{"id":308,"pagetitle":"Low-level API","title":"Ephemerides.∂lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂lagrange","content":" Ephemerides.∂lagrange  —  Function ∂lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Recursively evaluate a Lagrange polynomial and its derivative at  x  by using  Neville's algorithm. This function is valid only for equally-spaced polynomials.  idx   is the index of the desired state,  N  is the number of coefficients of the polynomial and   Δt is the length of the polynomial interval Note x  is a re-work of the actual ascissa value that starts at 1 See Also See also  lagrange  and  ∂²lagrange source ∂lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial and its derivative at  x  by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in  states  are interpolated at  epochs . source"},{"id":309,"pagetitle":"Low-level API","title":"Ephemerides.∂²lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²lagrange","content":" Ephemerides.∂²lagrange  —  Function ∂²lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Recursively evaluate a Lagrange polynomial and its two derivatives at  x  by using  Neville's algorithm. This function is valid only for equally-spaced polynomials.  idx   is the index of the desired state,  N  is the number of coefficients of the polynomial and   Δt is the length of the polynomial interval Note x  is a re-work of the actual ascissa value that starts at 1 See Also See also  lagrange  and  ∂lagrange source ∂²lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial and its two derivatives at  x  by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in  states  are interpolated at  epochs . See Also See also  lagrange  and  ∂lagrange source"},{"id":310,"pagetitle":"Low-level API","title":"Hermite Polynomials","ref":"/Ephemerides/stable/api/lapi/#Hermite-Polynomials","content":" Hermite Polynomials"},{"id":311,"pagetitle":"Low-level API","title":"Ephemerides.hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.hermite","content":" Ephemerides.hermite  —  Function hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial at  x  using a recursive algorithm. This function is valid  only for equally-spaced polynomials.  idx  is the index of the desired state,  N   is the number of coefficients of the polynomial and  Δt  is the length of the polynomial  interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  ∂hermite ,  ∂²hermite  and  ∂³hermite . source hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial at  x  using a recursive algorithm. This function handles  unequally-spaced polynomials, where the coefficients in  states  are interpolated  at  epochs . source"},{"id":312,"pagetitle":"Low-level API","title":"Ephemerides.∂hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂hermite","content":" Ephemerides.∂hermite  —  Function ∂hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its derivative at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂²hermite  and  ∂³hermite . source ∂hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its derivative at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":313,"pagetitle":"Low-level API","title":"Ephemerides.∂²hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²hermite","content":" Ephemerides.∂²hermite  —  Function ∂²hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its two derivatives at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂hermite  and  ∂³hermite . source ∂²hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its two derivatives at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":314,"pagetitle":"Low-level API","title":"Ephemerides.∂³hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂³hermite","content":" Ephemerides.∂³hermite  —  Function ∂³hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its three derivatives at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂hermite  and  ∂²hermite . source ∂³hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its three derivatives at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":315,"pagetitle":"Low-level API","title":"Introspection","ref":"/Ephemerides/stable/api/lapi/#Introspection","content":" Introspection"},{"id":316,"pagetitle":"Low-level API","title":"Ephemerides.AbstractEphemRecord","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractEphemRecord","content":" Ephemerides.AbstractEphemRecord  —  Type AbstractEphemRecord Abstract type for ephemeris segment records. source"},{"id":317,"pagetitle":"Low-level API","title":"Ephemerides.initial_times","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_times","content":" Ephemerides.initial_times  —  Function initial_times(record::AbstractEphemRecord) Recover the initial times of each sub-window in which the ephemeris data of  record  is  defined, expressed in TDB seconds since J2000 source"},{"id":318,"pagetitle":"Low-level API","title":"Ephemerides.final_times","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_times","content":" Ephemerides.final_times  —  Function final_times(record::AbstractEphemRecord) Recover the final times of each sub-window in which the ephemeris data of  record  is  defined, expressed in TDB seconds since J2000 source"},{"id":319,"pagetitle":"Low-level API","title":"Ephemerides.analyse_timespan","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.analyse_timespan","content":" Ephemerides.analyse_timespan  —  Function analyse_timespan(records) Analyse a set of  AbstractEphemRecord , returning the minimum and maximum covered  times, in TDB seconds since J2000, together with a continuity parameter. References CALCEPH  C++ library See Also See also  ephem_spk_timespan  and  ephem_pck_timespan . source"},{"id":320,"pagetitle":"Low-level API","title":"TwoBody Routines","ref":"/Ephemerides/stable/api/lapi/#TwoBody-Routines","content":" TwoBody Routines"},{"id":321,"pagetitle":"Low-level API","title":"Ephemerides.TwoBodyUniversalCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TwoBodyUniversalCache","content":" Ephemerides.TwoBodyUniversalCache  —  Type TwoBodyUniversalCache A container to store precomputed quantities required for the two-body propagation based on  universal variables. Only the quantities that depend on the initial state are computed. source"},{"id":322,"pagetitle":"Low-level API","title":"Ephemerides.update_cache!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.update_cache!","content":" Ephemerides.update_cache!  —  Function update_cache!(c::TwoBodyUniversalCache) Update the precomputed values in the cache using the position and velocity in  c . source"},{"id":323,"pagetitle":"Low-level API","title":"Ephemerides.propagate_twobody","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.propagate_twobody","content":" Ephemerides.propagate_twobody  —  Function propagate_twobody(cache::TwoBodyUniversalCache, Δt::Number) Propagate the state vector in  cache  of  Δt  using the universal variables formulation for  Kepler's Equation and the Lagrange coefficients f and g. Note This routine is valid for any type of orbit and uses a bisection method to find the  root of the universal variables Kepler's equation. The algorithm has been directly  taken from the SPICE toolkit  prob2b.f . References SPICE Toolkit source"},{"id":324,"pagetitle":"Low-level API","title":"Ephemerides.stumpff","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.stumpff","content":" Ephemerides.stumpff  —  Function stumpff(x::Number, p::AbstractVector) Compute Stumpff's functions from C₀ up to C₃ at  x .  Note This routine uses the trigonometrical expressions of the functions when the absolute  value of  x  is greater or equal to 1. If that is not the case, the C₂ and C₃ functions  are computed from a truncated expression of the Maclaurin series at order 11, which  guarantees a higher precision and avoid overflow errors when  x  is null. References SPICE Toolkit source"},{"id":327,"pagetitle":"Benchmarks","title":"Performance Benchmarks","ref":"/Ephemerides/stable/benchmarks/#Performance-Benchmarks","content":" Performance Benchmarks The performance of this package have been tested against both CALCEPH and SPICE, two of the most-popular open-source ephemeris readers used in the space industry. The results show that  Ephemerides.jl  largely outperforms SPICE as well as CALCEPH for most SPK segment types. For example, for state vector computations (i.e., position and velocity) the mean execution times are the following: Additionally, it is better optimised to compute higher order derivatives (i.e., acceleration and jerk) with respect to CALCEPH.  Note These time benchmarks have been obtained on an Intel Core i7-6700 CPU @ 3.40 GHz with 16 GB of RAM"},{"id":330,"pagetitle":"Kernels Inspection","title":"Kernels Inspection","ref":"/Ephemerides/stable/tutorials/inspect/#Kernels-Inspection","content":" Kernels Inspection This tutorial will walk you through the basic features and interfaces that allow you to inspect the properties of binary ephemeris kernels."},{"id":331,"pagetitle":"Kernels Inspection","title":"Available Times","ref":"/Ephemerides/stable/tutorials/inspect/#Available-Times","content":" Available Times"},{"id":332,"pagetitle":"Kernels Inspection","title":"Timescale","ref":"/Ephemerides/stable/tutorials/inspect/#Timescale","content":" Timescale SPK and PCK segments support two types of ephemeris timescales, namely, TDB and TCB. The timescale of the loaded kernels can be retrieved as follows:  using Ephemerides \n\n# Load the kernel\neph = EphemerisProvider(\"kernel.bsp\")\n\n# Retrieve the ID of the kernel timescales\nid = ephem_timescale_id(eph) The retrieved ID is 1 for TDB and 2 for TCB. A value of -1 is returned if the kernels are empty.  Note Only one timescale is admissed within a single  EphemerisProvider  object, "},{"id":333,"pagetitle":"Kernels Inspection","title":"Timespan","ref":"/Ephemerides/stable/tutorials/inspect/#Timespan","content":" Timespan To retrieve the first and last available time in the ephemeris files associated to a provider  object, two functions are available to distinguish between SPK and PCK data:  ephem_spk_timespan(eph)\nephem_pck_timespan(eph) where  eph  is an  EphemerisProvider  instance. Both functions return the minimum and maximum available time in TDB seconds since J2000, as well as a continuity parameter defined as follows:  0  no SPK or PCK data is available. 1  the quantities of all bodies are available for any time between the first and last time. 2  the quantities of some bodies are available on discontinuous time intervals between the    first and last time. 3  the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time."},{"id":334,"pagetitle":"Kernels Inspection","title":"Available Points and Axes","ref":"/Ephemerides/stable/tutorials/inspect/#Available-Points-and-Axes","content":" Available Points and Axes To retrieve the list of NAIF IDs with the points or axes that have available ephemeris data, these function should be called on an  EphemerisProvider  instance: ephem_get_points(eph)\nephem_get_axes(eph)"},{"id":335,"pagetitle":"Kernels Inspection","title":"Segment Records","ref":"/Ephemerides/stable/tutorials/inspect/#Segment-Records","content":" Segment Records Position and orientation metadata relative to the records loaded in the ephemeris kernels can be retrieved with the following two functions, respectively: ephem_spk_records(eph)\nephem_pck_records(eph) Both functions return a vector of  Ephemerides.EphemRecordSPK  or  Ephemerides.EphemRecordPCK  ordered by priority, i.e., they use the highest priority records when there are multiple records that could satisfy the same target, center pair for a given epoch. In particular SPK records contain the following information:  target: NAIF ID of the target object center: NAIF ID of the center object axes: NAIF ID of the reference axes t_start: start times of each sub-window, in TDB seconds since J2000 t_end: final times of each sub-window, in TDB seconds since J2000 Similarly, PCK records contain these information: target: NAIF ID of the target axes center: NAIF ID of the reference axes t_start: start times of each sub-window, in TDB seconds since J2000 t_end: final times of each sub-window, in TDB seconds since J2000 For PCK records, the reference axes ID is set into the  center  field. Please notice that whenever a gap between the data of a given pair of (center, target) objects is present,  t_start  and  t_end  will store the start and end times of each window with available data, respectively."},{"id":338,"pagetitle":"Loading Kernels","title":"Loading Kernels","ref":"/Ephemerides/stable/tutorials/load/#Loading-Kernels","content":" Loading Kernels This tutorial will walk you through the basic features and interfaces that allow you to load binary ephemeris kernels. The supported sources of ephemerides are currently limited to binary PCK and SPK segments of type: 1, 2, 3, 5, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, and 21.  Note Support for IMCCE INPOP ephemerides is yet to be implemented. Before retrieving position and orientation data of celestial objects, the user is first required to load the ephemerides files into an  EphemerisProvider  object.  using Ephemerides \n\n# Load a single ephemeris file \neph1 = EphemerisProvider(\"kernel1.bsp\")\n\n# Load multiple ephemeris files simultaneously\neph2 = EphemerisProvider([\"kernel1.bsp\", \"kernel2.bsp\"]) You must specify the relative or absolute path(s) of the file(s) to load. Either one or multiple ephemeris files can be simultaneously loaded into a single  EphemerisProvider  object. However,  once a provider has been created, no more kernels can be loaded inside it. "},{"id":341,"pagetitle":"Reading Ephemeris Data","title":"Reading Ephemeris Data","ref":"/Ephemerides/stable/tutorials/position/#Reading-Ephemeris-Data","content":" Reading Ephemeris Data This tutorials will walk you through the basic features and interfaces that allow you to compute translation and orientation data from binary ephemeris kernels."},{"id":342,"pagetitle":"Reading Ephemeris Data","title":"Computing state vectors","ref":"/Ephemerides/stable/tutorials/position/#Computing-state-vectors","content":" Computing state vectors Ephemerides.jl  allows the computation of a relative position between two points and its higher order derivatives up to order 3 (i.e., velocity, acceleration and jerk). All these computations are natively  thread-safe and compatible with Automatic Differentiation (AD) with respect to time via  ForwardDiff.jl . In particular, the following methods are available to compute translation data:  ephem_vector3(eph, from, to, time)\nephem_vector6(eph, from, to, time)\nephem_vector9(eph, from, to, time)\nephem_vector12(eph, from, to, time) They all share the same interface, requiring an  EphemerisProvider  object as the first input.  from  and  to  are integer numbers representing the ID of the center and target points that we desired. The  time  argument is expressed in TDB seconds since J2000.0. Note Differently, from traditional ephemerides readers,  Ephemerides.jl  is only meant to read the data stored in the binary kernels and it does not perform any concatenation of state vectors. This means that if data from point 399 is expressed with respect to point 3, we will only be able to compute the relative position of 339 with respect to 3 or viceversa, but not of 399 with respect to another point. The reason behind this is that  Ephemerides.jl  is meant to be used in combination with  FrameTransformations.jl , which already enables tranformations between different user-defined point and axes. An example to compute the position of the Moon (399) with respect to the Earth-Moon Barycenter (3) at J2000 (time = 0), is the following:  using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_de440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\npos = ephem_vector3(eph, 3, 399, 0) Instead, if one desires the whole state vector, up to the jerk components, the functions become:  # Compute position and velocity \npv = ephem_vector6(eph, 3, 399, 0)\n\n# Compute position, velocity and acceleration\npva = ephem_vector9(eph, 3, 399, 0)\n\n# Compute position, velocity, acceleration and jerk\npvaj = ephem_vector12(eph, 3, 399, 0) In all these examples, the returned data is always in the form of a  StaticArray  in order to minimise memory allocations. Warning SPK segments of types 1 5, 15, 17 and 21 do not natively support acceleration and jerk computations. However, these values can be computed by Automatic Differentiation (AD) of the position and/or velocity components."},{"id":343,"pagetitle":"Reading Ephemeris Data","title":"Computing orientation angles","ref":"/Ephemerides/stable/tutorials/position/#Computing-orientation-angles","content":" Computing orientation angles Similarly to position components,  Ephemerides.jl  also allows the computation of orientation angles and their derivatives up to order 3. All these computations are natively thread-safe and compatible with Automatic Differentiation (AD) with respect to time via  ForwardDiff.jl . In particular, the following methods are available to compute orientation data:  ephem_rotation3(eph, from, to, time)\nephem_rotation6(eph, from, to, time)\nephem_rotation9(eph, from, to, time)\nephem_rotation12(eph, from, to, time) Again, they all share the same interface, requiring an  EphemerisProvider  object as the first input.  from  and  to  are integer numbers representing the ID of the reference and target axes that we desired. The  time  argument is expressed in TDB seconds since J2000.0. An example to compute the Euler angles of the PA440 axes (31008) with respect to the ICRF (1) at J2000 (time = 0), is the following:  using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_pa440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\nang = ephem_rotation3(eph, 1, 31008, 0) Instead, if one desires the whole vector, up to the 3rd order derivative, the functions become:  # Compute angles and derivatives \npv = ephem_rotation6(eph, 1, 31008, 0)\npva = ephem_rotation9(eph, 1, 31008, 0)\npvaj = ephem_rotation12(eph, 1, 31008, 0) The returned orientation data is always in the form of a  StaticArray  in order to minimise memory allocations. Note Differently from the translational data contained in SPK kernels, the orientation angles can only be computed in one direction, i.e., if the orientation of the Moon's Principal Axes (PA) is defined with respect to the ICRF, it is not possible to compute the rotation from the PA to the ICRF with this routine. "},{"id":346,"pagetitle":"Home","title":"CalcephEphemeris.jl API","ref":"/CalcephEphemeris/stable/#CalcephEphemeris.jl-API","content":" CalcephEphemeris.jl API A lightweight CALCEPH wrapper for the JSMD ecosystem. This package is a lightweight wrapper around  CALCEPH_jll.jl  that implements the  JSMDInterfaces.jl  interfaces to extract data from SPICE and INPOP ephemeris kernels.  The CALCEPH is a C++ library written by the research team Astronomie et systèmes dynamiques  (CNRS/Observatoire de Paris/IMCCE). For further information on CALCEPH visit its   official website . Inspiration for this package has been taken from the original Julia's  CALCEPH.jl   wrapper."},{"id":347,"pagetitle":"Home","title":"Installation","ref":"/CalcephEphemeris/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg; \n\njulia> Pkg.add(\"CalcephEphemeris.jl\")"},{"id":350,"pagetitle":"API","title":"API","ref":"/CalcephEphemeris/stable/api/#API","content":" API This package implements all of the required JSMD Interfaces for Ephemeris files, which  are already well-documented in  JSMDInterfaces ."},{"id":351,"pagetitle":"API","title":"CalcephEphemeris.CalcephProvider","ref":"/CalcephEphemeris/stable/api/#CalcephEphemeris.CalcephProvider","content":" CalcephEphemeris.CalcephProvider  —  Type CalcephProvider(file::String)\nCalcephProvider(files::Vector{String}) Create a  CalcephProvider  instance by loading a single or multiples ephemeris kernel  files specified by  files . Note Once the object is created kernels cannot be added nor removed from the  generated  CalcephProvider  instance.   Example julia> eph1 = CalcephProvider(\"PATH_TO_KERNEL\")\n1-kernel CalcephProvider\n \"PATH_TO_KERNEL\"\n\njulia> eph2 = CalcephProvider([\"PATH_TO_KERNEL_1\", \"PATH_TO_KERNEL_2\"])\n2-kernel CalcephProvider:\n \"PATH_TO_KERNEL_1\"\n \"PATH_TO_KERNEL_2\" source"},{"id":354,"pagetitle":"Home","title":"Welcome to IERSConventions.jl!","ref":"/IERSConventions/stable/#Welcome-to-IERSConventions.jl!","content":" Welcome to IERSConventions.jl! IERS Conventions made easy. The aim of this package is to provide a set of standardised functions that allow the user to easily handle all the computations related to the IERS, from the earlier 1996 up to the latest 2010 conventions."},{"id":355,"pagetitle":"Home","title":"Installation","ref":"/IERSConventions/stable/#Installation","content":" Installation This package can be installed using Julia's package manager:  julia> import Pkg\n\njulia> Pkg.add(\"IERSConventions.jl\");"},{"id":358,"pagetitle":"Public API","title":"Public Documentation","ref":"/IERSConventions/stable/api/api/#iers_api","content":" Public Documentation"},{"id":359,"pagetitle":"Public API","title":"IERS Models","ref":"/IERSConventions/stable/api/api/#iers_models","content":" IERS Models This is a list of the supported IERS models and their approximations that can be used to  selected the algorithm associated to a specific IERS convention. "},{"id":360,"pagetitle":"Public API","title":"2010 Conventions","ref":"/IERSConventions/stable/api/api/#2010-Conventions","content":" 2010 Conventions"},{"id":361,"pagetitle":"Public API","title":"IERSConventions.iers2010a","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers2010a","content":" IERSConventions.iers2010a  —  Constant iers2010a The singleton instance of type  IERS2010A , representing the IERS 2010A family of models. source"},{"id":362,"pagetitle":"Public API","title":"IERSConventions.iers2010b","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers2010b","content":" IERSConventions.iers2010b  —  Constant iers2010b The singleton instance of type  IERS2010B , representing the IERS 2010B family of models. Note This is not an official IERS model. source"},{"id":363,"pagetitle":"Public API","title":"IERSConventions.CPNc","ref":"/IERSConventions/stable/api/api/#IERSConventions.CPNc","content":" IERSConventions.CPNc  —  Constant CPNc The singleton instance of type  CPNC , representing the concise CPNc from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few mas. Note This is not an official IERS model. source"},{"id":364,"pagetitle":"Public API","title":"IERSConventions.CPNd","ref":"/IERSConventions/stable/api/api/#IERSConventions.CPNd","content":" IERSConventions.CPNd  —  Constant CPNd The singleton instance of type  CPND , representing the concise CPNd from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few arcseconds. Note This is not an official IERS model. source"},{"id":365,"pagetitle":"Public API","title":"2003 Conventions","ref":"/IERSConventions/stable/api/api/#2003-Conventions","content":" 2003 Conventions"},{"id":366,"pagetitle":"Public API","title":"IERSConventions.iers2003a","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers2003a","content":" IERSConventions.iers2003a  —  Constant iers2003a The singleton instance of type  IERS2003A , representing the IERS 2003A family of models. source"},{"id":367,"pagetitle":"Public API","title":"IERSConventions.iers2003b","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers2003b","content":" IERSConventions.iers2003b  —  Constant iers2003b The singleton instance of type  IERS2003B , representing the IERS 2003B family of models. source"},{"id":368,"pagetitle":"Public API","title":"1996 Conventions","ref":"/IERSConventions/stable/api/api/#1996-Conventions","content":" 1996 Conventions"},{"id":369,"pagetitle":"Public API","title":"IERSConventions.iers1996","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers1996","content":" IERSConventions.iers1996  —  Constant iers1996 The singleton instance of type  IERS1996 , representing the IERS 1996 family of models. source"},{"id":370,"pagetitle":"Public API","title":"Rotations","ref":"/IERSConventions/stable/api/api/#Rotations","content":" Rotations"},{"id":371,"pagetitle":"Public API","title":"CIO-based rotations","ref":"/IERSConventions/stable/api/api/#CIO-based-rotations","content":" CIO-based rotations"},{"id":372,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_cirf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_cirf","content":" IERSConventions.iers_rot3_gcrf_to_cirf  —  Function iers_rot3_gcrf_to_cirf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the Celestial Intermediate Reference Frame (CIRF) at time  tt_s , expressed in TT seconds  since  J2000 , following the IERS Conventions  m .  Note EOP corrections to the CIP coordinates (δX, δY) are only added in the  iers2003a  and  iers2010a  models. References IERS Technical Note No.  36 See also See also  iers_rot3_gcrf_to_tirf  and  iers_rot3_gcrf_to_itrf . source"},{"id":373,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_itrf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_itrf","content":" IERSConventions.iers_rot3_gcrf_to_itrf  —  Function iers_rot3_gcrf_to_itrf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the International Terrestrial Reference Frame (ITRF) at time  tt_s , expressed in TT seconds  since  J2000 , following the IERS Conventions  m .  Note EOP corrections to the CIP coordinates (δX, δY) are only added in the  iers2003a  and  iers2010a  models. Note Polar motion is neglected in the  CPNd  model.  References IERS Technical Note No.  36 See also See also  iers_rot3_gcrf_to_cirf  and  iers_rot3_gcrf_to_tirf . source"},{"id":374,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_tirf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_tirf","content":" IERSConventions.iers_rot3_gcrf_to_tirf  —  Function iers_rot3_gcrf_to_tirf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the Terrestrial Intermediate Reference Frame (TIRF) at time  tt_s , expressed in TT seconds  since  J2000 , following the IERS Conventions  m .  Note EOP corrections to the CIP coordinates (δX, δY) are only added in the  iers2003a  and  iers2010a  models. References IERS Technical Note No.  36 See also See also  iers_rot3_gcrf_to_cirf  and  iers_rot3_gcrf_to_itrf . source"},{"id":375,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_itrf_to_cirf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_itrf_to_cirf","content":" IERSConventions.iers_rot3_itrf_to_cirf  —  Function iers_rot3_itrf_to_cirf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Celestial Intermediate Reference Frame (CIRF) at time  tt_s , expressed in TT seconds  since  J2000 , following the IERS Conventions  m .  Note Polar motion is neglected in the  CPNd  model.  References IERS Technical Note No.  36 See also See also  iers_rot3_gcrf_to_cirf  and  iers_rot3_itrf_to_tirf . source"},{"id":376,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_itrf_to_tirf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_itrf_to_tirf","content":" IERSConventions.iers_rot3_itrf_to_tirf  —  Function iers_rot3_itrf_to_tirf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Terrestrial Intermediate Reference Frame (TIRF) at time  tt_s , expressed in TT seconds  since  J2000 , following the IERS Conventions  m .  Note Polar motion is neglected in the  CPNd  model.  References IERS Technical Note No.  36 See also See also  iers_rot3_gcrf_to_tirf  and  iers_rot3_itrf_to_cirf . source"},{"id":377,"pagetitle":"Public API","title":"IERSConventions.iers_rot6_gcrf_to_itrf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot6_gcrf_to_itrf","content":" IERSConventions.iers_rot6_gcrf_to_itrf  —  Function iers_rot6_gcrf_to_itrf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix and its derivative from the Geocentric Celestial Reference Frame  (GCRF) to the International Terrestrial Reference Frame (ITRF) at time  tt_s , expressed  in TT seconds since  J2000 , following the IERS Conventions  m .  Note EOP corrections to the CIP coordinates (δX, δY) are only added in the  iers2003a  and  iers2010a  models. Note Polar motion is neglected in the  CPNd  model.  Note The time derivative of the nutation and precession effects is neglected. References IERS Technical Note No.  36 source"},{"id":378,"pagetitle":"Public API","title":"IERSConventions.iers_rot9_gcrf_to_itrf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot9_gcrf_to_itrf","content":" IERSConventions.iers_rot9_gcrf_to_itrf  —  Function iers_rot9_gcrf_to_itrf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix, its first and second derivative from the Geocentric Celestial  Reference Frame (GCRF) to the International Terrestrial Reference Frame (ITRF) at time   tt_s , expressed in TT seconds since  J2000 , following the IERS Conventions  m .  Note EOP corrections to the CIP coordinates (δX, δY) are only added in the  iers2003a  and  iers2010a  models. Note Polar motion is neglected in the  CPNd  model.  Note The time derivative of the nutation and precession effects is neglected. References IERS Technical Note No.  36 source"},{"id":379,"pagetitle":"Public API","title":"IERSConventions.iers_rot12_gcrf_to_itrf","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot12_gcrf_to_itrf","content":" IERSConventions.iers_rot12_gcrf_to_itrf  —  Function iers_rot12_gcrf_to_itrf(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix, its first, second and third derivative from the Geocentric  Celestial Reference Frame (GCRF) to the International Terrestrial Reference Frame (ITRF)  at time  tt_s , expressed in TT seconds since  J2000 , following the IERS Conventions  m .  Note EOP corrections to the CIP coordinates (δX, δY) are only added in the  iers2003a  and  iers2010a  models. Note Polar motion is neglected in the  CPNd  model.  Note The time derivative of the nutation and precession effects is neglected. References IERS Technical Note No.  36 source"},{"id":380,"pagetitle":"Public API","title":"Equinox-based rotations","ref":"/IERSConventions/stable/api/api/#Equinox-based-rotations","content":" Equinox-based rotations"},{"id":381,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_gtod","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_gtod","content":" IERSConventions.iers_rot3_gcrf_to_gtod  —  Function iers_rot3_gcrf_to_gtod(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the Greenwich True-of-Date (GTOD) at time  tt_s , expressed in TT seconds since  J2000 . Note If the  iers1996  conventions are used, the rotation is actually computed  starting from the MEME2000 rather than the GCRF.   Note The EOP nutation corrections are only used for the  iers2003a  and   iers2010a  models.  See also See also  iers_rot3_itrf_to_gtod . source"},{"id":382,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_mod","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_mod","content":" IERSConventions.iers_rot3_gcrf_to_mod  —  Function iers_rot3_gcrf_to_mod(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the Mean-of-Date (MOD) at time  tt_s , expressed in TT seconds since  J2000 . Note The Mean-of-Date axes are obtained by applying the frame bias and precession matrix.  For this reason, if the  iers1996  conventions are used, the rotation is  actually computed starting from the MEME2000 rather than the GCRF.   See also See also  iers_pb  and  iers_rot3_itrf_to_mod . source"},{"id":383,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_pef","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_pef","content":" IERSConventions.iers_rot3_gcrf_to_pef  —  Function iers_rot3_gcrf_to_pef(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the Pseudo-Earth Fixed (PEF) at time  tt_s , expressed in TT seconds since  J2000 . Note If the  iers1996  conventions are used, the rotation is actually computed  starting from the MEME2000 rather than the GCRF.   Note The EOP nutation corrections are only used for the  iers2003a  and   iers2010a  models.  Note For the  iers1996  and  CPNd  models, there are no differences  between the PEF and GTOD axes. # TODO: specify the magnitude of the rotation! See also See also  iers_rot3_gcrf_to_gtod  and  iers_rot3_itrf_to_pef . source"},{"id":384,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_gcrf_to_tod","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_gcrf_to_tod","content":" IERSConventions.iers_rot3_gcrf_to_tod  —  Function iers_rot3_gcrf_to_tod(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the Geocentric Celestial Reference Frame (GCRF) to  the True-of-Date (TOD) at time  tt_s , expressed in TT seconds since  J2000 . Note The True-of-Date axes are obtained by applying the frame bias, precession and  nutation matrix. For this reason, if the  iers1996  conventions are used, the  rotation is actually computed starting from the MEME2000 rather than the GCRF.   Note The EOP nutation corrections are only used for the  iers2003a  and   iers2010a  models.  See also See also  iers_npb  and  iers_rot3_itrf_to_tod . source"},{"id":385,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_itrf_to_mod","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_itrf_to_mod","content":" IERSConventions.iers_rot3_itrf_to_mod  —  Function iers_rot3_itrf_to_mod(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Mean-of-Date (MOD) at time  tt_s , expressed in TT seconds since  J2000 . Note The EOP nutation corrections are only used for the  iers2003a  and   iers2010a  models.  See also See also  iers_rot3_itrf_to_tod  and  iers_rot3_gcrf_to_mod . source"},{"id":386,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_itrf_to_tod","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_itrf_to_tod","content":" IERSConventions.iers_rot3_itrf_to_tod  —  Function iers_rot3_itrf_to_tod(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the True-of-Date (TOD) at time  tt_s , expressed in TT seconds since  J2000 . Note The EOP corrections in longitude are only used for the  iers2003a  and   iers2010a  models.  See also See also  iers_rot3_itrf_to_gtod  and  iers_rot3_gcrf_to_tod . source"},{"id":387,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_itrf_to_gtod","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_itrf_to_gtod","content":" IERSConventions.iers_rot3_itrf_to_gtod  —  Function iers_rot3_itrf_to_gtod(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Greenwich True-of-Date (GTOD) at time  tt_s , expressed in TT seconds since  J2000 . Note The  CPNd  model returns an identity rotation because it neglects the  effects of polar motion. # TODO: specify magnitude! Note For the  iers1996  model, the GTOD and PEF axes are equal because the IERS  1996 conventions do not account for the TIO locator effects. See also See also  iers_rot3_itrf_to_pef  and  iers_rot3_gcrf_to_gtod . source"},{"id":388,"pagetitle":"Public API","title":"IERSConventions.iers_rot3_itrf_to_pef","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_rot3_itrf_to_pef","content":" IERSConventions.iers_rot3_itrf_to_pef  —  Function iers_rot3_itrf_to_pef(tt_s::Number, m::IERSModel=iers2010b) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Pseudo-Earth Fixed (PEF) at time  tt_s , expressed in TT seconds since  J2000 . Note The  CPNd  model returns an identity rotation because it neglects the  effects of polar motion. # TODO: specify magnitude! See also See also  iers_rot3_gcrf_to_pef . source"},{"id":389,"pagetitle":"Public API","title":"Bias, Precession and Nutation","ref":"/IERSConventions/stable/api/api/#Bias,-Precession-and-Nutation","content":" Bias, Precession and Nutation"},{"id":390,"pagetitle":"Public API","title":"IERSConventions.iers_bias","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_bias","content":" IERSConventions.iers_bias  —  Function iers_bias(m::IERSModel, tt_c::Number) Compute the frame bias matrix, which transform vectors from the GCRF axes to the Mean  Equinox and Mean Equator of J2000 (MEME2000) axes.  Note Since in the IERS 1996 conventions the bias matrix was still undefined, the returned  matrix is the identity.  References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_precession ,  iers_pb  and  iers_npb . source"},{"id":391,"pagetitle":"Public API","title":"IERSConventions.iers_nutation","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_nutation","content":" IERSConventions.iers_nutation  —  Function iers_nutation(m::IERSModel, tt_c::Number, δΔψ::Number=0, δΔϵ::Number=0) Compute the nutation matrix that rotates a vector from Mean-of-Date (MOD) to True-of-Date  (TOD) axes following the IERS convention  m , at time  tt_c  expressed in  TT  Julian  Centuries since  J2000 .  Optional EOP nutation corrections can be provided via the  δΔψ  and  δΔϵ  parameters. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 See also See also  iers_nutation_comp  and  iers_obliquity .  source"},{"id":392,"pagetitle":"Public API","title":"IERSConventions.iers_nutation_comp","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_nutation_comp","content":" IERSConventions.iers_nutation_comp  —  Function iers_nutation_comp(m::IERSModel, tt_c::Number) Compute the nutation components in longitude and obliquity for the IERS convention  m , in  radians, at time  tt_c  expressed in  TT  Julian Centuries since  J2000 . Note For the  IAU 2006A  model, the function strictly follows the SOFA implementation. It  first computes the IAU 2000A nutation, then applies adjustments for the consequences of  the change in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii)  for the secular variation in the Earth's dynamical form factor J2. These corrections  ensure that the IAU 2000A nutation is consistent with the IAU 2006 precession model.  Please note that the coefficients available on the IERS tables already include those  corrections, and are retrieved by multiplying the amplitudes of the SOFA nutation in  longitude coefficients by 1.00000047.  Note The expressions of these components for the  CPNc  and  CPNd  models are  indirectly computed from their CIP series expansion. Warning The computation of the free-core nutation and time dependent effects are excluded from  this model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation  models, such effects must be included a-posteriori (through δΔψ and δΔϵ) using the IERS  EOP data. References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations ERFA  nut06a  and   nut00b  functions  See also See also  iers_nutation source"},{"id":393,"pagetitle":"Public API","title":"IERSConventions.iers_obliquity","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_obliquity","content":" IERSConventions.iers_obliquity  —  Function iers_obliquity(m::IERSModel, tt_c::Number) Compute the mean obliquity of the ecliptic at epoch, in radians, at time  tt_c  expressed in   TT  Julian centuries since  J2000 , according to the IERS convention  m . Note The mean obliquity for the IERS 2003 conventions already accounts the adjustment to the  IAU 1976 precession model for the IAU 2000 precession-rate of the equator in obliquity . References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 source"},{"id":394,"pagetitle":"Public API","title":"IERSConventions.iers_precession","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_precession","content":" IERSConventions.iers_precession  —  Function iers_precession(m::IERSModel, tt_c::Number) Return the precession matrix that rotates a vector from MEME2000 axes to Mean of Date (MOD)  axes, at time  tt_c  expressed in  TT  Julian centuries since  J2000 , according to the IERS  convention  m .  Note This matrix rotates vectors from the Mean Equator and Mean Equinox of J2000 (MEME2000)  to Mean-of-Date (MOD) axes. The frame bias between the GCRF and MEME2000 is excluded  from the returned matrix and must eventually be included with a separate rotation. Note The IAU Working Group on Precession and the Ecliptic (Hilton, 2006) has decided to leave  the choice of the parameterization for the precession angles to the user. In this  function for the IERS 1996 conventions, the precession matrix is computed using the  traditional parameterization of Newcomb and Liekse ( zₐ ,  θₐ ,  ζₐ ), whereas it adopts  the 4-angles formulation ( ϵ₀ ,  ψₐ ,  ωₐ ,  χₐ ) recommended by (Capitaine et al., 2003a) for all the remaining models. References Lieske J. H. et al, (1977), Expression for the Precession Quantities Based upon the IAU    (1976) System of Astronomical Constants. Hilton J. L. et al., (2006), Report of the International Astronomical Union Division I Working    Group on Precession and the Ecliptic. Capitaine N. et al., (2003a), Expressions for IAU 2000 precession quantities.  IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  precession_angles_rot3  and  precession_angles_rot4 source"},{"id":395,"pagetitle":"Public API","title":"IERSConventions.iers_pb","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_pb","content":" IERSConventions.iers_pb  —  Function iers_pb(m::IERSModel, tt_c::Number) Compute the precession-bias (PB) matrix, which transforms vectors from the GCRF axes to Mean-of-Date (MOD) axes, at time  tt_c  expressed in  TT  Julian centuries since  J2000 , according  to the IERS convention  m References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_bias ,  iers_precession  and  iers_npb . source"},{"id":396,"pagetitle":"Public API","title":"IERSConventions.iers_npb","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_npb","content":" IERSConventions.iers_npb  —  Function iers_npb(m::IERSModel, tt_c::Number, δΔψ=0, δΔϵ=0) Compute the nutation-bias-precession (NPB) matrix, which transforms vectors from the GCRF  to True-of-Date (TOD) axes, at time  tt_c  expressed in  TT  Julian centuries since  J2000 ,  according to the IERS convention  m References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_nutation ,  iers_precession  and  iers_pb . source"},{"id":397,"pagetitle":"Public API","title":"Celestial Intermediate Pole","ref":"/IERSConventions/stable/api/api/#Celestial-Intermediate-Pole","content":" Celestial Intermediate Pole"},{"id":398,"pagetitle":"Public API","title":"IERSConventions.iers_cip_motion","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_cip_motion","content":" IERSConventions.iers_cip_motion  —  Function iers_cip_motion(m::IERSModel, tt_c::Number, δX::Number=0, δY::Number=0) Compute the GCRF-to-CIRF rotation matrix, following the IERS Conventions  m , at time  tt_c   expressed in  TT  Julian centuries since J2000. Optional IERS EOP corrections for free-core  nutation and time dependent effects can be provided via  δX  and  δY References IERS Technical Note No.  36 See also See also  cip_xy  and  cip_xys . source"},{"id":399,"pagetitle":"Public API","title":"IERSConventions.cip_xy","ref":"/IERSConventions/stable/api/api/#IERSConventions.cip_xy","content":" IERSConventions.cip_xy  —  Function cip_xy(m::IERSModel, tt_c::Number) Compute the CIP X and Y coordinates, in radians, following the IERS Conventions  m , at  time  tt_c , expressed in  TT  Julian centuries since J2000. Warning The computation of the free-core nutation and time dependent effects are excluded from  this model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation  models, such effects must be included a-posteriori (through δX and δY) using the IERS  EOP data. References Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations. IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_cip_motion  and  cip_xys . source"},{"id":400,"pagetitle":"Public API","title":"IERSConventions.cip_xys","ref":"/IERSConventions/stable/api/api/#IERSConventions.cip_xys","content":" IERSConventions.cip_xys  —  Function cip_xys(m::IERSModel, tt_c::Number, δX::Number=0, δY::Number=0) Compute the CIP X, Y and CIO locator s coordinates, in radians, following the IERS  conventions  m  at time  tt_c , expressed in  TT  Julian centuries since J2000. Optional EOP  nutation corrections can be provided via the  δX  and  δY  parameters. Note Because of the small values of the CIP corrections, the CIO locator holds pretty much  irrespective on them. Indeed, some reports compute  s  with the corrected CIP  coordinates, some do not. References Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_cip_motion  and  cip_xy . source"},{"id":401,"pagetitle":"Public API","title":"IERSConventions.cip_vector","ref":"/IERSConventions/stable/api/api/#IERSConventions.cip_vector","content":" IERSConventions.cip_vector  —  Function cip_vector(m::IERSModel, tt_c::Number) Compute the Celestial Intermediate Pole (CIP) vector, following the IERS Conventions  m  at  time  tt_c , expressed in  TT  Julian centuries since J2000. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 See also See also  cip_xy . source"},{"id":402,"pagetitle":"Public API","title":"Earth Rotation and Sidereal Time","ref":"/IERSConventions/stable/api/api/#Earth-Rotation-and-Sidereal-Time","content":" Earth Rotation and Sidereal Time"},{"id":403,"pagetitle":"Public API","title":"IERSConventions.iers_era","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_era","content":" IERSConventions.iers_era  —  Function iers_era(m::IERSModel, ut1_d::Number) Compute the Earth Rotation Angle (ERA), in radians, at time  ut1_d  expressed as UT1 days  since  J2000 , according to the IERS convention  m . Note In the IERS 1996 conventions, θ is referred to as the Stellar Angle. References IERS Technical Note No.  21 IERS Technical Note No.  36 See also See also  iers_era_rotm . source"},{"id":404,"pagetitle":"Public API","title":"IERSConventions.iers_era_rotm","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_era_rotm","content":" IERSConventions.iers_era_rotm  —  Function iers_era_rotm(m::IERSModel, ut1_d::Number) Compute the CIRF-to-TIRF rotation matrix, according to the IERS conventions  m , at time   ut1_d  expressed in UT1 days since J2000  References IERS Technical Note No.  36 See also See also  iers_era . source"},{"id":405,"pagetitle":"Public API","title":"IERSConventions.iers_earth_rot_rate","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_earth_rot_rate","content":" IERSConventions.iers_earth_rot_rate  —  Function iers_earth_rot_rate(LOD::Number=0) Compute the true angular velocity of the Earth accounting for the Length of the Day, i.e.,  the instantaneous rate of change of UT1 with respect to a uniform time scale.  source"},{"id":406,"pagetitle":"Public API","title":"IERSConventions.iers_gmst","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_gmst","content":" IERSConventions.iers_gmst  —  Function iers_gmst(m::IERSModel, tt_c::Number) Compute the Greenwich Mean Sidereal Time (GMST), in radians, following the IERS Conventions   m  at time  tt_c  expressed as  TT  Julian centuries since J2000.  Note The input time is automatically converted to UT1 for the computation of the Earth  Rotation Angle (ERA) or for the computation of the GMST of the 1996 conventions. Thus,  EOP data must be loaded before calling this function.  References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_gast  and  iers_era . source"},{"id":407,"pagetitle":"Public API","title":"IERSConventions.iers_gast","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_gast","content":" IERSConventions.iers_gast  —  Function iers_gast(m::IERSModel, tt_c::Number, δΔψ::Number=0) Compute the Greenwich Apparent Sidereal Time (GAST), in radians, following the IERS  Conventions  m  at time  tt_c  expressed as  TT  Julian centuries since J2000. An optional EOP  correction for the nutation in longitude can be passed via  δΔψ  for the exact computation  of the equation of the equinoxes.  Note The input time is automatically converted to UT1 for the computation of the Earth  Rotation Angle (ERA) or for the computation of the GMST of the 1996 conventions. Thus,  EOP data must be loaded before calling this function.  References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_gmst ,  equation_equinoxes  and  iers_era . source"},{"id":408,"pagetitle":"Public API","title":"Polar Motion","ref":"/IERSConventions/stable/api/api/#Polar-Motion","content":" Polar Motion"},{"id":409,"pagetitle":"Public API","title":"IERSConventions.iers_polar_motion","ref":"/IERSConventions/stable/api/api/#IERSConventions.iers_polar_motion","content":" IERSConventions.iers_polar_motion  —  Function iers_polar_motion(m::IERSModel, xₚ::Number, yₚ::Number, tt_c::Number) Compute the Polar Motion TIRF-to-ITRF rotation matrix, according to the IERS Conventions   m , at time  tt_c  expressed in  TT  Julian centuries since  J2000 . The function requires   xp  and  yp , the Celestial Intermediate Pole (CIP) coordinates with respect to the  International Celestial Reference Frame (ITFR). TODO: expand description! (and check assumption for CPNd) References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 source"},{"id":410,"pagetitle":"Public API","title":"EOP Data","ref":"/IERSConventions/stable/api/api/#eop_data","content":" EOP Data"},{"id":411,"pagetitle":"Public API","title":"IERSConventions.eop_filename","ref":"/IERSConventions/stable/api/api/#IERSConventions.eop_filename","content":" IERSConventions.eop_filename  —  Function eop_filename() Get the loaded Earth Orientation Parameters (EOP) filename. source"},{"id":412,"pagetitle":"Public API","title":"IERSConventions.eop_load_data!","ref":"/IERSConventions/stable/api/api/#IERSConventions.eop_load_data!","content":" IERSConventions.eop_load_data!  —  Function eop_load_data!(m::IERS2010, filename) Initialise the Earth Orientation Parameters (EOP) from a dedicated JSMD  .eop.dat  file. source"},{"id":413,"pagetitle":"Public API","title":"IERSConventions.eop_unload_data!","ref":"/IERSConventions/stable/api/api/#IERSConventions.eop_unload_data!","content":" IERSConventions.eop_unload_data!  —  Function eop_unload_data!() Unload all the EOP data that has been loaded during the session.  source"},{"id":414,"pagetitle":"Public API","title":"IERSConventions.eop_generate_from_csv","ref":"/IERSConventions/stable/api/api/#IERSConventions.eop_generate_from_csv","content":" IERSConventions.eop_generate_from_csv  —  Function eop_generate_from_csv(m::IERSModel, inputfile, outputfile) Parse CSV files containing IERS EOP data and extract the relevant information to a dedicated  JSMD  .eop.dat  file. Supported formats are the EOP C04 series and the Rapid Data  prediction (finals). Note The  outputfile  name should not include the file extension, which is automatically  added by this function.   Note Depending on the type of file, either the CIP or the nutation corrections may be present.  This function applies a conversion algorithm to automatically retrieve the missing data. Warning The rapid data prediction files store the LOD, CIP and nutation corrections in  milliseconds and milliarcseconds, respectively, whereas the EOP C04 files do not. This  routine automatically detects the correct unit of measure by analysing the format of the  input filename. Thus, the filename should be kept equal to the one released by the IERS.  References USNO finals USNO finals 2000A See also See also  eop_generate_from_txt .  source"},{"id":415,"pagetitle":"Public API","title":"IERSConventions.eop_generate_from_txt","ref":"/IERSConventions/stable/api/api/#IERSConventions.eop_generate_from_txt","content":" IERSConventions.eop_generate_from_txt  —  Function eop_generate_from_txt(m::IERSModel, inputfile, outputfile) Parse TXT files containing IERS EOP data and extract the relevant information to a dedicated  JSMD  .eop.dat  file. Supported formats are the EOP C04 series and the Rapid Data  prediction (finals). Note The  outputfile  name should not include the file extension, which is automatically  added by this function.   Note Depending on the type of file, either the CIP or the nutation corrections may be present.  This function applies a conversion algorithm to automatically retrieve the missing data. Warning This routine recognises the file structure and column ordering by analysing the  input file name, which should be left equal to the one retrieved from the IERS website. References USNO finals USNO finals 2000A See also See also  eop_generate_from_csv .  source"},{"id":418,"pagetitle":"Low-level API","title":"Fundamental Arguments","ref":"/IERSConventions/stable/api/lapi/#Fundamental-Arguments","content":" Fundamental Arguments"},{"id":419,"pagetitle":"Low-level API","title":"Delaunay's Arguments","ref":"/IERSConventions/stable/api/lapi/#Delaunay's-Arguments","content":" Delaunay's Arguments"},{"id":420,"pagetitle":"Low-level API","title":"IERSConventions.DelaunayArgs","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.DelaunayArgs","content":" IERSConventions.DelaunayArgs  —  Type DelaunayArgs Container holding the Delaunay arguments of the Nutation Theory.  Fields M  – Mean anomaly of the Moon, in radians.  S  – Mean anomaly of the Sun, in radians.  F  – Mean longitude of the Moon minus mean longitude of the ascending node, in radians.  D  – Mean elongation of the Moon from the Sun, in radians.  Ω  – Mean longitude of the Moon's ascending node, in radians.  source"},{"id":421,"pagetitle":"Low-level API","title":"IERSConventions.delaunay_anomaly_moon","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.delaunay_anomaly_moon","content":" IERSConventions.delaunay_anomaly_moon  —  Function delaunay_anomaly_moon(m::IERSModel, tdb_c::Number) Compute the mean anomaly of the Moon, in radians, given time  tdb_c  expressed in TDB Julian  centuries since J2000.  source"},{"id":422,"pagetitle":"Low-level API","title":"IERSConventions.delaunay_anomaly_sun","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.delaunay_anomaly_sun","content":" IERSConventions.delaunay_anomaly_sun  —  Function delaunay_anomaly_sun(m::IERSModel, tdb_c::Number) Compute the mean anomaly of the Sun, in radians, given time  tdb_c  expressed in TDB Julian  centuries since J2000. source"},{"id":423,"pagetitle":"Low-level API","title":"IERSConventions.delaunay_longitude_diff","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.delaunay_longitude_diff","content":" IERSConventions.delaunay_longitude_diff  —  Function delaunay_longitude_diff(m::IERSModel, tdb_c::Number) Compute the difference between the longitude of the Moon and the longitude of the Moon's  node, in radians, given time  tdb_c  expressed in TDB Julian centuries since J2000. source"},{"id":424,"pagetitle":"Low-level API","title":"IERSConventions.delaunay_elongation_moon","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.delaunay_elongation_moon","content":" IERSConventions.delaunay_elongation_moon  —  Function delaunay_elongation_moon(m::IERSModel, tdb_c::Number) Compute the mean elongation of the Moon from the Sun, in radians, given time  tdb_c  expressed in  TDB Julian centuries since J2000. source"},{"id":425,"pagetitle":"Low-level API","title":"IERSConventions.delaunay_longitude_node","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.delaunay_longitude_node","content":" IERSConventions.delaunay_longitude_node  —  Function delaunay_longitude_node(m::IERSModel, tdb_c::Number) Compute the longitude of the mean ascending node of the lunar orbit on th ecliptic,  measured from the mean equinox of date, in radians, given time  tdb_c  expressed in TDB Julian  centuries since J2000. source"},{"id":426,"pagetitle":"Low-level API","title":"Planetary Arguments","ref":"/IERSConventions/stable/api/lapi/#Planetary-Arguments","content":" Planetary Arguments"},{"id":427,"pagetitle":"Low-level API","title":"IERSConventions.PlanetaryArgs","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.PlanetaryArgs","content":" IERSConventions.PlanetaryArgs  —  Type PlanetaryArgs Container holding the planetary arguments of the Nutation Theory.  Note The default constructors skip their computation when neither the   iers2003a  and  iers2010a  models are required. This results in a maximum error of about 1.5 mas between 2000 and 2100. Fields λ_Me  – Mercury's mean heliocentric longitude, in radians.  λ_Ve  – Venus's mean heliocentric longitude, in radians.  λ_Ea  – Earth's mean heliocentric longitude, in radians.  λ_Ma  – Mars's mean heliocentric longitude, in radians.  λ_Ju  – Jupiter's mean heliocentric longitude, in radians.  λ_Sa  – Saturn's mean heliocentric longitude, in radians.  λ_Ur  – Uranus's mean heliocentric longitude, in radians.  λ_Ne  – Neptune's mean heliocentric longitude, in radians.  pₐ  – General precession in longitude, in radians.  source"},{"id":428,"pagetitle":"Low-level API","title":"IERSConventions.pa_mercury","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_mercury","content":" IERSConventions.pa_mercury  —  Function pa_mercury(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Mercury in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  Warning This function has not been implemented for the IERS 1996 conventions. References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":429,"pagetitle":"Low-level API","title":"IERSConventions.pa_venus","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_venus","content":" IERSConventions.pa_venus  —  Function pa_venus(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Venus in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":430,"pagetitle":"Low-level API","title":"IERSConventions.pa_earth","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_earth","content":" IERSConventions.pa_earth  —  Function pa_earth(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Earth in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":431,"pagetitle":"Low-level API","title":"IERSConventions.pa_mars","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_mars","content":" IERSConventions.pa_mars  —  Function pa_mars(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Mars in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":432,"pagetitle":"Low-level API","title":"IERSConventions.pa_jupiter","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_jupiter","content":" IERSConventions.pa_jupiter  —  Function pa_jupiter(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Jupiter in radians, at time  tdb_c  expressed in  TDB  Julian centuries since  J2000 .  References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":433,"pagetitle":"Low-level API","title":"IERSConventions.pa_saturn","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_saturn","content":" IERSConventions.pa_saturn  —  Function pa_saturn(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Saturn in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":434,"pagetitle":"Low-level API","title":"IERSConventions.pa_uranus","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_uranus","content":" IERSConventions.pa_uranus  —  Function pa_uranus(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Uranus in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  Warning This function has not been implemented for the IERS 1996 conventions. References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":435,"pagetitle":"Low-level API","title":"IERSConventions.pa_neptune","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_neptune","content":" IERSConventions.pa_neptune  —  Function pa_neptune(m::IERSModel, tdb_c::Number) Return the mean heliocentric longitude of Neptune in radians, at time  tdb_c  expressed in  TDB   Julian centuries since  J2000 .  Warning This function has not been implemented for the IERS 1996 conventions. References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":436,"pagetitle":"Low-level API","title":"IERSConventions.pa_precession","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.pa_precession","content":" IERSConventions.pa_precession  —  Function pa precession(m::IERSModel, tdb c::Number)  Return the general accumulated precession in longitude  pₐ  in radians, at time  tdb_c   expressed in  TDB  Julian centuries since  J2000 .  References IERS Technical Note No.  21 IERS Technical Note No.  36 ERFA  software library source"},{"id":437,"pagetitle":"Low-level API","title":"Fukushima-Williams","ref":"/IERSConventions/stable/api/lapi/#Fukushima-Williams","content":" Fukushima-Williams"},{"id":438,"pagetitle":"Low-level API","title":"IERSConventions.fw2xy","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.fw2xy","content":" IERSConventions.fw2xy  —  Function fw2xy(ϵ::Number, ψ::Number, γ::Number, φ::Number) Compute the CIP X and Y coordinates from Fukushima-Williams bias-precession-nutation  angles, in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":439,"pagetitle":"Low-level API","title":"IERSConventions.fw_angles","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.fw_angles","content":" IERSConventions.fw_angles  —  Function fw_angles(m::IERS2010, tt_c::Number) Compute the precession angles, γ, ϕ, ψ, ϵ in radians, according to the IAU 2006  Fukushima-Williams 4-angle formulation at time  tt_c  expressed in  TT  Julian centuries  since  J2000 . References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":440,"pagetitle":"Low-level API","title":"IERSConventions.fw_matrix","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.fw_matrix","content":" IERSConventions.fw_matrix  —  Function fw_matrix(γ, ϕ, ψ, ε) Form a rotation matrix given the Fukushima-Williams angles, expressed in radians. The present function can construct three different matrices depending on which angles are  supplied as arguments:  NPB : To obtain the Nutation-Precession-Bias (NPB) matrix, generate the four standard FW    precession angles (̄γ, ̄ϕ, ̄ψ, ϵₐ) then generate the nutation components Δψ and Δϵ and add them    to ̄ψ, ϵₐ. Finally, call the present functions using those four angles as arguments.  PB : To obtain the Precession-Bias matrix, generate the four standard FW precession    angles and call the present function.  B : To obtain the frame bias matrix, generate the four standard FW precession angles at    date J2000.0 and call this function. The remaining nutation-only and precession only matrices can be obtained by combining these  three appropriately.  References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":441,"pagetitle":"Low-level API","title":"Earth Orientation Parameters","ref":"/IERSConventions/stable/api/lapi/#Earth-Orientation-Parameters","content":" Earth Orientation Parameters"},{"id":442,"pagetitle":"Low-level API","title":"Constants","ref":"/IERSConventions/stable/api/lapi/#Constants","content":" Constants"},{"id":443,"pagetitle":"Low-level API","title":"IERSConventions.NutationCorrections","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.NutationCorrections","content":" IERSConventions.NutationCorrections  —  Type NutationCorrections Container to hold the nutation corrections and celestial pole offsets associated to a   given IERS model (e.g., 2000A) Fields δX, δY : Celestial pole offsets referred to the model IAU2000A (rad). δΔψ, δΔϵ : Nutation corrections in longitude and obliquity (rad) See also See also  EOPData . source"},{"id":444,"pagetitle":"Low-level API","title":"IERSConventions.NutCorrectionsInterpolator","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.NutCorrectionsInterpolator","content":" IERSConventions.NutCorrectionsInterpolator  —  Type NutCorrectionsInterpolator Container to store the interpolators for the nutation corrections and celestial pole offsets  associated to a given IERS model.  See also See also  EOPInterpolator source"},{"id":445,"pagetitle":"Low-level API","title":"IERSConventions.EOPData","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.EOPData","content":" IERSConventions.EOPData  —  Type EOPData{T} EOP Data container. Data is parameterised by time expressed in Terrestrial Time (TT) days.  Fields filename  : File where the EOP data are stored.  days_UTC : UTC Julian days since J2000. cent_TT  : TT Julian centuries since J2000. UT1_TT : UT1 minus TT offset, in seconds. LOD : Length of day offset (s). xp, yp : Polar motion with respect to the crust (rad). nut1996, nut2003, nut2006 : nutation and CIP corrections.   source"},{"id":446,"pagetitle":"Low-level API","title":"IERSConventions.EOPInterpolator","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.EOPInterpolator","content":" IERSConventions.EOPInterpolator  —  Type EOPInterpolator Container to store the interpolators for the loaded EOP data.  source"},{"id":447,"pagetitle":"Low-level API","title":"IERSConventions.IERS_EOP","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.IERS_EOP","content":" IERSConventions.IERS_EOP  —  Constant IERS_EOP Earth Orientation Parameters (EOP) interpolators.  See also See also  eop_load_data!  and  EOPInterpolator . source"},{"id":448,"pagetitle":"Low-level API","title":"IERSConventions.IERS_EOP_DATA","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.IERS_EOP_DATA","content":" IERSConventions.IERS_EOP_DATA  —  Constant IERS_EOP_DATA Earth Orientation Parameters Data.  See also See also  EOPData . source"},{"id":449,"pagetitle":"Low-level API","title":"Loading","ref":"/IERSConventions/stable/api/lapi/#Loading","content":" Loading"},{"id":450,"pagetitle":"Low-level API","title":"IERSConventions.eop_read_data","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_read_data","content":" IERSConventions.eop_read_data  —  Function eop_read_data(filename) Read Earth Orientation Parameters (EOP) from a dedicated JSMD  .eop.dat  file.  Note JSMD's  .eop.dat  EOP files are meant to have a fixed structure to ease the  retrieval of the relevant EOP data.  source"},{"id":451,"pagetitle":"Low-level API","title":"IERSConventions.eop_set_data!","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_set_data!","content":" IERSConventions.eop_set_data!  —  Function eop_set_data!(m::IERSModel, filename) Set Earth Orientation Parameters (EOP) to be used for frames transformations from a JSMD   .eop.dat  file, given a reference model  m . source"},{"id":452,"pagetitle":"Low-level API","title":"Parsing","ref":"/IERSConventions/stable/api/lapi/#Parsing","content":" Parsing"},{"id":453,"pagetitle":"Low-level API","title":"IERSConventions.eop_write_data","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_write_data","content":" IERSConventions.eop_write_data  —  Function eop_write_data(data, output_filename) Write the EOP data stored in the matrix  data  to a dedicated JSMD  .eop-dat  file.   Note The  output_filename  should not include the file extension, which is automatically  added by this function.   See also See also  eop_generate_from_csv  and  eop_generate_from_txt .  source"},{"id":454,"pagetitle":"Low-level API","title":"IERSConventions.δnut_to_δcip","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.δnut_to_δcip","content":" IERSConventions.δnut_to_δcip  —  Function δnut_to_δcip(m::IERSModel, t::Number, δΔψ::Number, δΔϵ::Number) Convert nutation corrections in longitude  δΔψ  and obliquity  δΔϵ  to CIP corrections   δX ,  δY  at time  t  expressed in TT Julian centuries since J2000 for model  m . All  input and output EOP are given in radians.  References IERS Technical Note No.  36 Paris IERS observatory FTP server (UAI2000 package). See also See also  δcip_to_δnut . source"},{"id":455,"pagetitle":"Low-level API","title":"IERSConventions.δcip_to_δnut","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.δcip_to_δnut","content":" IERSConventions.δcip_to_δnut  —  Function δcip_to_δnut(m::IERSModel, t::Number, δX::Number, δY::Number) Convert CIP corrections  δX ,  δY  to nutation corrections in longitude  δΔψ  and obliquity   δΔϵ  to  at time  t  expressed in TT Julian centuries since J2000 for model  m . All  input and output EOP are given in radians.  References IERS Technical Note No.  36 Paris IERS observatory FTP server (UAI2000 package). See also See also  δnut_to_δcip . source"},{"id":456,"pagetitle":"Low-level API","title":"Interpolation Functions","ref":"/IERSConventions/stable/api/lapi/#Interpolation-Functions","content":" Interpolation Functions"},{"id":457,"pagetitle":"Low-level API","title":"IERSConventions.eop_δΔψ","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_δΔψ","content":" IERSConventions.eop_δΔψ  —  Function eop_δΔψ(m::IERSModel, tt_c::Number) Interpolate and retrieve the EOP nutation correction in longitude  δΔψ , in radians,  at time  tt_c  expressed in  TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. See also See also  eop_δΔϵ ,  eop_δX  and  eop_δY . source"},{"id":458,"pagetitle":"Low-level API","title":"IERSConventions.eop_δΔϵ","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_δΔϵ","content":" IERSConventions.eop_δΔϵ  —  Function eop_δΔϵ(m::IERSModel, tt_c::Number) Interpolate and retrieve the EOP nutation correction in obliquity  δΔϵ , in radians,  at time  tt_c  expressed in  TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. See also See also  eop_δΔψ ,  eop_δX  and  eop_δY . source"},{"id":459,"pagetitle":"Low-level API","title":"IERSConventions.eop_δX","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_δX","content":" IERSConventions.eop_δX  —  Function eop_δX(m::IERSModel, tt_c::Number) Interpolate and retrieve the CIP  δX  correction, in radians, at time  tt_c  expressed in   TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. See also See also  eop_δΔψ ,  eop_δΔϵ  and  eop_δY . source"},{"id":460,"pagetitle":"Low-level API","title":"IERSConventions.eop_δY","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_δY","content":" IERSConventions.eop_δY  —  Function eop_δY(m::IERSModel, tt_c::Number) Interpolate and retrieve the CIP  δY  correction, in radians, at time  tt_c  expressed in   TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. See also See also  eop_δΔψ ,  eop_δΔϵ  and  eop_δX . source"},{"id":461,"pagetitle":"Low-level API","title":"IERSConventions.eop_xp","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_xp","content":" IERSConventions.eop_xp  —  Function eop_xp(m::IERSModel, tt_c::Number) Interpolate and retrieve the pole  xₚ  coordinate, in radians, at time  tt_c  expressed in   TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. See also See also  eop_yp . source"},{"id":462,"pagetitle":"Low-level API","title":"IERSConventions.eop_yp","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_yp","content":" IERSConventions.eop_yp  —  Function eop_yp(m::IERSModel, tt_c::Number) Interpolate and retrieve the pole  yₚ  coordinate, in radians, at time  tt_c  expressed in   TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. See also See also  eop_xp . source"},{"id":463,"pagetitle":"Low-level API","title":"IERSConventions.eop_lod","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eop_lod","content":" IERSConventions.eop_lod  —  Function eop_lod(m::IERSModel, tt_c::Number) Interpolate and retrieve the length of day  LOD  offset, in seconds, at time  tt_c  expressed in   TT  Julian centuries since J2000 for the IERS convention  m . Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. source"},{"id":464,"pagetitle":"Low-level API","title":"IERSConventions.offset_tt2ut1","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.offset_tt2ut1","content":" IERSConventions.offset_tt2ut1  —  Function offset_tt2ut1(tt_s::Number) Return the TT-to-UT1 offset, in seconds, at  tt_s  expressed in TT seconds since J2000. Note If time is outside the boundaries for which there is available EOP data, a zero value is returned. source"},{"id":465,"pagetitle":"Low-level API","title":"Poisson Series","ref":"/IERSConventions/stable/api/lapi/#Poisson-Series","content":" Poisson Series"},{"id":466,"pagetitle":"Low-level API","title":"IERSConventions.PoissonSeries","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.PoissonSeries","content":" IERSConventions.PoissonSeries  —  Type PoissonSeries This container stores the non-polynomial part of a Poisson series, i.e., the  sine and cosine coefficients and the Delaunay's and Planetary arguments of the nutation  theory multipliers.  source"},{"id":467,"pagetitle":"Low-level API","title":"IERSConventions.NutationDataParser","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.NutationDataParser","content":" IERSConventions.NutationDataParser  —  Type NutationDataParser <: PoissonDataParser Parser for nutation-like data, in which the orders of the different coefficients are  stored on separate columns, e.g., in and out of phase.  Fields ncols: number of columns  c_dargs: first column of the Delaunay's arguments  c_pargs: first column of the planetary arguments  c_sin: column with the sine terms  c_cos: column with the cosine terms  linePattern: regex expression to parse the relevant data lines   source"},{"id":468,"pagetitle":"Low-level API","title":"IERSConventions.CIODataParser","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.CIODataParser","content":" IERSConventions.CIODataParser  —  Type CIODataParser <: PoissonDataParser Parser for CIO-like data, in which the orders of the different coefficients are  separated by a specific line header in the form of \" j = 0  Nb of terms = 1306\".  Fields ncols: number of columns  c_dargs: first column of the Delaunay's arguments  c_pargs: first column of the planetary arguments  c_sin: column with the sine terms  c_cos: column with the cosine terms  linePattern: regex expression to parse the relevant data lines   source"},{"id":469,"pagetitle":"Low-level API","title":"IERSConventions.parse_iers_constants","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.parse_iers_constants","content":" IERSConventions.parse_iers_constants  —  Function parse_iers_constants(filename::String, parser::PoissonDataParser) Retrieve the Poisson series within  filename  with the configuration of  parser . source"},{"id":470,"pagetitle":"Low-level API","title":"IERSConventions.generate_iers_file","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.generate_iers_file","content":" IERSConventions.generate_iers_file  —  Function generate_iers_file(filename::String, constant_name::Symbol, constant_data) Generate or append the data in  constant_data  to  filename  as a variable named   constant_name . source"},{"id":471,"pagetitle":"Low-level API","title":"Miscellaneous","ref":"/IERSConventions/stable/api/lapi/#Miscellaneous","content":" Miscellaneous"},{"id":472,"pagetitle":"Low-level API","title":"IERSConventions.cio_locator","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.cio_locator","content":" IERSConventions.cio_locator  —  Function cio_locator(m::IERSModel, tt_c::Number, x::Number, y::Number) Compute the CIO locator  s , in radians, following the IERS Conventions  m  at time  tt_c ,  expressed in  TT  Julian centuries since J2000, given the CIP coordinates  x  and  y . References Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_cip_motion ,  cip_xy  and  cip_xys . source"},{"id":473,"pagetitle":"Low-level API","title":"IERSConventions.equation_equinoxes","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.equation_equinoxes","content":" IERSConventions.equation_equinoxes  —  Function equation_equinoxes(m::IERSModel, tt_c::Number, δΔψ::Number = 0) Compute the Equation of the Equinoxes, in radians, according to the IERS Conventions  m ,  at time  tt_c  expressed as  TT  Julian centuries since J2000. An optional EOP correction for  the nutation in longitude can be passed via  δΔψ . Note In this framework, the equation of the equinoxes is always defined according to the  following equation:  GAST = GMST + equation of the equinoxes References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_obliquity ,  iers_nutation_comp  and  eeq_complementary . source"},{"id":474,"pagetitle":"Low-level API","title":"IERSConventions.eeq_complementary","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.eeq_complementary","content":" IERSConventions.eeq_complementary  —  Function eeq_complementary(m::IERSModel, tt_c::Number) Compute the complementary terms of the equation of the equinoxes, in radians, associated  to the IERS Conventions  m , at time  tt_c  expressed in  TT  Julian centuries since J2000. Note For the IERS 1996 Conventions, starting from 1997-02-27T00:00:00 UTC, two additional  terms are included to account for the Moon effect (see IAU 1997 C7 resolution).  The complementary terms of earlier dates are always null.  References IAU Resolution C7, Recommendation 3 (1994) IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 source"},{"id":475,"pagetitle":"Low-level API","title":"IERSConventions.npb2xy","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.npb2xy","content":" IERSConventions.npb2xy  —  Function npb2xy(A::AbstractMatrix) Retrieve the CIP X and Y coordinates from the nutation-precession-bias matrix, in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":476,"pagetitle":"Low-level API","title":"IERSConventions.precession_angles_rot3","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.precession_angles_rot3","content":" IERSConventions.precession_angles_rot3  —  Function precession_angles_rot3(m::IERSModel, tt_c::Number) Return the equatorial precession angles zₐ, θₐ, ζₐ, in radians, at time  tt_c  expressed in   TT  Julian centuries since  J2000  for the 3-rotations precession series initially used  by Newcomb and Lieske.  Note The expressions for these angles compatible with the IAU 2000A precession and nutation  have been developed in order to match the 4-rotation series to sub-microarcsecond  accuracy over 4 centuries. Note TT  is used as time argument instead of TDB. The largest term in the TDB-TT difference  causes a periodic error which is significantly under the microarcsecond accuracy. References Lieske J. H. et al, (1977), Expression for the Precession Quantities Based upon the IAU    (1976) System of Astronomical Constants. Capitained N. 2003b et al., Expressions for IAU 2000 precession quantities. Hilton J. L. et al., (2006), Report of the International Astronomical Union Division I Working  Group on Precession and the Ecliptic. IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_precession  and  precession_angles_rot4 source"},{"id":477,"pagetitle":"Low-level API","title":"IERSConventions.precession_angles_rot4","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.precession_angles_rot4","content":" IERSConventions.precession_angles_rot4  —  Function precession_angles_rot4(m::IERSModel, tt_c::Number) Return the precession angles ϵ₀, ψₐ, ωₐ, χₐ, in radians, at time  tt_c  expressed in  TT  Julian  centuries since  J2000  required for the canonical 4-rotations precession series. Note TT  is used as time argument instead of TDB. The largest term in the TDB-TT difference  causes a periodic error which is significantly under the microarcsecond accuracy. References IERS Technical Note No.  21 IERS Technical Note No.  32 IERS Technical Note No.  36 See also See also  iers_precession  and  precession_angles_rot4 source"},{"id":478,"pagetitle":"Low-level API","title":"IERSConventions.tio_locator","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.tio_locator","content":" IERSConventions.tio_locator  —  Function tio_locator(m::IERSModel, tt_c::Number) Compute the TIO locator  s'  at date, positioning the Terrestrial Intermediate Origin on  the equator of the Celestial Intermediate Pole (CIP) at time  tt_c  expressed as  TT  Julian  centuries since J2000.  This function approximates the unpredictable motion of the TIO locator s' with its secular  drift of ~0.47 μas/century.  Note A null value is returned for the  iers1996  and the  CPNd  models. References IERS Technical Note No.  36 Lambert, S. and Bizouard C. (2002), Positioning the Terrestrial Ephemeris Origin in the  Terrestrial Reference Frame,  DOI: 10.1051/0004-6361:20021139 source"},{"id":479,"pagetitle":"Low-level API","title":"IERSConventions.xys2m","ref":"/IERSConventions/stable/api/lapi/#IERSConventions.xys2m","content":" IERSConventions.xys2m  —  Function xys2m(x::Number, y::Number, s::Number) Compute the GCRF-to-CIRF matrix given the CIP  x ,  y' coordinates and the CIO  locator s`, all in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":486,"pagetitle":"Home","title":"Welcome to FrameTransformations.jl!","ref":"/FrameTransformations/stable/#Welcome-to-FrameTransformations.jl!","content":" Welcome to FrameTransformations.jl! A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame. Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, this package is the ideal starting point. FrameTransformations.jl is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. "},{"id":487,"pagetitle":"Home","title":"Features","ref":"/FrameTransformations/stable/#Features","content":" Features Convert between different time scales and representations (via  Tempo.jl ). Read binary ephemeris files (via  Ephemerides.jl  or  CalcephEphemeris.jl  extensions). Create custom reference frame systems with both standard and user-defined points, axes and directions. Transform states and their higher-order derivatives between different frames (up to jerk). All of this seamlessly integrated with  ForwardDiff.jl ."},{"id":488,"pagetitle":"Home","title":"Installation","ref":"/FrameTransformations/stable/#Installation","content":" Installation This package can be installed using Julia's package manager:  julia> import Pkg\n\njulia> Pkg.add(\"FrameTransformations.jl\");"},{"id":491,"pagetitle":"Axes","title":"Axes","ref":"/FrameTransformations/stable/API/axes_api/#axes_api","content":" Axes"},{"id":492,"pagetitle":"Axes","title":"Core","ref":"/FrameTransformations/stable/API/axes_api/#Core","content":" Core"},{"id":493,"pagetitle":"Axes","title":"FrameTransformations.add_axes!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes!","content":" FrameTransformations.add_axes!  —  Function add_axes!(frames, name::Symbol, id::Int, class::Int, funs, parentid) Add a new axes node to  frames . Inputs frames  – Target frame system  name  – Axes name, must be unique within  frames id  – Axes ID, must be unique within  frames class  – Axes class.   funs  –  FrameAxesFunctions  object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of  frames . parentid  – Axes ID of the parent axes. Not required only for the root axes. Warning This is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see  add_axes_inertial! ,  add_axes_rotating! ,   add_axes_fixedoffset!  and  add_axes_root! . source"},{"id":494,"pagetitle":"Axes","title":"FrameTransformations.add_axes_root!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_root!","content":" FrameTransformations.add_axes_root!  —  Function add_axes_root!(frames, name::Symbol, id::Int) Create root axes in  frames . source"},{"id":495,"pagetitle":"Axes","title":"FrameTransformations.add_axes_inertial!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_inertial!","content":" FrameTransformations.add_axes_inertial!  —  Function add_axes_inertial!(frames, name, id, parent, fun) Add inertial axes  name  and id  id  as a set of inertial axes to  frames . The axes relation  to the  parent  axes are given by a  fun . See also See also  add_axes! . source"},{"id":496,"pagetitle":"Axes","title":"FrameTransformations.add_axes_rotating!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_rotating!","content":" FrameTransformations.add_axes_rotating!  —  Function add_axes_rotating!(frames, name::Symbol, id::Int, parent, fun, δfun=nothing, \n    δ²fun=nothing, δ³fun=nothing) Add  axes  as a set of rotating axes to  frames . The orientation of these axes depends only  on time and is computed through the custom functions provided by the user.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a Direction Cosine Matrix (DCM). δfun : return the DCM and its 1st order time derivative. δ²fun : return the DCM and its 1st and 2nd order time derivatives. δ³fun : return the DCM and its 1st, 2nd and 3rd order time derivatives. If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed via automatic differentiation. Warning It is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types.  source"},{"id":497,"pagetitle":"Axes","title":"FrameTransformations.add_axes_fixedoffset!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_fixedoffset!","content":" FrameTransformations.add_axes_fixedoffset!  —  Function add_axes_fixedoffset!(frames, name::Symbol, id::Int, parent, dcm:DCM) Add axes  name  with id  id  to  frames  with a fixed-offset from  parent .  Fixed offset axes have a constant orientation with respect to their  parent  axes,  represented by  dcm , a Direction Cosine Matrix (DCM). See also See also  add_axes! . source"},{"id":498,"pagetitle":"Axes","title":"FrameTransformations.add_axes_alias!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_alias!","content":" FrameTransformations.add_axes_alias!  —  Function add_axes_alias!(frames, target, alias::Symbol) Add a name  alias  to a  target  axes registered in  frames . source"},{"id":499,"pagetitle":"Axes","title":"FrameTransformations.add_axes_frozen!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_frozen!","content":" FrameTransformations.add_axes_frozen!  —  Function add_axes_frozen!(frames, name, id, frozen, e) Create a frozen axes version of  frozen  at epoch  e , with  name  and  id  and add  it to  frames . Warning The parent axes are automatically assigned to the  frozen  parent. source"},{"id":500,"pagetitle":"Axes","title":"FrameTransformations.add_axes_ephemeris!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_ephemeris!","content":" FrameTransformations.add_axes_ephemeris!  —  Function add_axes_ephemeris!(frames::FrameSystem{O, N}, eph::AbstractEphemerisProvider, \n    name::Symbol, id::Int, seq::Symbol, class::Int) where {O, N} Add axes coming from an  AbstractEphemerisProvider  subtype to  frames .  The axes are identifies by the  id  and a have a user defined  name . The rotation matrix  is build using the rotation sequence specified in  seq . The axes type is specified by  class . Warning This is an interface only, concrete subtypes of  AbstractEphemerisProvider  requires  an proper implementation. source"},{"id":501,"pagetitle":"Axes","title":"Celestial","ref":"/FrameTransformations/stable/API/axes_api/#Celestial","content":" Celestial"},{"id":502,"pagetitle":"Axes","title":"FrameTransformations.add_axes_gcrf!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_gcrf!","content":" FrameTransformations.add_axes_gcrf!  —  Function add_axes_gcrf!(frames::FrameSystem) Add the Geocentric Celestial Reference Frame (GCRF) to the frames graph. The axes are  automatically named  GCRF  and assigned the 23 ID. These axes can only  be defined as a set of root axes or as child of the ICRF (ID = 1). See also See also  add_axes_icrf!  and  AXESID_GCRF . source"},{"id":503,"pagetitle":"Axes","title":"FrameTransformations.add_axes_icrf!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_icrf!","content":" FrameTransformations.add_axes_icrf!  —  Function add_axes_icrf!(frames::FrameSystem) Add the International Celestial Reference Frame (ICRF) as the root axes of the frames graph. The axes are automatically named  ICRF  and assigned the 1 ID.  See also See also  add_axes_root! ,  add_axes_gcrf!  and  AXESID_ICRF . source"},{"id":504,"pagetitle":"Axes","title":"FrameTransformations.add_axes_eme2000!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_eme2000!","content":" FrameTransformations.add_axes_eme2000!  —  Function add_axes_eme2000!(frames, name::Symbol=:EME2000, parentid::Int=AXESID_ICRF, \n    id::Int = AXESID_EME2000) Add Mean Equator Mean Equinox of J2000 axes to  frames . Custom  name ,  id  and  parentid   can be assigned by the user. See also See also  DCM_ICRF_TO_EME2000 . source"},{"id":505,"pagetitle":"Axes","title":"Ecliptic","ref":"/FrameTransformations/stable/API/axes_api/#Ecliptic","content":" Ecliptic"},{"id":506,"pagetitle":"Axes","title":"FrameTransformations.add_axes_ecl2000!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_ecl2000!","content":" FrameTransformations.add_axes_ecl2000!  —  Function add_axes_ecl2000!(frames, name::Symbol=:ECL2000, parentid::Int, id::Int = AXESID_ECL2000; \n    model::IERSModel=iers1996) Add Ecliptic Equinox of J2000 (ECL2000) axes to  frames . Custom  id ,  name  and  parentid  can be assigned by the user. The admissible parent axes are the following:  ICRF : for the International Celestial Reference Frame, with ID = 1 GCRF : for the Geocentric Celestial Reference Frame, with ID = 23 EME2000 : the Mean Earth/Moon Ephemeris of J2000, with ID = 22 Note The obliquity of the ecliptic is computed using the IERS convention  model . To retrieve the same orientation of the ECLIPJ2000 axes avaialble in the SPICE  Toolkit, the  iers1996  model must be used. source"},{"id":507,"pagetitle":"Axes","title":"Terrestrial","ref":"/FrameTransformations/stable/API/axes_api/#Terrestrial","content":" Terrestrial"},{"id":508,"pagetitle":"Axes","title":"FrameTransformations.add_axes_itrf!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_itrf!","content":" FrameTransformations.add_axes_itrf!  —  Function add_axes_itrf!(frames::FrameSystem, name::Symbol, parentid::Int=AXESID_ICRF, id::Int=AXESID_ITRF,\n    model::IERSModel=iers2010b) Add International Terrestrial Reference Frame (ITRF) axes to  frames . Use the  model   argument to specify which IERS convention should be used for the computations. Warning If the ID of the parent set of  axes  is neither the ICRF (ID = 1) nor the GCRF (ID = 23), an error is thrown.  source"},{"id":509,"pagetitle":"Axes","title":"FrameTransformations.add_axes_tirf!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_tirf!","content":" FrameTransformations.add_axes_tirf!  —  Function add_axes_tirf!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b) Add Terrestrial Intermediate Reference Frame (TIRF) axes to  frames . Use the  model  argument  to specify which IERS convention should be used for the computations. Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown.  source"},{"id":510,"pagetitle":"Axes","title":"FrameTransformations.add_axes_cirf!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_cirf!","content":" FrameTransformations.add_axes_cirf!  —  Function add_axes_cirf!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b) Add Celestial Intermediate Reference Frame (CIRF) axes to  frames . Use the  model  argument  to specify which IERS convention should be used for the computations. Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown.  source"},{"id":511,"pagetitle":"Axes","title":"FrameTransformations.add_axes_mod!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_mod!","content":" FrameTransformations.add_axes_mod!  —  Function add_axes_mod!(frames, name::Symbol, axesid::Int, parentid::Int, \n    model::IERSConventions.IERSModel=iers2010b) Add Mean Equator and Equinox of Date (MOD) axes to  frames . Use the  model  argument to  specify which IERS convention should be used for the computations. Note The Mean-of-Date axes are obtained by applying the frame bias and precession matrix.  For this reason, if the IERS 1996 conventions are used, the rotation is  actually computed starting from the EME2000 rather than the GCRF.   Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown.  source"},{"id":512,"pagetitle":"Axes","title":"FrameTransformations.add_axes_tod!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_tod!","content":" FrameTransformations.add_axes_tod!  —  Function add_axes_tod!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b) Add True Equator of Date (TOD) axes to  frames . Use the  model  argument to specify which  IERS convention should be used for the computations. Note The True-of-Date axes are obtained by applying the frame bias, precession and  nutation matrix. For this reason, if the IERS 1996 conventions are used, the  rotation is actually computed starting from the EME2000 rather than the GCRF.   Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown.  source"},{"id":513,"pagetitle":"Axes","title":"FrameTransformations.add_axes_gtod!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_gtod!","content":" FrameTransformations.add_axes_gtod!  —  Function add_axes_gtod!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b) Add Greenwich True-of-Date (GTOD) axes to  frames . Use the  model  argument to specify  which IERS convention should be used for the computations. Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown.  source"},{"id":514,"pagetitle":"Axes","title":"FrameTransformations.add_axes_pef!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_pef!","content":" FrameTransformations.add_axes_pef!  —  Function add_axes_pef!(frames::FrameSystem, name::Symbol, id::Int, parentid::Int=AXESID_ICRF, \n    model::IERSModel=iers2010b) Add Pseudo-Earth Fixed (PEF) axes to  frames . Use the  model  argument to specify which  IERS convention should be used for the computations. Warning The ID of the  parent  set of axes must be 1 (ICRF) or 23 (GCRF) otherwise an error is thrown.  source"},{"id":515,"pagetitle":"Axes","title":"Planetary","ref":"/FrameTransformations/stable/API/axes_api/#Planetary","content":" Planetary"},{"id":516,"pagetitle":"Axes","title":"FrameTransformations.add_axes_bci2000!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_bci2000!","content":" FrameTransformations.add_axes_bci2000!  —  Function add_axes_bci2000!(frames, axes::AbstractFrameAxes, center, data) Add Body-Centered Inertial (BCI) axes at J2000 with  name  and  id  to  frames .  The center point (i.e., the reference body) is  center . Warning The parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in  frames , an error is thrown. See also See also  add_axes_fixedoffset! ,  add_axes_bcrtod! . source"},{"id":517,"pagetitle":"Axes","title":"FrameTransformations.add_axes_bcrtod!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_bcrtod!","content":" FrameTransformations.add_axes_bcrtod!  —  Function add_axes_bcrtod!(frames, name, id, center; deriv=true) Add Body-Centered Rotating (BCR), True-of-Date (TOD) axes with  name  and  id  to  frames .  The center point (i.e., the reference body) is  center . These axes are the equivalent of SPICE's  IAU_<BODY_NAME>  frames. Warning The parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in  frames , an error is thrown. See also See also  add_axes_rotating! ,  add_axes_bci2000! . source"},{"id":518,"pagetitle":"Axes","title":"Lunar","ref":"/FrameTransformations/stable/API/axes_api/#Lunar","content":" Lunar"},{"id":519,"pagetitle":"Axes","title":"FrameTransformations.add_axes_me421!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_me421!","content":" FrameTransformations.add_axes_me421!  —  Function add_axes_me421!(frames, name::Symbol, parentid::Int, axesid::Int=AXESID_MOONME_DE421) Add DE421 Moon's Mean Earth/Mean Rotation (ME) axes to  frames . Warning The  parent  set of axes must either the DE440 Principal Axes (PA440, ID =  or the DE421 Principal Axes (PA421, ID =  31006), otherwise an error is thrown. Depending on that, the  relative axes orientation will be automatically selected by this function.  source"},{"id":520,"pagetitle":"Axes","title":"FrameTransformations.add_axes_pa421!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_pa421!","content":" FrameTransformations.add_axes_pa421!  —  Function add_axes_pa421!(frames, eph::AbstractEphemerisProvider, name::Symbol, \n    id::Int=AXESID_MOONPA_DE421) Add DE421 Moon's Principal Axes (PA) axes to  frames . The libration angles are extracted  from the  eph  ephemeris kernels, an error is thrown if such orientation data is not available.  Warning The parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown. Warning To properly read the ephemeris kernels, the ID associated to the input  axes  must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006). source"},{"id":521,"pagetitle":"Axes","title":"FrameTransformations.add_axes_pa440!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_pa440!","content":" FrameTransformations.add_axes_pa440!  —  Function add_axes_pa440!(frames, eph::AbstractEphemerisProvider, name::Symbol, \n    id::Int=AXESID_MOONPA_DE440) Add DE440 Moon's Principal Axes (PA) axes to  frames . The libration angles are extracted  from the  eph  ephemeris kernels, an error is thrown if such orientation data is not available.  Warning The parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown. Warning To properly read the ephemeris kernels, the ID associated to the input  axes  must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008). source"},{"id":522,"pagetitle":"Axes","title":"Topocentric","ref":"/FrameTransformations/stable/API/axes_api/#Topocentric","content":" Topocentric"},{"id":523,"pagetitle":"Axes","title":"FrameTransformations.add_axes_topocentric!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_topocentric!","content":" FrameTransformations.add_axes_topocentric!  —  Function add_axes_topocentric!(frames, name::Symbol, id::Int, parentid::Int, λ, ϕ, mount) Add topocentric axes to  frames  at a specified location and mounting. The orientation relative to the parent axes  parentid  is defined throuh the longitude  λ ,  the geodetic latitude  ϕ  and the mounting type  mount , which may be any of the following:  :NED  (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir. :SEZ  (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith. :ENU  (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith.  Warning The parent axes must be a set of body-fixed reference axes. This is under user  resposibility.  source"},{"id":524,"pagetitle":"Axes","title":"Others","ref":"/FrameTransformations/stable/API/axes_api/#Others","content":" Others"},{"id":525,"pagetitle":"Axes","title":"FrameTransformations.add_axes_twovectors!","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.add_axes_twovectors!","content":" FrameTransformations.add_axes_twovectors!  —  Function add_axes_twovectors!(frames, name::Symbol, id::Int, parentid::Int,\n    from1::Int, to1::Int, from2::Int, to2::Int, seq::Symbol; \n    inertial::Bool=false) Add a set of axes to  frames  based on two vectors defined by four points.  This function adds a new set of axes to  frames  using two vectors defined by four points.  The vectors are constructed from the points specified by  from1  to  to1  and  from2  to  to2 .  A right-handed coordinate system is generated based on the specified sequence direction ( seq ),  which determines the order in which the vectors are used to define the basis.  The  inertial  flag specifies whether the resulting axes are inertial. source"},{"id":526,"pagetitle":"Axes","title":"Utils","ref":"/FrameTransformations/stable/API/axes_api/#Utils","content":" Utils"},{"id":527,"pagetitle":"Axes","title":"IDs","ref":"/FrameTransformations/stable/API/axes_api/#frames_axesid","content":" IDs This is a list of NAIF IDs for standard axes that are used in astrodynamic applications."},{"id":528,"pagetitle":"Axes","title":"FrameTransformations.AXESID_ICRF","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_ICRF","content":" FrameTransformations.AXESID_ICRF  —  Constant AXESID_ICRF NAIF Axes ID for the International Celestial Reference Frame (ICRF) source"},{"id":529,"pagetitle":"Axes","title":"FrameTransformations.AXESID_MOONME_DE421","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_MOONME_DE421","content":" FrameTransformations.AXESID_MOONME_DE421  —  Constant AXESID_MOONME_DE421 NAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421). source"},{"id":530,"pagetitle":"Axes","title":"FrameTransformations.AXESID_MOONPA_DE421","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_MOONPA_DE421","content":" FrameTransformations.AXESID_MOONPA_DE421  —  Constant AXESID_MOONPA_DE421 NAIF axes id for the DE421 Moon Principal Axes (PA421). source"},{"id":531,"pagetitle":"Axes","title":"FrameTransformations.AXESID_MOONPA_DE440","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_MOONPA_DE440","content":" FrameTransformations.AXESID_MOONPA_DE440  —  Constant AXESID_MOONPA_DE440 NAIF Axes id for the DE440 Moon Principal Axes (PA440). source"},{"id":532,"pagetitle":"Axes","title":"FrameTransformations.AXESID_ECL2000","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_ECL2000","content":" FrameTransformations.AXESID_ECL2000  —  Constant AXESID_ECL2000 NAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECL2000). source"},{"id":533,"pagetitle":"Axes","title":"FrameTransformations.AXESID_EME2000","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_EME2000","content":" FrameTransformations.AXESID_EME2000  —  Constant AXESID_EME2000 Axes ID for the Mean Dynamical Equator and Equinox of J2000.0.  Note In SPICE the J2000 (EME2000) and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the EME2000 axes. 22 has been chosen because it is the first  unassigned axes ID among the built-in SPICE frames.  source"},{"id":534,"pagetitle":"Axes","title":"FrameTransformations.AXESID_GCRF","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.AXESID_GCRF","content":" FrameTransformations.AXESID_GCRF  —  Constant AXESID_GCRF Axes ID for the Geocentric Celestial Reference Frame (GCRFF) Note Although the ICRF and GCRF axes are identical, they are based upon a different  timescale. A different ID is here assigned to provide a robust way of distinguishing  between the two. 23 has been chosen because it is one of the unassigned axes ID among  the built-in SPICE frames. source"},{"id":535,"pagetitle":"Axes","title":"Rotation Matrices","ref":"/FrameTransformations/stable/API/axes_api/#frames_dcms","content":" Rotation Matrices"},{"id":536,"pagetitle":"Axes","title":"FrameTransformations.DCM_ICRF_TO_EME2000","ref":"/FrameTransformations/stable/API/axes_api/#FrameTransformations.DCM_ICRF_TO_EME2000","content":" FrameTransformations.DCM_ICRF_TO_EME2000  —  Constant DCM_ICRF_TO_EME2000 DCM for the rotation from the International Celestial Reference Frame ( ICRF ) and the  Mean Equator and Equinox of J2000.0 ( EME2000 ). This corresponds to the  J2000  frame in  the SPICE toolkit. Note The frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond. Moreover, according to  Hilton   there are multiple possibilities to define the proper rotation between the ICRS and  the EME2000. The transformation implemented here correspond to Eq. 6 using the parameters  in Table 3, line 1 (RIERS). References Hilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI:  10.1051/0004-6361:20031552 SOFA docs source"},{"id":539,"pagetitle":"Directions","title":"Directions","ref":"/FrameTransformations/stable/API/dir_api/#dir_api","content":" Directions"},{"id":540,"pagetitle":"Directions","title":"FrameTransformations.add_direction!","ref":"/FrameTransformations/stable/API/dir_api/#FrameTransformations.add_direction!","content":" FrameTransformations.add_direction!  —  Function add_direction!(frames, name::Symbol, axesid, funs) Add a new direction node to  frames . Inputs frames  – Target frame system  name  – Direction name, must be unique within  frames axesid  – ID of the axes the direction is expressed in funs  –  DirectionFunctions  object storing the functions to compute the direction and,            eventually, its time derivatives. It must match the type and order of  frames . source add_direction!(frames, name::Symbol, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Add a new direction node to  frames . The orientation of these direction depends only  on time and is computed through the custom functions provided by the user.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a direction vector. δfun : return a direction vector and its 1st order time derivative. δ²fun : return a direction vector and its 1st and 2nd order time derivatives. δ³fun : return a direction vector and its 1st, 2nd and 3rd order time derivatives. If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed via automatic differentiation. Warning It is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types.  source"},{"id":541,"pagetitle":"Directions","title":"FrameTransformations.add_direction_fixed!","ref":"/FrameTransformations/stable/API/dir_api/#FrameTransformations.add_direction_fixed!","content":" FrameTransformations.add_direction_fixed!  —  Function add_direction_fixed!(frames, name, axes, offset::AbstractVector) Add a fixed direction to  frames . source"},{"id":542,"pagetitle":"Directions","title":"FrameTransformations.add_direction_position!","ref":"/FrameTransformations/stable/API/dir_api/#FrameTransformations.add_direction_position!","content":" FrameTransformations.add_direction_position!  —  Function add_direction_position!(frames, name::Symbol, origin, target, axes) Add a direction based on the position vector from  origin  to  target  in the specified  axes . source"},{"id":543,"pagetitle":"Directions","title":"FrameTransformations.add_direction_velocity!","ref":"/FrameTransformations/stable/API/dir_api/#FrameTransformations.add_direction_velocity!","content":" FrameTransformations.add_direction_velocity!  —  Function add_direction_velocity!(frames, name::Symbol, origin, target, axes) Add a direction based on the velocity vector from  origin  to  target  in the specified  axes . source"},{"id":544,"pagetitle":"Directions","title":"FrameTransformations.add_direction_orthogonal!","ref":"/FrameTransformations/stable/API/dir_api/#FrameTransformations.add_direction_orthogonal!","content":" FrameTransformations.add_direction_orthogonal!  —  Function add_direction_orthogonal!(frames, name::Symbol, dir1, dir2) Add a direction as the cross product between two existing directions (i.e.  dir1  and  dir2 ). source"},{"id":545,"pagetitle":"Directions","title":"FrameTransformations.add_direction_normalize!","ref":"/FrameTransformations/stable/API/dir_api/#FrameTransformations.add_direction_normalize!","content":" FrameTransformations.add_direction_normalize!  —  Function add_direction_normalize!(frames, name::Symbol, dir) Add a direction as the normalized version of  dir . source"},{"id":548,"pagetitle":"Frames","title":"Frame System","ref":"/FrameTransformations/stable/API/frames_api/#frames_api","content":" Frame System"},{"id":549,"pagetitle":"Frames","title":"FrameTransformations.FrameSystem","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.FrameSystem","content":" FrameTransformations.FrameSystem  —  Type FrameSystem{O, N, S, D} A  FrameSystem  instance manages a collection of user-defined  FramePointNode ,   FrameAxesNode  and  Direction  objects, enabling computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order  O , the outputs  datatype  N  and an  AbstractTimeScale  instance  S ; the parameter  D  is the  length  of  the output ad shall always be  3O . The following transformation orders are accepted:  1 : position  2 : position and velocity  3 : position, velocity and acceleration 4 : position, velocity, acceleration and jerk FrameSystem{O, N, S}() Create a new, empty  FrameSystem  object of order  O , datatype  N  and timescale  S . The parameter  S  can be dropped, in case the default ( BarycentricDynamicalTime ) is used.  source"},{"id":550,"pagetitle":"Frames","title":"FrameTransformations.order","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.order","content":" FrameTransformations.order  —  Function order(R::Rotation{O}) where O Return the rotation order O. source order(frames::FrameSystem{O}) where O Return the frame system order  O . source"},{"id":551,"pagetitle":"Frames","title":"FrameTransformations.timescale","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.timescale","content":" FrameTransformations.timescale  —  Function timescale(frames::FrameSystem{O, N, S}) where {O, N, S} Return the frame system order timescale  S . source"},{"id":552,"pagetitle":"Frames","title":"Points","ref":"/FrameTransformations/stable/API/frames_api/#Points","content":" Points"},{"id":553,"pagetitle":"Frames","title":"FrameTransformations.has_point","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.has_point","content":" FrameTransformations.has_point  —  Function has_point(frames::FrameSystem, id) Check if  id  point is within  frames . source"},{"id":554,"pagetitle":"Frames","title":"FrameTransformations.points","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.points","content":" FrameTransformations.points  —  Function points(f::FrameSystem) Return the registered points names/ids map. source"},{"id":555,"pagetitle":"Frames","title":"FrameTransformations.points_graph","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.points_graph","content":" FrameTransformations.points_graph  —  Function points_graph(frames::FrameSystem) Return the frame system points graph. source"},{"id":556,"pagetitle":"Frames","title":"Axes","ref":"/FrameTransformations/stable/API/frames_api/#Axes","content":" Axes"},{"id":557,"pagetitle":"Frames","title":"FrameTransformations.has_axes","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.has_axes","content":" FrameTransformations.has_axes  —  Function has_axes(frames::FrameSystem, ax) Check if  ax  axes is within  frames . source"},{"id":558,"pagetitle":"Frames","title":"Base.axes","ref":"/FrameTransformations/stable/API/frames_api/#Base.axes","content":" Base.axes  —  Function axes(f::FrameSystem) Return the registered axes names/ids map. source"},{"id":559,"pagetitle":"Frames","title":"FrameTransformations.axes_graph","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.axes_graph","content":" FrameTransformations.axes_graph  —  Function axes_graph(frames::FrameSystem) Return the frame system axes graph. source"},{"id":560,"pagetitle":"Frames","title":"Directions","ref":"/FrameTransformations/stable/API/frames_api/#Directions","content":" Directions"},{"id":561,"pagetitle":"Frames","title":"FrameTransformations.has_direction","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.has_direction","content":" FrameTransformations.has_direction  —  Function has_axes(frames::FrameSystem, name::Symbol) Check if  name  direction is within  frames . source"},{"id":562,"pagetitle":"Frames","title":"FrameTransformations.directions","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.directions","content":" FrameTransformations.directions  —  Function directions(f::FrameSystem) Return the registered directions names. source"},{"id":563,"pagetitle":"Frames","title":"FrameTransformations.directions_map","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.directions_map","content":" FrameTransformations.directions_map  —  Function directions_map(f::FrameSystem) Return the direction dictionary. source"},{"id":564,"pagetitle":"Frames","title":"Rotations","ref":"/FrameTransformations/stable/API/frames_api/#rotation_api","content":" Rotations"},{"id":565,"pagetitle":"Frames","title":"FrameTransformations.Rotation","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.Rotation","content":" FrameTransformations.Rotation  —  Type Rotation{O, N} A container to efficiently compute  O -th order rotation matrices of type  N  between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the ( O -1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later. The rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object  R , constructed from the  DCM  A  and its time derivatives  δA  and  δ²A  rotates a vector  v  =  [p, v, a]  as:  ̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a] A  Rotation  object  R  call always be converted to a  SMatrix  or a  MMatrix  by invoking  the proper constructor.  Examples julia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0 Rotation(dcms::DCM...) Create a  Rotation  object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types. Examples julia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64} Rotation{O}(dcms::DCM...) where O Create a  Rotation  object of order  O . If the number of  dcms  is smaller than  O , the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than   O , only the first  O  DCMs are used.  Warning Usage of this constructor is not recommended as it may yield unexpected results to  unexperienced users.  Rotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N} Create a  Rotation  object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If  S1  <  S2 , only the first  S1  DCMs are considered, otherwise the  remaining orders are filled with null DCMs. Examples julia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R3 = Rotation{3}((A,B));\n\njulia> R3[1] == A\ntrue \n\njulia> R3[3] \nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Rotation{O}(u::UniformScaling{N}) where {O, N}\nRotation{O, N}(u::UniformScaling) where {O, N} Create an  O -order identity  Rotation  object of type  N  with identity position rotation  and null time derivatives. Examples julia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],)) Rotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\nRotation{S1, N}(R::Rotation{S2}) where {S1, S2, N} Transform a  Rotation  object of order  S2  to order  S1  and type  N . The behaviour of  these functions depends on the values of  S1  and  S2 :  S1  <  S2 : Only the first  S1  components of  rot  are considered. S1  >  S2 : The missing orders are filled with null DCMs. Examples julia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1);\n\njulia> R3[3]\nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Rotation(m::DCM{N}, ω::AbstractVector) where N Create a 2nd order  Rotation  object of type  N  to rotate between two set of axes  a  and   b  from a Direction Cosine Matrix (DCM) and the angular velocity vector  ω  of  b  with  respect to  a , expressed in  b source"},{"id":566,"pagetitle":"Frames","title":"Base.inv","ref":"/FrameTransformations/stable/API/frames_api/#Base.inv","content":" Base.inv  —  Function inv(rot::Rotation) Compute the invese of the rotation object  rot . The operation is efficiently performed by  taking the transpose of each rotation matrix within  rot . source"},{"id":567,"pagetitle":"Frames","title":"Transformations","ref":"/FrameTransformations/stable/API/frames_api/#transformations_api","content":" Transformations"},{"id":568,"pagetitle":"Frames","title":"Points","ref":"/FrameTransformations/stable/API/frames_api/#points_transform_api","content":" Points"},{"id":569,"pagetitle":"Frames","title":"FrameTransformations.vector3","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.vector3","content":" FrameTransformations.vector3  —  Function vector3(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 1. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector3(frame, from, to, axes, t::Number) Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000 .  source"},{"id":570,"pagetitle":"Frames","title":"FrameTransformations.vector6","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.vector6","content":" FrameTransformations.vector6  —  Function vector6(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 2. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector6(frame, from, to, axes, t::Number) Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000 .  source"},{"id":571,"pagetitle":"Frames","title":"FrameTransformations.vector9","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.vector9","content":" FrameTransformations.vector9  —  Function vector9(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 3. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector9(frame, from, to, axes, t::Number) Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000 .  source"},{"id":572,"pagetitle":"Frames","title":"FrameTransformations.vector12","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.vector12","content":" FrameTransformations.vector12  —  Function vector12(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 4. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector12(frame, from, to, axes, t::Number) Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000 .  source"},{"id":573,"pagetitle":"Frames","title":"Axes","ref":"/FrameTransformations/stable/API/frames_api/#axes_transform_api","content":" Axes"},{"id":574,"pagetitle":"Frames","title":"FrameTransformations.rotation3","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.rotation3","content":" FrameTransformations.rotation3  —  Function rotation3(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 1. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 1. source rotation3(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000 .  source"},{"id":575,"pagetitle":"Frames","title":"FrameTransformations.rotation6","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.rotation6","content":" FrameTransformations.rotation6  —  Function rotation6(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 2. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 2. source rotation6(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000 .  source"},{"id":576,"pagetitle":"Frames","title":"FrameTransformations.rotation9","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.rotation9","content":" FrameTransformations.rotation9  —  Function rotation9(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 3. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 3. source rotation9(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000 .  source"},{"id":577,"pagetitle":"Frames","title":"FrameTransformations.rotation12","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.rotation12","content":" FrameTransformations.rotation12  —  Function rotation12(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 4. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 4. source rotation12(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000 .  source"},{"id":578,"pagetitle":"Frames","title":"Directions","ref":"/FrameTransformations/stable/API/frames_api/#directions_transform_api","content":" Directions"},{"id":579,"pagetitle":"Frames","title":"FrameTransformations.direction3","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.direction3","content":" FrameTransformations.direction3  —  Function direction3(frames::FrameSystem, name::Symbol, axes, ep::Epoch) Compute the direction vector  name  of order 3 at epoch  ep  expressed in  the  axes  frame. Requires a frame system of order ≥ 1. source direction3(frames::FrameSystem, name::Symbol, axes, t::Number) Compute the direction vector  name  of order 3 at epoch  t , where  t  is  expressed in seconds since  J2000 . Requires a frame system of order ≥ 1. source"},{"id":580,"pagetitle":"Frames","title":"FrameTransformations.direction6","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.direction6","content":" FrameTransformations.direction6  —  Function direction6(frames::FrameSystem, name::Symbol, axes, ep::Epoch) Compute the direction vector  name  of order 6 at epoch  ep  expressed in  the  axes  frame. Requires a frame system of order ≥ 2. source direction6(frames::FrameSystem, name::Symbol, axes, t::Number) Compute the direction vector  name  of order 6 at epoch  t , where  t  is  expressed in seconds since  J2000 . Requires a frame system of order ≥ 2. source"},{"id":581,"pagetitle":"Frames","title":"FrameTransformations.direction9","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.direction9","content":" FrameTransformations.direction9  —  Function direction9(frames::FrameSystem, name::Symbol, axes, ep::Epoch) Compute the direction vector  name  of order 9 at epoch  ep  expressed in  the  axes  frame. Requires a frame system of order ≥ 3. source direction9(frames::FrameSystem, name::Symbol, axes, t::Number) Compute the direction vector  name  of order 9 at epoch  t , where  t  is  expressed in seconds since  J2000 . Requires a frame system of order ≥ 3. source"},{"id":582,"pagetitle":"Frames","title":"FrameTransformations.direction12","ref":"/FrameTransformations/stable/API/frames_api/#FrameTransformations.direction12","content":" FrameTransformations.direction12  —  Function direction12(frames::FrameSystem, name::Symbol, axes, ep::Epoch) Compute the direction vector  name  of order 12 at epoch  ep  expressed in  the  axes  frame. Requires a frame system of order ≥ 4. source direction12(frames::FrameSystem, name::Symbol, axes, t::Number) Compute the direction vector  name  of order 12 at epoch  t , where  t  is  expressed in seconds since  J2000 . Requires a frame system of order ≥ 4. source"},{"id":585,"pagetitle":"Points","title":"Points","ref":"/FrameTransformations/stable/API/point_api/#points_api","content":" Points"},{"id":586,"pagetitle":"Points","title":"FrameTransformations.add_point!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point!","content":" FrameTransformations.add_point!  —  Function add_point!(frames, name, id, axesid, class, funs, parentid=nothing) Create and add a new point node  name  to  frames  based on the input parameters.  Inputs frames  – Target frame system  name  – Point name, must be unique within  frames id  – Point ID, must be unique within  frames axesid  – ID of the axes in which the state vector of the point is expressed.  class  – Point class.  funs  –  FramePointFunctions  object storing the functions to update the state            vectors of the point. It must match the type and order of  frames parentid  – NAIF ID of the parent point. Not required only for the root point. Warning This is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see  add_point_dynamical! ,  add_point_fixedoffset!  and  add_point_root! . source"},{"id":587,"pagetitle":"Points","title":"FrameTransformations.add_point_root!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point_root!","content":" FrameTransformations.add_point_root!  —  Function add_point_root!(frames, name, id, axes) Add root  name  root point with the specified  id  to  frames . source"},{"id":588,"pagetitle":"Points","title":"FrameTransformations.add_point_dynamical!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point_dynamical!","content":" FrameTransformations.add_point_dynamical!  —  Function add_point_dynamical!(frames, name, id, parent, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Add  point  as a time point to  frames . The state vector for these points depends only on  time and is computed through the custom functions provided by the user.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a 3-elements vector: position δfun : return a 6-elements vector: position and velocity δ²fun : return a 9-elements vector: position, velocity and acceleration δ³fun : return a 12-elements vector: position, velocity, acceleration and jerk If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed with automatic differentiation.  Warning It is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions.  source"},{"id":589,"pagetitle":"Points","title":"FrameTransformations.add_point_fixedoffset!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point_fixedoffset!","content":" FrameTransformations.add_point_fixedoffset!  —  Function add_point_fixedoffset!(frames, name, id, parent, axes, offset::AbstractVector) Add  point  as a fixed-offset point to  frames . Fixed points are those whose positions have a  constant  offset  with respect their  parent  points in the given set of  axes . Thus, points  eligible for this class must have null velocity and acceleration with respect to  parent . source"},{"id":590,"pagetitle":"Points","title":"FrameTransformations.add_point_ephemeris!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point_ephemeris!","content":" FrameTransformations.add_point_ephemeris!  —  Function add_point_ephemeris!(frames::FrameSystem{O, N}, eph::AbstractEphemerisProvider, \n    name::Symbol, id::Int) where {O, N} Add a point coming from an  AbstractEphemerisProvider  subtype.  The point is identifies by the  id  and a have a user defined  name . Warning This is an interface only, concrete subtypes of  AbstractEphemerisProvider  requires  an proper implementation. source add_point_ephemeris!(frames, eph::AbstractEphemerisProvider, book::Dict{Int, Symbol}) Add all points found in the  eph  and using id-names relationships specified in  book . source"},{"id":591,"pagetitle":"Points","title":"FrameTransformations.add_point_surface!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point_surface!","content":" FrameTransformations.add_point_surface!  —  Function add_point_surface!(frames, name::Symbol, pointid::Int, parentid::Int, axesid::Int, \n    λ::Number, ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0) Add  point  to  frames  as a fixed point on the surface of the  parent  point body.  The relative  position is specified by the longitude  λ , the geodetic latitude  ϕ ,  the reference radius of the ellipsoid  R  and its flattening  f .  The altitude over the reference surface of the  ellipsoid  h  defaults to 0.  Warning Axes used here must be a set of body-fixed reference axes for the body represented by   parentid . This is under user resposibility.  source"},{"id":592,"pagetitle":"Points","title":"FrameTransformations.add_point_alias!","ref":"/FrameTransformations/stable/API/point_api/#FrameTransformations.add_point_alias!","content":" FrameTransformations.add_point_alias!  —  Function add_point_alias!(frames, target, alias::Symbol)\nadd_point_alias!(frames, target, alias::Symbol) Add a name  alias  to a  target  point registered in  frames . source"},{"id":595,"pagetitle":"Benchmarks","title":"Performance Benchmarks","ref":"/FrameTransformations/stable/benchmarks/#Performance-Benchmarks","content":" Performance Benchmarks A comparative analysis of the execution times of various routines of this package against  other state-of-the-art packages and libraries is here reported. "},{"id":596,"pagetitle":"Benchmarks","title":"IERS Rotation Models","ref":"/FrameTransformations/stable/benchmarks/#IERS-Rotation-Models","content":" IERS Rotation Models The Orient sub-module provides the capability to compute high-accuracy Earth rotation models based on the IERS 2010 conventions. However, differently from traditional packages, it leverages Julia's metaprogramming capabilities to generate optimised functions for the computation of the lengthy 2000A/B nutation series. A comparison against both  ERFA.jl  and  SatelliteToolbox.jl  is here reported. Details These time benchmarks have been obtained on an Intel Core i7-6700 @ 3.4 GHz with 16 GB of RAM"},{"id":597,"pagetitle":"Benchmarks","title":"Relative Orientation","ref":"/FrameTransformations/stable/benchmarks/#Relative-Orientation","content":" Relative Orientation Frames' performance have been tested against both  GODOT  and  SPICE.jl , two of the most-popular packages that can be used to define a system of reference axes and points and to compute the transformations between them. In particular, a comparative analysis of the execution times for computing the relative orientation between different reference axes has been carried out across four distinct scenarios:  Case 1 : From ICRF to the ECLIPJ2000 frame, a time-fixed rotation.  Case 2 : From the IAU-MOON to the ICRF, a time-dependent rotation.  Case 3 : From the IAU-MOON to the ICRF and subsequently to the IAU_EARTH.  Case 4 : From the IAU-MOON, to the ICRF, to the ECLIPJ2000 and finally a shift to the Sun-Earth rotating two-vector frame. Notice that the Sun and Earth positions are retrieved from binary ephemeris kernels. Details These time benchmarks have been obtained on an Intel Core i7-12700 @ 4.7 GHz with 32 GB of RAM This figure also underlines the capability of FrameTransformations (here referred to as  Multiverse ) to use different ephemeris readers as backends within the computational graph."},{"id":598,"pagetitle":"Benchmarks","title":"Relative States","ref":"/FrameTransformations/stable/benchmarks/#Relative-States","content":" Relative States Note Work in progress"},{"id":601,"pagetitle":"AstroRepresentations.jl","title":"AstroRepresentations.jl","ref":"/AstroRepresentations/stable/#AstroRepresentations.jl","content":" AstroRepresentations.jl Astrodynamical states representations and transformations."},{"id":604,"pagetitle":"Angles","title":"Angles Transformations","ref":"/AstroRepresentations/stable/angles/#Angles-Transformations","content":" Angles Transformations"},{"id":605,"pagetitle":"Angles","title":"AstroRepresentations.tra_to_eca","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tra_to_eca","content":" AstroRepresentations.tra_to_eca  —  Function tra_to_eca(tra::Number, ecc::Number) Convert true anomaly to eccentric anomaly. source"},{"id":606,"pagetitle":"Angles","title":"AstroRepresentations.tra_to_hya","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tra_to_hya","content":" AstroRepresentations.tra_to_hya  —  Function tra_to_hya(tra::Number, ecc::Number) Convert true anomaly to hyperbolic anomaly. source"},{"id":607,"pagetitle":"Angles","title":"AstroRepresentations.tra_to_man","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tra_to_man","content":" AstroRepresentations.tra_to_man  —  Function tra_to_man(tra::Number, ecc::Number) Convert true anomaly into mean anomaly source"},{"id":608,"pagetitle":"Angles","title":"AstroRepresentations.tra_to_par","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tra_to_par","content":" AstroRepresentations.tra_to_par  —  Function tra_to_par(ta::Number) Convert true anomaly to parabolic anomaly. source"},{"id":609,"pagetitle":"Angles","title":"AstroRepresentations.eca_to_tra","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.eca_to_tra","content":" AstroRepresentations.eca_to_tra  —  Function eca_to_tra(eca::Number, ecc::Number) Convert eccentric anomaly to true anomaly. source"},{"id":610,"pagetitle":"Angles","title":"AstroRepresentations.hya_to_tra","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.hya_to_tra","content":" AstroRepresentations.hya_to_tra  —  Function hya_to_tra(hca::Number, ecc::Number) Convert hyperbolic anomaly to true anomaly. source"},{"id":611,"pagetitle":"Angles","title":"AstroRepresentations.man_to_tra","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.man_to_tra","content":" AstroRepresentations.man_to_tra  —  Function man_to_tra(man::Number, ecc::Number) Convert mean anomaly to true anomaly. source"},{"id":612,"pagetitle":"Angles","title":"AstroRepresentations.par_to_tra","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.par_to_tra","content":" AstroRepresentations.par_to_tra  —  Function par_to_tra(pca::Number) Convert parabolic anomaly to true anomaly. source"},{"id":615,"pagetitle":"States","title":"State Transformations","ref":"/AstroRepresentations/stable/states/#State-Transformations","content":" State Transformations"},{"id":616,"pagetitle":"States","title":"Classical Orbital Elements (coe)","ref":"/AstroRepresentations/stable/states/#Classical-Orbital-Elements-(coe)","content":" Classical Orbital Elements (coe)"},{"id":617,"pagetitle":"States","title":"AstroRepresentations.convert6_cart_to_coe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_cart_to_coe","content":" AstroRepresentations.convert6_cart_to_coe  —  Function convert6_cart_to_coe(sv::AbstractVector{<:Number}, μ::Number) Convert cartesian state representation into classical orbital elements. Inputs sv  – state vector –  L, T μ  – center gravitational parameter  –  L³/T² Output Classical orbital elements representation of the state as a  SVector{6} .  References Vallado, David A. -  Fundamentals of astrodynamics and applications . Vol. 12.  Springer Science & Business Media, 2001. source"},{"id":618,"pagetitle":"States","title":"AstroRepresentations.convert6_coe_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_coe_to_cart","content":" AstroRepresentations.convert6_coe_to_cart  —  Function convert6_coe_to_cart(sv::AbstractVector{<:Number}, μ::Number) Convert classical orbital elements state vector to cartesian state. Inputs sv  – Keplerian elements –  L, rad μ  – Center's gravitational parameter  –  L³/T² Output Cartesian representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications . Vol. 12.  Springer Science & Business Media, 2001. source"},{"id":619,"pagetitle":"States","title":"Equinoctial Orbital Elements (equi)","ref":"/AstroRepresentations/stable/states/#Equinoctial-Orbital-Elements-(equi)","content":" Equinoctial Orbital Elements (equi)"},{"id":620,"pagetitle":"States","title":"AstroRepresentations.convert6_cart_to_equi","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_cart_to_equi","content":" AstroRepresentations.convert6_cart_to_equi  —  Function convert6_cart_to_equi(sv::AbstractVector{<:Number}, μ::Number) Convert cartesian state vector to Equinoctial keplerian elements. Inputs sv  – state vector –  L, T μ  – center gravitational parameter  –  L³/T² Output Equinoctial representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. Cefola - DOI: 10.2514/6.1972-937 source"},{"id":621,"pagetitle":"States","title":"AstroRepresentations.convert6_equi_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_equi_to_cart","content":" AstroRepresentations.convert6_equi_to_cart  —  Function convert6_equi_to_cart(equi::AbstractVector{<:Number}, μ::Number) Convert equinoctial state elements to cartesian state. Inputs equi  – Equinoctial elements –  L, rad μ  – center gravitational parameter  –  L³/T² Output Cartesian representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. Cefola - DOI: 10.2514/6.1972-937 source"},{"id":622,"pagetitle":"States","title":"AstroRepresentations.convert6_coe_to_equi","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_coe_to_equi","content":" AstroRepresentations.convert6_coe_to_equi  —  Function convert6_coe_to_equi(coe::AbstractVector{<:Number}) Convert classical orbital elements state vector to Equinoctial keplerian elements. Inputs coe  – Keplerian elements –  L, rad Output Equinoctial representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. source"},{"id":623,"pagetitle":"States","title":"AstroRepresentations.convert6_equi_to_coe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_equi_to_coe","content":" AstroRepresentations.convert6_equi_to_coe  —  Function convert6_equi_to_coe(coe::AbstractVector{<:Number}) Convert Equinoctial keplerian elements to classical orbital elements state vector . Inputs equi  – Equinoctial elements –  L, rad Output Keplerian representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. source"},{"id":624,"pagetitle":"States","title":"Spherical State Representation (sphe)","ref":"/AstroRepresentations/stable/states/#Spherical-State-Representation-(sphe)","content":" Spherical State Representation (sphe)"},{"id":625,"pagetitle":"States","title":"AstroRepresentations.convert6_cart_to_sphe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_cart_to_sphe","content":" AstroRepresentations.convert6_cart_to_sphe  —  Function convert6_cart_to_sphe(sv::AbstractVector{<:Number}) Convert cartesian state into spherical (ra-dec) representation. source"},{"id":626,"pagetitle":"States","title":"AstroRepresentations.convert6_sphe_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_sphe_to_cart","content":" AstroRepresentations.convert6_sphe_to_cart  —  Function convert6_sphe_to_cart(sv::AbstractVector{<:Number}) Convert spherical (ra-dec) state into cartesian representation. source"},{"id":627,"pagetitle":"States","title":"AstroRepresentations.convert3_cart_to_sphe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert3_cart_to_sphe","content":" AstroRepresentations.convert3_cart_to_sphe  —  Function convert3_cart_to_sphe(sv::AbstractVector{<:Number}) Convert cartesian position into spherical (ra-dec). source"},{"id":628,"pagetitle":"States","title":"AstroRepresentations.convert3_sphe_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert3_sphe_to_cart","content":" AstroRepresentations.convert3_sphe_to_cart  —  Function convert6_sphe_to_cart(sv::AbstractVector{<:Number}) Convert spherical (ra-dec) position into cartesian. source"},{"id":631,"pagetitle":"Home","title":"JSMDInterfaces.jl","ref":"/JSMDInterfaces/stable/#JSMDInterfaces.jl","content":" JSMDInterfaces.jl An interface-only package for the JSMD ecosystem JSMDInterfacesUtils.jl handles all the interface definitions for the  JSMD  ecosystem. It is a low-level and low dependency library made to be  depended on by the higher-level libraries to supply a common interface."},{"id":634,"pagetitle":"Bodies","title":"Bodies","ref":"/JSMDInterfaces/stable/interfaces/Bodies/#Bodies","content":" Bodies"},{"id":635,"pagetitle":"Bodies","title":"JSMDInterfaces.Bodies.body_declination","ref":"/JSMDInterfaces/stable/interfaces/Bodies/#JSMDInterfaces.Bodies.body_declination","content":" JSMDInterfaces.Bodies.body_declination  —  Function body_declination(T, ::Val{id}) Interface to compute the declination of the north pole of a  body identified by  id . source"},{"id":636,"pagetitle":"Bodies","title":"JSMDInterfaces.Bodies.body_pole","ref":"/JSMDInterfaces/stable/interfaces/Bodies/#JSMDInterfaces.Bodies.body_pole","content":" JSMDInterfaces.Bodies.body_pole  —  Function body_pole(T, ::Val{id}) Interface to compute the north pole direction of the  id  body. source"},{"id":637,"pagetitle":"Bodies","title":"JSMDInterfaces.Bodies.body_prime_meridian","ref":"/JSMDInterfaces/stable/interfaces/Bodies/#JSMDInterfaces.Bodies.body_prime_meridian","content":" JSMDInterfaces.Bodies.body_prime_meridian  —  Function body_prime_meridian(T, ::Val{id}) Interface to compute the prime meridian angle of a body identified by  id . source"},{"id":638,"pagetitle":"Bodies","title":"JSMDInterfaces.Bodies.body_right_ascension","ref":"/JSMDInterfaces/stable/interfaces/Bodies/#JSMDInterfaces.Bodies.body_right_ascension","content":" JSMDInterfaces.Bodies.body_right_ascension  —  Function body_right_ascension(T, ::Val{id}) Interface to compute the right ascension of the north pole of a  body identified by  id . source"},{"id":639,"pagetitle":"Bodies","title":"JSMDInterfaces.Bodies.body_rotational_elements","ref":"/JSMDInterfaces/stable/interfaces/Bodies/#JSMDInterfaces.Bodies.body_rotational_elements","content":" JSMDInterfaces.Bodies.body_rotational_elements  —  Function body_rotational_elements(T, ::Val{id}) Interface to compute the rotational elements of a body with ID  id . Rotational elements includes  α ,  δ  and  W  that identifies the north pole  of the body and its prime meridian. The north pole is that pole of rotation that lies on the north side of the  invariable plane of the solar system. Its direction is specified by the values  of its right ascension  α , declination  δ  . The location of the prime meridian is then given by  W , which is a rotation  in the body equator of date.  source"},{"id":642,"pagetitle":"Ephemeris","title":"Ephemeris","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#Ephemeris","content":" Ephemeris"},{"id":643,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.AbstractEphemerisProvider","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.AbstractEphemerisProvider","content":" JSMDInterfaces.Ephemeris.AbstractEphemerisProvider  —  Type AbstractEphemerisProvider Abstract type to represent ephemeris types. source"},{"id":644,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.EphemAxesRecord","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.EphemAxesRecord","content":" JSMDInterfaces.Ephemeris.EphemAxesRecord  —  Type EphemAxesRecord Store an orientation record metadata. Fields target  – NAIF ID of the target axes. jd_start  – Julian date of the first time. jd_end  – Julian date of the last time. axes  – NAIF ID of the reference axes. source"},{"id":645,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.EphemPointRecord","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.EphemPointRecord","content":" JSMDInterfaces.Ephemeris.EphemPointRecord  —  Type EphemPointRecord Store a position record metadata. Fields target  – NAIF ID of the target point. center  – NAIF ID of the center point. jd_start  – Julian date of the first time. jd_end  – Julian date of the last time. axes  – NAIF ID of the reference axes. source"},{"id":646,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.EphemerisError","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.EphemerisError","content":" JSMDInterfaces.Ephemeris.EphemerisError  —  Type JSMDInterfaces.Ephemeris.EphemerisError A type representing ephemeris load or computations errors. source"},{"id":647,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.ephem_compute!","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.ephem_compute!-Tuple{Any, JSMDInterfaces.Ephemeris.AbstractEphemerisProvider, Number, Number, Int64, Int64, Int64}","content":" JSMDInterfaces.Ephemeris.ephem_compute!  —  Method ephem_compute!(res, eph::AbstractEphemerisProvider, jd0::Number, time::Number, \n    target::Int, center::Int, order::Int) Abstract method to compute position and derivatives up to  order  of  target  with  respect to  center  at the Julian Date  jd0 + time . Inputs eph  – Ephemeris provider. jd0 ,  time  –  jd0 + time  must be equal to the Julian Day for the time coordinate    corresponding to the ephemeris.  target  – The body or reference point whose coordinates are required.  center  – The origin of the coordinate system.  order  – The order of derivatives from 0 (position) to 3 (position, velocity,    acceleration and jerk). source"},{"id":648,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.ephem_orient!","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.ephem_orient!-Tuple{Any, JSMDInterfaces.Ephemeris.AbstractEphemerisProvider, Number, Number, Int64, Int64, Int64}","content":" JSMDInterfaces.Ephemeris.ephem_orient!  —  Method ephem_orient!(res, eph::AbstractEphemerisProvider, jd0::Number, time::Number, \n    target::Int, center::Int, order::Int) Abstract method to compute Euler angles and derivatives up to  order  for the orientation of  the  target  axes at epoch  jd0 + time . Inputs eph  – Ephemeris provider. jd0 ,  time  –  jd0 + time  must be equal to the Julian Day for the time coordinate    corresponding to the ephemeris.  target  – The axes whose orientation is required. center  – The parent set of axes. order  – The order of derivatives from 0 (angles) to 3 (angles, angles rate, etc...). source"},{"id":649,"pagetitle":"Ephemeris","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.FilesIO.load-Tuple{Type{<:JSMDInterfaces.Ephemeris.AbstractEphemerisProvider}, Any}","content":" JSMDInterfaces.FilesIO.load  —  Method load(::Type{<:AbstractEphemerisProvider}, files) Load ephemeris files. source"},{"id":652,"pagetitle":"Errors","title":"Errors","ref":"/JSMDInterfaces/stable/interfaces/Errors/#Errors","content":" Errors"},{"id":653,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.AbstractGenericException","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.AbstractGenericException","content":" JSMDInterfaces.Errors.AbstractGenericException  —  Type AbstractGenericException A supertype for all ecosystem related errors. source"},{"id":654,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.GenericError","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.GenericError","content":" JSMDInterfaces.Errors.GenericError  —  Type JSMDInterfaces.Errors.GenericError A type representing generic errors. source"},{"id":655,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.NotImplementedError","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.NotImplementedError","content":" JSMDInterfaces.Errors.NotImplementedError  —  Type JSMDInterfaces.Errors.NotImplementedError A type representing not implemented errors. source"},{"id":656,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.@custom_error","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.@custom_error-Tuple{Any}","content":" JSMDInterfaces.Errors.@custom_error  —  Macro @custom_error Create a type representing a custom error type. source"},{"id":659,"pagetitle":"FilesIO","title":"FilesIO","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#FilesIO","content":" FilesIO"},{"id":660,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.filepath","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.filepath","content":" JSMDInterfaces.FilesIO.filepath  —  Function filepath(files::AbstractFile, idx::Int=1) Return the path of the  idx -th file within  files .  source"},{"id":661,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.filepaths","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.filepaths-Tuple{JSMDInterfaces.FilesIO.AbstractFile}","content":" JSMDInterfaces.FilesIO.filepaths  —  Method filepaths(files::AbstractFile) Return the path of all the files loaded within  file . source"},{"id":662,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.load-Tuple{JSMDInterfaces.FilesIO.AbstractArchiveNode}","content":" JSMDInterfaces.FilesIO.load  —  Method function load(::AbstractArchiveNode) Generic loader for JSMD archive nodes. source"},{"id":663,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.load-Tuple{JSMDInterfaces.FilesIO.AbstractFile}","content":" JSMDInterfaces.FilesIO.load  —  Method load(files::T) where T <: AbstractFile Generic loader of different file/s formats. source"},{"id":664,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.@filetype","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.@filetype-Tuple{Any, Any}","content":" JSMDInterfaces.FilesIO.@filetype  —  Macro filetype(ftype, suptype) Create a type representing a specific file and the associated   filepaths  and  filepath  implementations. source"},{"id":667,"pagetitle":"Frames","title":"Frames","ref":"/JSMDInterfaces/stable/interfaces/Frames/#Frames","content":" Frames"},{"id":668,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.AbstractJSMDFrameGraph","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.AbstractJSMDFrameGraph","content":" JSMDInterfaces.Frames.AbstractJSMDFrameGraph  —  Type AbstractJSMDFrameGraph Abstract type for frames graphs.  Subtype it to create a new frames graph compatible with the ecosystem. source"},{"id":669,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation12","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation12-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation12  —  Method rotation12(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix, its first, second and third  derivative between two axes within a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":670,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation3","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation3-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation3  —  Method rotation3(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix between two axes within  a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":671,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation6","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation6-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation6  —  Method rotation6(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix and its first derivative  between two axes within a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":672,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation9","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation9-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation9  —  Method rotation9(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix, its first, second  derivative between two axes within a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":673,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector12","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector12-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector12  —  Method vector12(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position, velocity, acceleration, and jerk vector  using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":674,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector3","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector3-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector3  —  Method vector3(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position vector using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":675,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector6","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector6-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector6  —  Method vector6(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position and velocity vector using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":676,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector9","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector9-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector9  —  Method vector9(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position, velocity, and acceleration vector  using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":679,"pagetitle":"Graph","title":"Graph","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graph","content":" Graph"},{"id":680,"pagetitle":"Graph","title":"JSMDInterfaces.Graph.AbstractJSMDGraph","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#JSMDInterfaces.Graph.AbstractJSMDGraph","content":" JSMDInterfaces.Graph.AbstractJSMDGraph  —  Type AbstractJSMDGraph{T} Abstract type for graphs.  Subtype it to create graphs compatible with the JSMD ecosystem. Graphs here could be compatible with both JSMD ecosystem and  Graphs.jl : For  JSMD  compatibility, see also:  get_path . For  Graphs.jl  compatibility, see also:  Graphs.jl interface source"},{"id":681,"pagetitle":"Graph","title":"JSMDInterfaces.Graph.AbstractJSMDGraphNode","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#JSMDInterfaces.Graph.AbstractJSMDGraphNode","content":" JSMDInterfaces.Graph.AbstractJSMDGraphNode  —  Type AbstractJSMDGraphNode Abstract type for graph nodes.  Subtype it to create a node graph compatible with the JSMD ecosystem. source"},{"id":682,"pagetitle":"Graph","title":"Graphs.SimpleGraphs.add_edge!","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graphs.SimpleGraphs.add_edge!-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, Int64, Int64, Int64}","content":" Graphs.SimpleGraphs.add_edge!  —  Method add_edge!(g::AbstractJSMDGraph, from::Int, to::Int, cost::Int) This function add an edge between  from  and  to  with weight  cost . source"},{"id":683,"pagetitle":"Graph","title":"Graphs.SimpleGraphs.add_vertex!","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{N}, Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, N}} where N<:JSMDInterfaces.Graph.AbstractJSMDGraphNode","content":" Graphs.SimpleGraphs.add_vertex!  —  Method add_node!(g::AbstractJSMDGraph, vertex::AbstractJSMDGraphNode) This function adds  vertex  to the graph  g . source"},{"id":684,"pagetitle":"Graph","title":"Graphs.has_path","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graphs.has_path-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, Int64, Int64}","content":" Graphs.has_path  —  Method has_path(g::AbstractJSMDGraph, from::Int, to::Int) Return true if there is a path between  from  and  to  in the graph  g . source"},{"id":685,"pagetitle":"Graph","title":"JSMDInterfaces.Graph.get_path","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#JSMDInterfaces.Graph.get_path-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, Int64, Int64}","content":" JSMDInterfaces.Graph.get_path  —  Method get_path(g::AbstractJSMDGraph, from::Int, to::Int) Get the nodes on hte path between and including  from' and to . Returns an empty array if  either from or to are not part of g` or if there is no path between them. source"},{"id":688,"pagetitle":"Interface","title":"Interface","ref":"/JSMDInterfaces/stable/interfaces/Interface/#Interface","content":" Interface"},{"id":689,"pagetitle":"Interface","title":"JSMDInterfaces.Interface.@interface","ref":"/JSMDInterfaces/stable/interfaces/Interface/#JSMDInterfaces.Interface.@interface-Tuple{Any}","content":" JSMDInterfaces.Interface.@interface  —  Macro @interface This macro can be used to create a in interface function within the  JSMD ecosystem.  Interface functions are intended as functions with some abstract  types as inputs throwing a  NotImplementedError  as default behaviour. source"},{"id":692,"pagetitle":"Math","title":"Math","ref":"/JSMDInterfaces/stable/interfaces/Math/#Math","content":" Math"},{"id":693,"pagetitle":"Math","title":"JSMDInterfaces.Math.AbstractInterpolationMethod","ref":"/JSMDInterfaces/stable/interfaces/Math/#JSMDInterfaces.Math.AbstractInterpolationMethod","content":" JSMDInterfaces.Math.AbstractInterpolationMethod  —  Type AbstractInterpolationMethod Abstract type representing any interpolation method. source"},{"id":694,"pagetitle":"Math","title":"JSMDInterfaces.Math.interpolate","ref":"/JSMDInterfaces/stable/interfaces/Math/#JSMDInterfaces.Math.interpolate-Tuple{JSMDInterfaces.Math.AbstractInterpolationMethod, Any}","content":" JSMDInterfaces.Math.interpolate  —  Method interpolate(::AbstractInterpolationMethod, x) Abstract interpolator call method. source"},{"id":697,"pagetitle":"Models","title":"Models","ref":"/JSMDInterfaces/stable/interfaces/Models/#Models","content":" Models"},{"id":698,"pagetitle":"Models","title":"JSMDInterfaces.Models.AbstractJSMDModel","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.AbstractJSMDModel","content":" JSMDInterfaces.Models.AbstractJSMDModel  —  Type AbstractJSMDModel Basic abstract type for every JSMD compatible model.  source"},{"id":699,"pagetitle":"Models","title":"JSMDInterfaces.Models.AbstractJSMDModelData","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.AbstractJSMDModelData","content":" JSMDInterfaces.Models.AbstractJSMDModelData  —  Type AbstractJSMDModelData Basic abstract type for every JSMD compatible model data.  JSMD  ModelData  types are the interface of the JSMD environment with the external world,  and are meant to provide a model agnostic interface to any customly formatted file. The main objective of this data type is to create a JSMD simulation compatible  Model   by means of the  parse_model  interface. source"},{"id":700,"pagetitle":"Models","title":"JSMDInterfaces.Models.dump_model","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.dump_model-Union{Tuple{N}, Tuple{JSMDInterfaces.Models.AbstractJSMDModel, N, Vararg{Any}}} where N<:JSMDInterfaces.FilesIO.AbstractArchiveNode","content":" JSMDInterfaces.Models.dump_model  —  Method dump_model(::AbstractJSMDModel, ::N, args...; \n    kargs...) where {N <: AbstractArchiveNode} This function serves as an interface to dump to an archive node a JSMD compatible model. source"},{"id":701,"pagetitle":"Models","title":"JSMDInterfaces.Models.load_model","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.load_model-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Type{<:JSMDInterfaces.Models.AbstractJSMDModel}, N, Vararg{Any}}} where {T, N<:JSMDInterfaces.FilesIO.AbstractArchiveNode}","content":" JSMDInterfaces.Models.load_model  —  Method load_model(::Type{T}, ::Type{ <: AbstractJSMDModel}, ::N, \n    args...; kargs...) where {T, N <: AbstractArchiveNode} This function serves as an interface to load from an archive node a JSMD compatible model. source"},{"id":702,"pagetitle":"Models","title":"JSMDInterfaces.Models.parse_data","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.parse_data-Union{Tuple{D}, Tuple{T}, Tuple{Type{T}, Type{D}, AbstractString}} where {T, D<:JSMDInterfaces.Models.AbstractJSMDModelData}","content":" JSMDInterfaces.Models.parse_data  —  Method parse_data(::Type{T}, ::Type{D}, ::AbstractString; \n    kargs...) where {T, D <: AbstractJSMDModelData} end This function serves as an interface to create a JSMD compatible  model data object from a file. source"},{"id":703,"pagetitle":"Models","title":"JSMDInterfaces.Models.parse_model","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.parse_model-Union{Tuple{M}, Tuple{D}, Tuple{T}, Tuple{Type{T}, Type{M}, Type{D}, Vararg{Any}}} where {T, D<:JSMDInterfaces.Models.AbstractJSMDModelData, M<:JSMDInterfaces.Models.AbstractJSMDModel}","content":" JSMDInterfaces.Models.parse_model  —  Method parse_model(::Type{T}, ::Type{M}, ::Type{D}, args...; \n    kargs...) where {T, D <: AbstractJSMDModelData, M <: AbstractJSMDModel} This function serves as an interface to create a JSMD compatible  model type from a  ModelData  type. source"},{"id":706,"pagetitle":"Home","title":"JSMDUtils.jl","ref":"/JSMDUtils/stable/#JSMDUtils.jl","content":" JSMDUtils.jl A utily package for the JSMD ecosystem JSMDUtils.jl is a low-level package holding different utility functions and type definitions that are reused by many packages within the  JSMD  ecosystem. "},{"id":709,"pagetitle":"API","title":"JSMDUtils API","ref":"/JSMDUtils/stable/api/#JSMDUtils-API","content":" JSMDUtils API"},{"id":710,"pagetitle":"API","title":"Math","ref":"/JSMDUtils/stable/api/#Math","content":" Math"},{"id":711,"pagetitle":"API","title":"JSMDUtils.Math.InterpAkima","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpAkima","content":" JSMDUtils.Math.InterpAkima  —  Type InterpAkima{T, N} <: AbstractInterpolationMethod Type storing an Akima spline nodes and coefficient.  T  is the interpolation data type  and  N  is the spline dimension (i.e., the number of interpolated functions). Fields n  – Number of node points. xn  – Interpolated node points.  yn  – Node points function values  c  – Akima polynomial coefficients.  source"},{"id":712,"pagetitle":"API","title":"JSMDUtils.Math.InterpAkima","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpAkima-Tuple{AbstractVector, AbstractArray}","content":" JSMDUtils.Math.InterpAkima  —  Method InterpAkima(x::AbstractVector, y::AbstractArray) Construct an Akima spline interpolant from a set of data points  x  and their values  y .  Multi-dimensional splines can be constructed passing  y  as a subtype of  AbstractMatrix  such  that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points. References Akima, H. (1970),  A New Method of Interpolation and Smooth Curve Fitting Based on Local   Procedures, Journal of the ACM,  DOI: source"},{"id":713,"pagetitle":"API","title":"JSMDUtils.Math.InterpCubicSplines","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpCubicSplines","content":" JSMDUtils.Math.InterpCubicSplines  —  Type InterpCubicSplines(x::AbstractVector, y::AbstractArray, type::Symbol=:Natural) Construct a cubic spline interpolant from a set of data points  x  and their values  y .  Multi-dimensional splines can be constructed by passing  y  as a subtype of  AbstractMatrix ,  such that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points. Different boundary conditions can be applied based on the specified  type :  :Natural : the second derivative of the first and the last polynomial are equal to    zero at the boundary points.  :NotAKnot : the third derivatives of the first and last two polynomials are    equal in the points where they meet each other. :Periodic : the first and second derivatives at the initial and final points are equal. :Quadratic : the first and the last polynomial are quadratic.  source"},{"id":714,"pagetitle":"API","title":"JSMDUtils.Math.InterpCubicSplines","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpCubicSplines","content":" JSMDUtils.Math.InterpCubicSplines  —  Type InterpCubicSplines{T, N} <: AbstractInterpolationMethod Type storing a cubic spline nodes and coefficients.  T  is the spline data type and   N  is the spline dimension (i.e., the number of interpolated functions).  Fields n  – Number of node points. m  – Size of the interpolated element.  xn  – Interpolated node points. yn  – Node points function values.  c  –  Spline polynomials coefficients.  type  – Boundary conditions type. source"},{"id":715,"pagetitle":"API","title":"JSMDInterfaces.Math.interpolate","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number, Bool}} where T","content":" JSMDInterfaces.Math.interpolate  —  Method interpolate(ak::InterpAkima, x::Number, flat::Bool=true) Interpolate the Akima spline  ak  at point  x . If the spline has a single  dimension (e.g.,  InterpAkima{T, 1} ), a scalar value is returned. Otherwise, an  SVector  is computed.  If  x  is outside the boundary range of  sp  a flat extrapolation is used by default.  If the  flat  argument is  false , the first and last polynomials will be used to  compute all the outside values. source"},{"id":716,"pagetitle":"API","title":"JSMDInterfaces.Math.interpolate","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number, Bool}} where T","content":" JSMDInterfaces.Math.interpolate  —  Method interpolate(sp::InterpCubicSplines, x::Number, flat::Bool=true) Interpolate the cubic spline  sp  at point  x . If the spline has a single  dimension (e.g.,  InterpCubicSpline{T, 1} ), a scalar value is returned. Otherwise, an  SVector  is computed.  If  x  is outside the boundary range of  sp  a flat extrapolation is used by default.  If the  flat  argument is  false , the first and last polynomials will be used to  compute all the outside values. source"},{"id":717,"pagetitle":"API","title":"JSMDUtils.Math.D²","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.D²-Tuple{Any, Any}","content":" JSMDUtils.Math.D²  —  Method D²(f, x::Real) Return  d²f/dx²  evaluated at  x  using ForwardDiff, assuming  f  is called as  f(x) . This method assumes that  isa(f(x), Union{Real, AbstractArray}) . source"},{"id":718,"pagetitle":"API","title":"JSMDUtils.Math.D³","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.D³-Tuple{Any, Any}","content":" JSMDUtils.Math.D³  —  Method D³(f, x::Real) Return  d³f/dx³  evaluated at  x  using ForwardDiff, assuming  f  is called as  f(x) . This method assumes that  isa(f(x), Union{Real, AbstractArray}) . source"},{"id":719,"pagetitle":"API","title":"JSMDUtils.Math.D¹","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.D¹-Tuple{Any, Any}","content":" JSMDUtils.Math.D¹  —  Method D¹(f, x::Real) Return  df/dx  evaluated at  x  using ForwardDiff, assuming  f  is called as  f(x) . This method assumes that  isa(f(x), Union{Real, AbstractArray}) . source"},{"id":720,"pagetitle":"API","title":"JSMDUtils.Math._3angles_to_δdcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math._3angles_to_δdcm-Tuple{Any, Symbol}","content":" JSMDUtils.Math._3angles_to_δdcm  —  Method _3angles_to_δdcm(θ, rot_seq::Symbol) Compute the time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":721,"pagetitle":"API","title":"JSMDUtils.Math._3angles_to_δ²dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math._3angles_to_δ²dcm-Tuple{Any, Symbol}","content":" JSMDUtils.Math._3angles_to_δ²dcm  —  Method _3angles_to_δ²dcm(θ, rot_seq::Symbol) Compute the 2nd time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":722,"pagetitle":"API","title":"JSMDUtils.Math._3angles_to_δ³dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math._3angles_to_δ³dcm-Tuple{Any, Symbol}","content":" JSMDUtils.Math._3angles_to_δ³dcm  —  Method _3angles_to_δ³dcm(θ, rot_seq::Symbol) Compute the 3rd order time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":723,"pagetitle":"API","title":"JSMDUtils.Math.angle_to_δdcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angle_to_δdcm","content":" JSMDUtils.Math.angle_to_δdcm  —  Function angle_to_δdcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX) Compute the derivative of the direction cosine matrix that perform a set of rotations ( θ ,   ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation input must be an indexable  objected which includes the angle and its first time derivative. The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δ²dcm source"},{"id":724,"pagetitle":"API","title":"JSMDUtils.Math.angle_to_δ²dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angle_to_δ²dcm","content":" JSMDUtils.Math.angle_to_δ²dcm  —  Function angle_to_δ²dcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX) Compute the second order time derivative of the direction cosine matrix that perform  a set of rotations ( θ ,  ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation  input must be an indexable objected which includes the angle and its first and second order  time derivatives. The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δdcm source"},{"id":725,"pagetitle":"API","title":"JSMDUtils.Math.angle_to_δ³dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angle_to_δ³dcm","content":" JSMDUtils.Math.angle_to_δ³dcm  —  Function angle_to_δ³dcm(θ::Number[, ϕ::Number[, γ::Number]], rot_seq::Symbol = :Z) Compute the second order time derivative of the direction cosine matrix that perform  a set of rotations ( θ ,  ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation  input must be an indexable objected which includes the angle and its time derivatives up to  order 3 (jerk). The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δdcm source"},{"id":726,"pagetitle":"API","title":"JSMDUtils.Math.angleplane","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angleplane-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.angleplane  —  Method angleplane(v1::AbstractArray, n::AbstractArray) Compute the angle between a vector  v1  and (its projection on) a plane with normal  n , in rad.  source"},{"id":727,"pagetitle":"API","title":"JSMDUtils.Math.angleplaned","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angleplaned-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.angleplaned  —  Method angleplaned(v1::AbstractArray, n::AbstractArray) Compute the angle between a vector  v1  and (its projection on) a plane with normal  n , in deg.  source"},{"id":728,"pagetitle":"API","title":"JSMDUtils.Math.anglevec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.anglevec-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.anglevec  —  Method anglevec(v1::AbstractArray, v2::AbstractArray) Compute the angle between two vectors  v1  and  v2 , in rad. source"},{"id":729,"pagetitle":"API","title":"JSMDUtils.Math.anglevecd","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.anglevecd-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.anglevecd  —  Method anglevecd(v1::AbstractArray, v2::AbstractArray) Compute the angle between two vectors  v1  and  v2 , in deg. source"},{"id":730,"pagetitle":"API","title":"JSMDUtils.Math.cross12","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross12-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross12  —  Method cross12(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its 1st, 2nd and 3rd order time derivatives.  Note x  and  y  must be 12-elements state vectors (position, velocity and acceleration) source"},{"id":731,"pagetitle":"API","title":"JSMDUtils.Math.cross3","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross3-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross3  —  Method cross3(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y , considering only their first 3 elements. source"},{"id":732,"pagetitle":"API","title":"JSMDUtils.Math.cross6","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross6-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross6  —  Method cross6(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its time derivative.  Note x  and  y  must be 6-elements state vectors, with the last elements of each vector  representing the time derivatives of the first three. source"},{"id":733,"pagetitle":"API","title":"JSMDUtils.Math.cross9","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross9-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross9  —  Method cross9(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its 1st and 2nd-order time derivatives.  Note x  and  y  must be 9-elements state vectors (position, velocity and acceleration) source"},{"id":734,"pagetitle":"API","title":"JSMDUtils.Math.projplane","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.projplane-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.projplane  —  Method projplane(v1::AbstractArray, n::AbstractArray) Compute the orthogonal projection of a vector  v1  on a plane with normal  n . source"},{"id":735,"pagetitle":"API","title":"JSMDUtils.Math.projvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.projvec-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.projvec  —  Method projvec(v1::AbstractArray, v2::AbstractArray) Compute the orthogonal projection of a vector  v1  on a vector  v2 . source"},{"id":736,"pagetitle":"API","title":"JSMDUtils.Math.skew","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.skew-Tuple{AbstractArray}","content":" JSMDUtils.Math.skew  —  Method skew(a) Create a skew matrix from the vector  v . source"},{"id":737,"pagetitle":"API","title":"JSMDUtils.Math.unitcross","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.unitcross-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.unitcross  —  Method unitcross(v1::AbstractArray, v2::AbstractArray) Compute the normalized cross product of  v1  and  v2 . source"},{"id":738,"pagetitle":"API","title":"JSMDUtils.Math.unitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.unitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.unitvec  —  Method unitvec(v::AbstractVector) Normalise the vector  v . source"},{"id":739,"pagetitle":"API","title":"JSMDUtils.Math.δunitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.δunitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.δunitvec  —  Method δunitvec(v::AbstractVector) Compute the time derivative of a unit vector  v . source"},{"id":740,"pagetitle":"API","title":"JSMDUtils.Math.δ²unitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.δ²unitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.δ²unitvec  —  Method δ²unitvec(v::AbstractVector) Compute the 2nd-order time derivative of a unit vector  v . source"},{"id":741,"pagetitle":"API","title":"JSMDUtils.Math.δ³unitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.δ³unitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.δ³unitvec  —  Method δ³unitvec(v::AbstractVector) Compute the 3rd-order time derivative of a unit vector  v . source"},{"id":742,"pagetitle":"API","title":"Autodiff","ref":"/JSMDUtils/stable/api/#Autodiff","content":" Autodiff"},{"id":743,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoHessianConfig","content":" JSMDUtils.Autodiff.AutoHessianConfig  —  Type AutoHessianConfig Wrapper object around a  ForwardDiff.HessianConfig  type.  source"},{"id":744,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoHessianConfig-Tuple{Any}","content":" JSMDUtils.Autodiff.AutoHessianConfig  —  Method AutoHessianConfig(x) Generate a  Autodiff.AutoHessianConfig  instance based on the type and shape of the  input vector  x .  The returned  AutoHessianConfig  instance contains all the work buffers required by   Autodiff.hessian!  when the target function takes the form  f(x) . The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers.  Warning The dual numbers that are generated from this instance all share the   Autodiff.JSMDDiffTag  tag, which could lead to perturbation confusion if the  hessian operation is not used with care. See Also See also  Autodiff.hessian! . source"},{"id":745,"pagetitle":"API","title":"JSMDUtils.Autodiff.JSMDDiffTag","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.JSMDDiffTag","content":" JSMDUtils.Autodiff.JSMDDiffTag  —  Type JSMDDiffTag Singleton to be used as a ForwardDiff tag for the JSMD ecosystem. source"},{"id":746,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoGradientConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoGradientConfig-Tuple{Any}","content":" JSMDUtils.Autodiff.AutoGradientConfig  —  Method AutoGradientConfig(x) Generate a  ForwardDiff.GradientConfig  instance based on the type and shape of the  input  x .  The returned  GradientConfig  instance contains all the work buffers required by   Autodiff.gradient! . The chunk size is automatically set to 1 since it is part of  the type. Having a larger chunk-size improves performance but would require a greater  number of dispatches for the function wrappers.  Warning The dual numbers that are generated from this instance all share the   Autodiff.JSMDDiffTag  tag, which could lead to perturbation confusion if the  gradient operation is not used with care. See also See also  Autodiff.gradient! source"},{"id":747,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoJacobianConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoJacobianConfig-Tuple{Any}","content":" JSMDUtils.Autodiff.AutoJacobianConfig  —  Method AutoJacobianConfig(x) Generate a  ForwardDiff.JacobianConfig  instance based on the type and shape of the  input vector  x .  The returned  JacobianConfig  instance contains all the work buffers required by   Autodiff.jacobian!  when the target function takes the form  f(x) . The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers.  AutoJacobianConfig(y, x) Generate a  ForwardDiff.JacobianConfig  instance based on the type and shape of the  input vector  x  and the output vector  y .  The returned  JacobianConfig  instance contains all the work buffers required by   Autodiff.jacobian!  when the target function takes the in-place form  f!(y, x). Warning The dual numbers that are generated from this instance all share the   Autodiff.JSMDDiffTag  tag, which could lead to perturbation confusion if the  gradient operation is not used with care. See Also See also  Autodiff.jacobian! . source"},{"id":748,"pagetitle":"API","title":"JSMDUtils.Autodiff.derivative","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.derivative-Tuple{Any, Number}","content":" JSMDUtils.Autodiff.derivative  —  Method derivative(f, x::Number) Return  df/dx  evaluated at  x , assuming  f  is called as  f(x) .  Note This function assumes that  isa(f(x), Union{Real, AbstractArray}) . Warning The dual numbers generated by this function are tagged with the   Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain  scenarios. Hence, this derivative operation should be used with care. See also See also  Autodiff.gradient!  and  Autodiff.hessian! source"},{"id":749,"pagetitle":"API","title":"JSMDUtils.Autodiff.gentag","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.gentag-Tuple{Any}","content":" JSMDUtils.Autodiff.gentag  —  Method gentag(x) Generate a dual tag for the element type of  x . source"},{"id":750,"pagetitle":"API","title":"JSMDUtils.Autodiff.gradient!","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.gradient!-Tuple{Any, Any, Any}","content":" JSMDUtils.Autodiff.gradient!  —  Method gradient!(res, f, x)\ngradient!(res, f, x, cfg::GradientConfig) Compute  ∇f  evaluated at  x  and store the output in  res , assuming  f  is called as   f(x) . To avoid runtime allocations, a  GradientConfig  instance must be provided.  Note This function assumes that  isa(f(x), Real) . Warning If the gradient config has been setup with  Autodiff.AutoGradientConfig ,  the dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag   which could lead to perturbation confusion in certain scenarios. Hence, this gradient  operation should be used with care. See Also See also  Autodiff.AutoGradientConfig source"},{"id":751,"pagetitle":"API","title":"JSMDUtils.Autodiff.hessian!","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.hessian!-Tuple{Any, Any, Any}","content":" JSMDUtils.Autodiff.hessian!  —  Method hessian!(res, f, x)\nhessian!(res, f, x, ahc::AutoHessianConfig) Compute  H(f)  (i.e.,  J(∇(f)) ) evaluated at  x  and store the output in  res , assuming   f  is called as  f(x) . To avoid runtime allocations, an  Autodiff.AutoHessianConfig   instance must be provided.  Note This function assumes that  isa(f(x), Real) . Warning The dual numbers generated by this function are tagged with the   Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain  scenarios. Hence, this hessian operation should be used with care. See Also See also  Autodiff.AutoHessianConfig .  source"},{"id":752,"pagetitle":"API","title":"JSMDUtils.Autodiff.jacobian!","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.jacobian!-Tuple{Any, Any, Any}","content":" JSMDUtils.Autodiff.jacobian!  —  Method jacobian!(res, f, x)\njacobian!(res, f, x, cfg::JacobianConfig) Compute  J(f)  evaluated at the input vector  x  and store the result in  res , assuming   f  is called as  f(x) . To avoid runtime allocations, a  JacobianConfig  instance must be  provided.  Note This function assumes that  isa(f(x), Union{AbstractArray}) . jacobian!(res, f!, y, x) jacobian!(res, f!, y, x, cfg::JacobianConfig) Compute  J(f)  evaluated at the input vector  x  and store the result in  res , assuming   f  is called as  f!(y, x) , where the result is stored in  y . To avoid runtime allocations, a  JacobianConfig  instance must be  provided.  Warning If the jacobian config has been setup with  Autodiff.AutoJacobianConfig ,  the dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag   which could lead to perturbation confusion in certain scenarios. Hence, this jacobian  operation should be used with care. See Also See also  Autodiff.AutoJacobianConfig source"},{"id":753,"pagetitle":"API","title":"FileUtils","ref":"/JSMDUtils/stable/api/#FileUtils","content":" FileUtils"},{"id":754,"pagetitle":"API","title":"JSMDUtils.FileUtils.JSON","ref":"/JSMDUtils/stable/api/#JSMDUtils.FileUtils.JSON","content":" JSMDUtils.FileUtils.JSON  —  Type JSMDUtils.FileUtils.JSON <: JSMDInterfaces.FilesIO.AbstractFile A type representing JSMDUtils.FileUtils.JSON files. source"},{"id":755,"pagetitle":"API","title":"JSMDUtils.FileUtils.TXT","ref":"/JSMDUtils/stable/api/#JSMDUtils.FileUtils.TXT","content":" JSMDUtils.FileUtils.TXT  —  Type JSMDUtils.FileUtils.TXT <: JSMDInterfaces.FilesIO.AbstractFile A type representing JSMDUtils.FileUtils.TXT files. source"},{"id":756,"pagetitle":"API","title":"JSMDUtils.FileUtils.YAML","ref":"/JSMDUtils/stable/api/#JSMDUtils.FileUtils.YAML","content":" JSMDUtils.FileUtils.YAML  —  Type JSMDUtils.FileUtils.YAML <: JSMDInterfaces.FilesIO.AbstractFile A type representing JSMDUtils.FileUtils.YAML files. source"},{"id":757,"pagetitle":"API","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.JSON{1}}","content":" JSMDInterfaces.FilesIO.load  —  Method load(file::JSON{1}) Open a JSON file and parse its data in a dictionary. source"},{"id":758,"pagetitle":"API","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.TXT{1}}","content":" JSMDInterfaces.FilesIO.load  —  Method load(file::TXT{1}) Open a TEXT file and parse its data in a list of strings. source"},{"id":759,"pagetitle":"API","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.YAML{1}}","content":" JSMDInterfaces.FilesIO.load  —  Method load(file::YAML{1}) Open a YAML file and parse its data in a dictionary. source"},{"id":760,"pagetitle":"API","title":"Miscellaneous","ref":"/JSMDUtils/stable/api/#Miscellaneous","content":" Miscellaneous"},{"id":761,"pagetitle":"API","title":"JSMDUtils.NullEphemerisProvider","ref":"/JSMDUtils/stable/api/#JSMDUtils.NullEphemerisProvider","content":" JSMDUtils.NullEphemerisProvider  —  Type EmptyEphemerisProvider <: AbstractEphemerisProvider Empty provider to initialise the frame system without loading  ephemeris files.  source"},{"id":762,"pagetitle":"API","title":"JSMDUtils.format_camelcase","ref":"/JSMDUtils/stable/api/#JSMDUtils.format_camelcase-Tuple{S} where S<:AbstractString","content":" JSMDUtils.format_camelcase  —  Method format_camelcase(str::AbstractString) Format  str  in CamelCase, such that the first letter of each word  in the sentence is capitalized and spaces are removed. source"},{"id":763,"pagetitle":"API","title":"JSMDUtils.format_snakecase","ref":"/JSMDUtils/stable/api/#JSMDUtils.format_snakecase-Tuple{S} where S<:AbstractString","content":" JSMDUtils.format_snakecase  —  Method format_snakecase(str::AbstractString) Format  str  in SnakeCase, such that all the letters are in lower case and  spaces are replaced with underscores. source"},{"id":766,"pagetitle":"Home","title":"SMDGraphs","ref":"/SMDGraphs/stable/#SMDGraphs","content":" SMDGraphs A simple, light, and flexible API for graph-like data structure handling. The purpose of SMDGraphs.jl is to enable efficient support for graph operations and analysis  on custom user-defined datatypes. It achieves so by offering a set of light-weight wrappers  around  Graphs.jl . "},{"id":767,"pagetitle":"Home","title":"Installation","ref":"/SMDGraphs/stable/#Installation","content":" Installation This package can be installed using Julia's package manager:  julia> import Pkg; \njulia> Pkg.add(\"SMDGraphs.jl\")"},{"id":768,"pagetitle":"Home","title":"Overview","ref":"/SMDGraphs/stable/#Overview","content":" Overview This package currently supports the following graph-like structures: Mapped-Node Graphs"},{"id":769,"pagetitle":"Home","title":"Supporting","ref":"/SMDGraphs/stable/#Supporting","content":" Supporting This package was developed as part of the  JSMD  ecosystem.  If you found this package useful in your applications, please consider starring the repository."},{"id":772,"pagetitle":"API","title":"API","ref":"/SMDGraphs/stable/api/#API","content":" API"},{"id":773,"pagetitle":"API","title":"SMDGraphs.MappedNodeGraph","ref":"/SMDGraphs/stable/api/#SMDGraphs.MappedNodeGraph","content":" SMDGraphs.MappedNodeGraph  —  Type MappedNodeGraph{N, G} <: AbstractJSMDGraph{Int} Create a graph with mapped nodes.  Fields graph  – Graph mid  – Mapped id to nodes dictionary nodes  – Mapped nodes  edges  – List of the edges between the nodes  paths  – List of the available paths in the graph Constructors MappedNodeGraph{N}(g::G) where {G <: AbstractGraph, N <: AbstractGraphNode} source"},{"id":774,"pagetitle":"API","title":"SMDGraphs.MappedDiGraph","ref":"/SMDGraphs/stable/api/#SMDGraphs.MappedDiGraph-Union{Tuple{Type{N}}, Tuple{N}} where N","content":" SMDGraphs.MappedDiGraph  —  Method MappedDiGraph(::Type{N}) where {N} Construct a directed  MappedNodeGraph  from node type  N . source"},{"id":775,"pagetitle":"API","title":"SMDGraphs.MappedGraph","ref":"/SMDGraphs/stable/api/#SMDGraphs.MappedGraph-Union{Tuple{Type{N}}, Tuple{N}} where N","content":" SMDGraphs.MappedGraph  —  Method MappedGraph(::Type{N}) where {N} Construct a  MappedNodeGraph  from node type  N . source"},{"id":776,"pagetitle":"API","title":"SMDGraphs.add_edge_cost!","ref":"/SMDGraphs/stable/api/#SMDGraphs.add_edge_cost!-Union{Tuple{N}, Tuple{T}, Tuple{SMDGraphs.MappedNodeGraph{T, N}, Int64, Int64, Int64}} where {T, N<:Graphs.SimpleGraphs.SimpleGraph}","content":" SMDGraphs.add_edge_cost!  —  Method add_edge_cost!(g::MappedNodeGraph{T, <:SimpleGraph}, fid::Int, tid::Int, cost::Int) For a  SimpleGraph  type, register the edge cost between the nodes with mapped IDs   fid  and  tid  in both directions.   source"},{"id":777,"pagetitle":"API","title":"SMDGraphs.add_edge_cost!","ref":"/SMDGraphs/stable/api/#SMDGraphs.add_edge_cost!-Union{Tuple{T}, Tuple{SMDGraphs.MappedNodeGraph{T}, Int64, Int64, Int64}} where T","content":" SMDGraphs.add_edge_cost!  —  Method add_edge_cost!(g::MappedNodeGraph, fid::Int, tid::Int, cost::Int) Register the cost between of the edge from the node with mapped ID  fid  to the  node with mapped ID  tid .  source"},{"id":778,"pagetitle":"API","title":"SMDGraphs.compute_paths!","ref":"/SMDGraphs/stable/api/#SMDGraphs.compute_paths!-Union{Tuple{SMDGraphs.MappedNodeGraph{T}}, Tuple{T}} where T","content":" SMDGraphs.compute_paths!  —  Method compute_paths(g::MappedNodeGraph) Compute all possible paths in the graph. source"},{"id":779,"pagetitle":"API","title":"SMDGraphs.get_edgecosts","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_edgecosts-Union{Tuple{T}, Tuple{SMDGraphs.MappedNodeGraph{T}, Int64, Int64}} where T","content":" SMDGraphs.get_edgecosts  —  Method get_edgecosts(g::MappedNodeGraph, from::Int, to::Int) Get all costs assigned to the edges between  from  and  to . Returns an empty array if  either  from  or  to  are not a part of  g  or if there is no path between them. source"},{"id":780,"pagetitle":"API","title":"SMDGraphs.get_mappedid","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_mappedid-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_mappedid  —  Method get_mappedid(g::MappedNodeGraph, node::Int) Get the mappedid associated with a node. The mappedid is the internal ID that is assigned  to the node within the graph. source"},{"id":781,"pagetitle":"API","title":"SMDGraphs.get_mappednode","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_mappednode-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_mappednode  —  Method get_mappednode(g::MappedNodeGraph, mid::Int) Get the node associated to the given mapped id. source"},{"id":782,"pagetitle":"API","title":"SMDGraphs.get_node","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_node-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_node  —  Method get_node(g::MappedNodeGraph, node::Int) Get the node associated with a node index. source"},{"id":783,"pagetitle":"API","title":"SMDGraphs.get_node_id","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_node_id-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraphNode}","content":" SMDGraphs.get_node_id  —  Method get_node_id(b::AbstractJSMDGraphNode) Get the mapped-id of an  AbstractJSMDGraphNode . Warning This method is abstract! A concrete implementation for each concrete node shall be defined. source"},{"id":784,"pagetitle":"API","title":"SMDGraphs.get_outerid","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_outerid-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_outerid  —  Method get_outerid(g::MappedNodeGraph, id::Int) Return the id of the node associated to the mapped id  id . The outer ID is the ID that is  assigned to the node by the user. source"},{"id":787,"pagetitle":"Mapped Graphs","title":"Mapped-Node Graphs","ref":"/SMDGraphs/stable/mappedgraph/#Mapped-Node-Graphs","content":" Mapped-Node Graphs Mapped-Node graphs enable graph operations on any custom user-defined  concrete type, effectively replacing the integer nodes of the  Graphs.jl  graph, with the desired type. To enforce type-stability and avoid allocations,  the linking between the inner graph nodes and the custom nodes is achieved via  an integer mapping. Therefore, the only requirement is that an integer ID can  be associated to the custom type. The user will then be able to retrieve the  items in the nodes through this ID."},{"id":788,"pagetitle":"Mapped Graphs","title":"Usage","ref":"/SMDGraphs/stable/mappedgraph/#Usage","content":" Usage Suppose that you want to create a graph to connect items that store planetary bodies  properties. First, we will define our custom node type, which must be  a sub-type of  AbstractJSMDGraphNode : import JSMDInterfaces.Graph: AbstractJSMDGraphNode \n\nstruct SpaceBody{T} <: AbstractGraphNode\n    radius::T\n    density::T\n    id::Int \n    name::String\nend Before using this structure as node, the function  SMDGraphs.get_node_id  must be implemented for this data-type. For this reason, we have included within  SpaceBody  an integer field to store the ID of the body. SMDGraphs.get_node_id(body::SpaceBody) = body.id We are now ready to create our custom graph. The  MappedNodeGraph  constructor is called as follows: import SMDGraphs: MappedGraph\ngraph = MappedGraph(SpaceBody{Float64}) This line will create an empty  SimpleGraph  with nodes of type  SpaceBody{Float64} . A directed  SimpleDiGraph  graph is also supported by replacing the above line  with the  MappedDiGraph  constructor. To avoid allocations, all the nodes must belong  to the same concrete type. To show the capabilities of mapped graphs, we will define a bunch of custom bodies and add them to the graph.  # Define some custom bodies \nearth = SpaceBody(6378.0, 5.51, 399, \"Earth\")\nsun = SpaceBody(696340.0, 1.41, 10, \"Sun\")\nmoon = SpaceBody(1737.4, 3.34, 301, \"Moon\")\n\n# Populate the graph with these bodies\nSMDGraphs.add_vertex!(graph, earth)\nSMDGraphs.add_vertex!(graph, sun)\nSMDGraphs.add_vertex!(graph, moon) Please note that the order in which these bodies are added to the graph does not matter,  because it will only affect the inner ID associated to each node. To access the items  stored inside the graph, we can use either their user-defined ID or the internal one. The latter is retrieved with the  SMDGraphs.get_mappedid  function: julia> SMDGraphs.get_node(graph, 399)\nSpaceBody{Float64}(6378.0, 5.51, 399, \"Earth\")\n\njulia> SMDGraphs.get_mappedid(graph, 301)\n3\n\njulia> SMDGraphs.get_mappednode(graph, 3)\nSpaceBody{Float64}(1737.4, 3.34, 301, \"Moon\") Here we have retrieved Earth's property through its nominal ID and exploited   get_mappedid  and  get_mappednode  to discover the internal ID of the Moon and access its content. Connections between the items in the graph are easily added as follows:  SMDGraphs.add_edge!(graph, 10, 399)\nSMDGraphs.add_edge!(graph, 399, 301) By providing an additional integer input to  add_edge! , a weight factor  can be associated to the edge. The default weight is null. Finally, the path between two nodes is retrived as:  julia> path = SMDGraphs.get_path(graph, 10, 301);\njulia> print(path)\n[2, 1, 3] Note that  get_path  returns an integer vector of internal IDs instead of the user-defined ones. This enables a faster retrieval of the nodes via  SMDGraphs.get_mappednode , allowing to skip the dictionary lookup for the ID mapping of each node in the path."}]