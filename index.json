[{"id":3,"pagetitle":"Home","title":"Welcome to Ephemerides.jl!","ref":"/Ephemerides/stable/#Welcome-to-Ephemerides.jl!","content":" Welcome to Ephemerides.jl! Ephemerides.jl is a Julia library that provides fast, thread-safe and allocation-free access to binary JPL  SPK  and  PCK  ephemeris files. Completely written in Julia, it enables Automatic-Differentiation (AD) via  ForwardDiff.jl  across all of its function calls.  It outperforms both  SPICE.jl  and  CALCEPH.jl  calls for most types of SPK segments and supports state vector and orientation angles computation up to order 3 (jerk). Note This package is meant to be used in combination with  FrameTransformations.jl , which enables transformations between different point and axes. Indeed, differently from traditional ephemeris readers such as  CALCEPH  and  SPICE , this package is only meant to read the data stored in the binary kernels. It does not perform transformations between reference frames nor concatenations of state vectors. For example, if ephemeris data for point 399 (Earth) is defined with respect to point 3 (Earth-Moon Barycenter) in the ICRF axes, with this package we will only be able to compute the state vector from 399 to 3 or viceversa.  Note All the package routines have been extensively tested against both SPICE and CALCEPH."},{"id":4,"pagetitle":"Home","title":"Installation","ref":"/Ephemerides/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg\n\njulia> Pkg.add(\"Ephemerides.jl\");"},{"id":5,"pagetitle":"Home","title":"Quickstart","ref":"/Ephemerides/stable/#Quickstart","content":" Quickstart Load SPK and PCK ephemeris kernels:  using Ephemerides \n\n# Load a single SPK kernel \neph_spk = EphemerisProvider(\"de440.bsp\")\n\n# Load a single PCK kernel\neph_pck = EphemerisProvider(\"pa440.bsp\")\n\n# Load multiple SPK and PCK kernels\neph = EphemerisProvider([\"de440.bsp\", \"pa440.bsp\"]) Inspect the kernels properties: # Retrieve the list of NAIF ID for all the available points \npoints = ephem_available_points(eph)\n\n# Retrieve the list of NAIF ID for all the available axes\naxes = ephem_available_axes(eph) Retrieve state and orientation data: # TDB seconds at 2000-01-01T12:00:00 (J2000)\ntime = 0.0\n\n# Compute the position of point 399 with respect to 3 at J2000\npos = ephem_vector3(eph, 3, 399, time)\n\n# Compute the position and its derivatives for point 299 with respect to 2\npvaj = ephem_vector12(eph, 2, 299, time)\n\n# Compute the orientation of axes 31006 (PA440) with respect to 1 (ICRF) at J2000\nangles = ephem_rotation3(eph, 1, 31006, time)"},{"id":6,"pagetitle":"Home","title":"Current Limitations","ref":"/Ephemerides/stable/#Current-Limitations","content":" Current Limitations The supported JPL binary SPK/PCK segments types are: 1, 2, 3, 5, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, 21.  Binary INPOP kernels are not supported.  Acceleration and jerk computations are unavailable for SPK segments of type 1, 5, 15, 17 and 21."},{"id":9,"pagetitle":"Public API","title":"Public Documentation","ref":"/Ephemerides/stable/api/api/#ephemerides_api","content":" Public Documentation"},{"id":10,"pagetitle":"Public API","title":"Kernels Loading and Inspection Functions","ref":"/Ephemerides/stable/api/api/#Kernels-Loading-and-Inspection-Functions","content":" Kernels Loading and Inspection Functions"},{"id":11,"pagetitle":"Public API","title":"Ephemerides.EphemerisProvider","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemerisProvider","content":" Ephemerides.EphemerisProvider  —  Type EphemerisProvider(file::String)\nEphemerisProvider(files::Vector{String}) Create an  EphemerisProvider  instance by loading a single or multiple binary ephemeris  kernel files specified by  files . Currently, only NAIF Double precision Array File (DAF) kernels (i.e., SPK and PCK) are accepted. Example julia> eph = EphemerisProvider(\"PATH_TO_KERNEL\")\nEphemerisProvider([...])\n\njulia> eph = EphemerisProvider([\"PATH_TO_KERNEL_1\", \"PATH_TO_KERNEL_2\"])\nEphemerisProvider([]) source"},{"id":12,"pagetitle":"Public API","title":"Ephemerides.EphemRecordSPK","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemRecordSPK","content":" Ephemerides.EphemRecordSPK  —  Type EphemRecordSPK <: AbstractEphemRecord Store the SPK metadata relative to a given (target, center) objects pair. Fields target  –  Int  target object NAIF ID center  –  Int  center object NAIF ID axes  –  Int  reference axes ID  t_start  – start times of each sub-window, in TDB seconds since J2000 t_end  – final times of each sub-window, in TDB seconds since J2000 source"},{"id":13,"pagetitle":"Public API","title":"Ephemerides.EphemRecordPCK","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemRecordPCK","content":" Ephemerides.EphemRecordPCK  —  Type EphemRecordPCK <: AbstractEphemRecord Store the PCK metadata relative to a given (target, center) axes pair. Fields target  –  Int  target axes NAIF ID center  –  Int  center axes NAIF ID t_start  – start times of each sub-window, in TDB seconds since J2000 t_end  – final times of each sub-window, in TDB seconds since J2000 source"},{"id":14,"pagetitle":"Public API","title":"Ephemerides.ephem_timescale_id","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_timescale_id","content":" Ephemerides.ephem_timescale_id  —  Function ephem_timescale_id(eph::EphemerisProvider) Retrieve a timescale ID associated with the ephemeris handler  eph .  It returns 1 for Barycentric Dynamical Time (TDB) and 2 for Barycentric Coordinate Time (TCB). Warning Ephemeris providers with mixed timescales are not supported. An error is thrown if in  the ephemeris handler some segments are defined in TDB and some other segments in TCB. source"},{"id":15,"pagetitle":"Public API","title":"Ephemerides.ephem_spk_timespan","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_spk_timespan","content":" Ephemerides.ephem_spk_timespan  —  Function ephem_spk_timespan(eph::EphemerisProvider) Return the minimum and maximum time available in the SPK kernels loaded within  eph , in  TDB seconds since J2000, together with a continuity parameter defined as follows:  0  no SPK data is available. 1  the quantities of all bodies are available for any time between the first and last time. 2  the quantities of some bodies are available on discontinuous time intervals between the    first and last time. 3  the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time. References CALCEPH  C++ library See Also See also  ephem_pck_timespan . source"},{"id":16,"pagetitle":"Public API","title":"Ephemerides.ephem_pck_timespan","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_pck_timespan","content":" Ephemerides.ephem_pck_timespan  —  Function ephem_pck_timespan(eph::EphemerisProvider) Return the minimum and maximum time available in the PCK kernels loaded within  eph , in  TDB seconds since J2000, together with a continuity parameter defined as follows:  0  no PCK data is available. 1  the quantities of all axes are available for any time between the first and last time. 2  the quantities of some axes are available on discontinuous time intervals between the    first and last time. 3  the quantities of each axis are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time. References CALCEPH  C++ library See Also See also  ephem_spk_timespan . source"},{"id":17,"pagetitle":"Public API","title":"Ephemerides.ephem_spk_records","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_spk_records","content":" Ephemerides.ephem_spk_records  —  Function ephem_spk_records(eph::EphemerisProvider) Return a list of  EphemRecordSPK  storing metadata relative to each (target, center) object pairs in the loaded SPK kernels.  source"},{"id":18,"pagetitle":"Public API","title":"Ephemerides.ephem_pck_records","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_pck_records","content":" Ephemerides.ephem_pck_records  —  Function ephem_pck_records(eph::EphemerisProvider) Return a list of  EphemRecordPCK  storing metadata relative to each (target, center) axes pairs in the loaded PCK kernels.  source"},{"id":19,"pagetitle":"Public API","title":"Ephemerides.ephem_get_points","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_get_points","content":" Ephemerides.ephem_get_points  —  Function ephem_get_points(eph::EphemerisProvider) Return a list of NAIFIds representing bodies with available ephemeris data.  source"},{"id":20,"pagetitle":"Public API","title":"Ephemerides.ephem_get_axes","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_get_axes","content":" Ephemerides.ephem_get_axes  —  Function ephem_get_axes(eph::EphemerisProvider) Return a list of Frame IDs representing axes with available orientation data.  source"},{"id":21,"pagetitle":"Public API","title":"Computing Positions","ref":"/Ephemerides/stable/api/api/#Computing-Positions","content":" Computing Positions"},{"id":22,"pagetitle":"Public API","title":"Ephemerides.ephem_vector3","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector3","content":" Ephemerides.ephem_vector3  —  Function ephem_vector3(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 3-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":23,"pagetitle":"Public API","title":"Ephemerides.ephem_vector6","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector6","content":" Ephemerides.ephem_vector6  —  Function ephem_vector6(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 6-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":24,"pagetitle":"Public API","title":"Ephemerides.ephem_vector9","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector9","content":" Ephemerides.ephem_vector9  —  Function ephem_vector9(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 9-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":25,"pagetitle":"Public API","title":"Ephemerides.ephem_vector12","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector12","content":" Ephemerides.ephem_vector12  —  Function ephem_vector12(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 12-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":26,"pagetitle":"Public API","title":"Computing Orientation","ref":"/Ephemerides/stable/api/api/#Computing-Orientation","content":" Computing Orientation"},{"id":27,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation3","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation3","content":" Ephemerides.ephem_rotation3  —  Function ephem_rotation3(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 3-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":28,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation6","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation6","content":" Ephemerides.ephem_rotation6  —  Function ephem_rotation6(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 6-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":29,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation9","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation9","content":" Ephemerides.ephem_rotation9  —  Function ephem_rotation9(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 9-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":30,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation12","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation12","content":" Ephemerides.ephem_rotation12  —  Function ephem_rotation12(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 12-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":33,"pagetitle":"Low-level API","title":"Low-level API","ref":"/Ephemerides/stable/api/lapi/#ephemerides_api","content":" Low-level API These functions are not meant to be used outside of the package. They are documented  only to aid future developments of the package."},{"id":34,"pagetitle":"Low-level API","title":"Ephemeris Provider","ref":"/Ephemerides/stable/api/lapi/#Ephemeris-Provider","content":" Ephemeris Provider"},{"id":35,"pagetitle":"Low-level API","title":"Ephemerides.get_daf","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_daf","content":" Ephemerides.get_daf  —  Function daf(eph::EphemerisProvider) Return the  DAF  files stored in the ephemeris provider.  source daf(eph::EphemerisProvider, id::Int) Return the  DAF  file in the ephemeris provider at index  id . source"},{"id":36,"pagetitle":"Low-level API","title":"Ephemerides.spk_links","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.spk_links","content":" Ephemerides.spk_links  —  Function spk_links(eph::EphemerisProvider) Return the [ SPKLinkTable ] for the SPK segments. source"},{"id":37,"pagetitle":"Low-level API","title":"Ephemerides.pck_links","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.pck_links","content":" Ephemerides.pck_links  —  Function pck_links(eph::EphemerisProvider) Return the  SPKLinkTable  for the PCK segments. source"},{"id":38,"pagetitle":"Low-level API","title":"DAF Routines","ref":"/Ephemerides/stable/api/lapi/#DAF-Routines","content":" DAF Routines"},{"id":39,"pagetitle":"Low-level API","title":"DAF Header","ref":"/Ephemerides/stable/api/lapi/#DAF-Header","content":" DAF Header"},{"id":40,"pagetitle":"Low-level API","title":"Ephemerides.DAFHeader","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAFHeader","content":" Ephemerides.DAFHeader  —  Type DAFHeader The DAF header, or file record, is the first physical record in a DAF and stores general  information about the content of the file.  Fields nd  –  Int32  number of double components in each array summary ni  –  Int32  number of integer components in each array summary fwd  –  Int32  record number of initial summary record bwd  –  Int32  record number of final summary record ffa  –  Int32  first free address of the file  name  –  String  internal name of the file lend  –  Bool  true if the file was generated in little endian  References DAF Required Reading See Also See also  DAF  and  EphemerisProvider source"},{"id":41,"pagetitle":"Low-level API","title":"Ephemerides.initial_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_record","content":" Ephemerides.initial_record  —  Function initial_record(head::DAFHeader) Return the record number of the initial summary record in the DAF  source initial_record(daf::DAF) Return the record number of the initial summary record in the DAF. source"},{"id":42,"pagetitle":"Low-level API","title":"Ephemerides.final_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_record","content":" Ephemerides.final_record  —  Function final_record(head::DAFHeader) Return the record number of the final summary record in the DAF  source final_record(daf::DAF) Return the record number of the final summary record in the DAF. source"},{"id":43,"pagetitle":"Low-level API","title":"Ephemerides.free_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.free_address","content":" Ephemerides.free_address  —  Function free_address(head::DAFHeader) Return the first free address in the file, i.e., the address at which the first element of  the next array is to be added. source free_address(daf::DAF) Return the first free address in the file, i.e., the address at which the first element of  the next array is to be added. source"},{"id":44,"pagetitle":"Low-level API","title":"Ephemerides.endian","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.endian","content":" Ephemerides.endian  —  Function endian(head::DAFHeader) Return  true  if the DAF file is in little-endian. source endian(daf::DAF) Return  true  if the DAF is in little-endian. source"},{"id":45,"pagetitle":"Low-level API","title":"Ephemerides.filename","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.filename","content":" Ephemerides.filename  —  Function filename(head::DAFHeader) Return the internal description of the DAF. source"},{"id":46,"pagetitle":"Low-level API","title":"Ephemerides.summary_size","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.summary_size","content":" Ephemerides.summary_size  —  Function summary_size(head::DAFHeader) Compute the size of a single summary record of a DAF file, in bytes. source"},{"id":47,"pagetitle":"Low-level API","title":"DAF Descriptor","ref":"/Ephemerides/stable/api/lapi/#DAF-Descriptor","content":" DAF Descriptor"},{"id":48,"pagetitle":"Low-level API","title":"Ephemerides.DAFSegmentDescriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAFSegmentDescriptor","content":" Ephemerides.DAFSegmentDescriptor  —  Type DAFSegmentDescriptor A container object to store both SPK and PCK descriptors information. Fields segtype  –  Int32  SPK/PCK segment type tstart  –  Float64  initial segment type, in TDB seconds since J2000.0 tend  –  Float64  final segment type, in TDB seconds since J2000.0 tid  –  Int32  target object NAIF ID cid  –  Int32  center object NAIF ID axesid  –  Int32  reference axes ID. Defaults to -1 for PCKs iaa  –  Int32  initial array address faa  –  Int32  final array address References SPK Required Reading PCK Required Reading source"},{"id":49,"pagetitle":"Low-level API","title":"Ephemerides.segment_type","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.segment_type","content":" Ephemerides.segment_type  —  Function segment_type(desc::DAFSegmentDescriptor) Return the SPK/PCK segment type. source"},{"id":50,"pagetitle":"Low-level API","title":"Ephemerides.initial_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_time","content":" Ephemerides.initial_time  —  Function initial_time(desc::DAFSegmentDescriptor) Return the initial epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0 source initial_time(link::SPKLink) Return the initial epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0 source"},{"id":51,"pagetitle":"Low-level API","title":"Ephemerides.final_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_time","content":" Ephemerides.final_time  —  Function final_time(desc::DAFSegmentDescriptor) Return the final epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0 source final_time(link::SPKLink) Return the final epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0 source"},{"id":52,"pagetitle":"Low-level API","title":"Ephemerides.center","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.center","content":" Ephemerides.center  —  Function center(desc::DAFSegmentDescriptor) Return the NAIF integer code for the reference object or axes for SPK and PCK, respectively. source"},{"id":53,"pagetitle":"Low-level API","title":"Ephemerides.target","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.target","content":" Ephemerides.target  —  Function target(desc::DAFSegmentDescriptor) Return the NAIF integer code for the target object or axes for SPK and PCK, respectively. source"},{"id":54,"pagetitle":"Low-level API","title":"Ephemerides.axes","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.axes","content":" Ephemerides.axes  —  Function axes(desc::DAFSegmentDescriptor) Return the NAIF integer code for the reference axes. It is valid only for SPK files and  defaults to -1 for PCKs.  source"},{"id":55,"pagetitle":"Low-level API","title":"Ephemerides.initial_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_address","content":" Ephemerides.initial_address  —  Function initial_address(desc::DAFSegmentDescriptor) Return the initial address of the segment array in the DAF. source"},{"id":56,"pagetitle":"Low-level API","title":"Ephemerides.final_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_address","content":" Ephemerides.final_address  —  Function final_address(desc::DAFSegmentDescriptor) Return the final address of the segment array in teh DAF. source"},{"id":57,"pagetitle":"Low-level API","title":"Ephemerides.get_segment_boundaries","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_segment_boundaries","content":" Ephemerides.get_segment_boundaries  —  Function get_segment_boundaries(desclist::Vector{DAFSegmentDescriptor}) Parse all the segment descriptors of a given (center, target) pair and return a set of  initial and final times, in TDB seconds since J2000, representing all the time  sub-windows in which the ephemeris data for this pair is defined.  source"},{"id":58,"pagetitle":"Low-level API","title":"Ephemerides.parse_spk_segment_descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_spk_segment_descriptor","content":" Ephemerides.parse_spk_segment_descriptor  —  Function parse_spk_segment_descriptor(summary::Vector{UInt8}, lend::Bool) Create a  DAFSegmentDescriptor  object by parsing a binary SPK segment descriptor. References SPK Required Reading source"},{"id":59,"pagetitle":"Low-level API","title":"Ephemerides.parse_pck_segment_descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_pck_segment_descriptor","content":" Ephemerides.parse_pck_segment_descriptor  —  Function parse_pck_segment_descriptor(summary::Vector{UInt8}, lend::Bool) Create a  DAFSegmentDescriptor  object by parsing a binary PCK segment descriptor.  A default value of -1 is used to fill the reference frame field. The target and center fields are used for the actual target and center axes. References PCK Required Reading source"},{"id":60,"pagetitle":"Low-level API","title":"DAF","ref":"/Ephemerides/stable/api/lapi/#DAF","content":" DAF"},{"id":61,"pagetitle":"Low-level API","title":"Ephemerides.DAF","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAF","content":" Ephemerides.DAF  —  Type DAF Container to hold the information of NAIF's Double precision Array File (DAF).  Fields filepath  –  String  system filepath of the DAF  array  –  Vector{UInt8}  binary content of the DAF header  –  DAFHeader  file record of the DAF comment  –  String  text within the DAF comment area  ftype  –  Int  file type, equals 1 for SPK and 2 for PCK desc  – DAF PCK/SPK segment descriptors seglist  –  SPKSegmentList  list of the SPK/PCK segments within the DAF References DAF Required Reading See Also See also  DAFHeader ,  Ephemerides.SPKSegmentList  and  EphemerisProvider source"},{"id":62,"pagetitle":"Low-level API","title":"Ephemerides.DAF_RECORD_LENGTH","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAF_RECORD_LENGTH","content":" Ephemerides.DAF_RECORD_LENGTH  —  Constant DAF_RECORD_LENGTH DAF record length, in bytes. References DAF Required Reading source"},{"id":63,"pagetitle":"Low-level API","title":"Ephemerides.FTPSTR","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.FTPSTR","content":" Ephemerides.FTPSTR  —  Constant FTPSTR Validation string that guarantees the integrity of a DAF file.  References DAF Required Reading source"},{"id":64,"pagetitle":"Low-level API","title":"Ephemerides.comment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.comment","content":" Ephemerides.comment  —  Function get_comment(daf::DAF) Return the comment written in the DAF comment section.  source"},{"id":65,"pagetitle":"Low-level API","title":"Ephemerides.header","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.header","content":" Ephemerides.header  —  Function header(spk::AbstractSPKSegment) Return the segment header. source get_header(daf::DAF) Return the  DAFHeader  header of the DAF. source"},{"id":66,"pagetitle":"Low-level API","title":"Ephemerides.array","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.array","content":" Ephemerides.array  —  Function get_array(daf::DAF) Return the byte content of the DAF file. source"},{"id":67,"pagetitle":"Low-level API","title":"Ephemerides.descriptors","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.descriptors","content":" Ephemerides.descriptors  —  Function get_descriptors(daf::DAF) Return the SPK/PCK segment descriptors contained in the DAF. source"},{"id":68,"pagetitle":"Low-level API","title":"Ephemerides.segment_list","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.segment_list","content":" Ephemerides.segment_list  —  Function get_segment_list(daf::DAF) Return the  Ephemerides.SPKSegmentList  list of segments stored in the DAF. source"},{"id":69,"pagetitle":"Low-level API","title":"Ephemerides.filepath","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.filepath","content":" Ephemerides.filepath  —  Function filepath(daf::DAF) Return the system path of the DAF. source"},{"id":70,"pagetitle":"Low-level API","title":"Ephemerides.is_spk","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_spk","content":" Ephemerides.is_spk  —  Function is_spk(daf::DAF) Return  true  if the DAF stores SPK data. source"},{"id":71,"pagetitle":"Low-level API","title":"Ephemerides.is_pck","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_pck","content":" Ephemerides.is_pck  —  Function is_pck(daf::DAF) Return  true  if the DAF stores PCK data. source"},{"id":72,"pagetitle":"Low-level API","title":"Ephemerides.parse_daf_comment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_daf_comment","content":" Ephemerides.parse_daf_comment  —  Function parse_daf_comment(array::Vector{UInt8}, header::DAFHeader) Retrieve the comment section of a binary DAF. References DAF Required Reading See Also See also  DAF ,  DAFHeader  and  parse_daf_summaries source"},{"id":73,"pagetitle":"Low-level API","title":"Ephemerides.parse_daf_summaries","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_daf_summaries","content":" Ephemerides.parse_daf_summaries  —  Function parse_daf_summaries(array::Vector{UInt8}, head::DAFHeader) Parse the DAF binary content and retrieve all the summary records. References DAF Required Reading See Also See also  DAF ,  DAFHeader  and  parse_daf_comment source"},{"id":74,"pagetitle":"Low-level API","title":"Ephemerides.initialise_segments!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initialise_segments!","content":" Ephemerides.initialise_segments!  —  Function initialise_segments!(daf::DAF) Fill the  Ephemerides.SPKSegmentList  by initialising the SPK/PCK segments associated to all  the descriptors stores within the DAF. See Also See also  DAF  and  create_spk_segment source"},{"id":75,"pagetitle":"Low-level API","title":"Ephemerides.create_spk_segment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.create_spk_segment","content":" Ephemerides.create_spk_segment  —  Function create_spk_segment(daf::DAF, desc::DAFSegmentDescriptor) Initialise an SPK segment according to the segment type defined in the   DAFSegmentDescriptor desc . source"},{"id":76,"pagetitle":"Low-level API","title":"Ephemerides.get_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_record","content":" Ephemerides.get_record  —  Function get_record(array::Vector{UInt8}, index::Integer) Retrieve a whole DAF record at position  index . source"},{"id":77,"pagetitle":"Low-level API","title":"Ephemerides.is_little_endian","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_little_endian","content":" Ephemerides.is_little_endian  —  Function is_little_endian(array::Vector{UInt8}) Return true if the array corresponds to the string indicating a little-endian format. source"},{"id":78,"pagetitle":"Low-level API","title":"SPK Links","ref":"/Ephemerides/stable/api/lapi/#SPK-Links","content":" SPK Links"},{"id":79,"pagetitle":"Low-level API","title":"Ephemerides.SPKLink","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKLink","content":" Ephemerides.SPKLink  —  Type SPKLink A link object to create a mapping between  DAFSegmentDescriptor  and its actual  location within an  EphemerisProvider  object.  Fields desc  –  DAFSegmentDescriptor  for the segment associated to this link fid  –  Int  index of the DAF containg the link data. lid  –  Int  field number in the  SPKSegmentList  for this segment type. eid  –  Int  index of the inner segment list that stores this SPK segment. fct  –  Int  1 or -1 depending on whether the (from, to) directions must be reversed. See Also See also  SPKLinkTable ,  SPKSegmentList  and  add_spklinks! . source"},{"id":80,"pagetitle":"Low-level API","title":"Ephemerides.SPKLinkTable","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKLinkTable","content":" Ephemerides.SPKLinkTable  —  Type SPKLinkTable Dictionary object providing all the  SPKLink  available between a set of (from, to) objects source"},{"id":81,"pagetitle":"Low-level API","title":"Ephemerides.descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.descriptor","content":" Ephemerides.descriptor  —  Function descriptor(link::SPKLink) Return the SPK/PCK segment descriptor associated to this link. source"},{"id":82,"pagetitle":"Low-level API","title":"Ephemerides.file_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.file_id","content":" Ephemerides.file_id  —  Function file_id(link::SPKLink) Return the DAF file index. source"},{"id":83,"pagetitle":"Low-level API","title":"Ephemerides.list_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.list_id","content":" Ephemerides.list_id  —  Function list_id(link::SPKLink) Return the index of the list containing the segments of the given SPK/PCK type. source"},{"id":84,"pagetitle":"Low-level API","title":"Ephemerides.element_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.element_id","content":" Ephemerides.element_id  —  Function element_id(link::SPKLink) Return the segment index in the inner SPK/PCK segment list. source"},{"id":85,"pagetitle":"Low-level API","title":"Ephemerides.factor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.factor","content":" Ephemerides.factor  —  Function factor(link::SPKLink) Return the direction multiplicative factor. source"},{"id":86,"pagetitle":"Low-level API","title":"Ephemerides.reverse_link","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.reverse_link","content":" Ephemerides.reverse_link  —  Function reverse_link(link::SPKLink) Reverse the sign, i.e. change the sign of the multiplicative factor, of the link. source"},{"id":87,"pagetitle":"Low-level API","title":"Ephemerides.create_linktables","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.create_linktables","content":" Ephemerides.create_linktables  —  Function create_linktables(dafs::Vector{DAF}) Create the SPK and PCK  SPKLinkTable  for all the segments stores in the input DAFs. source"},{"id":88,"pagetitle":"Low-level API","title":"Ephemerides.add_spklinks!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.add_spklinks!","content":" Ephemerides.add_spklinks!  —  Function add_spklinks!(table::SPKLinkTable, daf::DAF, fid::Int) Insert in the input  SPKLinkTable  all the SPK or PCK links associated to  the segment descriptors of the input DAF. source"},{"id":89,"pagetitle":"Low-level API","title":"SPK Segment List","ref":"/Ephemerides/stable/api/lapi/#SPK-Segment-List","content":" SPK Segment List"},{"id":90,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentList","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentList","content":" Ephemerides.SPKSegmentList  —  Type SPKSegmentList A container object to efficiently store all the different SPK segments that are contained  within a single DAF file. SPKSegmentList() Initialises an empty  SPKSegmentList  object. See also See also  Ephemerides.add_segment! source"},{"id":91,"pagetitle":"Low-level API","title":"Ephemerides.add_segment!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.add_segment!","content":" Ephemerides.add_segment!  —  Function add_segment!(list::SPKSegmentList, spk::AbstractSPKSegment) Add the SPK segment to the proper vector within the given  Ephemerides.SPKSegmentList list source"},{"id":92,"pagetitle":"Low-level API","title":"Ephemerides.get_segment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_segment","content":" Ephemerides.get_segment  —  Function get_segment(list::SPKSegmentList, lid::Int, eid::Int) Return the segment contained in the  lid  list at index  eid . source"},{"id":93,"pagetitle":"Low-level API","title":"Ephemerides.SPK_SEGMENTLIST_MAPPING","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPK_SEGMENTLIST_MAPPING","content":" Ephemerides.SPK_SEGMENTLIST_MAPPING  —  Constant SPK_SEGMENT_MAPPING A dictionary mapping SPK segment types to the field index of the  SPKSegmentList . source"},{"id":94,"pagetitle":"Low-level API","title":"Ephemerides.TCB_SEGMENTS","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TCB_SEGMENTS","content":" Ephemerides.TCB_SEGMENTS  —  Constant TCB_SEGMENTS List of the SPK/PCK segment types for which the time argument is expressed in the TCB scale. source"},{"id":95,"pagetitle":"Low-level API","title":"Ephemerides.TDB_SEGMENTS","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TDB_SEGMENTS","content":" Ephemerides.TDB_SEGMENTS  —  Constant TDB_SEGMENTS List of the SPK/PCK segment types for which the time argument is expressed in the TDB scale.  source"},{"id":96,"pagetitle":"Low-level API","title":"SPK Segment Types","ref":"/Ephemerides/stable/api/lapi/#SPK-Segment-Types","content":" SPK Segment Types"},{"id":97,"pagetitle":"Low-level API","title":"Abstract SPK Types","ref":"/Ephemerides/stable/api/lapi/#Abstract-SPK-Types","content":" Abstract SPK Types"},{"id":98,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKHeader","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKHeader","content":" Ephemerides.AbstractSPKHeader  —  Type AbstractSPKHeader Abstract type for all SPK segment type headers.  source"},{"id":99,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKCache","content":" Ephemerides.AbstractSPKCache  —  Type AbstractSPKCache Abstract type for all SPK segment type caches. source"},{"id":100,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKSegment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKSegment","content":" Ephemerides.AbstractSPKSegment  —  Type AbstractSPKSegment Abstract type for all SPK segment types. source"},{"id":101,"pagetitle":"Low-level API","title":"Ephemerides.cache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.cache","content":" Ephemerides.cache  —  Function cache(spk::AbstractSPKSegment) Return the segment cache data. source"},{"id":102,"pagetitle":"Low-level API","title":"Ephemerides.spk_field","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.spk_field","content":" Ephemerides.spk_field  —  Function spk_field(spk::AbstractSPKSegment) Return the field number in the  Ephemerides.SPKSegmentList  associated to the given SPK  segment type. source"},{"id":103,"pagetitle":"Low-level API","title":"SPK Type 1 and 21","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-1-and-21","content":" SPK Type 1 and 21"},{"id":104,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader1","content":" Ephemerides.SPKSegmentHeader1  —  Type SPKSegmentHeader1 <: AbstractSPKHeader Header instance for SPK segments of type 1 and 21. Fields n  –  Int  number of records in the segment  ndirs  –  Int  number of directory epochs epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the MDA records) recsize  -  Int  Number of double numbers stored in each MDA record maxdim  -  Int  MDA dimension (fixed to 15 for type 1) source"},{"id":105,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache1","content":" Ephemerides.SPKSegmentCache1  —  Type SPKSegmentCache1 <: AbstractSPKCache Cache instance for SPK segments of type 1 and 21. The fields contained within this cache  are taken from the FORTRAN NAIF's SPICE implementation for type 1 SPK segments.  Fields tl  – Reference epoch of the difference line. g  – Stepsize function vector. refpos  – Reference position vector. refvel  – Reference velocity vector. dt  – Modified Divided Difference arrays, with size (maxdim, 3) kqmax  – Maximum integration order plus 1. kq  – Integration order array. id  – Index of the currently loaded logical record. fc  – Buffer for the MDA computations. wc  – Buffer for the MDA computations. w  – Buffer for the MDA computations. vct  – Buffer for the MDA computations. source"},{"id":106,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType1","content":" Ephemerides.SPKSegmentType1  —  Type SPKSegmentType1 <: AbstractSPKSegment Segment instance for SPK segments of type 1 and 21, which contain Modified Difference Arrays  (MDA). This data type is normally used for spacecraft whose ephemerides are produced by JPL's  principal trajectory integrator DPTRAJ.  Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":107,"pagetitle":"Low-level API","title":"Ephemerides.compute_mda_position","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.compute_mda_position","content":" Ephemerides.compute_mda_position  —  Function compute_mda_position(cache::SPKSegmentCache1, Δ::Number) source"},{"id":108,"pagetitle":"Low-level API","title":"Ephemerides.compute_mda_velocity","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.compute_mda_velocity","content":" Ephemerides.compute_mda_velocity  —  Function compute_mda_velocity(cache::SPKSegmentCache1, Δ::Number) source"},{"id":109,"pagetitle":"Low-level API","title":"SPK Type 2 and 3","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-2-and-3","content":" SPK Type 2 and 3"},{"id":110,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader2","content":" Ephemerides.SPKSegmentHeader2  —  Type SPKSegmentHeader2 <: AbstractSPKHeader Header instance for SPK segments of type 2 and 3. Fields tstart  –  Float64  initial epoch of the first record, in seconds since J2000 tlen  –  Float64  interval length covered by each record, in seconds order  –  Int  polynomial order  N  –  Int  number of coefficients in each window n  –  Int  number of records in the segment recsize  –  Int  byte size of each logical record ncomp  –  Int  number of vector components iaa  –  Int  initial segment file address type  –  Int  SPK segment type, either 2 or 2 source"},{"id":111,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache2","content":" Ephemerides.SPKSegmentCache2  —  Type SPKSegmentCache2 <: AbstractSPKCache Cache instance for SPK segments of type 2 and 3. Fields A  – Chebyshev's polynomial coefficients, with size (ncomp, order) p  – Stores the record mid point and radius and scale factor buff  – Stores the buffers for the Chebyshev polynomials id  – Index of the currently loaded logical record source"},{"id":112,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType2","content":" Ephemerides.SPKSegmentType2  —  Type SPKSegmentType2 <: AbstractSPKSegment Segment instance for SPK segments of type 2 and 3, which contain Chebyshev polynomial  coefficients for the position and/or state of the body as function of time. This data type  is normally used for planet barycenters, and for satellites whose ephemerides are integrated. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":113,"pagetitle":"Low-level API","title":"SPK Type 5","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-5","content":" SPK Type 5"},{"id":114,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader5","content":" Ephemerides.SPKSegmentHeader5  —  Type SPKSegmentHeader5 <: AbstractSPKHeader Header instance for SPK segments of type 5. Fields GM  –  Float64  Gravitational constant  n  –  Int  number of states  ndirs  –  Int  number of epoch directories etid  –  Int  initial address for the epoch table (after all the state data) epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  source"},{"id":115,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache5","content":" Ephemerides.SPKSegmentCache5  —  Type SPKSegmentCache5 <: AbstractSPKCache Cache instance for SPK segments of type 5. Fields c1  – Twobody propagation cache for the left state. c2  – Twobody propagation cache for the right state. epochs  – Epochs associated to the two states. id  – Index of the currently loaded logical record. source"},{"id":116,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType5","content":" Ephemerides.SPKSegmentType5  —  Type SPKSegmentType5 <: AbstractSPKSegment Segment instance for SPK segments of type 5.  Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":117,"pagetitle":"Low-level API","title":"SPK Type 8 and 12","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-8-and-12","content":" SPK Type 8 and 12"},{"id":118,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader8","content":" Ephemerides.SPKSegmentHeader8  —  Type SPKSegmentHeader8 <: AbstractSPKHeader Header instance for SPK segments of type 8 and 12. Fields tstart  –  Float64  segment starting epoch, in TDB seconds since J2000  tlen  –  Float64  interval length, in seconds order  –  Int  interpolating polynomial degree N  –  Int  group size n  –  Int  number of states in the segment iaa  -  Int  initial segment file address  iseven  –  Bool  true for even group size type  –  Int  SPK type (either 8 or 12) source"},{"id":119,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache8","content":" Ephemerides.SPKSegmentCache8  —  Type SPKSegmentCache8 <: AbstractSPKCache Cache instance for SPK segments of type 8 and 12. Fields states  – Matrix storing the states of the interpolating points. buff  – Buffers to compute the interpolating polynomials. id  – Index of the currently loaded logical record. source"},{"id":120,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType8","content":" Ephemerides.SPKSegmentType8  —  Type SPKSegmentType8 <: AbstractSPKSegment Segment instance for SPK segments of type 8 and 12. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":121,"pagetitle":"Low-level API","title":"SPK Type 9 and 13","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-9-and-13","content":" SPK Type 9 and 13"},{"id":122,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader9","content":" Ephemerides.SPKSegmentHeader9  —  Type SPKSegmentHeader9 <: AbstractSPKHeader Header instance for SPK segments of type 9 and 13. Fields n  –  Int  number of states in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the state data) order  –  Int  interpolating polynomial degree N  –  Int  group size  iseven  –  Bool  true for even group size type  –  Int  SPK type (either 9 or 13) source"},{"id":123,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache9","content":" Ephemerides.SPKSegmentCache9  —  Type SPKSegmentCache9 <: AbstractSPKCache Cache instance for SPK segments of type 9 and 13. Fields epochs  – Epochs of the interpolating points.  states  – Matrix storing the states of the interpolating points.  buff  – Buffers to compute the interpolating polynomials. id  – Index of the currently loaded logical record. source"},{"id":124,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType9","content":" Ephemerides.SPKSegmentType9  —  Type SPKSegmentType9 <: AbstractSPKSegment Segment instance for SPK segments of type 9 and 13. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":125,"pagetitle":"Low-level API","title":"SPK Type 14","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-14","content":" SPK Type 14"},{"id":126,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader14","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader14","content":" Ephemerides.SPKSegmentHeader14  —  Type SPKSegmentHeader14 <: AbstractSPKHeader Header instance for SPK segments of type 14. Fields order  –  Int  interpolating polynomial degree n  –  Int  number of packets in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) etid  –  Int  initial address for the epoch table (after all the state data) ptid  –  Int  initial address for the packet table (after the constants) pktsize  –  Int  size of each data packet excluding the packet information area. pktoff  –  Int  offset of the packet data from the packet start  ncomp  –  Int  number of states coefficients (= 6 for SPK 14) N  –  Int  number of polynomial coefficients source"},{"id":127,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType14","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType14","content":" Ephemerides.SPKSegmentType14  —  Type SPKSegmentType14 <: AbstractSPKSegment Segment instance for SPK segments of type 14. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source Note SPK segments of type 14 have the same cache structure of SPK type 2 and 3."},{"id":128,"pagetitle":"Low-level API","title":"SPK Type 15","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-15","content":" SPK Type 15"},{"id":129,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader15","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader15","content":" Ephemerides.SPKSegmentHeader15  —  Type SPKSegmentHeader15 <: AbstractSPKHeader Header instance for SPK segments of type 15. Fields epoch  – Epoch of periapsis  tp  – Trajectory pole, i.e., vector parallel to the angular momentum of the orbit pv  – Central body north pole unit vector  pa  – Periapsis unit vector at epoch  p  – Semi-latus rectum  ecc  – Eccentricity  j2f  – J2 processing flag  vj2  – J2 validation flag, true if the orbit shape is compliant with J2 pertubations. GM  – Central body gravitational constant (km³/s²) J2  – Central body J2  R  – Central body radius (km) dmdt  – Mean anomaly rate of change (rad/s) kn  – Gain factor for the regression of the nodes  kp  – Gain factor for the precession of the pericenter source"},{"id":130,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType15","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType15","content":" Ephemerides.SPKSegmentType15  —  Type SPKSegmentType15 <: AbstractSPKSegment Segment instance for SPK segments of type 15. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source Note The cache of SPK Type 15 segments is made of  Ephemerides.TwoBodyUniversalCache  objects."},{"id":131,"pagetitle":"Low-level API","title":"SPK Type 17","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-17","content":" SPK Type 17"},{"id":132,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader17","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader17","content":" Ephemerides.SPKSegmentHeader17  —  Type SPKSegmentHeader17 <: AbstractSPKHeader Header instance for SPK segments of type 17. Fields epoch : epoch of periapsis (s) sma : semi-major axis (km) h : H term of the equinoctial elements k : K term of the equinoctial elements  lon : mean longitude at epoch (rad) p : P term of the equinoctial elements  q : Q term of the equinoctial elements  dlpdt : rate of longitude of the periapse (rad/s) dmldt : mean longitude rate (mean motion rate), (rad/s) dnodedt : longitude of the ascending node rate (rad/s) ra : equatorial pole right ascension (rad) de : equatorial pole declination (rad) R : Rotation matrix from planetary equator to inertial reference frame source"},{"id":133,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType17","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType17","content":" Ephemerides.SPKSegmentType17  —  Type SPKSegmentType17 <: AbstractSPKSegment Segment instance for SPK segments of type 17. Fields head  – Segment header  Note SPK segments of type 17 do not require a cache because they do not extract any  additional coefficients at runtime. References SPK Required Reading SPICE Toolkit source Note SPK segments of type 17 do not require a cache structure."},{"id":134,"pagetitle":"Low-level API","title":"SPK Type 18 and 19","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-18-and-19","content":" SPK Type 18 and 19"},{"id":135,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader18","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader18","content":" Ephemerides.SPKSegmentHeader18  —  Type SPKSegmentHeader18 <: AbstractSPKHeader Header instance for SPK segments of type 18. Fields n  –  Int  number of states in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the state data) order  –  Int  interpolating polynomial degree N  –  Int  group size  subtype  –  Int  type 18 subtype, either 0 (Hermite) or 1 (Lagrange) packetsize  –  Int  packet size for each point, either 12 (Hermite) or 6 (Lagrange) source"},{"id":136,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache18","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache18","content":" Ephemerides.SPKSegmentCache18  —  Type SPKSegmentCache18 <: AbstractSPKCache Cache instance for SPK segments of type 18. Fields p  – Vector storing indexes of the first and last points as well as the window size. epochs  – Epochs of the interpolating points.  states  – Matrix storing the states of the interpolating points.  buff  – Buffers to compute the interpolating polynomials. source"},{"id":137,"pagetitle":"Low-level API","title":"Ephemerides.reset_indexes!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.reset_indexes!","content":" Ephemerides.reset_indexes!  —  Function reset_indexes!(cache::SPKSegmentCache18) Reset the cache indexes to force the coefficients reload. source"},{"id":138,"pagetitle":"Low-level API","title":"Ephemerides.update_header!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.update_header!","content":" Ephemerides.update_header!  —  Function update_header!(head::SPKSegmentHeader18, daf::DAF, iaa, faa, type) Update the header of type 18 segments. source"},{"id":139,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader19","content":" Ephemerides.SPKSegmentHeader19  —  Type SPKSegmentHeader19 <: AbstractSPKHeader Header instance for SPK segments of type 19. Fields n  –  Int  number of states in the segment. ndirs  –  Int  number of epoch directories. times  – Storage for interval directories or start times (when ndirs = 0). iaa  -  Int  initial segment file address. etid  –  Int  byte address for the interval table (after all the minisegment data). ptid  –  Int  byte for the pointer table. usefirst  –  Bool  boundary flag, true if the preceding segment should be used. type  –  Int  either type 18 or 19. source"},{"id":140,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache19","content":" Ephemerides.SPKSegmentCache19  —  Type SPKSegmentCache19 <: AbstractSPKCache Cache instance for SPK segments of type 19. Fields minihead  – Header with the mini-segment properties. minidata  – Cache for the mini-segment. id  – Index of the currently loaded mini-segment. source"},{"id":141,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType19","content":" Ephemerides.SPKSegmentType19  —  Type SPKSegmentType19 <: AbstractSPKSegment Segment instance for SPK segments of type 18 and 19. Type 18 segments are treated as  special cases of a type 19 with a single mini-segment. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":142,"pagetitle":"Low-level API","title":"Ephemerides.find_minisegment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.find_minisegment","content":" Ephemerides.find_minisegment  —  Function find_minirecord(daf::DAF, head::SPKSegmentHeader19, time::Number) source"},{"id":143,"pagetitle":"Low-level API","title":"Ephemerides.load_minisegment!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.load_minisegment!","content":" Ephemerides.load_minisegment!  —  Function load_minisegment!(daf::DAF, head::SPKSegmentHeader19, cache::SPKSegmentCache19, index::Int) source Note SPK segments of type 18 are the only ones that do not posses a dedicated SPK segment type structure, because they are treated as special cases (i.e., single minisegments) of the type 19."},{"id":144,"pagetitle":"Low-level API","title":"SPK Type 20","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-20","content":" SPK Type 20"},{"id":145,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader20","content":" Ephemerides.SPKSegmentHeader20  —  Type SPKSegmentHeader20 <: AbstractSPKHeader Header instance for SPK segments of type 20. Fields dscale  –  Float64  length conversion factor tscale  –  Float64  time conversion factor tstart  –  Float64  initial epoch of the first record, in seconds since J2000 tlen  –  Float64  interval length covered by each record, in seconds recsize  –  Int  byte size of each logical record order  –  Int  polynomial order  N  –  Int  number of coefficients in each window n  –  Int  number of records in the segment iaa  –  Int  initial segment file address source"},{"id":146,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache20","content":" Ephemerides.SPKSegmentCache20  —  Type SPKSegmentCache20 <: AbstractSPKCache Cache instance for SPK segments of type 20. Fields id  – Index of the currently loaded logical record p  – Stores the record position constants A  – Chebyshev's polynomial coefficients, with size (ncomp, order) buff  – Stores the buffers for the Chebyshev polynomials source"},{"id":147,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType20","content":" Ephemerides.SPKSegmentType20  —  Type SPKSegmentType2 <: AbstractSPKSegment Segment instance for SPK segments of type 20, which contain Chebyshev polynomial coefficients  for the position and/or state of the body as function of time. This data type is normally  used for planet barycenters, and for satellites whose ephemerides are integrated. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":148,"pagetitle":"Low-level API","title":"SPK Utility Functions","ref":"/Ephemerides/stable/api/lapi/#SPK-Utility-Functions","content":" SPK Utility Functions"},{"id":149,"pagetitle":"Low-level API","title":"Ephemerides.normalise_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.normalise_time","content":" Ephemerides.normalise_time  —  Function normalise_time(cache::SPKSegmentCache2, time::Number) Transform  time  in an interval between [-1, 1] for compliance with Chebyshev polynomials. source normalise_time(head::SPKSegmentHeader8, time::Number, index::Int) Returned a normalised time that starts at 1 at the beginning of the interval. source normalise_time(head::SPKSegmentHeader20, time::Number, index::Int) source"},{"id":150,"pagetitle":"Low-level API","title":"Ephemerides.find_logical_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.find_logical_record","content":" Ephemerides.find_logical_record  —  Function find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number) source find_logical_record(head::SPKSegmentHeader2, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader5, time::Number) source find_logical_record(head::SPKSegmentHeader8, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader14, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader18, time::Number) source find_logical_record(head::SPKSegmentHeader20, time::Number) source"},{"id":151,"pagetitle":"Low-level API","title":"Ephemerides.get_coefficients!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_coefficients!","content":" Ephemerides.get_coefficients!  —  Function get_coefficients!(daf::DAF, head::SPKSegmentHeader1, cache::SPKSegmentCache1, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader2, cache::SPKSegmentCache2, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader5, cache::SPKSegmentCache5, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader8, cache::SPKSegmentCache8, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader9, cache::SPKSegmentCache9, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader14, cache::SPKSegmentCache14, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader18, cache::SPKSegmentCache18, first::Int, last::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader20, cache::SPKSegmentCache20, index::Int) source"},{"id":152,"pagetitle":"Low-level API","title":"Interpolating Functions","ref":"/Ephemerides/stable/api/lapi/#Interpolating-Functions","content":" Interpolating Functions"},{"id":153,"pagetitle":"Low-level API","title":"Caches","ref":"/Ephemerides/stable/api/lapi/#Caches","content":" Caches"},{"id":154,"pagetitle":"Low-level API","title":"Ephemerides.InterpCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.InterpCache","content":" Ephemerides.InterpCache  —  Type InterpCache{T} source"},{"id":155,"pagetitle":"Low-level API","title":"Ephemerides.get_buffer","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_buffer","content":" Ephemerides.get_buffer  —  Function get_buffer(c::InterpCache, idx::int, x::Number) Return the  idx -th buffer from the corresponding  DiffCache  depending on the type of  x .  source"},{"id":156,"pagetitle":"Low-level API","title":"Chebyshev Polynomials","ref":"/Ephemerides/stable/api/lapi/#Chebyshev-Polynomials","content":" Chebyshev Polynomials"},{"id":157,"pagetitle":"Low-level API","title":"Ephemerides.chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.chebyshev","content":" Ephemerides.chebyshev  —  Function chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, ibuff::Int) Evaluate a sum of Cheybyshev polynomials of the first kind at  t  using a  recursive algorithm. It simultenously evalutes the 3 state components.  idx  is the  index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  ∂chebyshev ,  ∂²chebyshev  and  ∂³chebyshev source"},{"id":158,"pagetitle":"Low-level API","title":"Ephemerides.∂chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂chebyshev","content":" Ephemerides.∂chebyshev  —  Function ∂chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its derivative at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂²chebyshev  and  ∂³chebyshev source"},{"id":159,"pagetitle":"Low-level API","title":"Ephemerides.∂²chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²chebyshev","content":" Ephemerides.∂²chebyshev  —  Function ∂²chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its two derivatives at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂chebyshev  and  ∂³chebyshev source"},{"id":160,"pagetitle":"Low-level API","title":"Ephemerides.∂³chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂³chebyshev","content":" Ephemerides.∂³chebyshev  —  Function ∂³chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its three derivatives at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂chebyshev  and  ∂²chebyshev source"},{"id":161,"pagetitle":"Low-level API","title":"Ephemerides.∫chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∫chebyshev","content":" Ephemerides.∫chebyshev  —  Function ∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀) Evaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. It assumes the Chebyshev polynomials  up to degree N have already been computed and are stored in the buffer with index  ibuff .   tlen  is the size of the record interval,  Δt  is the timescale factor, and  p₀  is a  vector containing the position coefficients at the midpoint (i.e., when the integral is  evaluated at t = 0). Note x  is a re-work of the actual ascissa value that lies between [-1, 1] source ∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀) Evaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. This function simultaneously  computes both the Chebyshev polynomials as well as their integrals. source"},{"id":162,"pagetitle":"Low-level API","title":"Lagrange Polynomials","ref":"/Ephemerides/stable/api/lapi/#Lagrange-Polynomials","content":" Lagrange Polynomials"},{"id":163,"pagetitle":"Low-level API","title":"Ephemerides.lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.lagrange","content":" Ephemerides.lagrange  —  Function lagrange(cache::InterpCache, states, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial at  x  by using Neville's algorithm. This  function is valid only for equally-spaced polynomials.  idx  is the index of the desired  state and  N  is the number of coefficients of the polynomial.  Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  ∂lagrange  and  ∂²lagrange . source lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial at  x  by using Neville's algorithm. This  function handles unequally-spaced polynomials, where the coefficients in  states  are  interpolated at  epochs . source"},{"id":164,"pagetitle":"Low-level API","title":"Ephemerides.∂lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂lagrange","content":" Ephemerides.∂lagrange  —  Function ∂lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Recursively evaluate a Lagrange polynomial and its derivative at  x  by using  Neville's algorithm. This function is valid only for equally-spaced polynomials.  idx   is the index of the desired state,  N  is the number of coefficients of the polynomial and   Δt is the length of the polynomial interval Note x  is a re-work of the actual ascissa value that starts at 1 See Also See also  lagrange  and  ∂²lagrange source ∂lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial and its derivative at  x  by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in  states  are interpolated at  epochs . source"},{"id":165,"pagetitle":"Low-level API","title":"Ephemerides.∂²lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²lagrange","content":" Ephemerides.∂²lagrange  —  Function ∂²lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Recursively evaluate a Lagrange polynomial and its two derivatives at  x  by using  Neville's algorithm. This function is valid only for equally-spaced polynomials.  idx   is the index of the desired state,  N  is the number of coefficients of the polynomial and   Δt is the length of the polynomial interval Note x  is a re-work of the actual ascissa value that starts at 1 See Also See also  lagrange  and  ∂lagrange source ∂²lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial and its two derivatives at  x  by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in  states  are interpolated at  epochs . See Also See also  lagrange  and  ∂lagrange source"},{"id":166,"pagetitle":"Low-level API","title":"Hermite Polynomials","ref":"/Ephemerides/stable/api/lapi/#Hermite-Polynomials","content":" Hermite Polynomials"},{"id":167,"pagetitle":"Low-level API","title":"Ephemerides.hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.hermite","content":" Ephemerides.hermite  —  Function hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial at  x  using a recursive algorithm. This function is valid  only for equally-spaced polynomials.  idx  is the index of the desired state,  N   is the number of coefficients of the polynomial and  Δt  is the length of the polynomial  interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  ∂hermite ,  ∂²hermite  and  ∂³hermite . source hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial at  x  using a recursive algorithm. This function handles  unequally-spaced polynomials, where the coefficients in  states  are interpolated  at  epochs . source"},{"id":168,"pagetitle":"Low-level API","title":"Ephemerides.∂hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂hermite","content":" Ephemerides.∂hermite  —  Function ∂hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its derivative at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂²hermite  and  ∂³hermite . source ∂hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its derivative at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":169,"pagetitle":"Low-level API","title":"Ephemerides.∂²hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²hermite","content":" Ephemerides.∂²hermite  —  Function ∂²hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its two derivatives at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂hermite  and  ∂³hermite . source ∂²hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its two derivatives at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":170,"pagetitle":"Low-level API","title":"Ephemerides.∂³hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂³hermite","content":" Ephemerides.∂³hermite  —  Function ∂³hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its three derivatives at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂hermite  and  ∂²hermite . source ∂³hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its three derivatives at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":171,"pagetitle":"Low-level API","title":"Introspection","ref":"/Ephemerides/stable/api/lapi/#Introspection","content":" Introspection"},{"id":172,"pagetitle":"Low-level API","title":"Ephemerides.AbstractEphemRecord","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractEphemRecord","content":" Ephemerides.AbstractEphemRecord  —  Type AbstractEphemRecord Abstract type for ephemeris segment records. source"},{"id":173,"pagetitle":"Low-level API","title":"Ephemerides.initial_times","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_times","content":" Ephemerides.initial_times  —  Function initial_times(record::AbstractEphemRecord) Recover the initial times of each sub-window in which the ephemeris data of  record  is  defined, expressed in TDB seconds since J2000 source"},{"id":174,"pagetitle":"Low-level API","title":"Ephemerides.final_times","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_times","content":" Ephemerides.final_times  —  Function final_times(record::AbstractEphemRecord) Recover the final times of each sub-window in which the ephemeris data of  record  is  defined, expressed in TDB seconds since J2000 source"},{"id":175,"pagetitle":"Low-level API","title":"Ephemerides.analyse_timespan","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.analyse_timespan","content":" Ephemerides.analyse_timespan  —  Function analyse_timespan(records) Analyse a set of  AbstractEphemRecord , returning the minimum and maximum covered  times, in TDB seconds since J2000, together with a continuity parameter. References CALCEPH  C++ library See Also See also  ephem_spk_timespan  and  ephem_pck_timespan . source"},{"id":176,"pagetitle":"Low-level API","title":"TwoBody Routines","ref":"/Ephemerides/stable/api/lapi/#TwoBody-Routines","content":" TwoBody Routines"},{"id":177,"pagetitle":"Low-level API","title":"Ephemerides.TwoBodyUniversalCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TwoBodyUniversalCache","content":" Ephemerides.TwoBodyUniversalCache  —  Type TwoBodyUniversalCache A container to store precomputed quantities required for the two-body propagation based on  universal variables. Only the quantities that depend on the initial state are computed. source"},{"id":178,"pagetitle":"Low-level API","title":"Ephemerides.update_cache!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.update_cache!","content":" Ephemerides.update_cache!  —  Function update_cache!(c::TwoBodyUniversalCache) Update the precomputed values in the cache using the position and velocity in  c . source"},{"id":179,"pagetitle":"Low-level API","title":"Ephemerides.propagate_twobody","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.propagate_twobody","content":" Ephemerides.propagate_twobody  —  Function propagate_twobody(cache::TwoBodyUniversalCache, Δt::Number) Propagate the state vector in  cache  of  Δt  using the universal variables formulation for  Kepler's Equation and the Lagrange coefficients f and g. Note This routine is valid for any type of orbit and uses a bisection method to find the  root of the universal variables Kepler's equation. The algorithm has been directly  taken from the SPICE toolkit  prob2b.f . References SPICE Toolkit source"},{"id":180,"pagetitle":"Low-level API","title":"Ephemerides.stumpff","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.stumpff","content":" Ephemerides.stumpff  —  Function stumpff(x::Number, p::AbstractVector) Compute Stumpff's functions from C₀ up to C₃ at  x .  Note This routine uses the trigonometrical expressions of the functions when the absolute  value of  x  is greater or equal to 1. If that is not the case, the C₂ and C₃ functions  are computed from a truncated expression of the Maclaurin series at order 11, which  guarantees a higher precision and avoid overflow errors when  x  is null. References SPICE Toolkit source"},{"id":183,"pagetitle":"Benchmarks","title":"Performance Benchmarks","ref":"/Ephemerides/stable/benchmarks/#Performance-Benchmarks","content":" Performance Benchmarks The performance of this package have been tested against both CALCEPH and SPICE, two of the most-popular open-source ephemeris readers used in the space industry. The results show that  Ephemerides.jl  largely outperforms SPICE as well as CALCEPH for most SPK segment types. For example, for state vector computations (i.e., position and velocity) the mean execution times are the following: Additionally, it is better optimised to compute higher order derivatives (i.e., acceleration and jerk) with respect to CALCEPH.  Note These time benchmarks have been obtained on an Intel Core i7-6700 CPU @ 3.40 GHz with 16 GB of RAM"},{"id":186,"pagetitle":"Kernels Inspection","title":"Kernels Inspection","ref":"/Ephemerides/stable/tutorials/inspect/#Kernels-Inspection","content":" Kernels Inspection This tutorial will walk you through the basic features and interfaces that allow you to inspect the properties of binary ephemeris kernels."},{"id":187,"pagetitle":"Kernels Inspection","title":"Available Times","ref":"/Ephemerides/stable/tutorials/inspect/#Available-Times","content":" Available Times"},{"id":188,"pagetitle":"Kernels Inspection","title":"Timescale","ref":"/Ephemerides/stable/tutorials/inspect/#Timescale","content":" Timescale SPK and PCK segments support two types of ephemeris timescales, namely, TDB and TCB. The timescale of the loaded kernels can be retrieved as follows:  using Ephemerides \n\n# Load the kernel\neph = EphemerisProvider(\"kernel.bsp\")\n\n# Retrieve the ID of the kernel timescales\nid = ephem_timescale_id(eph) The retrieved ID is 1 for TDB and 2 for TCB. A value of -1 is returned if the kernels are empty.  Note Only one timescale is admissed within a single  EphemerisProvider  object, "},{"id":189,"pagetitle":"Kernels Inspection","title":"Timespan","ref":"/Ephemerides/stable/tutorials/inspect/#Timespan","content":" Timespan To retrieve the first and last available time in the ephemeris files associated to a provider  object, two functions are available to distinguish between SPK and PCK data:  ephem_spk_timespan(eph)\nephem_pck_timespan(eph) where  eph  is an  EphemerisProvider  instance. Both functions return the minimum and maximum available time in TDB seconds since J2000, as well as a continuity parameter defined as follows:  0  no SPK or PCK data is available. 1  the quantities of all bodies are available for any time between the first and last time. 2  the quantities of some bodies are available on discontinuous time intervals between the    first and last time. 3  the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time."},{"id":190,"pagetitle":"Kernels Inspection","title":"Available Points and Axes","ref":"/Ephemerides/stable/tutorials/inspect/#Available-Points-and-Axes","content":" Available Points and Axes To retrieve the list of NAIF IDs with the points or axes that have available ephemeris data, these function should be called on an  EphemerisProvider  instance: ephem_get_points(eph)\nephem_get_axes(eph)"},{"id":191,"pagetitle":"Kernels Inspection","title":"Segment Records","ref":"/Ephemerides/stable/tutorials/inspect/#Segment-Records","content":" Segment Records Position and orientation metadata relative to the records loaded in the ephemeris kernels can be retrieved with the following two functions, respectively: ephem_spk_records(eph)\nephem_pck_records(eph) Both functions return a vector of  Ephemerides.EphemRecordSPK  or  Ephemerides.EphemRecordPCK  ordered by priority, i.e., they use the highest priority records when there are multiple records that could satisfy the same target, center pair for a given epoch. In particular SPK records contain the following information:  target: NAIF ID of the target object center: NAIF ID of the center object axes: NAIF ID of the reference axes t_start: start times of each sub-window, in TDB seconds since J2000 t_end: final times of each sub-window, in TDB seconds since J2000 Similarly, PCK records contain these information: target: NAIF ID of the target axes center: NAIF ID of the reference axes t_start: start times of each sub-window, in TDB seconds since J2000 t_end: final times of each sub-window, in TDB seconds since J2000 For PCK records, the reference axes ID is set into the  center  field. Please notice that whenever a gap between the data of a given pair of (center, target) objects is present,  t_start  and  t_end  will store the start and end times of each window with available data, respectively."},{"id":194,"pagetitle":"Loading Kernels","title":"Loading Kernels","ref":"/Ephemerides/stable/tutorials/load/#Loading-Kernels","content":" Loading Kernels This tutorial will walk you through the basic features and interfaces that allow you to load binary ephemeris kernels. The supported sources of ephemerides are currently limited to binary PCK and SPK segments of type: 1, 2, 3, 5, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, and 21.  Note Support for IMCCE INPOP ephemerides is yet to be implemented. Before retrieving position and orientation data of celestial objects, the user is first required to load the ephemerides files into an  EphemerisProvider  object.  using Ephemerides \n\n# Load a single ephemeris file \neph1 = EphemerisProvider(\"kernel1.bsp\")\n\n# Load multiple ephemeris files simultaneously\neph2 = EphemerisProvider([\"kernel1.bsp\", \"kernel2.bsp\"]) You must specify the relative or absolute path(s) of the file(s) to load. Either one or multiple ephemeris files can be simultaneously loaded into a single  EphemerisProvider  object. However,  once a provider has been created, no more kernels can be loaded inside it. "},{"id":197,"pagetitle":"Reading Ephemeris Data","title":"Reading Ephemeris Data","ref":"/Ephemerides/stable/tutorials/position/#Reading-Ephemeris-Data","content":" Reading Ephemeris Data This tutorials will walk you through the basic features and interfaces that allow you to compute translation and orientation data from binary ephemeris kernels."},{"id":198,"pagetitle":"Reading Ephemeris Data","title":"Computing state vectors","ref":"/Ephemerides/stable/tutorials/position/#Computing-state-vectors","content":" Computing state vectors Ephemerides.jl  allows the computation of a relative position between two points and its higher order derivatives up to order 3 (i.e., velocity, acceleration and jerk). All these computations are natively  thread-safe and compatible with Automatic Differentiation (AD) with respect to time via  ForwardDiff.jl . In particular, the following methods are available to compute translation data:  ephem_vector3(eph, from, to, time)\nephem_vector6(eph, from, to, time)\nephem_vector9(eph, from, to, time)\nephem_vector12(eph, from, to, time) They all share the same interface, requiring an  EphemerisProvider  object as the first input.  from  and  to  are integer numbers representing the ID of the center and target points that we desired. The  time  argument is expressed in TDB seconds since J2000.0. Note Differently, from traditional ephemerides readers,  Ephemerides.jl  is only meant to read the data stored in the binary kernels and it does not perform any concatenation of state vectors. This means that if data from point 399 is expressed with respect to point 3, we will only be able to compute the relative position of 339 with respect to 3 or viceversa, but not of 399 with respect to another point. The reason behind this is that  Ephemerides.jl  is meant to be used in combination with  FrameTransformations.jl , which already enables tranformations between different user-defined point and axes. An example to compute the position of the Moon (399) with respect to the Earth-Moon Barycenter (3) at J2000 (time = 0), is the following:  using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_de440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\npos = ephem_vector3(eph, 3, 399, 0) Instead, if one desires the whole state vector, up to the jerk components, the functions become:  # Compute position and velocity \npv = ephem_vector6(eph, 3, 399, 0)\n\n# Compute position, velocity and acceleration\npva = ephem_vector9(eph, 3, 399, 0)\n\n# Compute position, velocity, acceleration and jerk\npvaj = ephem_vector12(eph, 3, 399, 0) In all these examples, the returned data is always in the form of a  StaticArray  in order to minimise memory allocations. Warning SPK segments of types 1 5, 15, 17 and 21 do not natively support acceleration and jerk computations. However, these values can be computed by Automatic Differentiation (AD) of the position and/or velocity components."},{"id":199,"pagetitle":"Reading Ephemeris Data","title":"Computing orientation angles","ref":"/Ephemerides/stable/tutorials/position/#Computing-orientation-angles","content":" Computing orientation angles Similarly to position components,  Ephemerides.jl  also allows the computation of orientation angles and their derivatives up to order 3. All these computations are natively thread-safe and compatible with Automatic Differentiation (AD) with respect to time via  ForwardDiff.jl . In particular, the following methods are available to compute orientation data:  ephem_rotation3(eph, from, to, time)\nephem_rotation6(eph, from, to, time)\nephem_rotation9(eph, from, to, time)\nephem_rotation12(eph, from, to, time) Again, they all share the same interface, requiring an  EphemerisProvider  object as the first input.  from  and  to  are integer numbers representing the ID of the reference and target axes that we desired. The  time  argument is expressed in TDB seconds since J2000.0. An example to compute the Euler angles of the PA440 axes (31008) with respect to the ICRF (1) at J2000 (time = 0), is the following:  using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_pa440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\nang = ephem_rotation3(eph, 1, 31008, 0) Instead, if one desires the whole vector, up to the 3rd order derivative, the functions become:  # Compute angles and derivatives \npv = ephem_rotation6(eph, 1, 31008, 0)\npva = ephem_rotation9(eph, 1, 31008, 0)\npvaj = ephem_rotation12(eph, 1, 31008, 0) The returned orientation data is always in the form of a  StaticArray  in order to minimise memory allocations. Note Differently from the translational data contained in SPK kernels, the orientation angles can only be computed in one direction, i.e., if the orientation of the Moon's Principal Axes (PA) is defined with respect to the ICRF, it is not possible to compute the rotation from the PA to the ICRF with this routine. "},{"id":202,"pagetitle":"Home","title":"Welcome to Tempo.jl!","ref":"/Tempo/stable/#Welcome-to-Tempo.jl!","content":" Welcome to Tempo.jl! Efficient Astronomical Time transformations in Julia. Tempo.jl is an astronomical library that enables fast, efficient and high-accuracy time transformations between common and user-defined time scales and time representations."},{"id":203,"pagetitle":"Home","title":"Installation","ref":"/Tempo/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg\n\njulia> Pkg.add(\"Tempo.jl\");"},{"id":204,"pagetitle":"Home","title":"Quickstart","ref":"/Tempo/stable/#Quickstart","content":" Quickstart Create an  Epoch :  # Create an Epoch from an ISO-formatted string\ntai = Epoch(\"2022-10-02T12:04:23.043 TAI\")\n\n# Create an Epoch from a Julian Date\njd = Epoch(\"JD 2451545.0\")\n\n# Create an Epoch from a DateTime object and a timescale\ndt = DateTime(2001, 6, 15, 0, 0, 0, 0.0)\ne = Epoch(dt, TT) Efficiently transform epochs between various timescales: # Convert an Epoch from TAI to TDB \ntai = Epoch(\"2022-10-02T12:04:23.043 TAI\")\ntdb = convert(TDB, tai)\n\n# Convert an Epoch from TAI to UTC automatically handling leapseconds \nutc = convert(UTC, tai)"},{"id":205,"pagetitle":"Home","title":"Tempo.jl vs AstroTime.jl","ref":"/Tempo/stable/#Tempo.jl-vs-AstroTime.jl","content":" Tempo.jl vs AstroTime.jl Tempo.jl and  AstroTime.jl  are very similar libraries that allow transformations between various astronomical time representations. The major differences are: AstroTime.jl supports accurate Epoch transformations by leveraging high    precision arithmetics. Tempo.jl is more efficient when multiple timescales conversions must be    performed to convert a given Epoch (e.g., it does not allocate memory)."},{"id":208,"pagetitle":"Public API","title":"Public Documentation","ref":"/Tempo/stable/api/#tempo_api","content":" Public Documentation"},{"id":209,"pagetitle":"Public API","title":"Datetime","ref":"/Tempo/stable/api/#Datetime","content":" Datetime"},{"id":210,"pagetitle":"Public API","title":"Tempo.Date","ref":"/Tempo/stable/api/#Tempo.Date","content":" Tempo.Date  —  Type Date A type to represent a calendar date by storing the year, month and day. Date(year::Int, month::Int, day::Int) Construct a  Date  object given the  year ,  month  and  day . Date(offset::Integer) Create a  Date  object given an integer number of days since  2000-01-01 . Date(year::Integer, dayinyear::Integer) Create a  Date  object given the  year  and the day of the year  dayinyear . Examples julia> Date(2020, 1)\n2020-01-01\n\njulia> Date(2020, 300)\n2020-10-26 Date(dt::DateTime) Extract the  Date  object from a  DateTime  structure.  See also See also  Time  and  DateTime . source"},{"id":211,"pagetitle":"Public API","title":"Tempo.Time","ref":"/Tempo/stable/api/#Tempo.Time","content":" Tempo.Time  —  Type Time{T} A type representing the time of the day storing the hour, minute, seconds and fraction  of seconds. Time(hour::Int, minute::Int, second::Int, fraction::T) where {T <: Number} Create a  Time  object of type  T . Time(hour::Int, minute::Int, second::Number) Construct a  Time  object given the  hour ,  minute  and  seconds . In this case, the  seconds can either be an integer or a floating point number. The fraction of seconds will be computed under the hood. Time(secondinday::Int, fraction::Number)\nTime(secondinday::Number) Create a  Time  object given the seconds of the day  secondinday  and/or the fraction of  seconds.  Time(dt::DateTime) Extract the  Time  object from a  DateTime  structure.  See also See also  Date  and  DateTime . source"},{"id":212,"pagetitle":"Public API","title":"Tempo.DateTime","ref":"/Tempo/stable/api/#Tempo.DateTime","content":" Tempo.DateTime  —  Type DateTime{T} A type wrapping a  Date  and a  Time  object. DateTime(date::Date, time::Time{T}) Construct a  DateTime  object of type  T  from its  Date  and  Time  components. DateTime(year::Int, month::Int, day::Int, hour::Int, min::Int, sec::Int, frac::Number) Create a  DateTime  object by parts.  DateTime(iso::AbstractString) Create a  DateTime  object from by parsing an ISO datetime string  iso , in the format   YYYY-MM-DDThh:mm:ss.ffffffff . The DateTime parts not provided in the string will be  assigned default values. Examples julia> DateTime(\"2023-05-18T20:14:55.02\")\n2023-05-18T20:14:55.020\n\njulia> Tempo.DateTime(\"2022-05-12\")\n2022-05-12T00:00:00.00 DateTime(seconds::Number) Create a  DateTime  object given the number of seconds elapsed since  J2000 . DateTime(d::Date, sec::Number) Create a  DateTime  object given a  Date  and the number of seconds since midnight. Examples julia> d = Date(2023, 5, 18)\n2023-05-18\n\njulia> DateTime(d, 0)\n2023-05-18T12:00:00.000\n\njulia> DateTime(d, 1)\n2023-05-18T12:00:01.000 See also See also  Date ,  Time  and  Epoch . source"},{"id":213,"pagetitle":"Public API","title":"Tempo.year","ref":"/Tempo/stable/api/#Tempo.year","content":" Tempo.year  —  Function year(d::Date) Get year associated to a  Date . source year(d::DateTime) Get year associated to a  DateTime  type. source"},{"id":214,"pagetitle":"Public API","title":"Tempo.month","ref":"/Tempo/stable/api/#Tempo.month","content":" Tempo.month  —  Function month(d::Date) Get month associated to a  Date . source month(d::DateTime) Get month associated to a  DateTime  type. source"},{"id":215,"pagetitle":"Public API","title":"Tempo.day","ref":"/Tempo/stable/api/#Tempo.day","content":" Tempo.day  —  Function day(d::Date) Get day associated to a  Date . source day(d::DateTime) Get day associated to a  DateTime  type. source"},{"id":216,"pagetitle":"Public API","title":"Tempo.hour","ref":"/Tempo/stable/api/#Tempo.hour","content":" Tempo.hour  —  Function hour(t::Time) Get the current hour. source hour(d::DateTime) Get hour associated to a  DateTime  type. source"},{"id":217,"pagetitle":"Public API","title":"Tempo.minute","ref":"/Tempo/stable/api/#Tempo.minute","content":" Tempo.minute  —  Function minute(t::Time) Get the current minute. source minute(d::DateTime) Get minute associated to a  DateTime  type. source"},{"id":218,"pagetitle":"Public API","title":"Tempo.second","ref":"/Tempo/stable/api/#Tempo.second","content":" Tempo.second  —  Function second(::Type{<:AbstractFloat}, t::Time)\nsecond(::Type{<:Integer}, t::Time)\nsecond(t::Time) Get the current second. source second(::Type{<:AbstractFloat}, t::Time)\nsecond(d::DateTime) Get the seconds associated to a  DateTime  type. If a floating-point type is given  as first argument, the returned value will also account for the fraction of seconds. source"},{"id":219,"pagetitle":"Public API","title":"Tempo.find_dayinyear","ref":"/Tempo/stable/api/#Tempo.find_dayinyear","content":" Tempo.find_dayinyear  —  Function find_dayinyear(month::Integer, day::Integer, isleap::Bool) Find the day of the year given the month, the day of the month and whether the year  is leap or not. source find_dayinyear(d::Date) Find the day in the year. source"},{"id":220,"pagetitle":"Public API","title":"Epochs","ref":"/Tempo/stable/api/#Epochs","content":" Epochs"},{"id":221,"pagetitle":"Public API","title":"Types","ref":"/Tempo/stable/api/#Types","content":" Types"},{"id":222,"pagetitle":"Public API","title":"Tempo.Epoch","ref":"/Tempo/stable/api/#Tempo.Epoch","content":" Tempo.Epoch  —  Type Epoch{S, T} A type to represent Epoch-like data. Epochs are internally represented as seconds + fraction of  seconds since a reference epoch, which is considered to be  2000-01-01T12:00:00 ,  i.e.  J2000 . Epoch(sec::Number, scale::AbstractTimeScale)\nEpoch(sec::Number, scale::Type{<:AbstractTimeScale})\nEpoch{S}(seconds::Number) where {S <: AbstractTimeScale} Create an  Epoch  object from the number of seconds since  J2000  with the  timescale  S . Epoch(dt::DateTime, scale::AbstractTimeScale)\nEpoch(dt::DateTime, scale::Type{<:AbstractTimeScale}) Create an  Epoch  object from a  DateTime  structure with timescale  scale . Epoch(str::AbstractString, scale::AbstractTimeScale)\nEpoch(str::AbstractString) Create an  Epoch  object from an ISO-formatted string. The timescale can either be  specified as a second argument or written at the end of the string.  This constructor requires that the  str  is in the format: ISO  –  yyyy-mm-ddTHH:MM:SS.ffff  : assume J2000 as origin J2000  –  DDDD.ffff  : parse Julian Date since J2000, in days JD  –  JD DDDDDDDDD.ffffff  : parse Julian Date, in days MJD  –  MJD DDDDDDDDD.ffffff  : parse a Modified Julian Date, in days A  TimeScale  can be added at the end of the string, separated by a whitespace.  If it is not declared,  TDB  will be used as a default timescale.  Examples julia> Epoch(\"2050-01-01T12:35:15.0000 TT\")\n2050-01-01T12:35:14.9999 TT\n\njulia> Epoch(\"2050-01-01T12:35:15.0000\")\n2050-01-01T12:35:14.9999 TDB\n\njulia> Epoch(\"JD 2400000.5\")\n1858-11-17T00:00:00.0000 TDB\n\njulia> Epoch(\"MJD 51544.5\")\n2000-01-01T12:00:00.0000 TDB\n\njulia> Epoch(\"12.0\")\n2000-01-13T12:00:00.0000 TDB\n\njulia> Epoch(\"12.0 TT\")\n2000-01-13T12:00:00.0000 TT source"},{"id":223,"pagetitle":"Public API","title":"Tempo.timescale","ref":"/Tempo/stable/api/#Tempo.timescale","content":" Tempo.timescale  —  Function timescale(ep::Epoch) Epoch timescale. source"},{"id":224,"pagetitle":"Public API","title":"Tempo.value","ref":"/Tempo/stable/api/#Tempo.value","content":" Tempo.value  —  Function value(ep::Epoch) Full  Epoch  value. source"},{"id":225,"pagetitle":"Public API","title":"Origins","ref":"/Tempo/stable/api/#Origins","content":" Origins"},{"id":226,"pagetitle":"Public API","title":"Tempo.JD","ref":"/Tempo/stable/api/#Tempo.JD","content":" Tempo.JD  —  Constant JD The singleton instance of the  JulianDate  epoch origin.  With this origin, Epoch reference is  -4712-01-01T12:00 . source"},{"id":227,"pagetitle":"Public API","title":"Tempo.J2000","ref":"/Tempo/stable/api/#Tempo.J2000","content":" Tempo.J2000  —  Constant J2000 The singleton instance of the  JulianDate2000  epoch origin.  With this origin, Epoch reference is  2000-01-01T12:00 . source"},{"id":228,"pagetitle":"Public API","title":"Tempo.MJD","ref":"/Tempo/stable/api/#Tempo.MJD","content":" Tempo.MJD  —  Constant MJD The singleton instance of the  ModifiedJulianDate  epoch origin.  With this origin, Epoch reference is  1858-11-17T00:00 . source"},{"id":229,"pagetitle":"Public API","title":"Tempo.MJD2000","ref":"/Tempo/stable/api/#Tempo.MJD2000","content":" Tempo.MJD2000  —  Constant MJD2000 The singleton instance of the  ModifiedJulianDate2000  epoch origin.  With this origin, Epoch reference is  2000-01-01T00:00 . source"},{"id":230,"pagetitle":"Public API","title":"Conversions","ref":"/Tempo/stable/api/#Conversions","content":" Conversions"},{"id":231,"pagetitle":"Public API","title":"Tempo.j2000","ref":"/Tempo/stable/api/#Tempo.j2000","content":" Tempo.j2000  —  Function j2000(jd)\nj2000(jd1, jd2) Convert Julian Date in days since J2000 source j2000(d::Date) Convert Gregorian calendar date  Date  to a Julian Date since  J2000 ,  in days. source j2000(dt::DateTime) Convert a  DateTime dt  in Julian days since  J2000 . source j2000(e::Epoch) Convert  Epoch  in Julian Date days since  J2000 . source"},{"id":232,"pagetitle":"Public API","title":"Tempo.j2000s","ref":"/Tempo/stable/api/#Tempo.j2000s","content":" Tempo.j2000s  —  Function j2000s(jd)\nj2000s(jd1, jd2) Convert Julian Date (in days) in seconds past J2000  source j2000s(dt::DateTime) Convert a  DateTime dt  to seconds since  J2000 . source j2000s(e::Epoch) Convert  Epoch  in Julian Date seconds since  J2000 . source"},{"id":233,"pagetitle":"Public API","title":"Tempo.j2000c","ref":"/Tempo/stable/api/#Tempo.j2000c","content":" Tempo.j2000c  —  Function j2000c(jd)\nj2000c(jd1, jd2) Convert Julian Date (in days) to Julian Centuries source j2000c(dt::DateTime) Convert  a  DateTime dt  in a Julian Date since  J2000 , in centuries. source j2000c(e::Epoch) Convert  Epoch  in Julian Date centuries since  J2000 . source"},{"id":234,"pagetitle":"Public API","title":"Timescales","ref":"/Tempo/stable/api/#Timescales","content":" Timescales"},{"id":235,"pagetitle":"Public API","title":"Time System","ref":"/Tempo/stable/api/#Time-System","content":" Time System"},{"id":236,"pagetitle":"Public API","title":"Tempo.@timescale","ref":"/Tempo/stable/api/#Tempo.@timescale","content":" Tempo.@timescale  —  Macro @timescale(name, id, type) Create a new timescale instance to alias the given  id . This macro creates an   AbstractTimeScale  subtype and its singleton instance called  name . Its  type   is obtained by appending  TimeScale  to  name  if it was not provided. Examples julia> @timescale NTS 100 NewTimeScale \n\njulia> typeof(NTS)\nNewTimeScale \n\njulia> timescale_alias(NTS)\n100\n\njulia> @timescale TBH 200\n\njulia> typeof(TBH)\nTBHTimeScale\n\njulia> timescale_alias(TBH)\n200 See also See also  timescale_alias  and  add_timescale! . source"},{"id":237,"pagetitle":"Public API","title":"Tempo.timescale_alias","ref":"/Tempo/stable/api/#Tempo.timescale_alias","content":" Tempo.timescale_alias  —  Function timescale_alias(scale::AbstractTimeScale) Return the ID associated to  scale . source"},{"id":238,"pagetitle":"Public API","title":"Tempo.timescale_name","ref":"/Tempo/stable/api/#Tempo.timescale_name","content":" Tempo.timescale_name  —  Function timescale_name(scale::AbstractTimeScale) Return the name of  scale . source"},{"id":239,"pagetitle":"Public API","title":"Tempo.timescale_id","ref":"/Tempo/stable/api/#Tempo.timescale_id","content":" Tempo.timescale_id  —  Function timescale_id(scale::AbstractTimeScale) Return the ID of  scale . source"},{"id":240,"pagetitle":"Public API","title":"Tempo.TimeSystem","ref":"/Tempo/stable/api/#Tempo.TimeSystem","content":" Tempo.TimeSystem  —  Type TimeSystem{T} A  TimeSystem  object manages a collection of default and user-defined  TimeScaleNode  objects, enabling efficient time transformations between them. It leverages a   MappedDiGraph  to keep track of the relationships between the timescales. TimeSystem{T}() Create a empty  TimeSystem  object with datatype  T . Examples julia> ts = TimeSystem{Float64}();\n\njulia> @timescale TSA 100 TimeScaleA\n\njulia> @timescale TSB 200 TimeScaleB\n\njulia> add_timescale!(ts, TSA)\n\njulia> offset_tsa2tsb(seconds) = 1.0\n\njulia> offset_tsb2tsa(seconds) = -1.0\n\njulia> add_timescale!(ts, TSB, offset_tsa2tsb; parent=TSA, ftp=offset_tsb2tsa) See also See also  @timescale  and  add_timescale! . source"},{"id":241,"pagetitle":"Public API","title":"Tempo.add_timescale!","ref":"/Tempo/stable/api/#Tempo.add_timescale!","content":" Tempo.add_timescale!  —  Function add_timescale!(s::TimeSystem, ts::TimeScaleNode) Register a new node in the  TimeSystem . Warning This is a low-level function and should not be called by the user. source add_timescale!(system::TimeSystem, scale::AbstractTimeScale, ffp::Function; ftp, parent) Add  scale  as a timescale to  system . A custom function  ffp  providing the time offset,  in seconds, between the  parent  scale and the current scale must be provided by the user.  The  parent  and  ffp  arguments are unneeded only for the root timescale. If the user  wishes to add a scale to a non-empty timesystem, this argument becomes mandatory. The input functions must accept only the seconds in the parent scale as argument and must  return a single numerical output. An optional function  ftp , with a similar interface, returning the offset from the current to the parent scale may also be provided.  Note If  ftp  is not provided, the reverse timescale transformation will not be possible.  Examples julia> SYSTEM = TimeSystem{Float64}();\n\njulia> @timescale RTS 102 RootTimeScale\n\njulia> @timescale CTS 103 ChildTimeScale\n\njulia> root_to_child(x::Number) = 13.3;\n\njulia> child_to_root(x::Number) = -13.3;\n\njulia> add_timescale!(SYSTEM, RTS)\n\njulia> add_timescale!(SYSTEM, CTS, root_to_child; parent=RTS, ftp=child_to_root) See also See also  @timescale  and  TimeSystem . source"},{"id":242,"pagetitle":"Public API","title":"Tempo.TIMESCALES","ref":"/Tempo/stable/api/#Tempo.TIMESCALES","content":" Tempo.TIMESCALES  —  Constant TIMESCALES Default time scales graph, containing at least: (\"TT\", \"TAI\", \"UTC\", \"TCG\", \"TCB\", \"TDB\", \"UT1\", \"TDBH\", \"GPS\") It can be easily extended using the  @timescale  to create new  TimeScaleNode   aliases and  add_timescale!  method to define its relation with the other nodes  in the graph.  Example # Define a new timescale type alias\n@timescale NTS 100 NewTimeScale\n\n# Define offset to and from another timescale in the graph \noffset_ffp(seconds) = 1.0\noffset_ftp(seconds) = -1.0\n\n# Connect to the graph, with the parent node (TDB in this example)\nadd_timescale!(TIMESCALES, NTS, offset_ffp, parent=TDB, ftp=offset_ftp) See also See also  @timescale  and  add_timescale! . source"},{"id":243,"pagetitle":"Public API","title":"Default Timescales","ref":"/Tempo/stable/api/#Default-Timescales","content":" Default Timescales"},{"id":244,"pagetitle":"Public API","title":"Tempo.GPS","ref":"/Tempo/stable/api/#Tempo.GPS","content":" Tempo.GPS  —  Constant GPS The singleton instance of the  GlobalPositioningSystemTime  type representing the Global Positioning System Time (GPS) time scale. source"},{"id":245,"pagetitle":"Public API","title":"Tempo.TAI","ref":"/Tempo/stable/api/#Tempo.TAI","content":" Tempo.TAI  —  Constant TAI The singleton instance of the  InternationalAtomicTime  type representing the International Atomic Time (TAI) time scale. source"},{"id":246,"pagetitle":"Public API","title":"Tempo.TCB","ref":"/Tempo/stable/api/#Tempo.TCB","content":" Tempo.TCB  —  Constant TCB The singleton instance of the  BarycentricCoordinateTime  type representing the Barycentric Coordinate Time (TCB) time scale. source"},{"id":247,"pagetitle":"Public API","title":"Tempo.TCG","ref":"/Tempo/stable/api/#Tempo.TCG","content":" Tempo.TCG  —  Constant TCG The singleton instance of the  GeocentricCoordinateTime  type representing the Geocentric Coordinate Time (TCG) time scale. source"},{"id":248,"pagetitle":"Public API","title":"Tempo.TDB","ref":"/Tempo/stable/api/#Tempo.TDB","content":" Tempo.TDB  —  Constant TDB The singleton instance of the  BarycentricDynamicalTime  type representing the Barycentric Dynamical Time (TDB) time scale. source"},{"id":249,"pagetitle":"Public API","title":"Tempo.TDBH","ref":"/Tempo/stable/api/#Tempo.TDBH","content":" Tempo.TDBH  —  Constant TDBH The singleton instance of the  HighPrecisionBarycentricDynamicalTime  type representing the High Precision Barycentric Dynamical Time (TDBH) time scale. source"},{"id":250,"pagetitle":"Public API","title":"Tempo.TT","ref":"/Tempo/stable/api/#Tempo.TT","content":" Tempo.TT  —  Constant TT The singleton instance of the  TerrestrialTime  type representing the Terrestrial Time (TT) time scale. source"},{"id":251,"pagetitle":"Public API","title":"Tempo.UT1","ref":"/Tempo/stable/api/#Tempo.UT1","content":" Tempo.UT1  —  Constant UT1 The singleton instance of the  UniversalTime  type representing the Universal Time (UT1) time scale. source"},{"id":252,"pagetitle":"Public API","title":"Tempo.UTC","ref":"/Tempo/stable/api/#Tempo.UTC","content":" Tempo.UTC  —  Constant UTC The singleton instance of the  CoordinatedUniversalTime  type representing the Coordinated Universal Time (UTC) time scale. source"},{"id":253,"pagetitle":"Public API","title":"Constants","ref":"/Tempo/stable/api/#Constants","content":" Constants"},{"id":254,"pagetitle":"Public API","title":"Tempo.DJ2000","ref":"/Tempo/stable/api/#Tempo.DJ2000","content":" Tempo.DJ2000  —  Constant DJ2000 Reference epoch  J2000 , Julian Date ( 2451545.0 ).  It is  12:00 01-01-2000 . source"},{"id":255,"pagetitle":"Public API","title":"Tempo.DMJD","ref":"/Tempo/stable/api/#Tempo.DMJD","content":" Tempo.DMJD  —  Constant DMJD Reference epoch  J2000 , Modified Julian Date ( 51544.5 ). source"},{"id":256,"pagetitle":"Public API","title":"Tempo.DJM0","ref":"/Tempo/stable/api/#Tempo.DJM0","content":" Tempo.DJM0  —  Constant DJM0 Julian Date of Modified Julian Date zero point ( 2400000.5 ). It is  00:00 17-11-1858 . source"},{"id":259,"pagetitle":"Low-level API","title":"Low-level API","ref":"/Tempo/stable/lapi/#tempo_lapi","content":" Low-level API These functions are not meant to be used outside of the package. They are documented only to aid future developments of the package."},{"id":260,"pagetitle":"Low-level API","title":"Epochs","ref":"/Tempo/stable/lapi/#Epochs","content":" Epochs"},{"id":261,"pagetitle":"Low-level API","title":"Tempo.AbstractEpochOrigin","ref":"/Tempo/stable/lapi/#Tempo.AbstractEpochOrigin","content":" Tempo.AbstractEpochOrigin  —  Type AbstractEpochOrigin Abstract type for all epoch origins. source"},{"id":262,"pagetitle":"Low-level API","title":"Tempo.JulianDate","ref":"/Tempo/stable/lapi/#Tempo.JulianDate","content":" Tempo.JulianDate  —  Type JulianDate A type representing the JulianDate (JD) epoch origin.  With this origin, Epoch reference is  -4712-01-01T12:00 . source"},{"id":263,"pagetitle":"Low-level API","title":"Tempo.JulianDate2000","ref":"/Tempo/stable/lapi/#Tempo.JulianDate2000","content":" Tempo.JulianDate2000  —  Type JulianDate2000 A type representing the JulianDate2000 (J2000) epoch origin.  With this origin, Epoch reference is  2000-01-01T12:00 . source"},{"id":264,"pagetitle":"Low-level API","title":"Tempo.ModifiedJulianDate","ref":"/Tempo/stable/lapi/#Tempo.ModifiedJulianDate","content":" Tempo.ModifiedJulianDate  —  Type ModifiedJulianDate A type representing the ModifiedJulianDate (MJD) epoch origin.  With this origin, Epoch reference is  1858-11-17T00:00 . source"},{"id":265,"pagetitle":"Low-level API","title":"Tempo.ModifiedJulianDate2000","ref":"/Tempo/stable/lapi/#Tempo.ModifiedJulianDate2000","content":" Tempo.ModifiedJulianDate2000  —  Type ModifiedJulianDate2000 A type representing the ModifiedJulianDate2000 (MJD2000) epoch origin.  With this origin, Epoch reference is  2000-01-01T00:00 . source"},{"id":266,"pagetitle":"Low-level API","title":"Tempo.EpochConversionError","ref":"/Tempo/stable/lapi/#Tempo.EpochConversionError","content":" Tempo.EpochConversionError  —  Type EpochConversionError A type representing epoch conversion errors. source"},{"id":267,"pagetitle":"Low-level API","title":"Tempo.parse_iso","ref":"/Tempo/stable/lapi/#Tempo.parse_iso","content":" Tempo.parse_iso  —  Function parse_iso(s::AbstractString) Parse an ISO datetime string, in the format  YYYY-MM-DDThh:mm:ss.ffffffff  and return  a  Tuple  containing the year, month, day , hour, minute, second and milliseconds. If the  string format is not recognised as ISO, an  ArgumentError  is thrown. source"},{"id":268,"pagetitle":"Low-level API","title":"Timescale Offsets","ref":"/Tempo/stable/lapi/#Timescale-Offsets","content":" Timescale Offsets"},{"id":269,"pagetitle":"Low-level API","title":"Tempo.offset","ref":"/Tempo/stable/lapi/#Tempo.offset","content":" Tempo.offset  —  Function offset(::Tempo.JulianDate) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  JulianDate  (with origin at  -4712-01-01T12:00 ) source offset(::Tempo.ModifiedJulianDate) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  ModifiedJulianDate  (with origin at  1858-11-17T00:00 ) source offset(::Tempo.JulianDate2000) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  JulianDate2000  (with origin at  2000-01-01T12:00 ) source offset(::Tempo.ModifiedJulianDate2000) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  ModifiedJulianDate2000  (with origin at  2000-01-01T00:00 ) source"},{"id":270,"pagetitle":"Low-level API","title":"Tempo.offset_gps2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_gps2tai","content":" Tempo.offset_gps2tai  —  Function offset_gps2tai(seconds) Return the fixed offset between  GPS  and  TAI  in seconds. source"},{"id":271,"pagetitle":"Low-level API","title":"Tempo.offset_tai2gps","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2gps","content":" Tempo.offset_tai2gps  —  Function offset_tai2gps(seconds) Return the fixed offset between  TAI  and  GPS  in seconds. source"},{"id":272,"pagetitle":"Low-level API","title":"Tempo.offset_tai2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2tt","content":" Tempo.offset_tai2tt  —  Function offset_tai2tt(seconds) Return the fixed offset between  TAI  and  TT  in seconds. source"},{"id":273,"pagetitle":"Low-level API","title":"Tempo.offset_tai2utc","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2utc","content":" Tempo.offset_tai2utc  —  Function offset_tai2utc(seconds) Return the offset between  TAI  and  UTC  in seconds. source"},{"id":274,"pagetitle":"Low-level API","title":"Tempo.offset_tcb2tdb","ref":"/Tempo/stable/lapi/#Tempo.offset_tcb2tdb","content":" Tempo.offset_tcb2tdb  —  Function offset_tcb2tdb(seconds) Return the linear offset between  TCB  and  TDB  in seconds. source"},{"id":275,"pagetitle":"Low-level API","title":"Tempo.offset_tcg2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tcg2tt","content":" Tempo.offset_tcg2tt  —  Function offset_tcg2tt(seconds) Return the linear offset between  TCG  and  TT  in seconds. source"},{"id":276,"pagetitle":"Low-level API","title":"Tempo.offset_tdb2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tdb2tt","content":" Tempo.offset_tdb2tt  —  Function offset_tdb2tt(seconds) Return the offset between  TDB  and  TT  in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer.  For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much  as ~4 microseconds. References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":277,"pagetitle":"Low-level API","title":"Tempo.offset_tdb2tcb","ref":"/Tempo/stable/lapi/#Tempo.offset_tdb2tcb","content":" Tempo.offset_tdb2tcb  —  Function offset_tdb2tcb(seconds) Return the linear offset between  TDB  and  TCB  in seconds. source"},{"id":278,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tai","content":" Tempo.offset_tt2tai  —  Function offset_tt2tai(seconds) Return the fixed offset between  TT  and  TAI  in seconds. source"},{"id":279,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tcg","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tcg","content":" Tempo.offset_tt2tcg  —  Function offset_tt2tcg(seconds) Return the linear offset between  TT  and  TCG  in seconds. source"},{"id":280,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tdb","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tdb","content":" Tempo.offset_tt2tdb  —  Function offset_tt2tdb(seconds) Return the offset between  TT  and  TDB  in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer.  For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much  as ~4 microseconds. References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":281,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tdbh","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tdbh","content":" Tempo.offset_tt2tdbh  —  Function offset_tt2tdbh(seconds) Return the offset between  TT  and  TDBH  in seconds. The maximum error in using the above formula is about 10 µs from 1600 to 2200. For even more precise applications, the series expansion by   Harada & Fukushima (2003)  is recommended. References The IAU Resolutions on Astronomical Reference Systems, Time Scales, and Earth Rotation Models,   United States Naval Observatory, https://arxiv.org/pdf/astro-ph/0602086.pdf source"},{"id":282,"pagetitle":"Low-level API","title":"Tempo.offset_utc2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_utc2tai","content":" Tempo.offset_utc2tai  —  Function offset_utc2tai(seconds) Return the offset between  UTC  and  TAI  in seconds. source"},{"id":283,"pagetitle":"Low-level API","title":"Timescale Types","ref":"/Tempo/stable/lapi/#Timescale-Types","content":" Timescale Types"},{"id":284,"pagetitle":"Low-level API","title":"Tempo.TimeScaleNode","ref":"/Tempo/stable/lapi/#Tempo.TimeScaleNode","content":" Tempo.TimeScaleNode  —  Type TimeScaleNode{T} <: AbstractGraphNode Define a timescale. Fields name  – timescale name id  – timescale identification number (ID) parentid  – ID of the parent timescale ffp  – offest function from the parent timescale ftp  – offset function to the parent timescale source"},{"id":285,"pagetitle":"Low-level API","title":"Tempo.AbstractTimeScale","ref":"/Tempo/stable/lapi/#Tempo.AbstractTimeScale","content":" Tempo.AbstractTimeScale  —  Type AbstractTimeScale All timescales are subtypes of the abstract type  AbstractTimeScale . source"},{"id":286,"pagetitle":"Low-level API","title":"Tempo.GlobalPositioningSystemTime","ref":"/Tempo/stable/lapi/#Tempo.GlobalPositioningSystemTime","content":" Tempo.GlobalPositioningSystemTime  —  Type GlobalPositioningSystemTime <: AbstractTimeScale A type representing the Global Positioning System Time (GPS) time scale. source"},{"id":287,"pagetitle":"Low-level API","title":"Tempo.BarycentricDynamicalTime","ref":"/Tempo/stable/lapi/#Tempo.BarycentricDynamicalTime","content":" Tempo.BarycentricDynamicalTime  —  Type BarycentricDynamicalTime <: AbstractTimeScale A type representing the Barycentric Dynamical Time (TDB) time scale. source"},{"id":288,"pagetitle":"Low-level API","title":"Tempo.HighPrecisionBarycentricDynamicalTime","ref":"/Tempo/stable/lapi/#Tempo.HighPrecisionBarycentricDynamicalTime","content":" Tempo.HighPrecisionBarycentricDynamicalTime  —  Type HighPrecisionBarycentricDynamicalTime <: AbstractTimeScale A type representing the High Precision Barycentric Dynamical Time (TDBH) time scale. source"},{"id":289,"pagetitle":"Low-level API","title":"Tempo.BarycentricCoordinateTime","ref":"/Tempo/stable/lapi/#Tempo.BarycentricCoordinateTime","content":" Tempo.BarycentricCoordinateTime  —  Type BarycentricCoordinateTime <: AbstractTimeScale A type representing the Barycentric Coordinate Time (TCB) time scale. source"},{"id":290,"pagetitle":"Low-level API","title":"Tempo.TerrestrialTime","ref":"/Tempo/stable/lapi/#Tempo.TerrestrialTime","content":" Tempo.TerrestrialTime  —  Type TerrestrialTime <: AbstractTimeScale A type representing the Terrestrial Time (TT) time scale. source"},{"id":291,"pagetitle":"Low-level API","title":"Tempo.InternationalAtomicTime","ref":"/Tempo/stable/lapi/#Tempo.InternationalAtomicTime","content":" Tempo.InternationalAtomicTime  —  Type InternationalAtomicTime <: AbstractTimeScale A type representing the International Atomic Time (TAI) time scale. source"},{"id":292,"pagetitle":"Low-level API","title":"Tempo.UniversalTime","ref":"/Tempo/stable/lapi/#Tempo.UniversalTime","content":" Tempo.UniversalTime  —  Type UniversalTime <: AbstractTimeScale A type representing the Universal Time (UT1) time scale. source"},{"id":293,"pagetitle":"Low-level API","title":"Tempo.CoordinatedUniversalTime","ref":"/Tempo/stable/lapi/#Tempo.CoordinatedUniversalTime","content":" Tempo.CoordinatedUniversalTime  —  Type CoordinatedUniversalTime <: AbstractTimeScale A type representing the Coordinated Universal Time (UTC) time scale. source"},{"id":294,"pagetitle":"Low-level API","title":"Tempo.GeocentricCoordinateTime","ref":"/Tempo/stable/lapi/#Tempo.GeocentricCoordinateTime","content":" Tempo.GeocentricCoordinateTime  —  Type GeocentricCoordinateTime <: AbstractTimeScale A type representing the Geocentric Coordinate Time (TCG) time scale. source"},{"id":295,"pagetitle":"Low-level API","title":"Conversions","ref":"/Tempo/stable/lapi/#Conversions","content":" Conversions"},{"id":296,"pagetitle":"Low-level API","title":"Base.convert","ref":"/Tempo/stable/lapi/#Base.convert","content":" Base.convert  —  Function convert(to::S2, e::Epoch{S1}; system::TimeSystem=TIMESCALES) Convert  Epoch  with timescale  S1  to  S2 . Allows to use the default  TimeSystem  or  a custom constructed one.  source"},{"id":297,"pagetitle":"Low-level API","title":"Tempo.cal2jd","ref":"/Tempo/stable/lapi/#Tempo.cal2jd","content":" Tempo.cal2jd  —  Function cal2jd(year::Integer, month::Integer, day::Integer) This function converts a given date in the Gregorian calendar (year, month, day) to the  corresponding two-parts Julian Date. The first part is the  DJ2000 , while the  second output is the number of days since  J2000 . The year must be greater than 1583, and the month must be between 1 and 12. The day must  also be valid, taking into account whether the year is a leap year. If the input year or  month or day are invalid, a  DomainError  is thrown. Examples julia> Tempo.cal2jd(2021, 1, 1)\n(2.4000005e6, 59215.0)\n\njulia> Tempo.cal2jd(2022, 2, 28)\n(2.4000005e6, 59638.0)\n\njulia> Tempo.cal2jd(2019, 2, 29)\nERROR: DomainError with 29:\nthe day shall be between 1 and 28. References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). Klein, A., (2006), A Generalized Kahan-Babuska-Summation-Algorithm.   Computing, 76, 279-293, Section 3. ERFA software library source cal2jd(d::Date) Convert Gregorian calendar  Date  to a Julian Date, in days. Outputs j2000  – J2000 zero point: always 2451545 d  – J2000 Date for 12 hrs source"},{"id":298,"pagetitle":"Low-level API","title":"Tempo.calhms2jd","ref":"/Tempo/stable/lapi/#Tempo.calhms2jd","content":" Tempo.calhms2jd  —  Function calhms2jd(year, month, day, hour, minute, seconds) Convert Gregorian Calendar date and time to a two-parts Julian Date. The first part  is the  DJ2000 , while the second output is the number of days since  J2000 . Examples julia> Tempo.calhms2jd(2000, 1, 1, 12, 0, 0)\n(2.451545e6, 0.0)\n\njulia> Tempo.calhms2jd(2022, 1, 1, 0, 0, 0)\n(2.451545e6, 8035.5) source"},{"id":299,"pagetitle":"Low-level API","title":"Tempo.fd2hms","ref":"/Tempo/stable/lapi/#Tempo.fd2hms","content":" Tempo.fd2hms  —  Function fd2hms(fd::Number) Convert the day fraction  fd  to hour, minute and seconds. source"},{"id":300,"pagetitle":"Low-level API","title":"Tempo.fd2hmsf","ref":"/Tempo/stable/lapi/#Tempo.fd2hmsf","content":" Tempo.fd2hmsf  —  Function fd2hmsf(fd::Number) Convert the day fraction  fd  to hour, minute, second and fraction of seconds. Examples julia> Tempo.fd2hms(0.5)\n(12, 0, 0.0) source"},{"id":301,"pagetitle":"Low-level API","title":"Tempo.hms2fd","ref":"/Tempo/stable/lapi/#Tempo.hms2fd","content":" Tempo.hms2fd  —  Function hms2fd(hour::Integer, minute::Integer, second::Number) Convert hours, minutes and seconds to day fraction. Examples julia> Tempo.hms2fd(12, 0, 0.0)\n0.5 source"},{"id":302,"pagetitle":"Low-level API","title":"Tempo.jd2cal","ref":"/Tempo/stable/lapi/#Tempo.jd2cal","content":" Tempo.jd2cal  —  Function jd2cal(dj1::Number, dj2::Number) This function converts a given Julian Date (JD) to a Gregorian calendar date  (year, month, day, and fraction of a day). Examples julia> Tempo.jd2cal(DJ2000, 0.0)\n(2000, 1, 1, 0.5)\n\njulia> Tempo.jd2cal(DJ2000, 365.5)\n(2001, 1, 1, 0.0)\n\njulia> Tempo.jd2cal(DJ2000 + 365, 0.5)\n(2001, 1, 1, 0.0) Note The Julian Date is apportioned in any convenient way between the arguments   dj1  and  dj2 . For example,  JD = 2450123.7  could be expressed in any of these  ways, among others: dj1 dj2 2450123.7 0.0 (JD method) 2451545.0 -1421.3 (J2000 method) 2400000.5 50123.2 (MJD method) 2450123.5 0.2 (date & time method) Warning The earliest valid date is -68569.5 (-4713 Jan 1). The largest value accepted is 1e9. References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). Klein, A., (2006), A Generalized Kahan-Babuska-Summation-Algorithm.   Computing, 76, 279-293, Section 3. ERFA software library source"},{"id":303,"pagetitle":"Low-level API","title":"Tempo.jd2calhms","ref":"/Tempo/stable/lapi/#Tempo.jd2calhms","content":" Tempo.jd2calhms  —  Function jd2calhms(dj1::Number, dj2::Number) Convert a two-parts Julian Date to Gregorian year, month, day, hour, minute, seconds. See   jd2cal  for more information on the Julian Date composition.  julia> Tempo.jd2calhms(DJ2000, 0.0)\n(2000, 1, 1, 12, 0, 0.0)\n\njulia> Tempo.jd2calhms(DJ2000 + 1, 0.25)\n(2000, 1, 2, 18, 0, 0.0)\n\njulia> Tempo.jd2calhms(DJ2000, 1.25)\n(2000, 1, 2, 18, 0, 0.0) source"},{"id":304,"pagetitle":"Low-level API","title":"Tempo.tai2utc","ref":"/Tempo/stable/lapi/#Tempo.tai2utc","content":" Tempo.tai2utc  —  Function tai2utc(tai1, tai2) Transform a 2-part (quasi) Julian Date, in days, in International Atomic Time,  TAI   to a 2-part Julian Date in the Coordinated Universal Time,  UTC , scale. Note tai1 + tai2  is Julian Date, apportioned in any convenient way between the two arguments, for example such that  tai1  is the Julian Day Number and  tai2  is the fraction of a day.  The returned  utc1   and  utc2  form an analogous pair. Note JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.   References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) ERFA software library source"},{"id":305,"pagetitle":"Low-level API","title":"Tempo.utc2tai","ref":"/Tempo/stable/lapi/#Tempo.utc2tai","content":" Tempo.utc2tai  —  Function utc2tai(utc1, utc2) Transform a 2-part (quasi) Julian Date, in days, in Coordinate Universal Time,  UTC   to a 2-part Julian Date in the International Atomic Time,  TAI  scale. Note utc1 + utc2  is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example such that  utc1  is the Julian Day Number and  utc2  is the fraction of a day. Note JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.   References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) ERFA software library source"},{"id":306,"pagetitle":"Low-level API","title":"Leapseconds","ref":"/Tempo/stable/lapi/#Leapseconds","content":" Leapseconds"},{"id":307,"pagetitle":"Low-level API","title":"Tempo.Leapseconds","ref":"/Tempo/stable/lapi/#Tempo.Leapseconds","content":" Tempo.Leapseconds  —  Type Leapseconds{T} Stores information about the leap seconds that have been added to Coordinated Universal Time  (UTC). Fields lastupdate : a  DatesDateTime  object representing the date and time when the Leapseconds    struct was last updated. jd2000 : a vector storing the Julian Date, in days since J2000, of each leap second. leap : a vector storing the number of leap seconds at each corresponding entry of the         jd2000  field. source"},{"id":308,"pagetitle":"Low-level API","title":"Tempo.LEAPSECONDS","ref":"/Tempo/stable/lapi/#Tempo.LEAPSECONDS","content":" Tempo.LEAPSECONDS  —  Constant LEAPSECONDS Leapseconds data. source"},{"id":309,"pagetitle":"Low-level API","title":"Tempo.get_leapseconds","ref":"/Tempo/stable/lapi/#Tempo.get_leapseconds","content":" Tempo.get_leapseconds  —  Function get_leapseconds() Parse leapseconds data and return a  Leapseconds  type.  Note The leapsecond kernel is retrieved from the artifacts of this package. This artifact  will be updated whenever a new leapsecond is added. source"},{"id":310,"pagetitle":"Low-level API","title":"Tempo.leapseconds","ref":"/Tempo/stable/lapi/#Tempo.leapseconds","content":" Tempo.leapseconds  —  Function leapseconds(jd2000::Number) For a given UTC date, in Julian days since  J2000 , calculate Delta(AT) = TAI - UTC. source"},{"id":311,"pagetitle":"Low-level API","title":"Miscellaneous","ref":"/Tempo/stable/lapi/#Miscellaneous","content":" Miscellaneous"},{"id":312,"pagetitle":"Low-level API","title":"Tempo.find_year","ref":"/Tempo/stable/lapi/#Tempo.find_year","content":" Tempo.find_year  —  Function find_year(d::Integer) Return the Gregorian year associated to the given Julian Date day  d  since  J2000 . source"},{"id":313,"pagetitle":"Low-level API","title":"Tempo.find_month","ref":"/Tempo/stable/lapi/#Tempo.find_month","content":" Tempo.find_month  —  Function find_month(dayinyear::Integer, isleap::Bool) Find the month from the day of the year, depending on whether the year is leap or not. source"},{"id":314,"pagetitle":"Low-level API","title":"Tempo.find_day","ref":"/Tempo/stable/lapi/#Tempo.find_day","content":" Tempo.find_day  —  Function find_day(dayinyear::Integer, month::Integer, isleap::Bool) Find the day of the month from the day in the year and the month, depending on whether the  year is leap or not. source"},{"id":315,"pagetitle":"Low-level API","title":"Tempo.fraction_of_day","ref":"/Tempo/stable/lapi/#Tempo.fraction_of_day","content":" Tempo.fraction_of_day  —  Function fraction_of_day(t::Time)\nhms2fd(t::Time) Find the fraction of the day. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.fraction_of_day(t)\n0.5213002592592593 source"},{"id":316,"pagetitle":"Low-level API","title":"Tempo.fraction_of_second","ref":"/Tempo/stable/lapi/#Tempo.fraction_of_second","content":" Tempo.fraction_of_second  —  Function fraction_of_second(t::Time) Find the fraction of seconds. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.fraction_of_second(t)\n0.3423999999999978 source fraction_of_second(d::DateTime) Get the fraction of seconds associated to a  DateTime  object. source"},{"id":317,"pagetitle":"Low-level API","title":"Tempo.isleapyear","ref":"/Tempo/stable/lapi/#Tempo.isleapyear","content":" Tempo.isleapyear  —  Function isleapyear(year::Integer) Return  true  if the given Gregorian year is leap. source isleapyear(d::Date) True if  Date  is within a leap year. source"},{"id":318,"pagetitle":"Low-level API","title":"Tempo.lastj2000dayofyear","ref":"/Tempo/stable/lapi/#Tempo.lastj2000dayofyear","content":" Tempo.lastj2000dayofyear  —  Function lastj2000dayofyear(year::Integer) source"},{"id":319,"pagetitle":"Low-level API","title":"Tempo.second_in_day","ref":"/Tempo/stable/lapi/#Tempo.second_in_day","content":" Tempo.second_in_day  —  Function second_in_day(t::Time) Find the second in the day. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.second_in_day(t)\n45040.3424 source"},{"id":322,"pagetitle":"-","title":"Overview","ref":"/Tempo/stable/tmp/#Overview","content":" Overview There are different ways to represent an epoch within  Tempo , depending on the specific application. This section is here to help you choose the proper time representation and to present the capabilities of the module in transforming time between different representations. First of all, there is a deep difference in the way time is thought in the everyday life and  when dealing with space-related applications.  Whenever we say  the 12:35 of the 1st of January 2023 , we are merging three concepts:  the  calendar  ( 1st January 2023 ) and the  time representation  ( 12:35 ) together with its  scale . Calculations in any scientific discipline may involve precise time, but what  sets astronomy apart is the number and variety of  time scales  that have to be used. In fact, in astronomical applications the physical context of the “clock” matters, whether it is on Earth, moving or stationary, or on a spacecraft.  Time Conversions - The difference in each timescale is shown with \n    respect to TAI.  The most relevant time scales for these applications are: UT1  (Universal Time 1): UT1 is a time scale based on the rotation of the Earth.    It is used to measure the positions of celestial objects relative to the Earth's    surface. UT1 is closely related to  Greenwich Mean Time (GMT) , and the two time    scales are often used interchangeably. TAI  (International Atomic Time): TAI is a time scale based on the average    frequency of a set of atomic clocks. It is used to measure the positions of    celestial objects relative to the Earth's surface. TT  (Terrestrial Time): TT is a time scale based on the motion of celestial    objects around the solar system barycenter (the center of mass of the solar system).    It is used to measure the positions of celestial objects relative to the Earth's surface. TDB  (Barycentric Dynamical Time): TDB is a time scale based on the motion of    celestial objects around the solar system barycenter (the center of mass of the    solar system). It is used to measure the positions of celestial objects relative    to the solar system barycenter. TCB  (Barycentric Coordinate Time): TCB is a time scale based on the motion of    celestial objects around the solar system barycenter (the center of mass of the    solar system). It is used to measure the positions of celestial objects relative    to the solar system barycenter. TCG  (Geocentric Coordinate Time): TCG is a time scale based on the rotation of    the Earth. It is used to measure the positions of celestial objects relative to the    Earth's surface. Teph  (Ephemeris Time): Teph is a time scale based on the motion of celestial    objects around the solar system barycenter (the center of mass of the solar    system). It is used to measure the positions of celestial objects relative to    the solar system barycenter – here considered equivalent of  TDB . Of the seven time scales to be described here, one is atomic time (TAI),  one is solar time (UT1), one is an atomic/solar hybrid (UTC) and four are  dynamical times (TT, TCG, TCB, TDB). Other time scales of interest may also be the  ones associated to the different positioning systems. In particular:  GPS  (Global  Positioning System),  GLONASS  (Global Navigation Satellite System) and  GALILEO   (Global Navigation Satellite System) times could be defined as a constant offset with respect to TAI."},{"id":323,"pagetitle":"-","title":"Time in  JSMD","ref":"/Tempo/stable/tmp/#Time-in-JSMD","content":" Time in  JSMD Within  Tempo , the way in which time is represented in  Tempo  is through the use of   Epoch s.  Epoch s are an efficient, differentiable and precise way to represent  astronomical time. To parse an epoch object, two parameters shall be assigned: Timescale : This parameter determines the timescale that the epoch is based on.    For example, it can be set to UTC, TAI, TDB, or TCB. This allows the user to convert    the epoch between different timescales if necessary. Origin : This parameter determines the origin of the epoch, which is the point in time    from which the epoch is measured. This can be in the form of a Julian date, a   Modified Julian date or any user-defined origin.    The origin can also be set to a specific event, such as J2000.0 or B1950.0. By assigning these two parameters,  Epoch s can be used to represent time in a precise  manner, which is crucial for accurate timekeeping and coordination of events in a universe model."},{"id":326,"pagetitle":"Epochs","title":"Epochs Handling and Conversions","ref":"/Tempo/stable/tutorials/t01_epochs/#tutorial_01_epochs","content":" Epochs Handling and Conversions In this tutorial, the general workflow to be followed when dealing with time representations and their transformations is presented. In particular, most of the features of this package are designed around the  Epoch  data type, which differently from the  DateTime  object, provides the capability to represent time in different standard and user-define time scales."},{"id":327,"pagetitle":"Epochs","title":"Creating Epochs","ref":"/Tempo/stable/tutorials/t01_epochs/#Creating-Epochs","content":" Creating Epochs Time representions for space applications embed three different concepts:  The representation type (e.g. Gregorian or Julian calendar representation) The origin (e.g. J2000, JD, MJD, ...) The time scale (e.g. TAI, TT, TDB, UTC, UT, ...) All three infromation are considered when building an  Epoch . In particular, within  Tempo , the (interal) time representation is always based upon the Julian calendar, with the origin fixed at  J2000 , i.e., the 1st of January 2000 at noon. Different timescales are instead available, with the default one being the  TDB . The set of pre-defined time scales supported by this package is:  TT :  Terrestrial Time , is a time scale that is used for the prediction or recording of the positions of celestial bodies as measured by an observer on Earth.  TDB :  Barycentric Dynamical Time  is a relativistic time scale that is used for the prediction or recording of the positions of celestial bodies relative to the solar system's barycenter. TAI :  International Atomic Time  is a time scale based on the average frequency of a set of atomic clocks. TCG :  Geocentric Coordinate Time  is a relativistic coordinate time scale that is used for precise calculations of objects relative to the Earth.  TCB :  Barycentric Coordinate Time  is a relativistic coordinate time scale that is used for precise calculations of objects in the Solar System. UTC :  Coordinated Universal Time  is the primary civil time standard which is kept within one second from the mean solar time (UT1). However, since the rotation of the Earth is irregular, leap seconds are periodically inserted to keep UTC within 0.9 seconds of UT1.  TDBH : Although TDBH is not an official time scale, it is here used to provide a more accurate transformation between  TT  and  TDB , with a maximum error fo about 10 μs between 1600 and 2200. See  Tempo.offset_tt2tdbh  for more details.  GPS :  GPS Time  is a continuous time scale defined by the GPS Control segment defined as a constant offset of 19s from  TAI ."},{"id":328,"pagetitle":"Epochs","title":"ISO Strings","ref":"/Tempo/stable/tutorials/t01_epochs/#ISO-Strings","content":" ISO Strings With this in mind, many different ways are available to create a new  Epoch  object. The first is based upon the  ISO 8601  concept, an international standard to represent dates and times. The desired timescale can be either specified by appending its acronym to the string or as a second argument, as follows: julia> e = Epoch(\"2022-01-02T06:30:00.0 TT\") 2022-01-02T06:29:59.9999 TT julia> e = Epoch(\"2022-01-02T06:30:00.0\") 2022-01-02T06:29:59.9999 TDB julia> e = Epoch(\"2022-01-02T06:30:00.0\", TAI) 2022-01-02T06:29:59.9999 TAI As you can see, when we did not specify a timescale,  TDB  has been used by default. The usage of partial ISO strings is also supported: julia> e = Epoch(\"2020-01-01\") 2020-01-01T00:00:00.0000 TDB julia> e = Epoch(\"2021-01-30T01\") 2021-01-30T01:00:00.0000 TDB julia> e = Epoch(\"2022-06-12 UTC\") 2022-06-12T00:00:00.0000 UTC"},{"id":329,"pagetitle":"Epochs","title":"Julian Dates","ref":"/Tempo/stable/tutorials/t01_epochs/#Julian-Dates","content":" Julian Dates Epoch  objects can also be created from Julian Dates, Modified Julian Dates as well as Julian days or seconds since  J2000 . To parse a Julian Date, in days, the input string must be in the format  JD DDDDDDDDD.ffffff : julia> e = Epoch(\"JD 2451545.04\") 2000-01-01T12:57:36.0000 TDB julia> e = Epoch(\"JD 2451545.04 TT\") 2000-01-01T12:57:36.0000 TT Similarly, for Modified Julian Dates, the string format is  MJD DDDDDDDDD.ffffff : julia> e = Epoch(\"MJD 51544.54\") 2000-01-01T12:57:36.0000 TDB julia> e = Epoch(\"MJD 51544.54 TT\") 2000-01-01T12:57:36.0000 TT When a prefix is not specified, the epoch constructor assumes the input is expressed as Julian days since  J2000 : julia> e = Epoch(\"9.0\") 2000-01-10T12:00:00.0000 TDB julia> e = Epoch(\"9.0 TT\") 2000-01-10T12:00:00.0000 TT As you can see, the timescale acronym can always be appended to the predefined string format to override the default time scale. Finally, it is also possible to create an epoch by specifing the number of seconds since  J2000 . In the latter case, the constructor has a slightly different form and always requires the timescale argument: julia> e = Epoch(60.0, TT) 2000-01-01T12:01:00.0000 TT julia> e = Epoch(60.0, TerrestrialTime) 2000-01-01T12:01:00.0000 TT julia> e = Epoch{TerrestrialTime}(60.0) 2000-01-01T12:01:00.0000 TT"},{"id":330,"pagetitle":"Epochs","title":"DateTime","ref":"/Tempo/stable/tutorials/t01_epochs/#DateTime","content":" DateTime Finally, an  Epoch  can also be constructed from the  DateTime  object defined within this package: julia> dt = DateTime(2001, 6, 15, 0, 0, 0, 0.0) 2001-06-15T00:00:00.0000 julia> e = Epoch(dt, TT) 2001-06-15T00:00:00.0000 TT julia> e = Epoch(dt, TerrestrialTime) 2001-06-15T00:00:00.0000 TT"},{"id":331,"pagetitle":"Epochs","title":"Working with Epochs","ref":"/Tempo/stable/tutorials/t01_epochs/#Working-with-Epochs","content":" Working with Epochs"},{"id":332,"pagetitle":"Epochs","title":"Basic Operations","ref":"/Tempo/stable/tutorials/t01_epochs/#Basic-Operations","content":" Basic Operations The  Epoch  type supports a limited subset of basic mathematical and logical operations on it. For example, the offset, in seconds, between two epochs can be computed by subtracting them:  julia> e1 = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> e2 = Epoch(50.0, TT) 2000-01-01T12:00:50.0000 TT julia> e1 - e2 40.0 julia> e3 = Epoch(40, TAI) 2000-01-01T12:00:40.0000 TAI julia> e1 - e3 ERROR: only epochs defined in the same timescale can be subtracted. Notice that this operation can be performed only if the two epochs are defined on the same timescale. Epochs can also be shifted forward and backwards in time by adding or subtracting an arbitrary number of seconds:  julia> e1 = Epoch(30.0, TDB) 2000-01-01T12:00:30.0000 TDB julia> e1 += 50 2000-01-01T12:01:20.0000 TDB julia> e1 -= 30.42 2000-01-01T12:00:49.5800 TDB You can check whether an epoch is greater than an other with the logical operators: julia> e1 = Epoch(50.0, UTC) 2000-01-01T12:00:50.0000 UTC julia> e2 = Epoch(50.0, UTC) 2000-01-01T12:00:50.0000 UTC julia> e1 > e2 false julia> e1 == e2 true Again, the operations are supported only if the two epochs belong to the same timescale. Finally, it is also possible to construct ranges with  Epoch s, with a default timestep of one Julian day. User-defined timesteps are assumed to be expressed in seconds. julia> e1 = Epoch(\"2024-01-01T12:00:00\") 2024-01-01T12:00:00.0000 TDB julia> e2 = Epoch(\"2024-01-05T12:00:00\") 2024-01-05T12:00:00.0000 TDB julia> collect(e1:e2) 5-element Vector{Epoch{BarycentricDynamicalTime, Float64}}:\n 2024-01-01T12:00:00.0000 TDB\n 2024-01-02T12:00:00.0000 TDB\n 2024-01-03T12:00:00.0000 TDB\n 2024-01-04T12:00:00.0000 TDB\n 2024-01-05T12:00:00.0000 TDB julia> collect(e1:172800:e2) 3-element Vector{Epoch{BarycentricDynamicalTime, Float64}}:\n 2024-01-01T12:00:00.0000 TDB\n 2024-01-03T12:00:00.0000 TDB\n 2024-01-05T12:00:00.0000 TDB"},{"id":333,"pagetitle":"Epochs","title":"Julian Dates","ref":"/Tempo/stable/tutorials/t01_epochs/#Julian-Dates-2","content":" Julian Dates A predefined set of functions is also provided to easily convert [ Epoch ] objects to Julian seconds, days and centuries since  J2000 : julia> e = Epoch(\"2024-01-01T12:00:00 TAI\") 2024-01-01T12:00:00.0000 TAI julia> j2000(e) 8766.0 julia> j2000s(e) 7.573824e8 julia> j2000c(e) 0.24"},{"id":334,"pagetitle":"Epochs","title":"Converting Between Time Scales","ref":"/Tempo/stable/tutorials/t01_epochs/#Converting-Between-Time-Scales","content":" Converting Between Time Scales Epoch transformations between the standard and user-defined timescales are simply performed through the  convert  method by specifying the target time scale julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eTAI = convert(TAI, e) 2000-01-01T12:00:57.8160 TAI julia> eTCG = convert(TCG, e) 2000-01-01T12:01:30.5058 TCG These transformations are based on a  directed  graph of timescales ( TIMESCALES ) existing within  Tempo . Set of functions provide then the offsets in seconds between each pair of connected timescales, offering a simple, effective and efficient way to compute these transformations. julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eTAI = convert(TAI, e) 2000-01-01T12:00:57.8160 TAI"},{"id":335,"pagetitle":"Epochs","title":"UTC and Leap Seconds","ref":"/Tempo/stable/tutorials/t01_epochs/#UTC-and-Leap-Seconds","content":" UTC and Leap Seconds A special remark must be made on the conversion between TAI and UTC. The offset between these two timescales is defined by a leap seconds, which are introduced to keep the UTC time scale within 0.9 seconds from UT1. Since the rotation of the Earth is irregular, it is not possible to predict when a new leap second will be introduced in the future.  The latest NAIF's leap second kernel ( LSK ) is embedded within  Tempo  as a package artifact, which will be manually updated each time a new kernel is released, so that the user effort is minimised. Indeed, transforming an  Epoch  from a generic timescale to UTC is a simple as: julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eUTC = convert(UTC, e) 2000-01-01T12:00:25.8159 UTC"},{"id":336,"pagetitle":"Epochs","title":"UTC to UT1","ref":"/Tempo/stable/tutorials/t01_epochs/#UTC-to-UT1","content":" UTC to UT1 The offset between UT1 and UTC, which depends upon the rotation of the Earth, is available in the Earth Orientation Parameters (EOP) provided by the International Earth Rotation and Reference System Service ( IERS ). Since those parameters are also required to compute the orientation of the ITRF with respect to the ICRF, a decision has been made to define the UT1 timescale in  FrameTransformations.jl , a different package which enhances  Tempo  with the capability to transform from and to UT1."},{"id":339,"pagetitle":"Custom Timescales","title":"Creating Custom Timescales","ref":"/Tempo/stable/tutorials/t02_scales/#tutorial_02_scales","content":" Creating Custom Timescales In Tempo.jl, all timescales connections and epoch conversions are handled through a  directed graph .  A default graph ( TIMESCALES ), containing a set of predefined timescales is provided by this package. However, this package also provided a set of routines to either extend such graph or create a completely custom one. In this tutorial, we will explore both alternatives."},{"id":340,"pagetitle":"Custom Timescales","title":"Defining a New Timescale","ref":"/Tempo/stable/tutorials/t02_scales/#Defining-a-New-Timescale","content":" Defining a New Timescale Custom timescales can be created with the  @timescale  macro, which automatically creates the required types and structures, given the timescale acronym, an integer ID and, eventually, the full name of the timescale.  julia> @timescale ET 15 EphemerisTime The ID is an integer that is internally used to uniquely represent the timescale, whereas the acronym is used to alias such ID. It is also possible to define multiple acronyms associated to the same ID but you cannot assign multiple IDs to the same acronym. In case a full name is not provided, a default one will be built by appending  TimeScale  to the acronym. Warning The IDs from 1 to 10 are used to define the standard timescales of the package. To avoid unexpected behaviors, custom timescales should be registered with higher IDs. In the previous example, we have created a custom timescale named  EphemerisTime , with ID 15. We are now able to define epochs with respect to ET, but we cannot perform conversions towards other timescales until we register it in a graph system: julia> ep = Epoch(20.425, ET) 2000-01-01T12:00:20.4249 ET julia> convert(TT, ep) ERROR: EpochConversionError: cannot convert Epoch from the timescale Main.EphemerisTime to TerrestrialTime."},{"id":341,"pagetitle":"Custom Timescales","title":"Extending the Default Graph","ref":"/Tempo/stable/tutorials/t02_scales/#Extending-the-Default-Graph","content":" Extending the Default Graph In this section, the goal is to register ET as a zero-offset scale with respect to  TDB . To register this timescale in the default graph, we first need to define the offset functions of ET with respect to TDB:  julia> offset_tdb2et(sec::Number) = 0 offset_tdb2et (generic function with 1 method) julia> offset_et2tdb(sec::Number) = 0 offset_et2tdb (generic function with 1 method) Since we have assumed that the two scales are identical, our functions will always return a zero offset. Rememeber that timescales graph is  directed , meaning that if the user desires to go back and forth between two timescales, both transformations must be defined. The input argument of such functions is always the number of seconds since J2000 expressed in the origin timescale. Finally, the  add_timescale!  method can be used to register ET within the default graph: julia> add_timescale!(TIMESCALES, ET, offset_tdb2et, parent=TDB, ftp=offset_et2tdb) If the inverse transformation (from ET to TDB) is not provided, only one-way epoch conversions will be allowed. We can now check that the desired timescale has been properly registered and performs the same as TDB:  julia> ep = Epoch(\"200.432 TT\") 2000-07-19T22:22:04.8000 TT julia> convert(TDB, ep) 2000-07-19T22:22:04.7995 TDB julia> convert(ET, ep) 2000-07-19T22:22:04.7995 ET"},{"id":342,"pagetitle":"Custom Timescales","title":"Creating a Custom Graph","ref":"/Tempo/stable/tutorials/t02_scales/#Creating-a-Custom-Graph","content":" Creating a Custom Graph To create a custom directed graph to handle timescales, Tempo.jl provides the  TimeSystem  type. Therefore, let us define a new time transformation system called  TIMETRANSF : julia> const TIMETRANSF = TimeSystem{Float64}() TimeSystem{Float64}(SMDGraphs.MappedNodeGraph{Tempo.TimeScaleNode{Float64}, Graphs.SimpleGraphs.SimpleDiGraph{Int64}}(Graphs.SimpleGraphs.SimpleDiGraph{Int64}(0, Vector{Int64}[], Vector{Int64}[]), Dict{Int64, Int64}(), Tempo.TimeScaleNode{Float64}[], Dict{Int64, Dict{Int64, Vector{Int64}}}(), Dict{Int64, Dict{Int64, Int64}}())) This object contains a graph and the properties associated to the new time-system defined in  TIMETRANSF . At the moment, the computational graph is empty and we need to manually populate it with the new transformations. We begin by creating a new timescale:  julia> @timescale DTS 1 DefaultTimeScale Once created, the new timescale is ready to be registered. If it is the first scale registered in the computational graph, nothing else than the type alias is needed and the registration can be performed as follows: julia> add_timescale!(TIMETRANSF, DTS) julia> TIMETRANSF.scales.nodes 1-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1) Instead, in case the timescale is linked to a parent one, offset functions shall be defined. In this example, assume we want to register the timescales  NTSA  and  NTSB  such that  NTSA  has  DTS  as parent and a constant offset of 1 second, whereas NTSB  has  NTSA  as parent and a linear offset with slope of 1/86400. We begin by creating the first timescale: julia> @timescale NTSA 2 NewTimeScaleA We then define its offset functions and register it in  TIMETRANSF  via the  add_timescale!  method: julia> const OFFSET_DTS_TO_NTSA = 1.0 1.0 julia> offset_dts2ntsa(sec::Number) = OFFSET_DTS_TO_NTSA offset_dts2ntsa (generic function with 1 method) julia> offset_ntsa2dts(sec::Number) = -OFFSET_DTS_TO_NTSA offset_ntsa2dts (generic function with 1 method) julia> add_timescale!(TIMETRANSF, NTSA, offset_dts2ntsa, parent=DTS, ftp=offset_ntsa2dts) Now, if we have a look to the computational graph, we'll see that  NTSA  is registered: julia> TIMETRANSF.scales.nodes 2-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1)\n\n TimeScaleNode{Float64}(name=NTSA, id=2, parent=1) If now we create a  DTS  epoch, we can leverage our custom time transformation system to convert it to an epoch in the  NTSA  timescale: julia> e = Epoch(0.0, DTS) 2000-01-01T12:00:00.0000 DTS julia> convert(NTSA, e, system=TIMETRANSF) 2000-01-01T12:00:01.0000 NTSA Whenever the conversions are based on a custom time system, the graph must be provided as an additional argument to the  convert  method.  To conclude the example, we will now add the  NTSB  scale but only register the  NTSA -> NTSB  transformation: julia> @timescale NTSB 3 NewTimeScaleB julia> offset_ntsa2ntsb(sec::Number) = sec/86400.0 offset_ntsa2ntsb (generic function with 1 method) julia> add_timescale!(TIMETRANSF, NTSB, offset_ntsa2ntsb, parent=NTSA) Now, let's have a look to the nodes in the graph: julia> TIMETRANSF.scales.nodes 3-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1)\n\n TimeScaleNode{Float64}(name=NTSA, id=2, parent=1)\n\n TimeScaleNode{Float64}(name=NTSB, id=3, parent=2) You can see that the new timescale has been registered with the desired integer ID  3 . To test the complete system, we will translate forwad of 2 days the previous epoch  e  and transform it in both timescales:  julia> e += 2*86400 2000-01-03T12:00:00.0000 DTS julia> ea = convert(NTSA, e, system=TIMETRANSF) 2000-01-03T12:00:01.0000 NTSA julia> eb = convert(NTSB, e, system=TIMETRANSF) 2000-01-03T12:00:03.0000 NTSB As expected, we obtain translations of 1 and 3 seconds, respectively."},{"id":345,"pagetitle":"Home","title":"Welcome to FrameTransformations.jl!","ref":"/FrameTransformations/stable/#Welcome-to-FrameTransformations.jl!","content":" Welcome to FrameTransformations.jl! A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame. Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, this package is the ideal starting point. FrameTransformations.jl is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. "},{"id":346,"pagetitle":"Home","title":"Features","ref":"/FrameTransformations/stable/#Features","content":" Features Convert between different time scales and representations (via  Tempo.jl ); Read binary ephemeris files (via  Ephemerides.jl  or  CalcephEphemeris.jl ) Create custom reference frame systems with both standard and user-defined points and axes. Transform states and their higher-order derivatives between different frames (up to jerk) All of this seamlessly integrated with  ForwardDiff.jl ."},{"id":347,"pagetitle":"Home","title":"Installation","ref":"/FrameTransformations/stable/#Installation","content":" Installation This package can be installed using Julia's package manager:  julia> import Pkg\n\njulia> Pkg.add(\"FrameTransformations.jl\");"},{"id":350,"pagetitle":"Public API","title":"Frames's Public Documentation","ref":"/FrameTransformations/stable/Modules/frames_api/#basic_frames_api","content":" Frames's Public Documentation"},{"id":351,"pagetitle":"Public API","title":"Frame System","ref":"/FrameTransformations/stable/Modules/frames_api/#Frame-System","content":" Frame System"},{"id":352,"pagetitle":"Public API","title":"FrameTransformations.Frames.FrameSystem","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.FrameSystem","content":" FrameTransformations.Frames.FrameSystem  —  Type FrameSystem{O, T, S, E} A  FrameSystem  instance manages a collection of user-defined  FramePointNode  and   FrameAxesNode  objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order  O , the outputs  datatype  T  and an  AbstractTimeScale  instance  S . Additionally, an  AbstractEphemerisProvider   instance  E  can be provided to compute transformations that require ephemeris data.  The following transformation orders are accepted:  1 : position  2 : position and velocity  3 : position, velocity and acceleration 4 : position, velocity, acceleration and jerk By specifying the maximum transformation the  FrameSystem  memory usage and performance can  be optimised and tailored to the user's needs. FrameSystem{O, T}() Create a  FrameSystem  object of order  O  and datatype  T . The  BarycentricDynamicalTime   is automatically assigned as the default time scale. The resulting object is constructed  with a  NullEphemerisProvider , which does not allow the computation of transformation that  involve ephemeris files. Examples julia> F = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> rotation6(F, ICRF, ECLIPJ2000, 0.0)\nRotation{2, Float64}\n[...]\n\njulia> rotation9(F, ICRF, ECLIPJ2000, 0.0)\nERROR: Insufficient frame system order: transformation requires at least order 3.\n FrameSystem{O, T, S}() Create a  FrameSystem  object of order  O , datatype  T  and time scale  S . The resulting  object is constructed with a  NullEphemerisProvider , which does not allow the computation  of transformation that involve ephemeris files. Examples julia> F = FrameSystem{1, Float64, TerrestrialTime}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> ep_tt = Epoch(\"2023-02-10T12:00:00 TT\")\n2023-02-10T12:00:00.000 TT\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tt)\nRotation{1,Float64}([...])\n\njulia> ep_tdb = Epoch(\"2023-02-10T12:00:00 TDB\")\n2023-02-10T12:00:00.000 TDB\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tdb)\nERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.\n[...] FrameSystem{O, T}(eph::AbstractEphemerisProvider) Create a  FrameSystem  object of order  O  and datatype  T  by providing an instance of an   AbstractEphemerisProvider  subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in  eph . This constructor shall be used when the user desires  to compute transformations that involve ephemeris data.  Note All the kernels that will be used must be loaded within  eph . Once the  FrameSystem   has been created, no additional kernel can be added nor removed. Examples julia> eph = CalcephProvider(DE440_KERNEL_PATH)\nCalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0))\n\njulia> F = FrameSystem{2, Float64}(eph)\nFrameSystem{2, Float64, BarycentricDynamicalTime, CalcephProvider}(\n  eph: CalcephProvider(CALCEPH.Ephem(Ptr{Nothing} @0x0000000009e210c0)),\n  points: EMPTY\n  axes: EMPTY\n) See also See also  add_axes_inertial! ,  add_point_root! ,  vector3  and  rotation3 source"},{"id":353,"pagetitle":"Public API","title":"Axes","ref":"/FrameTransformations/stable/Modules/frames_api/#Axes","content":" Axes"},{"id":354,"pagetitle":"Public API","title":"FrameTransformations.Frames.@axes","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.@axes","content":" FrameTransformations.Frames.@axes  —  Macro @axes(name, id, type=nothing) Define a new axes instance to alias the given  id . This macro creates an   AbstractFrameAxes  subtype and its singleton instance callen  name . Its type name  is obtained by appending  Axes  to either  name  or  type  (if provided).  Examples julia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> typeof(ICRF)\nInternationalCelestialReferenceFrameAxes\n\njulia> axes_alias(ICRF) \n1\n\njulia> @axes IAU_EARTH 10013\n\njulia> typeof(IAU_EARTH)\nIauEarthAxes See also See also  @point  and  axes_alias . source"},{"id":355,"pagetitle":"Public API","title":"FrameTransformations.Frames.axes_alias","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.axes_alias","content":" FrameTransformations.Frames.axes_alias  —  Function axes_alias(ax::AbstractFrameAxes) Return the axes ID.  source"},{"id":356,"pagetitle":"Public API","title":"FrameTransformations.Frames.is_inertial","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.is_inertial","content":" FrameTransformations.Frames.is_inertial  —  Function is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)\nis_inertial(frame::FrameSystem, axesid::Int) Return true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes. Note FixedOffsetAxes with respect to an inertial set of axes, are also consired inertial. source"},{"id":357,"pagetitle":"Public API","title":"FrameTransformations.Frames.is_timefixed","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.is_timefixed","content":" FrameTransformations.Frames.is_timefixed  —  Function is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)\nis_timefixed(frame::FrameSystem, axesid::Int) Return true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes.  Note Only  :InertialAxes  and  :FixedOffsetAxes  defined with respect to other inertial axes  are here considered as time fixed.  source"},{"id":358,"pagetitle":"Public API","title":"FrameTransformations.Frames.ComputableAxesVector","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.ComputableAxesVector","content":" FrameTransformations.Frames.ComputableAxesVector  —  Type ComputableAxesVector(from, to, order::Int) Store the properties required to retrieve the i-th order components of a  desired vector. Arguments  from  and  to  are the NAIFIDs or  AbstractFramePoint  instances  that define the observer and target points. Only orders between 1 and 3 are supported. Example julia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> ComputableAxesVector(SSB, Sun, 1)\nComputableAxesVector(0, 10, 1)\n\njulia> ComputableAxesVector(0, 10, 1)\nComputableAxesVector(0, 10, 1) source"},{"id":359,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_bci2000!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_bci2000!","content":" FrameTransformations.Frames.add_axes_bci2000!  —  Function add_axes_bci2000!(frames::FrameSystem{O, T}, \n    data::AbstractDict, center::AbstractFramePoint, \n    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O} Insert Body-Centered Inertial (BCI) axes at J2000 relative to the body  center  to the   frames  system. Input/s frames  - The frame system to which the new frame will be added. data  - A dictionary containing a parsed  TPC  file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data. center : The center point of the new axes. axes : The new axes to be added to the frame system. parent : The parent axes of the new ones. Warning The  parent  set of axes must be the International Celestial Reference Frame (ICRF).  If the  parent  set of axes is not ICRF, an error is thrown. source"},{"id":360,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_bcrtod!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_bcrtod!","content":" FrameTransformations.Frames.add_axes_bcrtod!  —  Function add_axes_bcrtod!(frames::FrameSystem{O, T}, \n    data::AbstractDict, center::AbstractFramePoint, \n    axes::AbstractFrameAxes, parent::AbstractFrameAxes) where {T, O} Insert a Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the  frames  system. Input/s frames  - The frame system to which the new frame will be added. data  - A dictionary containing a parsed  TPC  file. The dictionary as has keys the NAIFId    of the bodies contained in the file, and as values a dictionary containing the keywords    and the values of the file's data. center : The center point of the new axes. axes : The new axes to be added to the frame system. parent : The parent axes of the new ones. Note The axes constructed here corresponds to the SPICE  IAU_<BODY_NAME>  frames.  Warning The  parent  set of axes must be the International Celestial Reference Frame (ICRF).  If the  parent  set of axes is not ICRF, an error is thrown. source"},{"id":361,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_computable!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_computable!","content":" FrameTransformations.Frames.add_axes_computable!  —  Function add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol) Add  axes  as a set of computable axes to  frames . Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE's parameterized two-vector frames.  These axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis.  The primary and secondary vectors,  v1  and  v2  are instances of  ComputableAxesVector ,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration).  For example, to define a primary vector that is parallel to the Sun's (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0),  v1  must be set as:   v1 = ComputableAxesVector(10, 0, 1) . seq  is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ  and  :ZY .  Given a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf's nadir direction and  velocity direction define the axes orientation.   Note Regardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to  parent . Examples julia> eph = CalcephProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{4, Float64}(eph);\n\njulia> @point SSB 0 SolarySystemBarycenter \n\njulia> @point Sun 10 \n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun, SSB)\n\njulia> @axes SunFrame 2\n\njulia> v1 = ComputableAxesVector(10, 0, 1)\nComputableAxesVector(10, 0, 1)\n\njulia> v2 = ComputableAxesVector(10, 0, 2)\nComputableAxesVector(10, 0, 2)\n\njulia> add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY) See also See also  ComputableAxesVector ,  add_axes_fixedoffset! ,  add_axes_inertial!   and  add_axes_computable! source"},{"id":362,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_eclipj2000!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_eclipj2000!","content":" FrameTransformations.Frames.add_axes_eclipj2000!  —  Function add_axes_eclipj2000!(frames, axes, parent::AbstractFrameAxes, iau_model::IAUModel=iau1980) Add  axes  as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to  frames . The obliquity of the ecliptic is computed using the IAU Model  iau_model . The admissed  parent  set of axes are the following:  ICRF : for the International Celestial Reference Frame, with ID = 1 MEME2000 : the Mean Earth/Moon Ephemeris of J2000, with ID = 22 Warning If the name (or the axes ID) of the parent set of  axes  is neither ICRF (ID = 1) nor  MEME2000 (ID = 22), an error is thrown.  Examples julia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes ECLIPJ2000 17 EclipticEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF) See also See also  add_axes_inertial!  and  Orient.DCM_ICRF_TO_J2000_BIAS source"},{"id":363,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_ephemeris!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_ephemeris!","content":" FrameTransformations.Frames.add_axes_ephemeris!  —  Function add_axes_ephemeris!(frames, axes, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Add  axes  as a set of ephemeris axes to  frames . The orientation of these axes is computed  with a series of 3 rotations specified by  rot_seq . The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in  frames . The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels. The rotation sequence is defined by a  Symbol  specifing the rotation axes. This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i-th  rotation.  The possible  rot_seq  values are:  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,  :YXZ ,  :YZX ,   :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ . Alternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives.  This operation is only possible if the ephemeris kernels loaded within  frames  contain  orientation data for the AXES ID associated to  axes . An error is returned if the parent  axes ID is yet to be added to  frames. Warning It is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels. See also See also  ComputableAxesVector ,  add_axes_fixedoffset! ,  add_axes_inertial!   and  add_axes_computable! source"},{"id":364,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_fixedoffset!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_fixedoffset!","content":" FrameTransformations.Frames.add_axes_fixedoffset!  —  Function add_axes_fixedoffset!(frames::FrameSystem{T}, axes, parent, dcm::DCM{T}) where T Add  axes  as a set of fixed offset axes to  frames . Fixed offset axes have a constant  orientation with respect to their  parent  axes, represented by  dcm , a Direction Cosine Matrix (DCM). add_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DMC{T}) where {T} Add new axes  name  with id  axesid  to  frames  with a fixed-offset from  parentid .   Low-level function. Note While inertial axes do not rotate with respect to the star background, fixed offset axes are only  constant with respect to their parent axes, but might be rotating with respect to some other  inertial axes. Examples julia> FRAMES = FrameSystem{1, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z)) See also See also  add_axes_rotating! ,  add_axes_inertial!  and  add_axes_computable! source"},{"id":365,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_inertial!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_inertial!","content":" FrameTransformations.Frames.add_axes_inertial!  —  Function add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing) Add  axes  as a set of inertial axes to  frames . Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added,  parent  and  dcm   become mandatory fields. add_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing) Add new axes  name  with id  axesid  to  frames .  Low-level function. Note The parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000)\nERROR: A set of parent axes for ECLIPJ2000 is required\n[...]\n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z)) See also See also  add_axes_rotating! ,  add_axes_fixedoffset!  and  add_axes_computable! source"},{"id":366,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_itrf!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_itrf!","content":" FrameTransformations.Frames.add_axes_itrf!  —  Function add_axes_itrf!(frames, axes, parent, model::Orient.IAU2006Model=Orient.iau2006b) Add  axes  as a set of axes representing the International Terrestrial Reference Frame (ITRF) to  frames . Only the :ICRF and :GCRF are accepted as  parent  axes. Use the  model  argument  to specify which IAU model model should be used for the computations. The default is set to   iau2006b . See also See also  orient_rot3_itrf_to_gcrf source"},{"id":367,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_me421!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_me421!","content":" FrameTransformations.Frames.add_axes_me421!  —  Function add_axes_me421!(frames, axes, parent) Add  axes  as fixed offset axes representing the DE421 Moon's Mean Earth/Mean Rotation (ME)  to  frames . The  parent  set of axes can be either the DE440 Principal Axes (PA440) or the DE421  Principal Axes (PA421), otherwise an error is thrown. Depending on that, the relative axes  orientation will be automatically selected by this function.  See also See also [`add_axes_pa440!`](@ref), and [`add_axes_pa421!`](@ref), \n[`Orient.DCM_MOON_PA421_TO_ME421`](@ref) and [`Orient.DCM_MOON_PA421_TO_ME421`](@ref), source"},{"id":368,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_meme2000!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_meme2000!","content":" FrameTransformations.Frames.add_axes_meme2000!  —  Function add_axes_meme2000!(frames::, axes, parent::AbstractFrameAxes) Add  axes  as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to  frames .  Warning The name (or the axes ID) of the parent set of axes must be  ICRF  (i.e., the International  Celestial Reference Frame, ID = 1), or the  ECLIPJ2000  (i.e., the Ecliptic Equinox of 7 J2000, ID = 17), otherwise and error is thrown. Examples julia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_meme2000!(FRAMES, MEME2000, ICRF) See also See also  add_axes_inertial!  and  Orient.DCM_ICRF_TO_J2000_BIAS source"},{"id":369,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_mememod!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_mememod!","content":" FrameTransformations.Frames.add_axes_mememod!  —  Function add_axes_mememod!(frames, axes, parent::AbstractFrameAxes, model::IAU2006Model=iau2006b) Add  axes  as a set of projected axes representing the Mean of Date Ecliptic Equinox to   frames .  Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The name of the  parent  set of axes must be the ICRF or have ID = 1 (i.e., the  International Celestial Reference Frame), otherwise an error is thrown.  source"},{"id":370,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_pa421!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_pa421!","content":" FrameTransformations.Frames.add_axes_pa421!  —  Function add_axes_pa421!(frames, axes, parent) Add  axes  as a set of ephemeris axes representing the DE421 Moon's Principal Axes (PA) to   frames . The libration angles are extracted from the ephemeris kernels loaded within  frames ,  an error is thrown if such orientation data is not available.  The  parent  set of axes must be named  ICRF  or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown. Warning To properly read the ephemeris kernels, the ID associated to the input  axes  must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006). See also See also [`Orient.AXESID_MOONPA_DE421`](@ref), [`Orient.orient_icrf_to_pa421`](@ref), \n[`add_axes_pa440!`](@ref), and [`add_axes_me421!`](@ref) source"},{"id":371,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_pa440!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_pa440!","content":" FrameTransformations.Frames.add_axes_pa440!  —  Function add_axes_pa440!(frames, axes, parent) Add  axes  as a set of ephemeris axes representing the DE440 Moon's Principal Axes (PA) to   frames . The libration angles are extracted from the ephemeris kernels loaded within  frames ,  an error is thrown if such orientation data is not available.  The  parent  set of axes must be named  ICRF  or have ID = 1 (i.e., the International  Celestial Reference Frame), otherwise and error is thrown. Warning To properly read the ephemeris kernels, the ID associated to the input  axes  must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008). See also See also  Orient.AXESID_MOONPA_DE440 ,  Orient.orient_rot3_icrf_to_pa440 ,   add_axes_pa421! , and  add_axes_me421! source"},{"id":372,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_projected!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_projected!","content":" FrameTransformations.Frames.add_axes_projected!  —  Function add_axes_projected!(frames, axes, parent, fun) Add  axes  as a set of projected axes to  frames . The orientation of these axes depends only  on time and is computed through the custom functions provided by the user.  Projected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time). Warning It is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types.  source"},{"id":373,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_rotating!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_rotating!","content":" FrameTransformations.Frames.add_axes_rotating!  —  Function add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) where T Add  axes  as a set of rotating axes to  frames . The orientation of these axes depends only  on time and is computed through the custom functions provided by the user.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a Direction Cosine Matrix (DCM). δfun : return the DCM and its 1st order time derivative. δ²fun : return the DCM and its 1st and 2nd order time derivatives δ³fun : return the DCM and its 1st, 2nd and 3rd order time derivatives If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed via automatic differentiation. Warning It is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types.  Examples julia> FRAMES = FrameSystem{3, Float64}();\n\njulia> @axes Inertial 1\n\njulia> add_axes_inertial!(FRAMES, Inertial)\n\njulia> @axes Synodic 2 \n\njulia> fun(t) = angle_to_dcm(t, :Z);\n\njulia> add_axes_rotating!(FRAMES, Synodic, Inertial, fun)\n\njulia> R = rotation6(FRAMES, Inertial, Synodic, π/6);\n\njulia> R[1]\nDCM{Float64}:\n  0.866025  0.5       0.0\n -0.5       0.866025  0.0\n  0.0       0.0       1.0\n\njulia> R[2]\nDCM{Float64}:\n -0.5        0.866025  0.0\n -0.866025  -0.5       0.0\n  0.0        0.0       0.0 See also See also  add_axes_fixedoffset! ,  add_axes_inertial!  and  add_axes_computable! source"},{"id":374,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_topocentric!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_topocentric!","content":" FrameTransformations.Frames.add_axes_topocentric!  —  Function add_axes_topocentric!(frames, axes, λ::Number, ϕ::Number, type::Symbol, parent) Add  axes  as a set of fixed-offset topocentric axes to  frames . The orientation relative  to the parent axes  parent  is defined throuh the longitude  λ , the geodetic latitude  ϕ   and the type  type , which may be any of the following:  :NED  (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir. :SEZ  (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith. :ENU  (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith.  Warning The  parent  axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong.  See also See also  add_axes_fixedoffset!  and  add_point_surface! . source"},{"id":375,"pagetitle":"Public API","title":"Points","ref":"/FrameTransformations/stable/Modules/frames_api/#Points","content":" Points"},{"id":376,"pagetitle":"Public API","title":"FrameTransformations.Frames.@point","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.@point","content":" FrameTransformations.Frames.@point  —  Macro @point(name, id, type=nothing) Define a new point instance to alias the given NAIFID  id . This macro creates an   AbstractFramePoint  subtype and its singleton instance called  name . Its type name  is obtained by appending  Point  to either  name  or  type  (if provided). Examples julia> @point Venus 299\n\njulia> typeof(Venus)\nVenusPoint \n\njulia> point_alias(Venus)\n299\n\njulia> @point EMB 3 EarthMoonBarycenter\n\njulia> typeof(EMB) \nEarthMoonBarycenterPoint\n\njulia> point_alias(EMB) \n3  See also See also  @axes  and  point_alias . source"},{"id":377,"pagetitle":"Public API","title":"FrameTransformations.Frames.point_alias","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.point_alias","content":" FrameTransformations.Frames.point_alias  —  Function point_alias(ax::AbstractFramePoint) Return the NAIF ID associated to the input point.  source"},{"id":378,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_dynamical!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_dynamical!","content":" FrameTransformations.Frames.add_point_dynamical!  —  Function add_point_dynamical!(frames, point, parent, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Add  point  as a time point to  frames . The state vector for these points depends only on  time and is computed through the custom functions provided by the user.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a 3-elements vector: position δfun : return a 6-elements vector: position and velocity δ²fun : return a 9-elements vector: position, velocity and acceleration δ³fun : return a 12-elements vector: position, velocity, acceleration and jerk If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed with automatic differentiation.  Warning It is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions.  Examples julia> FRAMES = FrameSystem{2, Float64}()\n\njulia> @axes ICRF 1 \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> @point Satellite 1 \n\njulia> satellite_pos(t::T) where T = [cos(t), sin(t), 0]\n\njulia> add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, π/6)\n6-element SVector{6, Float64} with indices SOneTo(6):\n  0.8660254037844387\n  0.49999999999999994\n  0.0\n -0.49999999999999994\n  0.8660254037844387\n  0.0 See also See also  add_point_root! ,  add_point_ephemeris! , add_point_fixed!  and  add_point_updatable! source"},{"id":379,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_ephemeris!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_ephemeris!","content":" FrameTransformations.Frames.add_point_ephemeris!  —  Function add_point_ephemeris!(frames, point, parent=nothing) Add  point  as an ephemeris point to  frames . This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). If a parent point is not specified, it will automatically be assigned to the point with respect to which the ephemeris  data is written in the kernels. Inputs frames  –  FrameSystem  object  point  –  FramePointNode  instance  parent  –  FramePointNode  parent instance  add_point_ephemeris!(frames, name::Symbol, naifid::Int, parentid::Int=nothing, axes=nothing) Add a new point called  name  and with id  naifid  to  frames . If a parentid is not specified, it will be automatically assigned depending on the ephemeris kernels. Inputs frames  –  FrameSystem  object  name::Symbol  – name of the point  naifid::Int  – NAIFId associated to the point  parentid::Int  – NAIFId associated to the parent point, default is  nothing axes  – Id associated to the axes in which the states are expressed, default  nothing     (taken automatically from the ephemeris files). Ephemeris points only accept as parent points root-points or other ephemeris points. Notes This operation is only possible if the ephemeris kernels loaded within  frames  contain  data for the NAIF ID associated to  point  and to its  parent .  The axes in which the state-vector is expressed are taken from the ephemeris data: an error  is returned if the axes ID is yet to be added to  frames . Warning It is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels. Examples julia> eph = CalcephProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{2, Float64}(eph);\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @point Jupiter 599\n\njulia> add_point_ephemeris!(FRAMES, Jupiter)\nERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.\n[...] See also See also  add_point_root! ,  add_point_fixed! ,  add_point_dynamical!  and  add_point_updatable! source"},{"id":380,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_fixed!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_fixed!","content":" FrameTransformations.Frames.add_point_fixed!  —  Function add_point_fixed!(frames, point, parent, axes, offset::AbstractVector) Add  point  as a fixed point to  frames . Fixed points are those whose positions have a  constant  offset  with respect their  parent  points in the given set of  axes . Thus, points  eligible for this class must have null velocity and acceleration with respect to  parent . Inputs frames  –  FrameSystem  object  point  –  FramePointNode  instance  parent  –  FramePointNode  parent instance  axes  –  FrameAxesNode  instance  offset  – Offset with respect to the parent add_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector) Add a new fixed point called  name  with id  pointid  and parent  parentid  in the axes   axesid  to  frames . frames  –  FrameSystem  object  name::Symbol  – name of the point  naifid::Int  – NAIFId associated to the point  parentid::Int  – NAIFId associated to the parent point, default is  nothing axesid::Int  – Id associated to the axes in which the states are expressed, default  nothing     (taken automatically from the ephemeris files). offset  – Offset with respect to the parent Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes SF -3000 SatelliteFrame\n\njulia> add_axes_inertial!(FRAMES, SF)\n\njulia> @point SC -10000 Spacecraft\n\njulia> @point SolarArrayCenter -10001\n\njulia> add_point_root!(FRAMES, SC, SF)\n\njulia> sa_offset = [0.10, 0.15, 0.30];\n\njulia> add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset) See also See also  add_point_root! ,  add_point_ephemeris! ,   add_point_dynamical!  and  add_point_updatable! source"},{"id":381,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_root!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_root!","content":" FrameTransformations.Frames.add_point_root!  —  Function add_point_root!(frames, point, axes) Add  point  as a root point to  frames  to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.). Inputs frames  –  FrameSystem  object  point  – Target point instance axes  – Id or instance of the axes where the point state-vector is expressed.  add_point_root!(frames, name, id, axes) Add a root point fo  frames  to initialize the points graphs.  Inputs frames  –  FrameSystem  object  name  – Name of the root point  id  – Id (NAIFId) of the root point  axes  – Id or instance of the axes where the point state-vector is expressed. Note This operation can be performed only once per  FrameSystem  object: multiple root  points in the same graph are both inadmissible and meaningless. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> @point Sun 10\n\njulia> add_point_root!(FRAMES, Sun, ICRF)\nERROR: ArgumentError: A root-point is already registed in the given FrameSystem.\n[...] See also See also  add_point_ephemeris! ,  add_point_fixed! ,  add_point_dynamical!  and  add_point_updatable! source"},{"id":382,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_surface!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_surface!","content":" FrameTransformations.Frames.add_point_surface!  —  Function add_point_surface!(frames, point, parent, axes, pck, λ, ϕ, h::Number=0.0) Add  point  to  frames  as a fixed point on the surface of the  parent  point. The  relative position is specified by the longitude  λ , the geodetic latitude  ϕ  and the altitude  over the surface of the reference ellipsoid  h , which defaults to 0.0. The ellipsoid  parameters are extracted from the input TPC kernel  pck  using the NAIFId associated to the   parent  point. Warning axes  must be a set of body-fixed reference axes for the body represented by  parent .  When this constraint is not satisfied, the results may be fundamentally wrong.  See also See also  add_point_fixed! ,  add_axes_topocentric!  and  geod2pos . source add_point_surface!(frames, point, parent, axes, λ, ϕ, R, f::Number=0.0, h::Number=0.0) Add  point  to  frames  as a fixed point on the surface of the  parent  point body. The relative  position is specified by the longitude  λ , the geodetic latitude  ϕ , the reference radius  of the ellipsoid  R  and its flattening  f . The altitude over the reference surface of the  ellipsoid  h  defaults to 0.  source"},{"id":383,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_updatable!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_updatable!","content":" FrameTransformations.Frames.add_point_updatable!  —  Function add_point_updatable!(frames, point, parent, axes) Add  point  as an updatable point to  frames . Differently from all the other classes, the  state vector for updatable points (expressed in the set of input  axes ) must be manually  updated before being used for other computations.   add_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes) Add a point called  name  with id  pointid  to  frames  as a state vector with respect to   parentid  in the  axes  axes. Note This class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.]\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2\n[...] See also See also  update_point! ,  add_point_root! ,  add_point_ephemeris! ,   add_point_dynamical!  and  add_point_fixed! source"},{"id":384,"pagetitle":"Public API","title":"FrameTransformations.Frames.update_point!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.update_point!","content":" FrameTransformations.Frames.update_point!  —  Function update_point!(frames, point, stv::AbstractVector, epoch::Epoch) source update_point!(frames::FrameSystem, point, stv::AbstractVector, time) Update the state vector of  point  at the input  time  in  frames . The only  accepted length for the input vector  stv  are 3, 6, 9 or 12. The order is automatically  inferred from the vector length. Examples julia> FRAMES = FrameSystem{2, Float64}();\n  \njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.];\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 \n[...]\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 \n[...]  See also See also  add_point_updatable! source"},{"id":385,"pagetitle":"Public API","title":"Rotations","ref":"/FrameTransformations/stable/Modules/frames_api/#rotation_api","content":" Rotations"},{"id":386,"pagetitle":"Public API","title":"FrameTransformations.Frames.Rotation","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.Rotation","content":" FrameTransformations.Frames.Rotation  —  Type Rotation{S, N} A container to efficiently compute  S -th order rotation matrices of type  N  between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the ( S -1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later. The rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object  R , constructed from the  DCM  A  and its time derivatives  δA  and  δ²A  rotates a vector  v  =  [p, v, a]  as:  ̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a] A  Rotation  object  R  call always be converted to a  SMatrix  or a  MMatrix  by invoking  the proper constructor.  Examples julia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0 Rotation(dcms::DCM...) Create a  Rotation  object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types. Examples julia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64} Rotation{S}(dcms::DCM...) where S Create a  Rotation  object of order  S . If the number of  dcms  is smaller than  S , the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than   S , only the first  S  DCMs are used.  Warning Usage of this constructor is not recommended as it may yield unexpected results to  unexperienced users.  Rotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N} Create a  Rotation  object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If  S1  <  S2 , only the first  S1  DCMs are considered, otherwise the  remaining orders are filled with null DCMs. Examples julia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R3 = Rotation{3}((A,B));\n\njulia> R3[1] == A\ntrue \n\njulia> R3[3] \nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Rotation{S}(u::UniformScaling{N}) where {S, N}\nRotation{S, N}(u::UniformScaling) where {S, N} Create an  S -order identity  Rotation  object of type  N  with identity position rotation  and null time derivatives. Examples julia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],)) Rotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\nRotation{S1, N}(R::Rotation{S2}) where {S1, S2, N} Transform a  Rotation  object of order  S2  to order  S1  and type  N . The behaviour of  these functions depends on the values of  S1  and  S2 :  S1  <  S2 : Only the first  S1  components of  rot  are considered. S1  >  S2 : The missing orders are filled with null DCMs. Examples julia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1);\n\njulia> R3[3]\nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Rotation(m::DCM{N}, ω::AbstractVector) where N Create a 2nd order  Rotation  object of type  N  to rotate between two set of axes  a  and   b  from a Direction Cosine Matrix (DCM) and the angular velocity vector  ω  of  b  with  respect to  a , expressed in  b See also See also  rotation3 ,  rotation6  and  rotation9 . source"},{"id":387,"pagetitle":"Public API","title":"FrameTransformations.Frames.order","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.order","content":" FrameTransformations.Frames.order  —  Function order(R::Rotation{S}) where S Return the rotation order S. source"},{"id":388,"pagetitle":"Public API","title":"Base.inv","ref":"/FrameTransformations/stable/Modules/frames_api/#Base.inv","content":" Base.inv  —  Function inv(rot::Rotation) Compute the invese of the rotation object  rot . The operation is efficiently performed by  taking the transpose of each rotation matrix within  rot . source"},{"id":389,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation3","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation3","content":" FrameTransformations.Frames.rotation3  —  Function rotation3(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 1. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 1. source rotation3(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":390,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation6","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation6","content":" FrameTransformations.Frames.rotation6  —  Function rotation6(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 2. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 2. source rotation6(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":391,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation9","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation9","content":" FrameTransformations.Frames.rotation9  —  Function rotation9(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 3. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 3. source rotation9(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":392,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation12","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation12","content":" FrameTransformations.Frames.rotation12  —  Function rotation12(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 4. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 4. source rotation12(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":393,"pagetitle":"Public API","title":"Transformations","ref":"/FrameTransformations/stable/Modules/frames_api/#Transformations","content":" Transformations"},{"id":394,"pagetitle":"Public API","title":"FrameTransformations.Frames.LightTime","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.LightTime","content":" FrameTransformations.Frames.LightTime  —  Constant LightTime The singleton instance of type  LightTimeCorrection , used to apply light-time (planetary  aberration) corrections when computing vectors from the  FrameSystem . See also See also  vector3  and  vector6 . source"},{"id":395,"pagetitle":"Public API","title":"FrameTransformations.Frames.PlanetaryAberration","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.PlanetaryAberration","content":" FrameTransformations.Frames.PlanetaryAberration  —  Constant PlanetaryAberration The singleton instance of type  PlanetaryAberrationCorrection , used to apply one-way  light-time and stellar aberration corrections when computing vectors from the  FrameSystem . See also See also  vector3  and  vector6 . source"},{"id":396,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector3","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector3","content":" FrameTransformations.Frames.vector3  —  Function vector3(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 1. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector3(frame, from, to, axes, t::Number) Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source vector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch  ep ,  using the aberration flag  ltcorr , which may be any of the following  AbstractLightTimeCorrection : LightTimeCorrection : it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation.  PlanetaryAberrationCorrection : it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the  LightTimeCorrection  option to account for the observer velocity    with respect to the Solar System Barycenter.  The integer argument  dir  is used to specify the correction direction, as follows: -1 : for  Reception , in which photons depart from the target's location at the    light-time corrected epoch  ep-lt  and arrive at the observer's location at  ep . +1 : for  Transmission , in which photons depart from the observer's location at    ep  and arrive at the target's location at the light-time corrected epoch  ep+lt . Keyword Arguments iters::Int=1 : the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations. axescenter : ID or instance of the center point for  axes . This parameter is used        only when  axes  have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to  from . Note If the  PlanetaryAberrationCorrection  is applied, the frame system must be at  least one order higher than that of the requested transformation. See also See also  LightTime ,  PlanetaryAberration  and  vector6 . References CSPICE  Library source vector3(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time  t ,   expressed in seconds since  J2000 , using the aberration flag  ltcorr  and  the direction  dir . source"},{"id":397,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector6","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector6","content":" FrameTransformations.Frames.vector6  —  Function vector6(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 2. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector6(frame, from, to, axes, t::Number) Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source vector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch  ep ,  using the aberration flag  ltcorr , which may be any of the following  AbstractLightTimeCorrection : LightTimeCorrection : it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation.  PlanetaryAberrationCorrection : it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the  LightTimeCorrection  option to account for the observer velocity    with respect to the Solar System Barycenter.  The integer argument  dir  is used to specify the correction direction, as follows: -1 : for  Reception , in which photons depart from the target's location at the    light-time corrected epoch  ep-lt  and arrive at the observer's location at  ep . +1 : for  Transmission , in which photons depart from the observer's location at    ep  and arrive at the target's location at the light-time corrected epoch  ep+lt . Keyword Arguments iters::Int=1 : the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations. axescenter : ID or instance of the center point for  axes . This parameter is used        only when  axes  have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to  from . Note If the  PlanetaryAberrationCorrection  is applied, the frame system must be at  least one order higher than that of the requested transformation. See also See also  LightTime ,  PlanetaryAberration  and  vector6 . References CSPICE  Library source vector6(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time  t ,   expressed in seconds since  J2000 , using the aberration flag  ltcorr  and  the direction  dir . source"},{"id":398,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector9","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector9","content":" FrameTransformations.Frames.vector9  —  Function vector9(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 3. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector9(frame, from, to, axes, t::Number) Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source"},{"id":399,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector12","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector12","content":" FrameTransformations.Frames.vector12  —  Function vector12(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 4. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector12(frame, from, to, axes, t::Number) Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source"},{"id":402,"pagetitle":"Low-level API","title":"Frames's Low-level API","ref":"/FrameTransformations/stable/Modules/frames_lapi/#low_frames_api","content":" Frames's Low-level API"},{"id":403,"pagetitle":"Low-level API","title":"Axes","ref":"/FrameTransformations/stable/Modules/frames_lapi/#Axes","content":" Axes"},{"id":404,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.AbstractFrameAxes","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes","content":" FrameTransformations.Frames.AbstractFrameAxes  —  Type AbstractFrameAxes Abstract type for all reference frames axes. source"},{"id":405,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.FrameAxesNode","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.FrameAxesNode","content":" FrameTransformations.Frames.FrameAxesNode  —  Type FrameAxesNode{O, T, N} <: AbstractGraphNode Define a set of axes. Fields name  – axes name  class  –  Symbol  representing the class of the axes  id  – axes ID (equivalent of NAIFId for axes) parentid  – ID of the parent axes  comp  – properties for computable axes  R  – rotation matrix for fixed relative axes  f  –  FrameAxesFunctions  container  angles  – vector storing the libration angles retrived from ephemerides source"},{"id":406,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.axes_name","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.axes_name","content":" FrameTransformations.Frames.axes_name  —  Function axes_name(axes::AbstractFrameAxes) Return the name of  axes . source"},{"id":407,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.axes_id","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.axes_id","content":" FrameTransformations.Frames.axes_id  —  Function axes_id(axes::AbstractFrameAxes) Return the ID associated to  axes . source"},{"id":408,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.build_axes","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.build_axes","content":" FrameTransformations.Frames.build_axes  —  Function build_axes(frames, name, id, class, funs; parentid, dcm, cax_prop) Create and add a  FrameAxesNode  to  frames  based on the input parameters. Current  supported classes are:  :InertialAxes ,  :FixedOffsetAxes ,  :RotatingAxes ,  :ProjectedAxes ,   :EphemerisAxes  and  :ComputableAxes . Inputs frames  – Target frame system  name  – Axes name, must be unique within  frames id  – Axes ID, must be unique within  frames class  – Axes class.   funs  –  FrameAxesFunctions  object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of  frames . Keywords parentid  – Axes ID of the parent axes. Not required only for the root axes. dcm  – DCM with respect to the parent axes. Required only for FixedOffsetAxes.  cax_prop  –  ComputableAxesProperties , required only by ComputableAxes. Warning This is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see  add_axes_inertial! ,  add_axes_rotating! ,   add_axes_computable! ,  add_axes_fixedoffset!  and  add_axes_projected! . source"},{"id":409,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.ComputableAxesProperties","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.ComputableAxesProperties","content":" FrameTransformations.Frames.ComputableAxesProperties  —  Type ComputableAxesProperties Store the properties required to retrieve all the vectors required by   a computable set of axes.  source"},{"id":410,"pagetitle":"Low-level API","title":"Points","ref":"/FrameTransformations/stable/Modules/frames_lapi/#Points","content":" Points"},{"id":411,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.AbstractFramePoint","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.AbstractFramePoint","content":" FrameTransformations.Frames.AbstractFramePoint  —  Type AbstractFramePoint Abstract type for all reference frames points. source"},{"id":412,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.FramePointNode","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.FramePointNode","content":" FrameTransformations.Frames.FramePointNode  —  Type FramePointNode{O, T, N} <: AbstractGraphNode Define a frame system point. Fields name  – point name  class  –  Symbol  representing the class of the point  axesid  – ID of the axes in which the point coordinates are expressed  parentid  – NAIF ID of the parent point  NAIFId  – NAIF ID of the point stv  – vector storing the point state vectors epochs  – vector storing the epochs associated to  stv nzo  – last order at which  stv  has been computed  f  –  FramePointFunctions  container  source"},{"id":413,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.point_name","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.point_name","content":" FrameTransformations.Frames.point_name  —  Function point_name(point::AbstractFramePoint) Return the name of  point . source"},{"id":414,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.point_id","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.point_id","content":" FrameTransformations.Frames.point_id  —  Function point_id(point::AbstractFramePoint) Return the NAIF ID associated to  point . source"},{"id":415,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.build_point","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.build_point","content":" FrameTransformations.Frames.build_point  —  Function build_point(frames, name, NAIFId, class, axesid, funs; parentid, offset) Create and add a  FramePointNode  to  frames  based on the input parameters.  Current supported point classes are:  :RootPoint ,  :TimePoint ,  :EphemerisPoint ,  :FixedPoint  and  :UpdatablePoint . Inputs frames  – Target frame system  name  – Point name, must be unique within  frames NAIFId  – Point NAIF ID, must be unique within  frames class  – Point class.  axesid  – ID of the axes in which the state vector of the point is expressed.  funs  –  FramePointFunctions  object storing the functions to update the state            vectors of the point. It must match the type and order of  frames Keywords parentid  – NAIF ID of the parent point. Not required only for the root point. offset  – Position offset with respect to a parent point. Required only for FixedPoints. Warning This is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see  add_point_ephemeris! ,  add_point_fixed! , etc... source"},{"id":416,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector3","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector3","content":" FrameTransformations.Frames._get_comp_axes_vector3  —  Function _get_comp_axes_vector3(frame, v::ComputableAxesVector, axesid, t) Compute a 3-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position 2 : velocity 3 : acceleration  source"},{"id":417,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector6","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector6","content":" FrameTransformations.Frames._get_comp_axes_vector6  —  Function _get_comp_axes_vector6(frame, v::ComputableAxesVector, axesid, t) Compute a 6-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position, velocity 2 : velocity, acceleration 3 : acceleration, jerk source"},{"id":418,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector9","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector9","content":" FrameTransformations.Frames._get_comp_axes_vector9  —  Function _get_comp_axes_vector9(frame, v::ComputableAxesVector, axesid, t) Compute a 9-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position, velocity, acceleration 2 : velocity, acceleration, jerk Warning This function does not support orders of `v' higher than 2, because it would  require the computation of vectors of order 5, which is currently not supported. source"},{"id":419,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector12","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector12","content":" FrameTransformations.Frames._get_comp_axes_vector12  —  Function _get_comp_axes_vector12(frame, v::ComputableAxesVector, axesid, t) Compute a 12-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position, velocity, acceleration, jerk Warning This function does not support orders of `v' higher than 1, because it would  require the computation of vectors of order 5 and 6, which are currently not supported. source"},{"id":420,"pagetitle":"Low-level API","title":"Two Vectors","ref":"/FrameTransformations/stable/Modules/frames_lapi/#Two-Vectors","content":" Two Vectors"},{"id":421,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_dcm","content":" FrameTransformations.Frames.twovectors_to_dcm  —  Function twovectors_to_dcm(a, b, seq) Generate a direction cosine matrix from two time-dependent vectors  a  and  b ,  following the directions specified in  seq .  Inputs a  – The primary vector that will be aligned with the first directions specified in  seq .  b  – The secondary vector. The component of this vector that is orthogonal to the         primary vector is aligned with the second direction specified in the sequence  seq . seq  – Accepted sequence directions are:        :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY Warning The primary and secondary vectors do not have to be orthogonal. However, a great loss of precision happens when the two vectors are almost aligned. This function does not perform  any check on the angular separation of the two vectors. The user should ensure that the  primary and secondary vector differ of at least 1 milliradian. source"},{"id":422,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δdcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δdcm","content":" FrameTransformations.Frames.twovectors_to_δdcm  —  Function twovectors_to_δdcm(a, b, seq) Compute the time derivative of a direction cosine matrix generated from two time-dependent  state vectors  a  and  b , following the directions specified in  seq .  Inputs a  and  b  – 6-elements state vectors (position and velocity). seq  – Accepted sequence directions are:        :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY source"},{"id":423,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ³dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ³dcm","content":" FrameTransformations.Frames.twovectors_to_δ³dcm  —  Function twovectors_to_δ³dcm(a, b, seq) Compute the 3rd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors  a  and  b , following the directions specified in  seq .  Inputs a  and  b  – 12-elements state vectors (position, velocity, acceleration and jerk). seq  – Accepted sequence directions are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY source"},{"id":424,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ²dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ²dcm","content":" FrameTransformations.Frames.twovectors_to_δ²dcm  —  Function twovectors_to_δ²dcm(a, b, seq) Compute the 2nd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors  a  and  b , following the directions specified in  seq .  Inputs a  and  b  – 9-elements state vectors (position velocity and acceleration). seq  – Accepted sequence directions are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY source"},{"id":425,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._twovectors_to_dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._twovectors_to_dcm","content":" FrameTransformations.Frames._twovectors_to_dcm  —  Function _twovectors_to_dcm(a, b, seq::Symbol, fc::Function, fn::Function, fk::Function) Generate a direction cosine matrix and/or its time derivatives from the vectors  a  and  b ,  according to the directions specifeid in  seq .  Notes fc  and  fn  are used to control the derivative order.  source"},{"id":426,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot6","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot6","content":" FrameTransformations.Frames._two_vectors_to_rot6  —  Function _two_vectors_to_rot6(a, b, seq::Symbol) Generate a direction cosine matrix and time-derivative, minimising  the number of repeated computations.  See also See  twovectors_to_dcm  and  twovectors_to_δdcm  for more information.  source"},{"id":427,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot9","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot9","content":" FrameTransformations.Frames._two_vectors_to_rot9  —  Function _two_vectors_to_rot9(a, b, seq::Symbol) Generate a direction cosine matrix and its 1st and 2nd-order time-derivatives, minimising  the number of repeated computations.  See also See  twovectors_to_dcm  and  twovectors_to_δ²dcm  for more information.  source"},{"id":428,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot12","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot12","content":" FrameTransformations.Frames._two_vectors_to_rot12  —  Function _two_vectors_to_rot12(a, b, seq::Symbol) Generate a direction cosine matrix and its 1st, 2nd and 3r-order time-derivatives, minimising  the number of repeated computations.  See also See  twovectors_to_dcm  and  twovectors_to_δdcm  for more information.  source"},{"id":429,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_basis","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_basis","content":" FrameTransformations.Frames._two_vectors_basis  —  Function _two_vectors_basis(a, b, seq::Symbol, fc::Function, fk::Function) Generate a 3D right-handed orthogonal vector basis and/or its time derivatives from the  vectors  a  and  b , according to the directions specified in  seq  and the input cross  function  fc .  fk  is a function that filters  a  to guarantee type-stability. The accepted sequence directions are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY The standard basis, its 1st, 2nd-order and 3rd order time derivatives can be computed by  passing  cross ,  cross6 ,  cross9  or  cross12  to  fc . The returned vectors will have  a length of 3, 6 or 9, respectively. source"},{"id":432,"pagetitle":"Public API","title":"Orient's Public Documentation","ref":"/FrameTransformations/stable/Modules/orient_api/#basic_orient_api","content":" Orient's Public Documentation"},{"id":433,"pagetitle":"Public API","title":"IAU Models","ref":"/FrameTransformations/stable/Modules/orient_api/#iers_models","content":" IAU Models This is a list of the supported IAU models and their approximations that can be used to select the desired procedure for the computation of the ITRF to GCRF rotation."},{"id":434,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2000a","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2000a","content":" FrameTransformations.Orient.iau2000a  —  Constant iau2000a The singleton instance of type  IAU2006a , representing the IAU 2000B family of models. source"},{"id":435,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2000b","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2000b","content":" FrameTransformations.Orient.iau2000b  —  Constant iau2000b The singleton instance of type  IAU2006a , representing the IAU 2000B family of models. source"},{"id":436,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2006a","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2006a","content":" FrameTransformations.Orient.iau2006a  —  Constant iau2006a The singleton instance of type  IAU2006a , representing the IAU 2006A family of models. source"},{"id":437,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2006b","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2006b","content":" FrameTransformations.Orient.iau2006b  —  Constant iau2006b The singleton instance of type  IAU2006B , representing the IAU 2006B family of models. Note This is not an official IERS model. source"},{"id":438,"pagetitle":"Public API","title":"FrameTransformations.Orient.CPNc","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.CPNc","content":" FrameTransformations.Orient.CPNc  —  Constant CPNc The singleton instance of type  CPNC , representing the concise CPNc from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few mas. source"},{"id":439,"pagetitle":"Public API","title":"FrameTransformations.Orient.CPNd","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.CPNd","content":" FrameTransformations.Orient.CPNd  —  Constant CPNd The singleton instance of type  CPND , representing the concise CPNd from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few arcseconds. source"},{"id":440,"pagetitle":"Public API","title":"IERS Transformations","ref":"/FrameTransformations/stable/Modules/orient_api/#IERS-Transformations","content":" IERS Transformations"},{"id":441,"pagetitle":"Public API","title":"FrameTransformations.Orient.IERS_EOP","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.IERS_EOP","content":" FrameTransformations.Orient.IERS_EOP  —  Constant IERS_EOP Earth orientation parameters: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values at 1-day intervals)  with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014. EOP 14 C04 is updated two times per week. Here the files are downloaded using the  RemoteFile  package with weekly updates. See also:  get_iers_eop source"},{"id":442,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot3_itrf_to_gcrf  —  Function orient_rot3_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  at time  t  expressed as  TT seconds since  J2000 , according to the IAU Model  m , as follows: IAU2000A : the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2000A model. IAU2000B : only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation    matrix is computed following the IAU 2000 model but with truncated expressions for the    nutation corrections.  IAU2006A : the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2006/2000A model. IAU2006B : only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation   matrix is computed following the IAU 2006A model but with truncated expressions for the    nutation corrections.  CPNc : a concise model with a cut-off at 2.5 mas of the X and Y series, delivering a    worst-case accuracy of about 15 mas between 1995-2050. It does not take into account the    Free Core Nutation (~0.2 mas).  CPNd : an extremely concise formulation with an accuracy of about 1 arcsec between 1995    and 2050. It neglects polar-motion (~0.25 arcsec), the FCN corrections and the CIO locator.  References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations source orient_rot3_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0) Compute the rotation matrix from ITRF to GCRF according to the IAU Model  m , at time  tt   and  ut1  expressed in TT seconds and  UT1  days since  J2000 , respectively.   This function has been implemented for  IAU2000 ,  IAU2006  and  CPN  models. Note All the input quantities  xₚ ,  yₚ ,  dX  and  dY  must be expressed in radians source"},{"id":443,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot6_itrf_to_gcrf  —  Function orient_rot6_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  and its derivative at time  t   expressed as TT seconds since  J2000 , according to the the IAU Model  m . source"},{"id":444,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot9_itrf_to_gcrf  —  Function orient_rot9_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  and its time derivatives up to order 2 at  time  t  expressed as TT seconds since  J2000 , according to the IAU Model  m . source"},{"id":445,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot12_itrf_to_gcrf  —  Function orient_rot12_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  and its time derivatives up to order 3 at  time  t  expressed as TT seconds since  J2000 , according to the IAU Model  m . source"},{"id":446,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_bias_precession","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession","content":" FrameTransformations.Orient.orient_bias_precession  —  Function orient_bias_precession(m::IAUModel, t::Number) Form the precession-frame bias (PB) matrix that transforms vectors from the GCRS to the  mean of date, following the IAU Model  m  at time  t  expressed as  TT  Julian centuries  since  J2000 . The function has been implemented for the  IAU2000  and  IAU2006  models. References: IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc. 24th General Assembly,  Manchester, UK.  Resolutions B1.3, B1.6. (2000) Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with IAU  2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  pmat06  function. ERFA  pmat00  function. source"},{"id":447,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_bias_precession_nutation","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession_nutation","content":" FrameTransformations.Orient.orient_bias_precession_nutation  —  Function orient_bias_precession_nutation(m::IAUModel, t::Number) Compute the equinox-based bias-precession-nutation matrix using the IAU Model  m  procedures  at time  t  expressed in  TT  Julian centuries since  J2000 . The function has been implemented for the  IAU2000  and  IAU2006  models. Note The computed matrix rotates a vector from the GCRS to the true equatorial triad of date. References ERFA  pn06  function ERFA  pn00  function source"},{"id":448,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_nutation","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_nutation","content":" FrameTransformations.Orient.orient_nutation  —  Function orient_nutation(m::IAUModel, t::Number) Compute the nutation components in longitude and obliquity for the IAU Model  m , in radians,  at time  t  expressed in  TT  Julian Centuries since  J2000 . Notes Due to their theoretical basis, the original developments required  t  expressed as TDB.  However, in practice, it is usually more convenient to use Terrestrial Time (TT) as it makes  no significant differences (< 0.01 μas) in the final result. For the  IAU 2006A  model, the function strictly follows the SOFA implementation. It first  computes the IAU 2000A nutation, then applies adjustments for the consequences of the change  in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) for the secular  variation in the Earth's dynamical form factor J2. These corrections ensure that the IAU  2000A nutation is consistent with the IAU 2006 precession model. Please note that the  coefficients available on the IERS tables already include those corrections, and are  retrieved by multiplying the amplitudes of the SOFA nutation in longitude coefficients by  1.00000047.  The computation of the free-core nutation and time dependent effects are excluded from this  model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation models,  such effects must be included a-posteriori (through dX and dY) using the IERS EOP data. For the  IAU 2000B  model, the nutation series is truncated from nearly 1400 terms to only 77,  yet it still delivers results of 1 mas accuracy at present epochs. In particular, it delivers  a pole accurate to 1 mas from 1900 to 2100 (only very occasionally just outside 1 mas).  The coefficients are taken from SOFA's implementation, which slighlty differ from those  reported in McCarthy and Luzum (2003). Comparisons with IAU 2006A show that the SOFA version  between 1995 and 2050 delivers 0.283 mas RMSE (0.994 mas in the worst case), whereas the  IERS Conventions website version delivers 0.312 RMSE (1.125 mas in the worst case). The  IAU 2000B  model includes constant planetary bias terms that compensate for long-period  nutations. These amplitudes used in this implementation are optimised for a  rigorous  method,  where frame bias, precession and nutation are applied separately and in that order  (see SOFA's documentation for further insights). A simplified version of the Fundamental Arguments, taken from Simon et al (1994) is exploited  for IAU2000B as the error introduced is below the model accuracy ( ~0.1 mas). References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Simon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets. ERFA  nut06a  and   nut00b  functions  source"},{"id":449,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_obliquity","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_obliquity","content":" FrameTransformations.Orient.orient_obliquity  —  Function orient_obliquity(m::IAUModel, t::Number) Compute the mean obliquity of the ecliptic at epoch, in radians, at time  t  expressed  in  TT  Julian centuries since  J2000 .  Note This function is implemented only for  IAU1980  and  IAU2006  models. IAU 2000 Models  implement proper precession-rate corrections to the IAU1980 mean obliquity.  References ERFA  obl80  and   obl06  functions. source"},{"id":450,"pagetitle":"Public API","title":"Moon Transformations","ref":"/FrameTransformations/stable/Modules/orient_api/#Moon-Transformations","content":" Moon Transformations"},{"id":451,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421","content":" FrameTransformations.Orient.orient_rot3_icrf_to_pa421  —  Function orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, t::Number) Compute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the given  input time  t , expressed in seconds since  J2000 .  Warning This function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions. source orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, ep::Epoch) Compute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the input  epoch  ep . source"},{"id":452,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa440","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440","content":" FrameTransformations.Orient.orient_rot3_icrf_to_pa440  —  Function orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, t::Number) Compute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the given  input time  t , expressed in seconds since  J2000 .  Warning This function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions. source orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, ep::Epoch) Compute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the input  epoch  ep . source"},{"id":453,"pagetitle":"Public API","title":"Axes ID","ref":"/FrameTransformations/stable/Modules/orient_api/#orient_axesid","content":" Axes ID This is a list of NAIF IDs for standard axes that are used in astrodynamic applications.  Note Although they are listed in the public documentation section, these IDs are not directly exported by the package."},{"id":454,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_ICRF","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_ICRF","content":" FrameTransformations.Orient.AXESID_ICRF  —  Constant AXESID_ICRF NAIF Axes ID for the International Celestial Reference Frame (ICRF) source"},{"id":455,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_ECLIPJ2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_ECLIPJ2000","content":" FrameTransformations.Orient.AXESID_ECLIPJ2000  —  Constant AXESID_ECLIPJ2000 NAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECLIPJ2000)  source"},{"id":456,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MEME2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MEME2000","content":" FrameTransformations.Orient.AXESID_MEME2000  —  Constant AXESID_MEME2000 Axes ID for the Mean Dynamical Equator and Equinox of J2000.0.  Note In SPICE the J2000 and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the MEME2000 axes. 22 has been chosen because it is the  first unassigned axes ID among the built-in SPICE frames.  source"},{"id":457,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MOONME_DE421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONME_DE421","content":" FrameTransformations.Orient.AXESID_MOONME_DE421  —  Constant AXESID_MOONME_DE421 NAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421). source"},{"id":458,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE421","content":" FrameTransformations.Orient.AXESID_MOONPA_DE421  —  Constant AXESID_MOONPA_DE421 NAIF axes id for the DE421 Moon Principal Axes (PA421). source"},{"id":459,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE440","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE440","content":" FrameTransformations.Orient.AXESID_MOONPA_DE440  —  Constant AXESID_MOONPA_DE440 NAIF Axes id for the DE440 Moon Principal Axes (PA440). source"},{"id":460,"pagetitle":"Public API","title":"Default Rotation Matrices","ref":"/FrameTransformations/stable/Modules/orient_api/#orient_dcms","content":" Default Rotation Matrices"},{"id":461,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS","content":" FrameTransformations.Orient.DCM_ICRF_TO_J2000_BIAS  —  Constant DCM_ICRF_TO_J2000_BIAS DCM for the rotation from the International Celestial Reference Frame ( ICRF ) and the  Mean Dynamical Equator and Equinox of J2000.0 ( MEME2000 ). Note The frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond. References Hilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI:  10.1051/0004-6361:20031552 SOFA docs source"},{"id":462,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","content":" FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000  —  Constant DCM_ICRF_TO_ECLIPJ2000 DCM for the rotation from the International Celestial Reference Frame ( ICRF ) to the  Mean Ecliptic Equinox of J2000 ( ECLIPJ2000 ). source"},{"id":463,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000","content":" FrameTransformations.Orient.DCM_J2000_TO_ECLIPJ2000  —  Constant DCM_J2000_TO_ECLIPJ2000 DCM for the rotation from the Mean Dynamical Equator of J2000 ( MEME2000 ) to the  Mean Ecliptic Equinox. This corresponds to the transformation  J2000 -> ECLIPJ2000   in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory. source"},{"id":464,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","content":" FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421  —  Constant DCM_MOON_PA421_TO_ME421 DCM for the rotation from the Moon Principal Axis 421 (PA421) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes. References J. G. Williams et al. (2008),  DE421 Lunar Orbit, Physical Librations, and Surface Coordinates ,    DE421 Lunar Ephemeris and Orientation source"},{"id":465,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","content":" FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421  —  Constant DCM_MOON_PA430_TO_ME421 DCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes. References Folkner M. William et al. (2014),  The Planetary and Lunar EphemeridesDE430 and DE431 J. G. Williams et al. (2013),  DE430 Lunar Orbit, Physical Librations, and Surface Coordinates ,    DE430 Lunar Ephemeris and Orientation source"},{"id":466,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","content":" FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430  —  Constant DCM_MOON_PA430_TO_ME430 DCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE430 (ME430) axes. References Folkner M. William et al. (2014),  The Planetary and Lunar EphemeridesDE430 and DE431 J. G. Williams et al. (2013),  DE430 Lunar Orbit, Physical Librations, and Surface Coordinates ,    DE430 Lunar Ephemeris and Orientation source"},{"id":467,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","content":" FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421  —  Constant DCM_MOON_PA440_TO_ME421 DCM for the rotation from the Moon Principal Axis 440 (PA440) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes. References Park, S. R. et al. (2021),  The JPL Planetary and Lunar Ephemerides DE440 and DE441 ,   DOI: 10.3847/1538-3881/abd414 source"},{"id":470,"pagetitle":"Low-level API","title":"Orient's Low-level API","ref":"/FrameTransformations/stable/Modules/orient_lapi/#low_orient_api","content":" Orient's Low-level API Although this routines are not meant to be used outside of the package, they are here documented to aid future developments or to help users that require specific computations."},{"id":471,"pagetitle":"Low-level API","title":"Outdated IAU Models","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Outdated-IAU-Models","content":" Outdated IAU Models"},{"id":472,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.iau1980","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.iau1980","content":" FrameTransformations.Orient.iau1980  —  Constant iau1980 The singleton instance of type  IAU1980 , representing the IAU 1980 family of models. source"},{"id":473,"pagetitle":"Low-level API","title":"Fundamental Arguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Fundamental-Arguments","content":" Fundamental Arguments"},{"id":474,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.FundamentalArguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.FundamentalArguments","content":" FrameTransformations.Orient.FundamentalArguments  —  Type FundamentalArguments{N <: Number} Type storing the fundamental luni-solar and planetary arguments. Fields Mₐ  – Mean anomaly of the Moon  Sₐ  – Mean anomaly of the Sun uₘ  – Mean longitude of the Moon minus mean longitude of the ascending node  F Dₛ  – Mean elongation of the Moon from the Sun  Ωₘ  – Mean longitude of the Moon's ascending node λ_Me  – Mercury's mean heliocentric longitude λ_Ve  – Venus's mean heliocentric longitude λ_Ea  – Earth's mean heliocentric longitude λ_Ma  – Mars's mean heliocentric longitude λ_Ju  – Jupiter's mean heliocentric longitude λ_Sa  – Saturn's mean heliocentric longitude λ_Ur  – Uranus's mean heliocentric longitude λ_Ne  – Neptune's mean heliocentric longitude pₐ  – General precession in longitude source"},{"id":475,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.LuniSolarArguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.LuniSolarArguments","content":" FrameTransformations.Orient.LuniSolarArguments  —  Function LuniSolarArguments(t::Number, m::IAUModel) Compute the fundamental (Delaunay) Luni-Solar arguments, in radians, associated to the  desired IAU model  m , at time  t  expressed in  TDB  Julian centuries since  J2000 . The returned values depend on the input model as follows:  IAU2006A : the Delaunay expressions are taken from the IERS 2010 Conventions. IAU2000B : the expressions are taken from Simon et al. (1994), following ERFA's   implementation of nut00b.c Outputs Mₐ  – Mean anomaly of the Moon Sₐ  – Mean anomaly of the Sun uₘ  – Mean longitude of the Moon minus mean longitude of the         ascending node  F Dₛ  – Mean elongation of the Moon from the Sun Ωₘ  – Mean longitude of the Moon's ascending node References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 Simon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets. ERFA  software library source"},{"id":476,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.PlanetaryArguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.PlanetaryArguments","content":" FrameTransformations.Orient.PlanetaryArguments  —  Function PlanetaryArguments(t::Number) Compute the fundamental planetary arguments and the general precession, in radians,  at time  t  expressed in  TDB  Julian centuries since  J2000 . Outputs λ☿  – Mercury's mean heliocentric longitude. λ♀  – Venus's mean heliocentric longitude. λe  – Earth's mean heliocentric longitude. λ♂  – Mars's mean heliocentric longitude. λ♃  – Jupiter's mean heliocentric longitude. λ♄  – Saturn's mean heliocentric longitude. λ⛢  – Uranus's mean heliocentric longitude. λ♆  – Neptune's mean heliocentric longitude. pλ  – General precession in longitude. References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 source"},{"id":477,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mano_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_moon","content":" FrameTransformations.Orient.fa_mano_moon  —  Function fa_mano_moon(t::Number) Return the mean anomaly of the Moon  Mₐ , in radians, at time  t  expressed in  TDB  Julian  centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":478,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mano_sun","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_sun","content":" FrameTransformations.Orient.fa_mano_sun  —  Function fa_mano_sun(t::Number) Return the mean anomaly of the Sun  Sₐ  in radians, at time  t  expressed in  TDB  Julian  centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":479,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_moon","content":" FrameTransformations.Orient.fa_mlon_moon  —  Function fa_mlon_moon(t::Number) Return the mean longitude of the Moon's ascending node  Ω  in radians, at time  t  expressed in  TDB  Julian centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":480,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlat_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlat_moon","content":" FrameTransformations.Orient.fa_mlat_moon  —  Function fa_mlat_moon(t::Number) Return the mean longitude of the Moon minus the mean longitude of the ascending node  F  in radians, at time  t  expressed in  TDB  Julian centuries since  J2000 .   References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":481,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_melo_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_melo_moon","content":" FrameTransformations.Orient.fa_melo_moon  —  Function fa_melo_moon(t::Number) Return the mean elongation of the Moon from the Sun  D  in radians, at time  t  expressed in   TDB  Julian centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":482,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_precession","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_precession","content":" FrameTransformations.Orient.fa_precession  —  Function fa_precession(t::Number)  Return the general accumulated precession in longitude  pₐ  in radians, at time  t   expressed in  TDB  Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":483,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mercury","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mercury","content":" FrameTransformations.Orient.fa_mlon_mercury  —  Function fa_mlon_mercury(t::Number) Return the mean heliocentric longitude of Mercury in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":484,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_venus","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_venus","content":" FrameTransformations.Orient.fa_mlon_venus  —  Function fa_mlon_venus(t::Number) Return the mean heliocentric longitude of Venus in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":485,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_earth","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_earth","content":" FrameTransformations.Orient.fa_mlon_earth  —  Function fa_mlon_earth(t::Number) Return the mean heliocentric longitude of Earth in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":486,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mars","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mars","content":" FrameTransformations.Orient.fa_mlon_mars  —  Function fa_mlon_mars(t::Number) Return the mean heliocentric longitude of Mars in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":487,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_jupiter","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_jupiter","content":" FrameTransformations.Orient.fa_mlon_jupiter  —  Function fa_mlon_jupiter(t::Number) Return the mean heliocentric longitude of Jupiter in radians, at time  t  expressed in  TDB  Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":488,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_saturn","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_saturn","content":" FrameTransformations.Orient.fa_mlon_saturn  —  Function fa_mlon_saturn(t::Number) Return the mean heliocentric longitude of Saturn in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":489,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_uranus","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_uranus","content":" FrameTransformations.Orient.fa_mlon_uranus  —  Function fa_mlon_uranus(t::Number) Return the mean heliocentric longitude of Uranus in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":490,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_neptune","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_neptune","content":" FrameTransformations.Orient.fa_mlon_neptune  —  Function fa_mlon_neptune(t::Number) Return the mean heliocentric longitude of Neptune in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":491,"pagetitle":"Low-level API","title":"Precession","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Precession","content":" Precession"},{"id":492,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.frame_bias","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.frame_bias","content":" FrameTransformations.Orient.frame_bias  —  Function frame_bias(::IAU2000Model) Compute the frame bias components of the IAU 2000 precession-nutation models, in radians. Notes The frame bias corrections in longitude and obliquity are required to correct for the  offset between the GCRS pole and the mean  J2000  pole. They define, with respect  to the GCRS axes, a J2000 mean pole that is consistent with teh IAU 2000A precession-nutation  model.  The function also returns an offset in right ascension taken from Chapront et al. (2002), necessary to completely describe the frame bias, but that is not part of the original IAU  2000A model. References ERFA  software library source"},{"id":493,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fw_angles","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fw_angles","content":" FrameTransformations.Orient.fw_angles  —  Function fw_angles(m::IAU2006Model, t::Number) Compute the precession angles in radians, following the IAU 2006 Fukushima-Williams 4-angle  formulation at time  t  expressed in  TT  Julian centuries since  J2000 . Outputs γ  – F-W 1st angle ϕ  – F-W 2nd angle ψ  – F-W 3rd angle    ε  – F-W 4th angle References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":494,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fw_matrix","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fw_matrix","content":" FrameTransformations.Orient.fw_matrix  —  Function fw_matrix(γ, ϕ, ψ, ε) Form the Nutation-Precession-Bias (NPB) rotation matrix given the Fukushima-Williams angles,  expressed in radians. The present function can construct three different matrices depending on which angles are  supplied as arguments:  NPB : To obtain the Nutation-Precession-Bias matrix, generate the four standard FW    precession angles (̄γ, ̄ϕ, ̄ψ, ϵₐ) then generate the nutation components Δψ and Δϵ and add them    to ̄ψ, ϵₐ. Finally, call the present functions using those four angles as arguments.  PB : To obtain the precession-frame bias matrix, generate the four standard FW precession    angles and call the present function.  B : To obtain the frame bias matrix, generate the four standard FW precession angles at    date J2000.0 and call this function. The remaining nutation-only and precession only matrices can be obtained by combining these  three appropriately.  References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":495,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.precession_angles","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.precession_angles","content":" FrameTransformations.Orient.precession_angles  —  Function precession_angles(m::IAU1980Model, t::Number) Compute the precession angles from Lieske et al. 1977 model, in radians, at time  t   expressed in  TT  Julian centuries since  J2000 . References ERFA  software library source"},{"id":496,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.precession_rate","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.precession_rate","content":" FrameTransformations.Orient.precession_rate  —  Function precession_rate(m::IAU2000Model, t::Number) Compute the precession-rate part of the IAU 2000 precession-nutation models, in radians, at  time  t  expressed as  TT  Julian centuries since  J2000 . References ERFA  software library source"},{"id":497,"pagetitle":"Low-level API","title":"IERS Routines","ref":"/FrameTransformations/stable/Modules/orient_lapi/#IERS-Routines","content":" IERS Routines"},{"id":498,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.bpn2xy","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.bpn2xy","content":" FrameTransformations.Orient.bpn2xy  —  Function bpn2xy(A::AbstractMatrix) Compute the CIP X and Y coordinates from the bias-precession-nutation matrix, in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":499,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cip_coords","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cip_coords","content":" FrameTransformations.Orient.cip_coords  —  Function cip_coords(m::IAUModel, t::Number) Computes the CIP X, Y coordinates, in radians, according to the IAU model  m  at time  t   expressed in  TT  Julian Centuries since  J2000 . This function has been implemented for the  IAU2000 ,  IAU2006  and the  CPN  models. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations source"},{"id":500,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cio_locator","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cio_locator","content":" FrameTransformations.Orient.cio_locator  —  Function cio_locator(m::IAUModel, t::Number, x::Number, y::Number) Compute the CIO Locator  s  in radians, according to the IAU Model  m , given the CIP  coordinates  X  and  Y  at time  t  expressed in  TT  Julian centuries since  J2000 The function has been implemented for the  IAU2000 ,  IAU2006  and the  CPN  models. References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations ERFA  library ERFA  library source"},{"id":501,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cip_motion","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cip_motion","content":" FrameTransformations.Orient.cip_motion  —  Function cip_motion(m::IAUModel, t::Number, dx::Number=0.0, dy::Number=0.0) Compute the CIRS to GCRS rotation matrix, according to the IAU Model  m , at time  t  expressed in  TT  Julian centuries since  J2000 . Optional IERS corrections for  free-core nutation and time depedented effects can be provided through  dx  and  dy .  References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":502,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_angle","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_angle","content":" FrameTransformations.Orient.earth_rotation_angle  —  Function earth_rotation_angle(t::Number) Compute the Earth Rotation Angle (ERA) in radians, i.e., the angle between the Celestial  Intermediate Origin (CIO) and the Terrestrial Intermediate Origin (TIO) at time  t   expressed as UT1 days since  J2000 . Note The function uses the fractional UT1 date to gain additional precision in the  computations (0.002737.. instead of 1.002737..) References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  library source"},{"id":503,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_rate","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_rate","content":" FrameTransformations.Orient.earth_rotation_rate  —  Function earth_rotation_rate() Compute the nominal Earth angular velocity.  source earth_rotation_rate(LOD::Number) Compute the true angular velocity of the Earth accounting for the Length of the Day, i.e.,  the instantaneous rate of change of UT1 with respect to a uniform time scale.  source"},{"id":504,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.era_rotm","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.era_rotm","content":" FrameTransformations.Orient.era_rotm  —  Function era_rotm(t::Number) Compute the TIRS to CIRS Earth Rotation matrix, according to the IERS 2010  conventions at time  t  expressed as UT1 days since  J2000 . References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 source"},{"id":505,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fw2xy","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fw2xy","content":" FrameTransformations.Orient.fw2xy  —  Function fw2xy(ϵ::Number, ψ::Number, γ::Number, φ::Number) Compute the CIP X and Y coordinates from Fukushima-Williams bias-precession-nutation  angles, in radians. Inputs ϵ  – F-W angle with IAU 2006A/B nutation corrections.  ψ  – F-W angle with IAU 2006A/B nutation corrections. γ  – F-W angle   ϕ  – F-W angle References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":506,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.tio_locator","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.tio_locator","content":" FrameTransformations.Orient.tio_locator  —  Function tio_locator(t::Number) Compute the TIO locator  s'  at date, positioning the Terrestrial Intermediate Origin on  the equator of the Celestial Intermediate Pole (CIP) at time  t  expressed as  TT  Julian  centuries since J2000.  This function approximates the unpredictable motion of the TIO locator s' with its secular  drift of ~0.47 μas/century.  References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Lambert, S. and Bizouard C. (2002), Positioning the Terrestrial Ephemeris Origin in the  Terrestrial Reference Frame,  DOI: 10.1051/0004-6361:20021139 source"},{"id":507,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.polar_motion","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.polar_motion","content":" FrameTransformations.Orient.polar_motion  —  Function polar_motion(t::Number, xₚ::Number, yₚ::Number) Compute the Polar Motion rotation matrix from ITRF to TIRS, according to the  IERS 2010 Conventions, at time  t  expressed in  TT  Julian centuries since  J2000 .  The function requires  xp  and  yp , the Celestial Intermediate Pole (CIP) coordinates with  respect to the International Celestial Reference Frame (ITFR). References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 source"},{"id":508,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.xys2m","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.xys2m","content":" FrameTransformations.Orient.xys2m  —  Function xys2m(x::Number, y::Number, s::Number) Compute the Intermediate-to-Celestial matrix given the CIP  x ,  y' coordinates and the CIO  locator s`, all in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":509,"pagetitle":"Low-level API","title":"EOP Data","ref":"/FrameTransformations/stable/Modules/orient_lapi/#EOP-Data","content":" EOP Data"},{"id":510,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.EOPData","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.EOPData","content":" FrameTransformations.Orient.EOPData  —  Type EOPData{T} EOP Data for IAU 2000A. Note Each field will be an  AbstractInterpolation  indexed by the Julian Day. Fields x, y : Polar motion with respect to the crust [arcsec]. UT1_UTC : Irregularities of the rotation angle [s]. LOD : Length of day offset [ms]. dX, dY : Celestial pole offsets referred to the model IAU2000A [milliarcsec]. source"},{"id":511,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.get_iers_eop","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.get_iers_eop","content":" FrameTransformations.Orient.get_iers_eop  —  Function get_iers_eop(; force_download = false) Download and parse the IERS EOP C04 data.  The files are downloaded using the  RemoteFile  package with weekly updates. Hence, if one  desires to force a download before the scheduled time, then set the keyword  force_download    to  true . Note The files will be downloaded from the default URL. If the user want to use another one, then use the specialized function  get_iers_eop_IAU2000A See also:  get_iers_eop_IAU2000A Returns A structure  EOPData  with the interpolations of the EOP parameters. Notice that the interpolation indexing is set to Julian days since J2000. source"},{"id":512,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.get_iers_eop_IAU2000A","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.get_iers_eop_IAU2000A","content":" FrameTransformations.Orient.get_iers_eop_IAU2000A  —  Function get_iers_eop_iau_2000A(url::String=\"https://datacenter.iers.org/data/csv/finals2000A.all.csv\"; \n    force_download = false) Get the IERS EOP C04 IAU2000A data from the URL  url . If  url  is omitted, then it defaults to https://datacenter.iers.org/data/csv/finals2000A.all.csv. The file is downloaded using the  RemoteFile  package with weekly updates. Hence, if one desires  to force a download before the scheduled time, then set the keyword  force_download  to  true . Note The interpolation of every field in  EOPData  between two points in the grid is linear. If extrapolation is needed, then if will use the nearest value (flat extrapolation). See also:  get_iers_eop Returns The structure  EOPData  with the interpolations of the EOP parameters. Notice that the  interpolation indexing is set to Julian days since J2000. source"},{"id":513,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.offset_utc2ut1","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.offset_utc2ut1","content":" FrameTransformations.Orient.offset_utc2ut1  —  Function offset_utc2ut1(seconds) Return the offset between  UTC  and  UT1  in seconds. source"},{"id":514,"pagetitle":"Low-level API","title":"Transformations","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Transformations","content":" Transformations"},{"id":515,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_mememod","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_mememod","content":" FrameTransformations.Orient.orient_rot3_icrf_to_mememod  —  Function orient_rot3_icrf_to_mememod(t::Number) Compute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Mean Equinox Mean Equator of Date at time  t , expressed in TT seconds since  J2000 . source"},{"id":518,"pagetitle":"Public API","title":"Utils's Public Documentation","ref":"/FrameTransformations/stable/Modules/utils_api/#basic_utils_api","content":" Utils's Public Documentation"},{"id":519,"pagetitle":"Public API","title":"TPC","ref":"/FrameTransformations/stable/Modules/utils_api/#TPC","content":" TPC"},{"id":520,"pagetitle":"Public API","title":"FrameTransformations.Utils.TPC","ref":"/FrameTransformations/stable/Modules/utils_api/#FrameTransformations.Utils.TPC","content":" FrameTransformations.Utils.TPC  —  Type TPC <: JSMDInterfaces.FilesIO.AbstractFile A type representing TPC files. source"},{"id":521,"pagetitle":"Public API","title":"JSMDInterfaces.FilesIO.load","ref":"/FrameTransformations/stable/Modules/utils_api/#JSMDInterfaces.FilesIO.load","content":" JSMDInterfaces.FilesIO.load  —  Function load(file::TPC{1}) Open a JPL ASCII  .tpc  file and parse its data in a dictionary. source load(files::TPC) Open a group of JPL ASCII  .tpc  files and parse their data in a dictionary. source"},{"id":522,"pagetitle":"Public API","title":"Math","ref":"/FrameTransformations/stable/Modules/utils_api/#Math","content":" Math"},{"id":523,"pagetitle":"Public API","title":"FrameTransformations.Utils.skew","ref":"/FrameTransformations/stable/Modules/utils_api/#FrameTransformations.Utils.skew","content":" FrameTransformations.Utils.skew  —  Function skew(a) Create a skew matrix from the first three elements of  a . source"},{"id":524,"pagetitle":"Public API","title":"Geodesy","ref":"/FrameTransformations/stable/Modules/utils_api/#Geodesy","content":" Geodesy"},{"id":525,"pagetitle":"Public API","title":"FrameTransformations.Utils.geoc2pos","ref":"/FrameTransformations/stable/Modules/utils_api/#FrameTransformations.Utils.geoc2pos","content":" FrameTransformations.Utils.geoc2pos  —  Function geoc2pos(r::Number, λ::Number, ϕ::Number)\ngeoc2pos(geoc::AbstractArray) Transform geocentric coordinates in a cartesian position vector, given the longitude  λ ,  the geocentric latitude  ϕ  and the radius  r . source"},{"id":526,"pagetitle":"Public API","title":"FrameTransformations.Utils.pos2geoc","ref":"/FrameTransformations/stable/Modules/utils_api/#FrameTransformations.Utils.pos2geoc","content":" FrameTransformations.Utils.pos2geoc  —  Function pos2geoc(pos::AbstractVector) Transform a cartesian 3-elements position vector  pos  into radius, longitude and geocentric  latitude, respectively. source"},{"id":527,"pagetitle":"Public API","title":"FrameTransformations.Utils.geod2pos","ref":"/FrameTransformations/stable/Modules/utils_api/#FrameTransformations.Utils.geod2pos","content":" FrameTransformations.Utils.geod2pos  —  Function geod2pos(h::Number, λ::Number, ϕ::Number, R::Number, f::Number) Transform longitude  λ , geodetic latitude  ϕ  and altitude over the reference ellipsoid to  a cartesian position vector, given the reference radius  R  and the flattening  f . References Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA. source"},{"id":528,"pagetitle":"Public API","title":"FrameTransformations.Utils.pos2geod","ref":"/FrameTransformations/stable/Modules/utils_api/#FrameTransformations.Utils.pos2geod","content":" FrameTransformations.Utils.pos2geod  —  Function pos2geod(pos::AbstratVector, R::Number, f::Number, toll::Number=1e-12) Transform a cartesian 3-elements position vector  pos  into longitude, geodetic latitude  and altitude over the reference ellipsoid with radius  R  and flattening  f .  References Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA. source"},{"id":531,"pagetitle":"Low-level API","title":"Utils's Low-level API","ref":"/FrameTransformations/stable/Modules/utils_lapi/#low_utils_api","content":" Utils's Low-level API"},{"id":532,"pagetitle":"Low-level API","title":"Geodesy","ref":"/FrameTransformations/stable/Modules/utils_lapi/#Geodesy","content":" Geodesy"},{"id":533,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.pv2geoc","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.pv2geoc","content":" FrameTransformations.Utils.pv2geoc  —  Function pv2geoc(pv::AbstractVector) Transform a cartesian 6-elements state vector (position and velocity) into radius, longitude,  geocentric latitude and their derivatives, respectively. source"},{"id":534,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.geoc2pv","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.geoc2pv","content":" FrameTransformations.Utils.geoc2pv  —  Function geoc2pv(geoc::AbstractVector) Transform a spherical geocentric 6-elements state vector (radius, longitude, geocentric  latitude and their derivatives) into a cartesian 6-elements vector (position and velocity). source"},{"id":535,"pagetitle":"Low-level API","title":"Vectors","ref":"/FrameTransformations/stable/Modules/utils_lapi/#Vectors","content":" Vectors"},{"id":536,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.cross3","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.cross3","content":" FrameTransformations.Utils.cross3  —  Function cross3(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y , considering only their first 3 elements. source"},{"id":537,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.cross6","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.cross6","content":" FrameTransformations.Utils.cross6  —  Function cross6(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its time derivative.  Notes x  and  y  must be 6-elements state vectors, with the last elements of each vector  representing the time derivatives of the first three. source"},{"id":538,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.cross9","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.cross9","content":" FrameTransformations.Utils.cross9  —  Function cross9(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its 1st and 2nd-order time derivatives.  Notes x  and  y  must be 9-elements state vectors (position, velocity and acceleration) source"},{"id":539,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.cross12","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.cross12","content":" FrameTransformations.Utils.cross12  —  Function cross12(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its 1st, 2nd and 3rd order time derivatives.  Notes x  and  y  must be 12-elements state vectors (position, velocity and acceleration) source"},{"id":540,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.normalize","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.normalize","content":" FrameTransformations.Utils.normalize  —  Function normalize(v::AbstractVector) Normalise the vector  v . source"},{"id":541,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.δnormalize","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.δnormalize","content":" FrameTransformations.Utils.δnormalize  —  Function δnormalize(v::AbstractVector) Compute the time derivative of a unit vector  v . source"},{"id":542,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.δ²normalize","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.δ²normalize","content":" FrameTransformations.Utils.δ²normalize  —  Function δ²normalize(v::AbstractVector) Compute the 2nd-order time derivative of a unit vector  v . source"},{"id":543,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.δ³normalize","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.δ³normalize","content":" FrameTransformations.Utils.δ³normalize  —  Function δ³normalize(v::AbstractVector) Compute the 3rd-order time derivative of a unit vector  v . source"},{"id":544,"pagetitle":"Low-level API","title":"Rotations","ref":"/FrameTransformations/stable/Modules/utils_lapi/#Rotations","content":" Rotations"},{"id":545,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.angle_to_δdcm","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.angle_to_δdcm","content":" FrameTransformations.Utils.angle_to_δdcm  —  Function angle_to_δdcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX) Compute the derivative of the direction cosine matrix that perform a set of rotations ( θ ,   ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation input must be an indexable  objected which includes the angle and its first time derivative. The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δ²dcm source"},{"id":546,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.angle_to_δ²dcm","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.angle_to_δ²dcm","content":" FrameTransformations.Utils.angle_to_δ²dcm  —  Function angle_to_δ²dcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX) Compute the second order time derivative of the direction cosine matrix that perform  a set of rotations ( θ ,  ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation  input must be an indexable objected which includes the angle and its first and second order  time derivatives. The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δdcm source"},{"id":547,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.angle_to_δ³dcm","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.angle_to_δ³dcm","content":" FrameTransformations.Utils.angle_to_δ³dcm  —  Function angle_to_δ³dcm(θ::Number[, ϕ::Number[, γ::Number]], rot_seq::Symbol = :Z) Compute the second order time derivative of the direction cosine matrix that perform  a set of rotations ( θ ,  ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation  input must be an indexable objected which includes the angle and its time derivatives up to  order 3 (jerk). The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δdcm source"},{"id":548,"pagetitle":"Low-level API","title":"FrameTransformations.Utils._3angles_to_δdcm","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils._3angles_to_δdcm","content":" FrameTransformations.Utils._3angles_to_δdcm  —  Function _3angles_to_δdcm(θ, rot_seq::Symbol) Compute the time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":549,"pagetitle":"Low-level API","title":"FrameTransformations.Utils._3angles_to_δ²dcm","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils._3angles_to_δ²dcm","content":" FrameTransformations.Utils._3angles_to_δ²dcm  —  Function _3angles_to_δ²dcm(θ, rot_seq::Symbol) Compute the 2nd time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":550,"pagetitle":"Low-level API","title":"FrameTransformations.Utils._3angles_to_δ³dcm","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils._3angles_to_δ³dcm","content":" FrameTransformations.Utils._3angles_to_δ³dcm  —  Function _3angles_to_δ³dcm(θ, rot_seq::Symbol) Compute the 3rd order time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":551,"pagetitle":"Low-level API","title":"Constants","ref":"/FrameTransformations/stable/Modules/utils_lapi/#Constants","content":" Constants"},{"id":552,"pagetitle":"Low-level API","title":"FrameTransformations.Utils.light_speed","ref":"/FrameTransformations/stable/Modules/utils_lapi/#FrameTransformations.Utils.light_speed","content":" FrameTransformations.Utils.light_speed  —  Constant light_speed Official light speed constant value used in CSPICE  source"},{"id":555,"pagetitle":"01 - Frame System","title":"Frame System Overview","ref":"/FrameTransformations/stable/Tutorials/t00_frames/#tutorial_00_frames","content":" Frame System Overview The core object of  FrameTransformations  is the  FrameSystem , which provides the capability to compute relative position, orientation and their time derivatives up to order 3 (jerk), between standard and user-defined point and axes. It works by creating two separate graphs that silently store and manage all the parent-child relationships between the user-registered axes and points, in the form of  Frames.FramePointNode  and  Frames.FrameAxesNode .  These two objects define two precise entities:  Axes : defines an orientation in space. These are related each other by means of a  Rotation  transformation which relate one axes to a parent axes in a certain time interval. Points : defines a location in space. These are related each other by means of a  Translation    transformation which relate one point to a parent point in a particular axes in a certain    time interval. Note A single  FrameSystem  instance simultaneously handles both the axes and point graphs, regardless of what the user registers in it. For instance, if no points are added, the point graph will remain empty. Additionally, any node can have several childs, each with different transformations with respect to the parent node. Moreover, nodes can be  created  independenlty of each other (by means of the  @axes , and  @point  macros). However, they shall be  registered  within the  FrameSystem  before being used in a transformation or as parents of other nodes."},{"id":556,"pagetitle":"01 - Frame System","title":"Basic Constructors","ref":"/FrameTransformations/stable/Tutorials/t00_frames/#Basic-Constructors","content":" Basic Constructors The creation of a generic  FrameSystem  requires the definition of the maximum desired transformation order and of its  DataType , which in most applications is a  Float64 . The transformation order is always one greater than the maximum desired time derivative. For instance,  if the user only desires to compute position and velocity components (i.e., order 1 time-derivative), the transformation order to be used is 2. Thus, the maximum allowed transformation order is 4.  In this example, we highlight the most basic way to initialise a  FrameSystem : julia> F = FrameSystem{2, Float64}() FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n) From this example, you can see that within the frame system there are both point and axes graphs. However, at the moment they are completely empty since the graph was just created. Each  FrameSystem  object is assigned a reference timescale that is used to perform  computations with epochs and to parse ephemeris files. The default timescale is the  BarycentricDynamicalTime , however, the user is free to select the most suited timescale for his applications. In this example, we set the  InternationalAtomicTime  as the reference scale. julia> F = FrameSystem{2, Float64, InternationalAtomicTime}() FrameSystem{2, Float64, InternationalAtomicTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n)"},{"id":557,"pagetitle":"01 - Frame System","title":"Ephemerides Support","ref":"/FrameTransformations/stable/Tutorials/t00_frames/#Ephemerides-Support","content":" Ephemerides Support In certain scenarios, the transformations require usage of binary ephemeris kernels, e.g., the JPL's DE440 files. To support this applications, an ephemeris provider can be associated to a  FrameSystem . Since this package leverages a set of standard interfaces, any ephemeris reader that exposes JSMD-compatible interfaces can be used as a backend in FrameTransformations. Currently, the only two supported readers are our own  Ephemerides.jl  or  CalcephEphemeris.jl . Although the former only can only parse binary PCK/SPK kernels, it seamlessly integrates with  ForwardDiff  since it is completely written in Julia. Once the desired ephemeris provider is created, it can be associated to the frame system object. However, in this case the reference timescale is retrieved from the ephemeris kernels and cannot be specified by the user. In this example we begin loading an old DE421 kernerl to pass to the  ephemeris reader. julia> using Ephemerides, Downloads julia> url = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\"; julia> eph = EphemerisProvider(Downloads.download(url)) 1-kernel EphemerisProvider:\n \"/tmp/jl_jw3K30RgBC\" julia> F = FrameSystem{2, Float64}(eph) FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n) As you can see, the default  NullEphemerisProvider  has been replaced by the user-constructed one. "},{"id":560,"pagetitle":"02 - Axes","title":"Axes Creation and Rotations","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#tutorial_01_axes","content":" Axes Creation and Rotations To compute relative orientations,  FrameTransformations  provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the  FrameSystem  In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes.  At the time being, the following types of axes are supported: Inertial axes : these are the only ones which can be used as root axes to initialise the axes graph.  Fixed offset axes : they have a constant orientation with respect to their parent axes. Rotating axes : the orientation of these axes depends only on time and is computed through the custom functions provided by the user Computable axes : they are computed through two vectors that are defined within the frame system itself. Computable axes are the equivalent of SPICE's parameterized two-vector frames. Projected axes : the orientation of these axes depends only on time and is computed through the custom functions provided by the user. Projected axes are similar to rotating axis, except that all the positions, velocity, etc ... are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null, despite the rotation depends on time). Ephemeris axes : these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the  FrameSystem . Note This package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g.,  add_axes_eclipj2000! ."},{"id":561,"pagetitle":"02 - Axes","title":"Rotations","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Rotations","content":" Rotations Before diving into the creation of the axes graph, it is worth highlighting that transformations that express the relative orientation or its time-derivatives between two generic set of axes are represented by a  Rotation  object, which stores a Direction Cosine Matrix (DCM) and its derivatives. This package leverages the already available  ReferenceFrameRotations.jl  to define the DCM objects.  A time-fixed rotation between two axes and its derivative can then be expressed as follows:  julia> using ReferenceFrameRotations julia> dcm  = angle_to_dcm(π/3, :Z) DCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0 julia> δdcm = DCM(0I) DCM{Int64}:\n 0  0  0\n 0  0  0\n 0  0  0 julia> R = Rotation(dcm, δdcm) Rotation{2, Float64}(([0.5000000000000001 0.8660254037844386 0.0; -0.8660254037844386 0.5000000000000001 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) julia> R[1] DCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0 julia> R[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 A rotation object is returned by all the rotation functions that are applied to the frame system. It provide overloads to the basic algebraic operations so that multiplication and inversions can be efficiently computed leveraging the properties of rotation matrixes. For example, to rotate a generic vector  v , we can simply do:  julia> v = [1., -6., 3., 0., 5., 0] 6-element Vector{Float64}:\n  1.0\n -6.0\n  3.0\n  0.0\n  5.0\n  0.0 julia> R*v 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -4.696152422706632\n -3.8660254037844393\n  3.0\n  4.330127018922193\n  2.5000000000000004\n  0.0 The inverse can instead be taken as:  julia> inv(R) Rotation{2, Float64}(([0.5000000000000001 -0.8660254037844386 0.0; 0.8660254037844386 0.5000000000000001 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) See the  Rotation API  for more information on this object."},{"id":562,"pagetitle":"02 - Axes","title":"Graph Initialisation","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Graph-Initialisation","content":" Graph Initialisation In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon's Principal Axes (PA) 440, whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, we will use our own  Ephemerides.jl  package and download the kernels from NAIF's website. julia> using Ephemerides, Downloads julia> url_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\"; julia> url_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\"; julia> eph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)]) 2-kernel EphemerisProvider:\n \"/tmp/jl_T8DabYBQpq\"\n \"/tmp/jl_jmXIRUlcTM\" julia> G = FrameSystem{3, Float64}(eph) FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 2-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n) To initialise the axes computational graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the  FrameSystem .  Before registering the axes, the  @axes  macro is used to define an acronym, an ID and a name of each set of axes that we wish to register in the system. If a name is not provided, a default one is used. In this example, we will use the  ICRF  as our base root inertial axes. julia> @axes ICRF 1 InternationalCelestialReferenceFrame julia> add_axes_inertial!(G, ICRF) Once a set of root axes has been registered, any other type of axes can be added to the system. Note For standard applications, it is good practice that the axes's IDs are as in agreement with NAIF's numbering system. A list of IDs for the most common axes is provided in the Orient submodule. Note The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the axes are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. For instance, one could register a set of rotating axes named  ICRF ."},{"id":563,"pagetitle":"02 - Axes","title":"Inertial Axes","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Inertial-Axes","content":" Inertial Axes Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis.  In this example, we register the  ECLIPJ2000  as a set of inertial axes with respect to the  ICRF . Since the set of root axes has already been defined, all the future usages of the  add_axes_inertial!  function require a parent set of axes and a DCM with the relative orientation. julia> @axes ECLIPJ2000 17 julia> add_axes_inertial!(G, ECLIPJ2000; parent=ICRF, dcm=DCM_ICRF_TO_ECLIPJ2000) julia> R = rotation6(G, ICRF, ECLIPJ2000, 10.0) Rotation{2, Float64}(([0.9999999999999941 -9.698854433992582e-8 4.57581833871911e-8; 7.078368694637674e-8 0.9174820489188898 0.3977771862633533; -8.05621421162006e-8 -0.3977771862633478 0.9174820489188915], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) julia> R[1] DCM{Float64}:\n  1.0         -9.69885e-8  4.57582e-8\n  7.07837e-8   0.917482    0.397777\n -8.05621e-8  -0.397777    0.917482 julia> R[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Notice that we leveraged the default DCM provided by Orient's to express the relative orientation between the  ICRF  and the  ECLIPJ2000 . For a set of default DCM exported by Orient, check the  API documentation . Additionally, since it is an inertial frame, the time derivative of the rotation is null. "},{"id":564,"pagetitle":"02 - Axes","title":"Fixed-offset Axes","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Fixed-offset-Axes","content":" Fixed-offset Axes Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes. In this example, we register  FO1  as a set of axes with a fixed rotation of  π/4  around the Z-axis with respect to the  ICRF . julia> @axes FO1 2 julia> rot = angle_to_dcm(π/4, :Z) DCM{Float64}:\n  0.707107  0.707107  0.0\n -0.707107  0.707107  0.0\n  0.0       0.0       1.0 julia> add_axes_fixedoffset!(G, FO1, ICRF, rot) The state rotation matrix can then be obtained as:  julia> R = rotation6(G, ICRF, FO1, 86400) Rotation{2, Float64}(([0.7071067811865476 0.7071067811865475 0.0; -0.7071067811865475 0.7071067811865476 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) julia> R[1] DCM{Float64}:\n  0.707107  0.707107  0.0\n -0.707107  0.707107  0.0\n  0.0       0.0       1.0 julia> R[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Since  FO1  has a constant orientation with respect to the  ICRF , the time derivative of the rotation matrix  R[2]  is infact null. For further information see the  add_axes_fixedoffset!  documentation."},{"id":565,"pagetitle":"02 - Axes","title":"Rotating Axes","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#rot_axes","content":" Rotating Axes Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from the  ReferenceFrameRotations.jl  package. julia> @axes RotAx 3 julia> fun(t) = angle_to_dcm(-t, :Z) fun (generic function with 1 method) julia> add_axes_rotating!(G, RotAx, FO1, fun) If we now compute the orientation between the  ICRF  and  RotAx  at  π/4  we obtain an identity rotation, since the orientation of  RotAx  is directed in the opposite direction of  FO1 . julia> R1 = rotation6(G, ICRF, RotAx, π/4) Rotation{2, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0], [0.0 -1.0 0.0; 1.0 0.0 0.0; 0.0 0.0 0.0])) julia> R1[1] DCM{Float64}:\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0 julia> R2 = rotation6(G, ICRF, RotAx, π/2) Rotation{2, Float64}(([0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 0.7071067811865475 0.0; 0.0 0.0 1.0], [-0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 -0.7071067811865476 0.0; 0.0 0.0 0.0])) julia> R2[2] DCM{Float64}:\n -0.707107  -0.707107  0.0\n  0.707107  -0.707107  0.0\n  0.0        0.0       0.0 Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of  fun . This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example:  julia> @axes RotAx2 4 julia> fun(t) = angle_to_dcm(-t, :Z) fun (generic function with 1 method) julia> dfun(t) = (angle_to_dcm(-t, :Z), Utils.angle_to_δdcm([-t, -1], :Z)) dfun (generic function with 1 method) julia> add_axes_rotating!(G, RotAx2, FO1, fun, dfun) julia> R2 = rotation6(G, ICRF, RotAx2, π/2) Rotation{2, Float64}(([0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 0.7071067811865475 0.0; 0.0 0.0 1.0], [-0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 -0.7071067811865476 0.0; 0.0 0.0 0.0])) julia> R2[2] DCM{Float64}:\n -0.707107  -0.707107  0.0\n  0.707107  -0.707107  0.0\n  0.0        0.0       0.0 We can see the results are in agreement with the previous example. For more details, consult the  add_axes_rotating!  documentation."},{"id":566,"pagetitle":"02 - Axes","title":"Projected Axes","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Projected-Axes","content":" Projected Axes Projected axes are a particular type of inertial axes. In this case the rotation is built by means of a time dependant function  f(t) . However, all the derivatives of  f(t)  are assumed to be zero. This axes type is usually used to build True-of-Date (TOD) axes sets.  In this example, we illustrate this difference by registering two new set of axes with the same relative orientation with respect to the  ICRF , one rotating and one projected.  julia> @axes ProjAx 500 julia> @axes RotAx3 501 julia> fun(t) = angle_to_dcm(-t, :Z) fun (generic function with 1 method) julia> add_axes_rotating!(G, RotAx3, ICRF, fun) julia> add_axes_projected!(G, ProjAx, ICRF, fun) julia> R1 = rotation6(G, ICRF, RotAx3, 50.0) Rotation{2, Float64}(([0.9649660284921133 0.26237485370392877 0.0; -0.26237485370392877 0.9649660284921133 0.0; 0.0 0.0 1.0], [0.26237485370392877 -0.9649660284921133 0.0; 0.9649660284921133 0.26237485370392877 0.0; 0.0 0.0 0.0])) julia> R2 = rotation6(G, ICRF, ProjAx, 50.0) Rotation{2, Float64}(([0.9649660284921133 0.26237485370392877 0.0; -0.26237485370392877 0.9649660284921133 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) julia> R1[1] - R2[1] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 julia> R1[2] DCM{Float64}:\n 0.262375  -0.964966  0.0\n 0.964966   0.262375  0.0\n 0.0        0.0       0.0 julia> R2[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 As you can see, while the relative orientation  R[1]  is equal, the time-derivative of the projected-axes orientation is null. For further information see the  add_axes_projected!  documentation."},{"id":567,"pagetitle":"02 - Axes","title":"Computable Axes","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Computable-Axes","content":" Computable Axes Computable axes are a kind of  time-dependant axes . In this case, differently from the rotating axes, the axes and their derivatives are computed through two time-dependant vectors which are expressed using any type of point that is registered in the system. These axes are the equivalent of SPICE's two-vector frames. In this example, we will register two ephemeris points, the Solar system barycenter and the Sun. For more information on how this operation is performed, see the  points tutorial . The two vectors that generate the set of computable axes are defined with the  ComputableAxesVector  object, by specifing the vector center and target point and its order, i.e., whether we are interested in the position, velocity or acceleration of that vector. A symbol is used to specify which direction the vectors have to align with.  In this example, the axes are constructed with the X-axis parallel to the instantaneous SSB to Sun direction, whereas the secondary vector is chosen parallel to the SSB to Sun velocity vector (order 2). Then, the component of this vector orthogonal to the X-axis is used to create the Y-axis.  julia> @axes SunFrame 600 julia> @point SSB 0 SolarSystemBarycenter julia> @point Sun 10 SunPoint julia> add_point_root!(G, SSB, ICRF) julia> add_point_ephemeris!(G, Sun, SSB) julia> v1 = ComputableAxesVector(Sun, SSB, 1) ComputableAxesVector(10, 0, 1) julia> v2 = ComputableAxesVector(Sun, SSB, 2) ComputableAxesVector(10, 0, 2) julia> add_axes_computable!(G, SunFrame, ICRF, v1, v2, :XY) julia> R = rotation6(G, ICRF, SunFrame, 0.0) Rotation{2, Float64}(([0.9307646313076896 0.3452349713257856 0.12037448101796602; -0.3646672694138606 0.8528460137376037 0.37372645005420435; 0.026362543976245705 -0.39174799479456546 0.9196947998382602], [-4.876410895608863e-9 1.1404444386663028e-8 4.997552250715579e-9; -1.24485977115153e-8 -4.583740451381578e-9 -1.686718623822076e-9; -3.054887777376799e-11 7.144454909647363e-11 3.1307782740910527e-11])) For further information see the  add_axes_computable!  documentation. Note The center and target point can either be specified with their integer IDs or their name aliases. "},{"id":568,"pagetitle":"02 - Axes","title":"Ephemeris Axes","ref":"/FrameTransformations/stable/Tutorials/t01_axes/#Ephemeris-Axes","content":" Ephemeris Axes Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth's ITRF. Note To properly compute the orientation of these axes, the  FrameSystem  object must contain an ephemeris provider that has loaded the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels.  In this example, the ephemeris provider  eph  in the frame system  G  has loaded the DE421 PCK kernel containing the orientation of the Moon's Principal Axes (PA421). NAIF's system has assigned to such set of axes the ID  31006 . If a different ID was assigned to the  MoonPA , the function would have thrown an error. A set of default axes IDs is also defined within the  Orient 's submodule for ease of use. The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix. julia> @axes MoonPA 31006 julia> add_axes_ephemeris!(G, MoonPA, :ZXZ) julia> R = rotation9(G, ICRF, MoonPA, 86400.0) Rotation{3, Float64}(([0.6219855961037569 0.7077415949385507 0.33501604891898906; -0.7827096425059984 0.5741656785808802 0.24020697131409327; -0.022350252069861617 -0.4116255681242284 0.911078952615425], [-2.0835792981059603e-6 1.5281546248856286e-6 6.400222345301864e-7; -1.6557195262995373e-6 -1.8840097087356063e-6 -8.917889621565607e-7; -3.880601321351557e-10 -4.740262874274574e-10 -2.236848750095691e-10], [-4.407703819959643e-12 -5.014536010737041e-12 -2.3750017657161296e-12; 5.546289270719377e-12 -4.068112024772315e-12 -1.7038759932684681e-12; 2.130250244357035e-15 -4.0450577593420844e-17 3.3516097976061354e-17])) For further information see the  add_axes_ephemeris!  documentation."},{"id":571,"pagetitle":"03 - Points","title":"Points Creation and Translations","ref":"/FrameTransformations/stable/Tutorials/t02_points/#tutorial_02_points","content":" Points Creation and Translations Similarly to  axes ,  FrameTransformations  also provides the capability to define custom and standard reference points (e.g., the Solar System Barycenter) and arbitrarily connect them through the  FrameSystem  In turn, this allows the computation of the relative position and its derivatives (up to order 3) between any two registered points and express it in any known set of axes.  At the time being, the following types of points are supported: Root point : it is the root of the point graph. Fixed points : are those whose positions have a constant offset with respect their parent point in a given set of axes. Dynamical points : the position of these points depends only on time and is computed through custom user-defined functions. Ephemeris points : are those whose state-vector is retrieved from binary SPK kernels (e.g., DE440) that are loaded within the  FrameSystem . Updatable points : differently from all the other classes, the state vector for updatable points must be manually updated at a given epoch before it can be used in any transformation at the same epoch. Note This package provides a dedicated function to register each type of supported points."},{"id":572,"pagetitle":"03 - Points","title":"Graph Initialisation","ref":"/FrameTransformations/stable/Tutorials/t02_points/#Graph-Initialisation","content":" Graph Initialisation In this section we will display how to create a frame system to compute generic points transformation. Differently from the axes graph, each register point is also associated to a set of axes. Hence, this tutorial assumes the reader to already be familiar with the different types of axes and their definitions. First of all, we need to load both this package and an ephemeris reader. The latter will be used to retrieve the positions of the planets from the binary SPK kernels. In this example, we will use our own  Ephemerides.jl  package and download the kernels from NAIF's website. julia> G = FrameSystem{2, Float64}() FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n) To initialise the point graph, we first need to define a root point. This, in turn, must be associated to an arbitrary set of axes. Therefore, we begin by definining a generic  SatelliteFrame , here considered as inertial, and then register a root point, called  SpacecraftCenter  in our graph. Similarly, to axes, the  @point  macro is used to define an acronym, an ID and a name of each point that we wish to register in the system. If a name is not provided, a default one is used.  A root point can be registered using the  add_point_root!  function:  julia> @axes SATF 1 SatelliteFrame julia> add_axes_inertial!(G, SATF) julia> @point SC -10000 SpacecraftCenter julia> add_point_root!(G, SC, SATF) Note For standard applications, it is good practice that the points's IDs are as in agreement with NAIF's numbering system. This becomes mandatory to properly read JPL's SPK kernels. Note The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the point are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning.  We can now see that our axes and point graphs are populating themselves: julia> G FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points:\n\t SC\n\n  axes:\n\tSATF\n\n)"},{"id":573,"pagetitle":"03 - Points","title":"Fixed Points","ref":"/FrameTransformations/stable/Tutorials/t02_points/#Fixed-Points","content":" Fixed Points Fixed points have a constant relative position vector with respect to their parent points in a given set of axes. Similarly to fixed-offset axes, these points are fixed w.r.t. their parents but might be moving with respect to others.  In this example, we use the  add_point_fixed!  function to register the location of an antenna and two solar panels, which are generally fixed in the satellite body-fixed frame. To do so, we define a position offset in the form of a 3-elements vector with respect to the  SpacecraftCenter . julia> @point SACL -10101 SolarArrayCenterLeft julia> @point SACR -10102 SolarArrayCenterRight julia> @point Antenna -10001 julia> sa_offset_left = [1.0, 0.0, 0.0] 3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0 julia> sa_offset_right = [-1.0, 0.0, 0.0] 3-element Vector{Float64}:\n -1.0\n  0.0\n  0.0 julia> an_offset = [0.0, 0.0, -1.0] 3-element Vector{Float64}:\n  0.0\n  0.0\n -1.0 julia> add_point_fixed!(G, SACL, SC, SATF, sa_offset_left) julia> add_point_fixed!(G, SACR, SC, SATF, sa_offset_right) julia> add_point_fixed!(G, Antenna, SC, SATF, an_offset) As a result the graph is now populated with the new points and we can finally compute their relative positions and velocities with the proper transformation functions:  julia> vector3(G, SACL, SC, SATF, 0.0) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -1.0\n -0.0\n -0.0 julia> vector6(G, Antenna, SACR, SATF, 10.0) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -1.0\n -0.0\n  1.0\n -0.0\n -0.0\n -0.0 As expected, since these points are fixed, the relative velocity vector is null."},{"id":574,"pagetitle":"03 - Points","title":"Dynamical Points","ref":"/FrameTransformations/stable/Tutorials/t02_points/#Dynamical-Points","content":" Dynamical Points Dynamical points are generic time-dependent points whose position vector (and optionally its derivatives) are only function of time. However, differently from ephemeris points, their position is computed through  user-defined functions. julia> @point TimeDependantAppendage -10003 julia> fun(t) = [cos(t), sin(t), 0] fun (generic function with 1 method) julia> add_point_dynamical!(G, TimeDependantAppendage, SACL, SATF, fun) julia> vector6(G, TimeDependantAppendage, SC, SATF, π/3) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -1.5\n -0.8660254037844386\n -0.0\n  0.8660254037844386\n -0.5000000000000001\n -0.0 Note To avoid allocations,  fun  should return a static array. Similarly to rotating-axes, if the user only provides the function to compute the relative position, the remaining derivatives are automatically retrievied via automatic differentiation of  fun . On the other hand, if those functions are specified, they must return a single vector that stacks all the components. For instance, for the second order derivative of  fun , the function should return a 9-elements vector containing the relative position, velocity and acceleration. For example:  julia> @point TimeDependantAppendage2 -10004 julia> fun(t) = [cos(t), sin(t), 0] fun (generic function with 1 method) julia> dfun(t) = [cos(t), sin(t), 0, -sin(t), cos(t), 0] dfun (generic function with 1 method) julia> add_point_dynamical!(G, TimeDependantAppendage2, SACL, SATF, fun, dfun) julia> vector6(G, TimeDependantAppendage2, SC, SATF, π/3) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -1.5\n -0.8660254037844386\n -0.0\n  0.8660254037844386\n -0.5000000000000001\n -0.0 We can again see that the results are in agreement with the previous example. For more details, consult the  add_point_dynamical!  documentation."},{"id":575,"pagetitle":"03 - Points","title":"Updatable Points","ref":"/FrameTransformations/stable/Tutorials/t02_points/#updatable_points","content":" Updatable Points Updatable points are a class of point whose states at a given epoch must be manually updated  before any other computation at the same epoch can occur. They can be inserted in the  computational graphs as follows: julia> @point UA -10002 UpdatableAppendage julia> add_point_updatable!(G, UA, SC, SATF) If we now call a transformation involving this point, an error will be thrown because we have  not registered any state for this point. To do so, we use the  update_point!  function and then  evaluate the relative position:  julia> ua_pos = [0.0, -1.0, 0.0] 3-element Vector{Float64}:\n  0.0\n -1.0\n  0.0 julia> update_point!(G, UA, ua_pos, 0.0) julia> vector3(G, Antenna, UA, SATF, 0.0) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.0\n -1.0\n  1.0 Note that in the previous example, only the position has been updated but the current frame system is of order two! Therefore, in this case, calling  vector6  will give an error since  the computational graph is order-sentitive. To correct that behaviour, also the higher order shall be updated: julia> update_point!(G, UA, [1.0, -1.0, 0.0, 0.0, 0.0, 0.0], .0) julia> vector6(G, Antenna, UA, SATF, 0.0) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n  1.0\n -1.0\n  1.0\n -0.0\n -0.0\n -0.0 Note Updatable points do not store any history of the updated states. Meaning that each time  a state is updated at a different epoch, the information of the older epochs is completely lost."},{"id":576,"pagetitle":"03 - Points","title":"Ephemeris Points","ref":"/FrameTransformations/stable/Tutorials/t02_points/#Ephemeris-Points","content":" Ephemeris Points Ephemeris points are a type of time-dependent points whose position and higher-order derivatives are retrieved from a binary SPK ephemeris kernel. However, differently from all other points, in this case the set of axes is automatically inferred from those contained in the ephemeris kernels. In case such set is not yet registered in the frame system, an error will be thrown.  Note To properly compute the position of these points, the  FrameSystem  object must contain an ephemeris provider that has loaded the necessary kernels. Additionally, in this case the ID of the registered points must match the ID contained in the SPK kernels.  In this example, we define a new frame system  F  and give it an ephemeris provider that has loaded the DE421 SPK kernel, containing the position of the major planets and/or their barycenters of the Solar System. julia> using Ephemerides, Downloads julia> spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\"; julia> eph = EphemerisProvider(Downloads.download(spk)) 1-kernel EphemerisProvider:\n \"/tmp/jl_7WjIzU7Kny\" julia> F = FrameSystem{2, Float64}(eph) FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n) We now register some points that are stored in the kernels using the  add_point_ephemeris!  function:  julia> @axes ICRF 1 julia> @point SSB 0 julia> @point Sun 10 julia> @point EMB 3 julia> @point Earth 399 julia> add_axes_inertial!(F, ICRF) julia> add_point_root!(F, SSB, ICRF) julia> add_point_ephemeris!(F, Sun, SSB) julia> add_point_ephemeris!(F, EMB) julia> add_point_ephemeris!(F, Earth) julia> F FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points:\n\t SSB\n\t  ├── Sun\n\t  ├── EMB\n\t   ├── Earth\n\n  axes:\n\tICRF\n\n) Notice that this function does not necessarily requires the parent point. Indeed, if no point is specified, the parent is automatically set to those contained in the descriptors of the ephemeris kernels. For instance, in the DE421, the Earth-Moon Barycenter (EMB) is defined with respect to the SSB, which the frame system automatically uses as parent for the EMB. Similarly, the EMB is the default parent point for the Earth. Note It is always recommended to use as parent of ephemeris points, the point with respect to which its ephemeris data is written in the binary kernels. This becomes mandatory if  Ephemerides.jl  is used as an ephemeris provider. Warning If a parent point is not specified and the point in the kernels has not yet been registered, an error is thrown.  Finally, we can retrieve the transformation data as usual:  julia> vector6(F, EMB, SSB, ICRF, 1000.0) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n  2.759995209892622e7\n -1.323531471583657e8\n -5.741553718779148e7\n 29.776022371329166\n  5.043381865003682\n  2.1867059592615563 julia> vector3(F, Earth, SSB, ICRF, 0.0) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n  2.756663231104537e7\n -1.3236142853828153e8\n -5.7418647383661106e7"},{"id":579,"pagetitle":"04 - Use Case: CR3BP","title":"Use Case: CR3BP","ref":"/FrameTransformations/stable/Tutorials/t03_cr3bp/#tutorial_03_cr3bp","content":" Use Case: CR3BP The power of the  FrameSystem  is its capability to handle axes transformations and point translations of both high-accuracy and simplified models. The use-case here presented includes the case of the Circular-Restricted Three-Body Problem (CR3BP) rotating frame transformation handling. In particular, when dealing with the  CR3BP , mission analysis are used to exploit non-dimensional, rotating coordinates to express the equations of motion and perform the computations.  In this tutorial, we create a  FrameSystem  to handle transformations within the Earth-Moon  CR3BP, which is characterized by a mass ratio of approximately  μ = 0.012 . We start off by creating a frame system without any ephemeris provider, since we are using a simplified model. julia> CR3BP = FrameSystem{2, Float64}() FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n) As always, the first step requires the definition of the root axes and points. In this case, we use the a generic set of  inertial axes  and the Earth-Moon Barycenter (EMB). julia> @axes InertialAx 1 InertialFrame julia> add_axes_inertial!(CR3BP, InertialAx) julia> @point EMBc 1 EarthMoonBarycenterCr3bp julia> add_point_root!(CR3BP, EMBc, InertialAx) We now proceed to add our synodic axes: in the CR3BP these are uniformly rotating with respect to the  InertialAx  about the Z-axis. Therefore, we leverage the  rotating axes  type:  julia> using ReferenceFrameRotations julia> f(t) = angle_to_dcm(t, :Z) f (generic function with 1 method) julia> @axes SynodicAx 2 SynodicFrame julia> add_axes_rotating!(CR3BP, SynodicAx, InertialAx, f) Note that there is no need to specify the rotation derivatives, as they'll be computed by  automatic differentiation via the  ForwardDiff  package. For performace-critical transformations, however, it is reccomended to manually define these derivatives. Now, let's assume we have our spacecraft. Most likely, its states will be expressed in the synodic frame. In this case, we leverage  updatable points , since we desire to manually update its state at each time. julia> @point Spacecraft -1_900_000 julia> add_point_updatable!(CR3BP, Spacecraft, EMBc, SynodicAx) We know assume that at  t = 0.8  our spacecraft is at L4, therefore we update its state accordingly: julia> μ = 0.012 0.012 julia> xL4 = [1/2-μ, sqrt(3)/2, 0.0, 0.0, 0.0, 0.0] 6-element Vector{Float64}:\n 0.488\n 0.8660254037844386\n 0.0\n 0.0\n 0.0\n 0.0 julia> t = 0.8 0.8 julia> update_point!(CR3BP, Spacecraft, xL4, t) Finally we can retrieve the spacecraft state in both the synodic as well as the inertial axes:  julia> vector6(CR3BP, EMBc, Spacecraft, SynodicAx, t) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 0.488\n 0.8660254037844386\n 0.0\n 0.0\n 0.0\n 0.0 julia> vector6(CR3BP, EMBc, Spacecraft, InertialAx, t) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -0.28125572411706895\n  0.9534354816406736\n  0.0\n -0.9534354816406736\n -0.28125572411706895\n  0.0"},{"id":582,"pagetitle":"05 - Use Case: High Fidelity","title":"Use Case: High Fidelity","ref":"/FrameTransformations/stable/Tutorials/t04_hifi/#tutorial_04_hifi","content":" Use Case: High Fidelity Once the general structure of the  FrameSystem  is understood, we can pass to a use case in which we want to build and exploit our frame system to perform computations in a high-fidelity environment. "},{"id":583,"pagetitle":"05 - Use Case: High Fidelity","title":"Frame system setup","ref":"/FrameTransformations/stable/Tutorials/t04_hifi/#Frame-system-setup","content":" Frame system setup In this example, we plan on using ephemeris data to retrieve accurate positions of the planets and the orientation of certain reference frames. Therefore, we create an ephemeris provider object leveraging our own  Ephemerides.jl  package and use it to generate a frame system instance: julia> using Ephemerides, Downloads julia> url_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\"; julia> url_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\"; julia> eph = EphemerisProvider([Downloads.download(url_spk), Downloads.download(url_pck)]) 2-kernel EphemerisProvider:\n \"/tmp/jl_BW7CNGl6PQ\"\n \"/tmp/jl_hcrqJYPaR0\" julia> FRAMES = FrameSystem{3, Float64}(eph) FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 2-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n) Once the graph is created, we assign the  GCRF  (Geocentric Celestial Reference Frame) as our set of inertial root-axes: julia> @axes GCRF 1 GeocentricCelestialReferenceFrame julia> add_axes_inertial!(FRAMES, GCRF) These axes are practically coincident with the  ICRF . To do so, we can leverage the possibility to define multiple aliases that are associated to the same integer ID. Thus let's create an alias of the  GCRF  and call it  ICRF :  julia> @axes ICRF 1 InternationalCelestialReferenceFrame ERROR: LoadError: UndefVarError: `@axes` not defined\nin expression starting at REPL[1]:1 In this scenario, we will be working within the Cislunar environment, therefore we will need the major bodies that influence this dynamic regime, i..e, the Earth, the Moon and the Sun. To do so, we also define the Solar System Barycenter (SSB) and the Earth-Moon Barycenter (EMB) as the ephemeris data of the remaining bodies is expressed with respect to those.  For this example, we will assume the SSB is our root point: julia> @point SSB 0 julia> @point EMB 3 julia> @point Sun 10 julia> @point Earth 399 julia> @point Moon 301 julia> add_point_root!(FRAMES, SSB, GCRF) julia> add_point_ephemeris!(FRAMES, EMB) julia> add_point_ephemeris!(FRAMES, Earth) julia> add_point_ephemeris!(FRAMES, Moon) julia> add_point_ephemeris!(FRAMES, Sun)"},{"id":584,"pagetitle":"05 - Use Case: High Fidelity","title":"Registering body-fixed axes","ref":"/FrameTransformations/stable/Tutorials/t04_hifi/#Registering-body-fixed-axes","content":" Registering body-fixed axes At this point, we want to be able to transform back and forth from body-fixed axes of the Earth  and the Moon to the  GCRF . The Earth and the Moon cases are actually  special cases  because  they have both high-accuracy and low-precision body-fixed rotation models.  Let's start with the low precision ones:  IAU_EARTH  and  IAU_MOON . To register such frames,  we first need to parse a  TPC  file with the required constants: julia> tpc = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/pck00011.tpc\"; julia> iau = load(TPC(Downloads.download(tpc))); At this point, we leverage the high-level interface provided by this package to automatically  generates ad-hoc functions from the IAU Rotational Elements via the  add_axes_bcrtod!  function. In particular, these axes are Body-Centric Rotating, True-of-Date axes, or BCR-TOD (which  are the  FrameTransformations  way of representing SPICE  IAU_XXX  axes). julia> @axes IAU_EARTH 3 julia> @axes IAU_MOON 4 julia> add_axes_bcrtod!(FRAMES, iau, Earth, IAU_EARTH, ICRF); ┌ Warning:  ignoring orient_rot9_icrf_to_bcr_tod_Earth, frame system order is less than 3\n └  @ FrameTransformations.Frames ~/work/FrameTransformations.jl/FrameTransformations.jl/src/Frames/axes.jl:494 julia> add_axes_bcrtod!(FRAMES, iau, Moon, IAU_MOON, ICRF); ┌ Warning:  ignoring orient_rot9_icrf_to_bcr_tod_Moon, frame system order is less than 3\n └  @ FrameTransformations.Frames ~/work/FrameTransformations.jl/FrameTransformations.jl/src/Frames/axes.jl:494 The registration of this type of axes requires either an alias or the ID of the point associated to the body. For convenience, let us also insert a set of inertial axes for the Moon. This can be done using the IAU-based Body-Centric Inertial J2000 axes available through the  add_axes_bci2000!  function, which defines a rotation from the  ICRF  to the local equatorial plane of the body at the J2000 epoch. julia> @axes LME2000 5 julia> add_axes_bci2000!(FRAMES, iau, Moon, LME2000, ICRF); Finally, we complete the axes definition by inserting the high-precision Earth and Lunar body-fixed rotation models.  For this purpose,  FrameTransformations  provides two high-level functions that can be used to ease these definitions:   add_axes_itrf!  and  add_axes_pa421! . julia> @axes ITRF 6 julia> @axes MOONPA_DE421 31006 julia> add_axes_itrf!(FRAMES, ITRF, GCRF) ┌ Warning:  ignoring #219, frame system order is less than 4\n └  @ FrameTransformations.Frames ~/work/FrameTransformations.jl/FrameTransformations.jl/src/Frames/axes.jl:494 julia> add_axes_pa421!(FRAMES, MOONPA_DE421, ICRF) The default ITRF model is the  iau2006b , but other approximations are also  available . If one was interested in the Moon's PA440 axes, a similar function named  add_axes_pa440!  is available. Note To correctly use the  add_axes_pa421!  function, the frame system must contain an ephemeris provider that has loaded the necessary PCK kernels with the DE421 data."},{"id":585,"pagetitle":"05 - Use Case: High Fidelity","title":"Using the  FrameSystem","ref":"/FrameTransformations/stable/Tutorials/t04_hifi/#Using-the-FrameSystem","content":" Using the  FrameSystem Now let's assume we have a spacecraft in orbit about the Moon in the  LME2000  axes, and we want to compute its position in the  GCRF  and with respect to both the Moon and the Earth surface. We then start by registering our spacecraft as an  updatable point : julia> @point SC -1_900_000 julia> add_point_updatable!(FRAMES, SC, Moon, LME2000) Therefore our final  FrameSystem  results in: julia> FRAMES FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 2-kernel EphemerisProvider,\n  points:\n\t SSB\n\t  ├── EMB\n\t   ├── Earth\n\t   ├── Moon\n\t    ├── SC\n\t  ├── Sun\n\n  axes:\n\tGCRF\n\t ├── IAU_EARTH\n\t ├── IAU_MOON\n\t ├── LME2000\n\t ├── ITRF\n\t ├── MOONPA_DE421\n\n) To begin exploiting our newly completed frame system, we assumed that our  SC  is on a circular equatorial orbit around the Moon at an altitude of 500 km, so that at the epoch  e , the spacecraft state vector is updated as: julia> e = Epoch(\"2020-01-01T12:45:30.0 TDB\"); julia> x = [2274.0, 0.0, 0.0, 0.0, sqrt(4904.87/2274.0), 0.0]; julia> update_point!(FRAMES, SC, x, e) Note The timescale used for the  Epoch  must be the same used in the  FrameSystem . At this point, we are completely free to compute the state of the spacecraft with respect to any other point registered in the frame system with respect to any known set of axes at the epoch  e . For example, the state in the  LME2000  is:  julia> vector6(FRAMES, Moon, SC, LME2000, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 2274.0\n    0.0\n    0.0\n    0.0\n    1.4686507128813133\n    0.0 The spacecraft state with respect to the Earth in the  GCRF ,  IAU_EARTH  and  ITRF  is instead: julia> vector6(FRAMES, Earth, SC, GCRF, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 401327.3108913339\n -36183.167308353884\n -54688.10677080455\n      0.21054873683700087\n      2.2235437515164302\n      0.9632321102666086 julia> vector6(FRAMES, Earth, SC, IAU_EARTH, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 180191.31638579842\n 360539.43904398684\n -53907.54565836778\n     24.296925174856536\n    -12.133987855895205\n      0.9636312231014527 julia> vector6(FRAMES, Earth, SC, ITRF, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 180632.14455485757\n 360316.9074754028\n -53920.08555987021\n     24.281930059864898\n    -12.163664688380054\n      0.9635795960568233 while the position with respect to the Moon in the  IAU_MOON  and  PA421  axes: julia> vector3(FRAMES, Moon, SC, IAU_MOON, e) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -2265.003321467859\n  -201.71716040981087\n   -12.088876530484505 julia> vector3(FRAMES, Moon, SC, MOONPA_DE421, e) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -2265.06075319964\n  -201.02407346884172\n   -12.84936576926823 These last examples are intended to show how easily the state of a spacecraft with respect to any other body can be retrieved by properly leveraging the  FrameSystem  and the high-level routines provided by this package. "},{"id":588,"pagetitle":"06 - Multithreading","title":"Multithreading","ref":"/FrameTransformations/stable/Tutorials/t05_multithread/#tutorial_05_threads","content":" Multithreading Note Work in progress"},{"id":591,"pagetitle":"Benchmarks","title":"Performance Benchmarks","ref":"/FrameTransformations/stable/benchmarks/#Performance-Benchmarks","content":" Performance Benchmarks A comparative analysis of the execution times of various routines of this package against  other state-of-the-art packages and libraries is here reported. "},{"id":592,"pagetitle":"Benchmarks","title":"IERS Rotation Models","ref":"/FrameTransformations/stable/benchmarks/#IERS-Rotation-Models","content":" IERS Rotation Models The Orient sub-module provides the capability to compute high-accuracy Earth rotation models based on the IERS 2010 conventions. However, differently from traditional packages, it leverages Julia's metaprogramming capabilities to generate optimised functions for the computation of the lengthy 2000A/B nutation series. A comparison against both  ERFA.jl  and  SatelliteToolbox.jl  is here reported. Details These time benchmarks have been obtained on an Intel Core i7-6700 @ 3.4 GHz with 16 GB of RAM"},{"id":593,"pagetitle":"Benchmarks","title":"Relative Orientation","ref":"/FrameTransformations/stable/benchmarks/#Relative-Orientation","content":" Relative Orientation Frames' performance have been tested against both  GODOT  and  SPICE.jl , two of the most-popular packages that can be used to define a system of reference axes and points and to compute the transformations between them. In particular, a comparative analysis of the execution times for computing the relative orientation between different reference axes has been carried out across four distinct scenarios:  Case 1 : From ICRF to the ECLIPJ2000 frame, a time-fixed rotation.  Case 2 : From the IAU-MOON to the ICRF, a time-dependent rotation.  Case 3 : From the IAU-MOON to the ICRF and subsequently to the IAU_EARTH.  Case 4 : From the IAU-MOON, to the ICRF, to the ECLIPJ2000 and finally a shift to the Sun-Earth rotating two-vector frame. Notice that the Sun and Earth positions are retrieved from binary ephemeris kernels. Details These time benchmarks have been obtained on an Intel Core i7-12700 @ 4.7 GHz with 32 GB of RAM This figure also underlines the capability of FrameTransformations (here referred to as  Multiverse ) to use different ephemeris readers as backends within the computational graph."},{"id":594,"pagetitle":"Benchmarks","title":"Relative States","ref":"/FrameTransformations/stable/benchmarks/#Relative-States","content":" Relative States Note Work in progress"},{"id":597,"pagetitle":"Roadmap","title":"Development Roadmap","ref":"/FrameTransformations/stable/roadmap/#Development-Roadmap","content":" Development Roadmap The following table reports the desired list of features considered in the development of  this package, together with their development status. The following color legend is used:  Description 🔵 Stable, deeply tested 🟢 Developed, working, partially tested 🟡 In development 🔴 Development not started but planned ⚪ Outdated/no more supported"},{"id":598,"pagetitle":"Roadmap","title":"Frames","ref":"/FrameTransformations/stable/roadmap/#Frames","content":" Frames All the initially desired features of Frames have been implemented. We are currently working  to avoid undesired allocations when using dual numbers. \n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n Feature Status Comment \n        Create a graph of custom points.\n     🔵 Points could be defined in different ways (not only associated to ephemeris). \n        Create a graph of custom axes.\n     🔵 Axes models for MEME2000, ITRF, IAU models and many others are already implemented and tested within FrameTransformationsFrameTransformations. \n        Get a state of a point relative to another in a custom frame.\n     🔵 Deeply tested against NAIF's SPICE. \n        Full compatibility with ForwardDiff.jl shall be assured.\n     🟡 Partial compatibility is already available. We are resolving the \n    last issues related to undesired allocations when using dual numbers. "},{"id":599,"pagetitle":"Roadmap","title":"Orient","ref":"/FrameTransformations/stable/roadmap/#Orient","content":" Orient All the features of the Orient submodule have been developed and tested. No major updates are currently foreseen. \n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n Feature Status Comment \n        Create IAU standard-based body-fixed rotation matrices.\n     🔵 Deeply tested against NAIF's SPICE. \n        Create ITRF (IERS-based) rotation matrices.\n     🔵 Deeply tested against ERFA. Models with different precisions are available. \n        Fetch automatically IERS EOP.\n     🟢 \n        Fetch leapseconds files automatically.\n     🟢"},{"id":600,"pagetitle":"Roadmap","title":"Utils","ref":"/FrameTransformations/stable/roadmap/#Utils","content":" Utils The initial development plan foresaw the possibility to automatically generate a frame system by parsing NASA JPL frame kernels. Although this capability is still desired within the JSMD ecosystem, we are currently re-evaluating whether it should be implemented within this package. Additionally, part of the math routines that are here available will be moved in the dedicated  JSMDUtils.jl  package. \n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n Feature Status Comment Read JPL ASCII PCK files (constants). 🟢 Fully implemented in FrameTransformations. Tested on NAIF's pck00010 and pck00011 files. Refactor math functions in JSMDUtils. 🔴 Soon planned. Read NASA JPL frame kernels. ⚪ Might be implemented in a different package. Write NASA JPL frame kernels ⚪ Might be implemented in a different package."},{"id":603,"pagetitle":"Contributing","title":"Contributing","ref":"/FrameTransformations/stable/todos/#Contributing","content":" Contributing Although  Basic  already implements may of its required functionalities, there is still  a lot to do to finish it.  \n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n ID Feature to develop AD1 Ephemeris : the actual default ephemeris provider for Basic is Calceph. \n        While it is a very versatile library, there is a inherent issue in that: the \n        impossibility to perform AD over it. Therefore, within the context of development \n        of Basic a (full) julia reader for JPL/INPOP ephemeris is foreseen. This package\n        is actually at the early stage of the development at the moment, thus any \n        contribution would be highly appreciated.\n\n        This is being performed in a separate package called `Ephemeris` within the JSMD\n        environment.\n     AD2 Caching : if you have a deep look into the FrameSystem structure, you'll \n        see that some frames have a dedicated cache. This goes in contrast with the use \n        of ForwardDiff, since it would require a Dual's compatible cache: there is, then,\n        the need of replacing those caches with a PreallocationTools.DiffCache or something\n        similar.\n     AD3 FunctionWrappers : if you have a deep look into the FrameSystem structure, you'll \n        see that the actual transformations are stored by means of FunctionWrapper. Again,\n        this goes against the AD integration but was choosen for efficiency reasons.\n        In this case there is the need to introduct FunctionWrappersWrappers dependency to\n        solve the issue. \n     Write down an  email  if your are interested in  contributing to one of those, we'll be for welcoming you with some additional guidelines. "},{"id":604,"pagetitle":"Contributing","title":"Guidelines","ref":"/FrameTransformations/stable/todos/#Guidelines","content":" Guidelines This section details the some of the guidelines that should be followed when contributing  to this package. Since the package is not consolidated yet, the most straight forward way to contribute is  by creating a branch of the  master  and develop there the desired feature. To this step,  follows the creation of a PR that will be accepted only if the new feature are  validated   by tests."}]