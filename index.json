[{"id":3,"pagetitle":"Home","title":"Welcome to Tempo.jl!","ref":"/Tempo/stable/#Welcome-to-Tempo.jl!","content":" Welcome to Tempo.jl! Efficient Astronomical Time transformations in Julia. Tempo.jl is an astronomical library that enables fast, efficient and high-accuracy time transformations between common and user-defined time scales and time representations."},{"id":4,"pagetitle":"Home","title":"Installation","ref":"/Tempo/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg\n\njulia> Pkg.add(\"Tempo.jl\");"},{"id":5,"pagetitle":"Home","title":"Quickstart","ref":"/Tempo/stable/#Quickstart","content":" Quickstart Create an  Epoch :  # Create an Epoch from an ISO-formatted string\ntai = Epoch(\"2022-10-02T12:04:23.043 TAI\")\n\n# Create an Epoch from a Julian Date\njd = Epoch(\"JD 2451545.0\")\n\n# Create an Epoch from a DateTime object and a timescale\ndt = DateTime(2001, 6, 15, 0, 0, 0, 0.0)\ne = Epoch(dt, TT) Efficiently transform epochs between various timescales: # Convert an Epoch from TAI to TDB \ntai = Epoch(\"2022-10-02T12:04:23.043 TAI\")\ntdb = convert(TDB, tai)\n\n# Convert an Epoch from TAI to UTC automatically handling leapseconds \nutc = convert(UTC, tai)"},{"id":6,"pagetitle":"Home","title":"Tempo.jl vs AstroTime.jl","ref":"/Tempo/stable/#Tempo.jl-vs-AstroTime.jl","content":" Tempo.jl vs AstroTime.jl Tempo.jl and  AstroTime.jl  are very similar libraries that allow transformations between various astronomical time representations. The major differences are: AstroTime.jl supports accurate Epoch transformations by leveraging high    precision arithmetics. Tempo.jl is more efficient when multiple timescales conversions must be    performed to convert a given Epoch (e.g., it does not allocate memory)."},{"id":9,"pagetitle":"Public API","title":"Public Documentation","ref":"/Tempo/stable/api/#tempo_api","content":" Public Documentation"},{"id":10,"pagetitle":"Public API","title":"Datetime","ref":"/Tempo/stable/api/#Datetime","content":" Datetime"},{"id":11,"pagetitle":"Public API","title":"Tempo.Date","ref":"/Tempo/stable/api/#Tempo.Date","content":" Tempo.Date  —  Type Date A type to represent a calendar date by storing the year, month and day. Date(year::Int, month::Int, day::Int) Construct a  Date  object given the  year ,  month  and  day . Date(offset::Integer) Create a  Date  object given an integer number of days since  2000-01-01 . Date(year::Integer, dayinyear::Integer) Create a  Date  object given the  year  and the day of the year  dayinyear . Examples julia> Date(2020, 1)\n2020-01-01\n\njulia> Date(2020, 300)\n2020-10-26 Date(dt::DateTime) Extract the  Date  object from a  DateTime  structure.  See also See also  Time  and  DateTime . source"},{"id":12,"pagetitle":"Public API","title":"Tempo.Time","ref":"/Tempo/stable/api/#Tempo.Time","content":" Tempo.Time  —  Type Time{T} A type representing the time of the day storing the hour, minute, seconds and fraction  of seconds. Time(hour::Int, minute::Int, second::Int, fraction::T) where {T <: Number} Create a  Time  object of type  T . Time(hour::Int, minute::Int, second::Number) Construct a  Time  object given the  hour ,  minute  and  seconds . In this case, the  seconds can either be an integer or a floating point number. The fraction of seconds will be computed under the hood. Time(secondinday::Int, fraction::Number)\nTime(secondinday::Number) Create a  Time  object given the seconds of the day  secondinday  and/or the fraction of  seconds.  Time(dt::DateTime) Extract the  Time  object from a  DateTime  structure.  See also See also  Date  and  DateTime . source"},{"id":13,"pagetitle":"Public API","title":"Tempo.DateTime","ref":"/Tempo/stable/api/#Tempo.DateTime","content":" Tempo.DateTime  —  Type DateTime{T} A type wrapping a  Date  and a  Time  object. DateTime(date::Date, time::Time{T}) Construct a  DateTime  object of type  T  from its  Date  and  Time  components. DateTime(year::Int, month::Int, day::Int, hour::Int, min::Int, sec::Int, frac::Number) Create a  DateTime  object by parts.  DateTime(iso::AbstractString) Create a  DateTime  object from by parsing an ISO datetime string  iso , in the format   YYYY-MM-DDThh:mm:ss.ffffffff . The DateTime parts not provided in the string will be  assigned default values. Examples julia> DateTime(\"2023-05-18T20:14:55.02\")\n2023-05-18T20:14:55.020\n\njulia> Tempo.DateTime(\"2022-05-12\")\n2022-05-12T00:00:00.00 DateTime(seconds::Number) Create a  DateTime  object given the number of seconds elapsed since  J2000 . DateTime(d::Date, sec::Number) Create a  DateTime  object given a  Date  and the number of seconds since midnight. Examples julia> d = Date(2023, 5, 18)\n2023-05-18\n\njulia> DateTime(d, 0)\n2023-05-18T12:00:00.000\n\njulia> DateTime(d, 1)\n2023-05-18T12:00:01.000 See also See also  Date ,  Time  and  Epoch . source"},{"id":14,"pagetitle":"Public API","title":"Tempo.year","ref":"/Tempo/stable/api/#Tempo.year","content":" Tempo.year  —  Function year(d::Date) Get year associated to a  Date . source year(d::DateTime) Get year associated to a  DateTime  type. source"},{"id":15,"pagetitle":"Public API","title":"Tempo.month","ref":"/Tempo/stable/api/#Tempo.month","content":" Tempo.month  —  Function month(d::Date) Get month associated to a  Date . source month(d::DateTime) Get month associated to a  DateTime  type. source"},{"id":16,"pagetitle":"Public API","title":"Tempo.day","ref":"/Tempo/stable/api/#Tempo.day","content":" Tempo.day  —  Function day(d::Date) Get day associated to a  Date . source day(d::DateTime) Get day associated to a  DateTime  type. source"},{"id":17,"pagetitle":"Public API","title":"Tempo.hour","ref":"/Tempo/stable/api/#Tempo.hour","content":" Tempo.hour  —  Function hour(t::Time) Get the current hour. source hour(d::DateTime) Get hour associated to a  DateTime  type. source"},{"id":18,"pagetitle":"Public API","title":"Tempo.minute","ref":"/Tempo/stable/api/#Tempo.minute","content":" Tempo.minute  —  Function minute(t::Time) Get the current minute. source minute(d::DateTime) Get minute associated to a  DateTime  type. source"},{"id":19,"pagetitle":"Public API","title":"Tempo.second","ref":"/Tempo/stable/api/#Tempo.second","content":" Tempo.second  —  Function second(::Type{<:AbstractFloat}, t::Time)\nsecond(::Type{<:Integer}, t::Time)\nsecond(t::Time) Get the current second. source second(::Type{<:AbstractFloat}, t::Time)\nsecond(d::DateTime) Get the seconds associated to a  DateTime  type. If a floating-point type is given  as first argument, the returned value will also account for the fraction of seconds. source"},{"id":20,"pagetitle":"Public API","title":"Tempo.find_dayinyear","ref":"/Tempo/stable/api/#Tempo.find_dayinyear","content":" Tempo.find_dayinyear  —  Function find_dayinyear(month::Integer, day::Integer, isleap::Bool) Find the day of the year given the month, the day of the month and whether the year  is leap or not. source find_dayinyear(d::Date) Find the day in the year. source"},{"id":21,"pagetitle":"Public API","title":"Epochs","ref":"/Tempo/stable/api/#Epochs","content":" Epochs"},{"id":22,"pagetitle":"Public API","title":"Types","ref":"/Tempo/stable/api/#Types","content":" Types"},{"id":23,"pagetitle":"Public API","title":"Tempo.Epoch","ref":"/Tempo/stable/api/#Tempo.Epoch","content":" Tempo.Epoch  —  Type Epoch{S, T} A type to represent Epoch-like data. Epochs are internally represented as seconds + fraction of  seconds since a reference epoch, which is considered to be  2000-01-01T12:00:00 ,  i.e.  J2000 . Epoch(sec::Number, scale::AbstractTimeScale)\nEpoch(sec::Number, scale::Type{<:AbstractTimeScale})\nEpoch{S}(seconds::Number) where {S <: AbstractTimeScale} Create an  Epoch  object from the number of seconds since  J2000  with the  timescale  S . Epoch(dt::DateTime, scale::AbstractTimeScale)\nEpoch(dt::DateTime, scale::Type{<:AbstractTimeScale}) Create an  Epoch  object from a  DateTime  structure with timescale  scale . Epoch(str::AbstractString, scale::AbstractTimeScale)\nEpoch(str::AbstractString) Create an  Epoch  object from an ISO-formatted string. The timescale can either be  specified as a second argument or written at the end of the string.  This constructor requires that the  str  is in the format: ISO  –  yyyy-mm-ddTHH:MM:SS.ffff  : assume J2000 as origin J2000  –  DDDD.ffff  : parse Julian Date since J2000, in days JD  –  JD DDDDDDDDD.ffffff  : parse Julian Date, in days MJD  –  MJD DDDDDDDDD.ffffff  : parse a Modified Julian Date, in days A  TimeScale  can be added at the end of the string, separated by a whitespace.  If it is not declared,  TDB  will be used as a default timescale.  Examples julia> Epoch(\"2050-01-01T12:35:15.0000 TT\")\n2050-01-01T12:35:14.9999 TT\n\njulia> Epoch(\"2050-01-01T12:35:15.0000\")\n2050-01-01T12:35:14.9999 TDB\n\njulia> Epoch(\"JD 2400000.5\")\n1858-11-17T00:00:00.0000 TDB\n\njulia> Epoch(\"MJD 51544.5\")\n2000-01-01T12:00:00.0000 TDB\n\njulia> Epoch(\"12.0\")\n2000-01-13T12:00:00.0000 TDB\n\njulia> Epoch(\"12.0 TT\")\n2000-01-13T12:00:00.0000 TT source"},{"id":24,"pagetitle":"Public API","title":"Tempo.timescale","ref":"/Tempo/stable/api/#Tempo.timescale","content":" Tempo.timescale  —  Function timescale(ep::Epoch) Epoch timescale. source"},{"id":25,"pagetitle":"Public API","title":"Tempo.value","ref":"/Tempo/stable/api/#Tempo.value","content":" Tempo.value  —  Function value(ep::Epoch) Full  Epoch  value. source"},{"id":26,"pagetitle":"Public API","title":"Origins","ref":"/Tempo/stable/api/#Origins","content":" Origins"},{"id":27,"pagetitle":"Public API","title":"Tempo.JD","ref":"/Tempo/stable/api/#Tempo.JD","content":" Tempo.JD  —  Constant JD The singleton instance of the  JulianDate  epoch origin.  With this origin, Epoch reference is  -4712-01-01T12:00 . source"},{"id":28,"pagetitle":"Public API","title":"Tempo.J2000","ref":"/Tempo/stable/api/#Tempo.J2000","content":" Tempo.J2000  —  Constant J2000 The singleton instance of the  JulianDate2000  epoch origin.  With this origin, Epoch reference is  2000-01-01T12:00 . source"},{"id":29,"pagetitle":"Public API","title":"Tempo.MJD","ref":"/Tempo/stable/api/#Tempo.MJD","content":" Tempo.MJD  —  Constant MJD The singleton instance of the  ModifiedJulianDate  epoch origin.  With this origin, Epoch reference is  1858-11-17T00:00 . source"},{"id":30,"pagetitle":"Public API","title":"Tempo.MJD2000","ref":"/Tempo/stable/api/#Tempo.MJD2000","content":" Tempo.MJD2000  —  Constant MJD2000 The singleton instance of the  ModifiedJulianDate2000  epoch origin.  With this origin, Epoch reference is  2000-01-01T00:00 . source"},{"id":31,"pagetitle":"Public API","title":"Conversions","ref":"/Tempo/stable/api/#Conversions","content":" Conversions"},{"id":32,"pagetitle":"Public API","title":"Tempo.j2000","ref":"/Tempo/stable/api/#Tempo.j2000","content":" Tempo.j2000  —  Function j2000(jd)\nj2000(jd1, jd2) Convert Julian Date in days since J2000 source j2000(d::Date) Convert Gregorian calendar date  Date  to a Julian Date since  J2000 ,  in days. source j2000(dt::DateTime) Convert a  DateTime dt  in Julian days since  J2000 . source j2000(e::Epoch) Convert  Epoch  in Julian Date days since  J2000 . source"},{"id":33,"pagetitle":"Public API","title":"Tempo.j2000s","ref":"/Tempo/stable/api/#Tempo.j2000s","content":" Tempo.j2000s  —  Function j2000s(jd)\nj2000s(jd1, jd2) Convert Julian Date (in days) in seconds past J2000  source j2000s(dt::DateTime) Convert a  DateTime dt  to seconds since  J2000 . source j2000s(e::Epoch) Convert  Epoch  in Julian Date seconds since  J2000 . source"},{"id":34,"pagetitle":"Public API","title":"Tempo.j2000c","ref":"/Tempo/stable/api/#Tempo.j2000c","content":" Tempo.j2000c  —  Function j2000c(jd)\nj2000c(jd1, jd2) Convert Julian Date (in days) to Julian Centuries source j2000c(dt::DateTime) Convert  a  DateTime dt  in a Julian Date since  J2000 , in centuries. source j2000c(e::Epoch) Convert  Epoch  in Julian Date centuries since  J2000 . source"},{"id":35,"pagetitle":"Public API","title":"Timescales","ref":"/Tempo/stable/api/#Timescales","content":" Timescales"},{"id":36,"pagetitle":"Public API","title":"Time System","ref":"/Tempo/stable/api/#Time-System","content":" Time System"},{"id":37,"pagetitle":"Public API","title":"Tempo.@timescale","ref":"/Tempo/stable/api/#Tempo.@timescale","content":" Tempo.@timescale  —  Macro @timescale(name, id, type) Create a new timescale instance to alias the given  id . This macro creates an   AbstractTimeScale  subtype and its singleton instance called  name . Its  type   is obtained by appending  TimeScale  to  name  if it was not provided. Examples julia> @timescale NTS 100 NewTimeScale \n\njulia> typeof(NTS)\nNewTimeScale \n\njulia> timescale_alias(NTS)\n100\n\njulia> @timescale TBH 200\n\njulia> typeof(TBH)\nTBHTimeScale\n\njulia> timescale_alias(TBH)\n200 See also See also  timescale_alias  and  add_timescale! . source"},{"id":38,"pagetitle":"Public API","title":"Tempo.timescale_alias","ref":"/Tempo/stable/api/#Tempo.timescale_alias","content":" Tempo.timescale_alias  —  Function timescale_alias(scale::AbstractTimeScale) Return the ID associated to  scale . source"},{"id":39,"pagetitle":"Public API","title":"Tempo.timescale_name","ref":"/Tempo/stable/api/#Tempo.timescale_name","content":" Tempo.timescale_name  —  Function timescale_name(scale::AbstractTimeScale) Return the name of  scale . source"},{"id":40,"pagetitle":"Public API","title":"Tempo.timescale_id","ref":"/Tempo/stable/api/#Tempo.timescale_id","content":" Tempo.timescale_id  —  Function timescale_id(scale::AbstractTimeScale) Return the ID of  scale . source"},{"id":41,"pagetitle":"Public API","title":"Tempo.TimeSystem","ref":"/Tempo/stable/api/#Tempo.TimeSystem","content":" Tempo.TimeSystem  —  Type TimeSystem{T} A  TimeSystem  object manages a collection of default and user-defined  TimeScaleNode  objects, enabling efficient time transformations between them. It leverages a   MappedDiGraph  to keep track of the relationships between the timescales. TimeSystem{T}() Create a empty  TimeSystem  object with datatype  T . Examples julia> ts = TimeSystem{Float64}();\n\njulia> @timescale TSA 100 TimeScaleA\n\njulia> @timescale TSB 200 TimeScaleB\n\njulia> add_timescale!(ts, TSA)\n\njulia> offset_tsa2tsb(seconds) = 1.0\n\njulia> offset_tsb2tsa(seconds) = -1.0\n\njulia> add_timescale!(ts, TSB, offset_tsa2tsb; parent=TSA, ftp=offset_tsb2tsa) See also See also  @timescale  and  add_timescale! . source"},{"id":42,"pagetitle":"Public API","title":"Tempo.add_timescale!","ref":"/Tempo/stable/api/#Tempo.add_timescale!","content":" Tempo.add_timescale!  —  Function add_timescale!(s::TimeSystem, ts::TimeScaleNode) Register a new node in the  TimeSystem . Warning This is a low-level function and should not be called by the user. source add_timescale!(system::TimeSystem, scale::AbstractTimeScale, ffp::Function; ftp, parent) Add  scale  as a timescale to  system . A custom function  ffp  providing the time offset,  in seconds, between the  parent  scale and the current scale must be provided by the user.  The  parent  and  ffp  arguments are unneeded only for the root timescale. If the user  wishes to add a scale to a non-empty timesystem, this argument becomes mandatory. The input functions must accept only the seconds in the parent scale as argument and must  return a single numerical output. An optional function  ftp , with a similar interface, returning the offset from the current to the parent scale may also be provided.  Note If  ftp  is not provided, the reverse timescale transformation will not be possible.  Examples julia> SYSTEM = TimeSystem{Float64}();\n\njulia> @timescale RTS 102 RootTimeScale\n\njulia> @timescale CTS 103 ChildTimeScale\n\njulia> root_to_child(x::Number) = 13.3;\n\njulia> child_to_root(x::Number) = -13.3;\n\njulia> add_timescale!(SYSTEM, RTS)\n\njulia> add_timescale!(SYSTEM, CTS, root_to_child; parent=RTS, ftp=child_to_root) See also See also  @timescale  and  TimeSystem . source"},{"id":43,"pagetitle":"Public API","title":"Tempo.TIMESCALES","ref":"/Tempo/stable/api/#Tempo.TIMESCALES","content":" Tempo.TIMESCALES  —  Constant TIMESCALES Default time scales graph, containing at least: (\"TT\", \"TAI\", \"UTC\", \"TCG\", \"TCB\", \"TDB\", \"UT1\", \"TDBH\", \"GPS\") It can be easily extended using the  @timescale  to create new  TimeScaleNode   aliases and  add_timescale!  method to define its relation with the other nodes  in the graph.  Example # Define a new timescale type alias\n@timescale NTS 100 NewTimeScale\n\n# Define offset to and from another timescale in the graph \noffset_ffp(seconds) = 1.0\noffset_ftp(seconds) = -1.0\n\n# Connect to the graph, with the parent node (TDB in this example)\nadd_timescale!(TIMESCALES, NTS, offset_ffp, parent=TDB, ftp=offset_ftp) See also See also  @timescale  and  add_timescale! . source"},{"id":44,"pagetitle":"Public API","title":"Default Timescales","ref":"/Tempo/stable/api/#Default-Timescales","content":" Default Timescales"},{"id":45,"pagetitle":"Public API","title":"Tempo.GPS","ref":"/Tempo/stable/api/#Tempo.GPS","content":" Tempo.GPS  —  Constant GPS The singleton instance of the  GlobalPositioningSystemTime  type representing the Global Positioning System Time (GPS) time scale. source"},{"id":46,"pagetitle":"Public API","title":"Tempo.TAI","ref":"/Tempo/stable/api/#Tempo.TAI","content":" Tempo.TAI  —  Constant TAI The singleton instance of the  InternationalAtomicTime  type representing the International Atomic Time (TAI) time scale. source"},{"id":47,"pagetitle":"Public API","title":"Tempo.TCB","ref":"/Tempo/stable/api/#Tempo.TCB","content":" Tempo.TCB  —  Constant TCB The singleton instance of the  BarycentricCoordinateTime  type representing the Barycentric Coordinate Time (TCB) time scale. source"},{"id":48,"pagetitle":"Public API","title":"Tempo.TCG","ref":"/Tempo/stable/api/#Tempo.TCG","content":" Tempo.TCG  —  Constant TCG The singleton instance of the  GeocentricCoordinateTime  type representing the Geocentric Coordinate Time (TCG) time scale. source"},{"id":49,"pagetitle":"Public API","title":"Tempo.TDB","ref":"/Tempo/stable/api/#Tempo.TDB","content":" Tempo.TDB  —  Constant TDB The singleton instance of the  BarycentricDynamicalTime  type representing the Barycentric Dynamical Time (TDB) time scale. source"},{"id":50,"pagetitle":"Public API","title":"Tempo.TDBH","ref":"/Tempo/stable/api/#Tempo.TDBH","content":" Tempo.TDBH  —  Constant TDBH The singleton instance of the  HighPrecisionBarycentricDynamicalTime  type representing the High Precision Barycentric Dynamical Time (TDBH) time scale. source"},{"id":51,"pagetitle":"Public API","title":"Tempo.TT","ref":"/Tempo/stable/api/#Tempo.TT","content":" Tempo.TT  —  Constant TT The singleton instance of the  TerrestrialTime  type representing the Terrestrial Time (TT) time scale. source"},{"id":52,"pagetitle":"Public API","title":"Tempo.UT1","ref":"/Tempo/stable/api/#Tempo.UT1","content":" Tempo.UT1  —  Constant UT1 The singleton instance of the  UniversalTime  type representing the Universal Time (UT1) time scale. source"},{"id":53,"pagetitle":"Public API","title":"Tempo.UTC","ref":"/Tempo/stable/api/#Tempo.UTC","content":" Tempo.UTC  —  Constant UTC The singleton instance of the  CoordinatedUniversalTime  type representing the Coordinated Universal Time (UTC) time scale. source"},{"id":54,"pagetitle":"Public API","title":"Constants","ref":"/Tempo/stable/api/#Constants","content":" Constants"},{"id":55,"pagetitle":"Public API","title":"Tempo.DJ2000","ref":"/Tempo/stable/api/#Tempo.DJ2000","content":" Tempo.DJ2000  —  Constant DJ2000 Reference epoch  J2000 , Julian Date ( 2451545.0 ).  It is  12:00 01-01-2000 . source"},{"id":56,"pagetitle":"Public API","title":"Tempo.DMJD","ref":"/Tempo/stable/api/#Tempo.DMJD","content":" Tempo.DMJD  —  Constant DMJD Reference epoch  J2000 , Modified Julian Date ( 51544.5 ). source"},{"id":57,"pagetitle":"Public API","title":"Tempo.DJM0","ref":"/Tempo/stable/api/#Tempo.DJM0","content":" Tempo.DJM0  —  Constant DJM0 Julian Date of Modified Julian Date zero point ( 2400000.5 ). It is  00:00 17-11-1858 . source"},{"id":60,"pagetitle":"Low-level API","title":"Low-level API","ref":"/Tempo/stable/lapi/#tempo_lapi","content":" Low-level API These functions are not meant to be used outside of the package. They are documented only to aid future developments of the package."},{"id":61,"pagetitle":"Low-level API","title":"Epochs","ref":"/Tempo/stable/lapi/#Epochs","content":" Epochs"},{"id":62,"pagetitle":"Low-level API","title":"Tempo.AbstractEpochOrigin","ref":"/Tempo/stable/lapi/#Tempo.AbstractEpochOrigin","content":" Tempo.AbstractEpochOrigin  —  Type AbstractEpochOrigin Abstract type for all epoch origins. source"},{"id":63,"pagetitle":"Low-level API","title":"Tempo.JulianDate","ref":"/Tempo/stable/lapi/#Tempo.JulianDate","content":" Tempo.JulianDate  —  Type JulianDate A type representing the JulianDate (JD) epoch origin.  With this origin, Epoch reference is  -4712-01-01T12:00 . source"},{"id":64,"pagetitle":"Low-level API","title":"Tempo.JulianDate2000","ref":"/Tempo/stable/lapi/#Tempo.JulianDate2000","content":" Tempo.JulianDate2000  —  Type JulianDate2000 A type representing the JulianDate2000 (J2000) epoch origin.  With this origin, Epoch reference is  2000-01-01T12:00 . source"},{"id":65,"pagetitle":"Low-level API","title":"Tempo.ModifiedJulianDate","ref":"/Tempo/stable/lapi/#Tempo.ModifiedJulianDate","content":" Tempo.ModifiedJulianDate  —  Type ModifiedJulianDate A type representing the ModifiedJulianDate (MJD) epoch origin.  With this origin, Epoch reference is  1858-11-17T00:00 . source"},{"id":66,"pagetitle":"Low-level API","title":"Tempo.ModifiedJulianDate2000","ref":"/Tempo/stable/lapi/#Tempo.ModifiedJulianDate2000","content":" Tempo.ModifiedJulianDate2000  —  Type ModifiedJulianDate2000 A type representing the ModifiedJulianDate2000 (MJD2000) epoch origin.  With this origin, Epoch reference is  2000-01-01T00:00 . source"},{"id":67,"pagetitle":"Low-level API","title":"Tempo.EpochConversionError","ref":"/Tempo/stable/lapi/#Tempo.EpochConversionError","content":" Tempo.EpochConversionError  —  Type EpochConversionError A type representing epoch conversion errors. source"},{"id":68,"pagetitle":"Low-level API","title":"Tempo.parse_iso","ref":"/Tempo/stable/lapi/#Tempo.parse_iso","content":" Tempo.parse_iso  —  Function parse_iso(s::AbstractString) Parse an ISO datetime string, in the format  YYYY-MM-DDThh:mm:ss.ffffffff  and return  a  Tuple  containing the year, month, day , hour, minute, second and milliseconds. If the  string format is not recognised as ISO, an  ArgumentError  is thrown. source"},{"id":69,"pagetitle":"Low-level API","title":"Timescale Offsets","ref":"/Tempo/stable/lapi/#Timescale-Offsets","content":" Timescale Offsets"},{"id":70,"pagetitle":"Low-level API","title":"Tempo.offset","ref":"/Tempo/stable/lapi/#Tempo.offset","content":" Tempo.offset  —  Function offset(::Tempo.JulianDate) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  JulianDate  (with origin at  -4712-01-01T12:00 ) source offset(::Tempo.ModifiedJulianDate) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  ModifiedJulianDate  (with origin at  1858-11-17T00:00 ) source offset(::Tempo.JulianDate2000) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  JulianDate2000  (with origin at  2000-01-01T12:00 ) source offset(::Tempo.ModifiedJulianDate2000) Offset in days to shift J2000 epochs (with origin at  2000-01-01T12:00 )  to  ModifiedJulianDate2000  (with origin at  2000-01-01T00:00 ) source"},{"id":71,"pagetitle":"Low-level API","title":"Tempo.offset_gps2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_gps2tai","content":" Tempo.offset_gps2tai  —  Function offset_gps2tai(seconds) Return the fixed offset between  GPS  and  TAI  in seconds. source"},{"id":72,"pagetitle":"Low-level API","title":"Tempo.offset_tai2gps","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2gps","content":" Tempo.offset_tai2gps  —  Function offset_tai2gps(seconds) Return the fixed offset between  TAI  and  GPS  in seconds. source"},{"id":73,"pagetitle":"Low-level API","title":"Tempo.offset_tai2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2tt","content":" Tempo.offset_tai2tt  —  Function offset_tai2tt(seconds) Return the fixed offset between  TAI  and  TT  in seconds. source"},{"id":74,"pagetitle":"Low-level API","title":"Tempo.offset_tai2utc","ref":"/Tempo/stable/lapi/#Tempo.offset_tai2utc","content":" Tempo.offset_tai2utc  —  Function offset_tai2utc(seconds) Return the offset between  TAI  and  UTC  in seconds. source"},{"id":75,"pagetitle":"Low-level API","title":"Tempo.offset_tcb2tdb","ref":"/Tempo/stable/lapi/#Tempo.offset_tcb2tdb","content":" Tempo.offset_tcb2tdb  —  Function offset_tcb2tdb(seconds) Return the linear offset between  TCB  and  TDB  in seconds. source"},{"id":76,"pagetitle":"Low-level API","title":"Tempo.offset_tcg2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tcg2tt","content":" Tempo.offset_tcg2tt  —  Function offset_tcg2tt(seconds) Return the linear offset between  TCG  and  TT  in seconds. source"},{"id":77,"pagetitle":"Low-level API","title":"Tempo.offset_tdb2tt","ref":"/Tempo/stable/lapi/#Tempo.offset_tdb2tt","content":" Tempo.offset_tdb2tt  —  Function offset_tdb2tt(seconds) Return the offset between  TDB  and  TT  in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer.  For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much  as ~4 microseconds. References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":78,"pagetitle":"Low-level API","title":"Tempo.offset_tdb2tcb","ref":"/Tempo/stable/lapi/#Tempo.offset_tdb2tcb","content":" Tempo.offset_tdb2tcb  —  Function offset_tdb2tcb(seconds) Return the linear offset between  TDB  and  TCB  in seconds. source"},{"id":79,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tai","content":" Tempo.offset_tt2tai  —  Function offset_tt2tai(seconds) Return the fixed offset between  TT  and  TAI  in seconds. source"},{"id":80,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tcg","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tcg","content":" Tempo.offset_tt2tcg  —  Function offset_tt2tcg(seconds) Return the linear offset between  TT  and  TCG  in seconds. source"},{"id":81,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tdb","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tdb","content":" Tempo.offset_tt2tdb  —  Function offset_tt2tdb(seconds) Return the offset between  TT  and  TDB  in seconds. This routine is accurate to ~40 microseconds over the interval 1900-2100. Note An accurate transformation between TDB and TT depends on the trajectory of the observer.  For two observers fixed on Earth's surface the quantity TDB-TT can differ by as much  as ~4 microseconds. References https://www.cv.nrao.edu/~rfisher/Ephemerides/times.html#TDB Issue #26 source"},{"id":82,"pagetitle":"Low-level API","title":"Tempo.offset_tt2tdbh","ref":"/Tempo/stable/lapi/#Tempo.offset_tt2tdbh","content":" Tempo.offset_tt2tdbh  —  Function offset_tt2tdbh(seconds) Return the offset between  TT  and  TDBH  in seconds. The maximum error in using the above formula is about 10 µs from 1600 to 2200. For even more precise applications, the series expansion by   Harada & Fukushima (2003)  is recommended. References The IAU Resolutions on Astronomical Reference Systems, Time Scales, and Earth Rotation Models,   United States Naval Observatory, https://arxiv.org/pdf/astro-ph/0602086.pdf source"},{"id":83,"pagetitle":"Low-level API","title":"Tempo.offset_utc2tai","ref":"/Tempo/stable/lapi/#Tempo.offset_utc2tai","content":" Tempo.offset_utc2tai  —  Function offset_utc2tai(seconds) Return the offset between  UTC  and  TAI  in seconds. source"},{"id":84,"pagetitle":"Low-level API","title":"Timescale Types","ref":"/Tempo/stable/lapi/#Timescale-Types","content":" Timescale Types"},{"id":85,"pagetitle":"Low-level API","title":"Tempo.TimeScaleNode","ref":"/Tempo/stable/lapi/#Tempo.TimeScaleNode","content":" Tempo.TimeScaleNode  —  Type TimeScaleNode{T} <: AbstractGraphNode Define a timescale. Fields name  – timescale name id  – timescale identification number (ID) parentid  – ID of the parent timescale ffp  – offest function from the parent timescale ftp  – offset function to the parent timescale source"},{"id":86,"pagetitle":"Low-level API","title":"Tempo.AbstractTimeScale","ref":"/Tempo/stable/lapi/#Tempo.AbstractTimeScale","content":" Tempo.AbstractTimeScale  —  Type AbstractTimeScale All timescales are subtypes of the abstract type  AbstractTimeScale . source"},{"id":87,"pagetitle":"Low-level API","title":"Tempo.GlobalPositioningSystemTime","ref":"/Tempo/stable/lapi/#Tempo.GlobalPositioningSystemTime","content":" Tempo.GlobalPositioningSystemTime  —  Type GlobalPositioningSystemTime <: AbstractTimeScale A type representing the Global Positioning System Time (GPS) time scale. source"},{"id":88,"pagetitle":"Low-level API","title":"Tempo.BarycentricDynamicalTime","ref":"/Tempo/stable/lapi/#Tempo.BarycentricDynamicalTime","content":" Tempo.BarycentricDynamicalTime  —  Type BarycentricDynamicalTime <: AbstractTimeScale A type representing the Barycentric Dynamical Time (TDB) time scale. source"},{"id":89,"pagetitle":"Low-level API","title":"Tempo.HighPrecisionBarycentricDynamicalTime","ref":"/Tempo/stable/lapi/#Tempo.HighPrecisionBarycentricDynamicalTime","content":" Tempo.HighPrecisionBarycentricDynamicalTime  —  Type HighPrecisionBarycentricDynamicalTime <: AbstractTimeScale A type representing the High Precision Barycentric Dynamical Time (TDBH) time scale. source"},{"id":90,"pagetitle":"Low-level API","title":"Tempo.BarycentricCoordinateTime","ref":"/Tempo/stable/lapi/#Tempo.BarycentricCoordinateTime","content":" Tempo.BarycentricCoordinateTime  —  Type BarycentricCoordinateTime <: AbstractTimeScale A type representing the Barycentric Coordinate Time (TCB) time scale. source"},{"id":91,"pagetitle":"Low-level API","title":"Tempo.TerrestrialTime","ref":"/Tempo/stable/lapi/#Tempo.TerrestrialTime","content":" Tempo.TerrestrialTime  —  Type TerrestrialTime <: AbstractTimeScale A type representing the Terrestrial Time (TT) time scale. source"},{"id":92,"pagetitle":"Low-level API","title":"Tempo.InternationalAtomicTime","ref":"/Tempo/stable/lapi/#Tempo.InternationalAtomicTime","content":" Tempo.InternationalAtomicTime  —  Type InternationalAtomicTime <: AbstractTimeScale A type representing the International Atomic Time (TAI) time scale. source"},{"id":93,"pagetitle":"Low-level API","title":"Tempo.UniversalTime","ref":"/Tempo/stable/lapi/#Tempo.UniversalTime","content":" Tempo.UniversalTime  —  Type UniversalTime <: AbstractTimeScale A type representing the Universal Time (UT1) time scale. source"},{"id":94,"pagetitle":"Low-level API","title":"Tempo.CoordinatedUniversalTime","ref":"/Tempo/stable/lapi/#Tempo.CoordinatedUniversalTime","content":" Tempo.CoordinatedUniversalTime  —  Type CoordinatedUniversalTime <: AbstractTimeScale A type representing the Coordinated Universal Time (UTC) time scale. source"},{"id":95,"pagetitle":"Low-level API","title":"Tempo.GeocentricCoordinateTime","ref":"/Tempo/stable/lapi/#Tempo.GeocentricCoordinateTime","content":" Tempo.GeocentricCoordinateTime  —  Type GeocentricCoordinateTime <: AbstractTimeScale A type representing the Geocentric Coordinate Time (TCG) time scale. source"},{"id":96,"pagetitle":"Low-level API","title":"Conversions","ref":"/Tempo/stable/lapi/#Conversions","content":" Conversions"},{"id":97,"pagetitle":"Low-level API","title":"Base.convert","ref":"/Tempo/stable/lapi/#Base.convert","content":" Base.convert  —  Function convert(to::S2, e::Epoch{S1}; system::TimeSystem=TIMESCALES) Convert  Epoch  with timescale  S1  to  S2 . Allows to use the default  TimeSystem  or  a custom constructed one.  source"},{"id":98,"pagetitle":"Low-level API","title":"Tempo.cal2jd","ref":"/Tempo/stable/lapi/#Tempo.cal2jd","content":" Tempo.cal2jd  —  Function cal2jd(year::Integer, month::Integer, day::Integer) This function converts a given date in the Gregorian calendar (year, month, day) to the  corresponding two-parts Julian Date. The first part is the  DJ2000 , while the  second output is the number of days since  J2000 . The year must be greater than 1583, and the month must be between 1 and 12. The day must  also be valid, taking into account whether the year is a leap year. If the input year or  month or day are invalid, a  DomainError  is thrown. Examples julia> Tempo.cal2jd(2021, 1, 1)\n(2.4000005e6, 59215.0)\n\njulia> Tempo.cal2jd(2022, 2, 28)\n(2.4000005e6, 59638.0)\n\njulia> Tempo.cal2jd(2019, 2, 29)\nERROR: DomainError with 29:\nthe day shall be between 1 and 28. References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). Klein, A., (2006), A Generalized Kahan-Babuska-Summation-Algorithm.   Computing, 76, 279-293, Section 3. ERFA software library source cal2jd(d::Date) Convert Gregorian calendar  Date  to a Julian Date, in days. Outputs j2000  – J2000 zero point: always 2451545 d  – J2000 Date for 12 hrs source"},{"id":99,"pagetitle":"Low-level API","title":"Tempo.calhms2jd","ref":"/Tempo/stable/lapi/#Tempo.calhms2jd","content":" Tempo.calhms2jd  —  Function calhms2jd(year, month, day, hour, minute, seconds) Convert Gregorian Calendar date and time to a two-parts Julian Date. The first part  is the  DJ2000 , while the second output is the number of days since  J2000 . Examples julia> Tempo.calhms2jd(2000, 1, 1, 12, 0, 0)\n(2.451545e6, 0.0)\n\njulia> Tempo.calhms2jd(2022, 1, 1, 0, 0, 0)\n(2.451545e6, 8035.5) source"},{"id":100,"pagetitle":"Low-level API","title":"Tempo.fd2hms","ref":"/Tempo/stable/lapi/#Tempo.fd2hms","content":" Tempo.fd2hms  —  Function fd2hms(fd::Number) Convert the day fraction  fd  to hour, minute and seconds. source"},{"id":101,"pagetitle":"Low-level API","title":"Tempo.fd2hmsf","ref":"/Tempo/stable/lapi/#Tempo.fd2hmsf","content":" Tempo.fd2hmsf  —  Function fd2hmsf(fd::Number) Convert the day fraction  fd  to hour, minute, second and fraction of seconds. Examples julia> Tempo.fd2hms(0.5)\n(12, 0, 0.0) source"},{"id":102,"pagetitle":"Low-level API","title":"Tempo.hms2fd","ref":"/Tempo/stable/lapi/#Tempo.hms2fd","content":" Tempo.hms2fd  —  Function hms2fd(hour::Integer, minute::Integer, second::Number) Convert hours, minutes and seconds to day fraction. Examples julia> Tempo.hms2fd(12, 0, 0.0)\n0.5 source"},{"id":103,"pagetitle":"Low-level API","title":"Tempo.jd2cal","ref":"/Tempo/stable/lapi/#Tempo.jd2cal","content":" Tempo.jd2cal  —  Function jd2cal(dj1::Number, dj2::Number) This function converts a given Julian Date (JD) to a Gregorian calendar date  (year, month, day, and fraction of a day). Examples julia> Tempo.jd2cal(DJ2000, 0.0)\n(2000, 1, 1, 0.5)\n\njulia> Tempo.jd2cal(DJ2000, 365.5)\n(2001, 1, 1, 0.0)\n\njulia> Tempo.jd2cal(DJ2000 + 365, 0.5)\n(2001, 1, 1, 0.0) Note The Julian Date is apportioned in any convenient way between the arguments   dj1  and  dj2 . For example,  JD = 2450123.7  could be expressed in any of these  ways, among others: dj1 dj2 2450123.7 0.0 (JD method) 2451545.0 -1421.3 (J2000 method) 2400000.5 50123.2 (MJD method) 2450123.5 0.2 (date & time method) Warning The earliest valid date is -68569.5 (-4713 Jan 1). The largest value accepted is 1e9. References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). Klein, A., (2006), A Generalized Kahan-Babuska-Summation-Algorithm.   Computing, 76, 279-293, Section 3. ERFA software library source"},{"id":104,"pagetitle":"Low-level API","title":"Tempo.jd2calhms","ref":"/Tempo/stable/lapi/#Tempo.jd2calhms","content":" Tempo.jd2calhms  —  Function jd2calhms(dj1::Number, dj2::Number) Convert a two-parts Julian Date to Gregorian year, month, day, hour, minute, seconds. See   jd2cal  for more information on the Julian Date composition.  julia> Tempo.jd2calhms(DJ2000, 0.0)\n(2000, 1, 1, 12, 0, 0.0)\n\njulia> Tempo.jd2calhms(DJ2000 + 1, 0.25)\n(2000, 1, 2, 18, 0, 0.0)\n\njulia> Tempo.jd2calhms(DJ2000, 1.25)\n(2000, 1, 2, 18, 0, 0.0) source"},{"id":105,"pagetitle":"Low-level API","title":"Tempo.tai2utc","ref":"/Tempo/stable/lapi/#Tempo.tai2utc","content":" Tempo.tai2utc  —  Function tai2utc(tai1, tai2) Transform a 2-part (quasi) Julian Date, in days, in International Atomic Time,  TAI   to a 2-part Julian Date in the Coordinated Universal Time,  UTC , scale. Note tai1 + tai2  is Julian Date, apportioned in any convenient way between the two arguments, for example such that  tai1  is the Julian Day Number and  tai2  is the fraction of a day.  The returned  utc1   and  utc2  form an analogous pair. Note JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.   References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) ERFA software library source"},{"id":106,"pagetitle":"Low-level API","title":"Tempo.utc2tai","ref":"/Tempo/stable/lapi/#Tempo.utc2tai","content":" Tempo.utc2tai  —  Function utc2tai(utc1, utc2) Transform a 2-part (quasi) Julian Date, in days, in Coordinate Universal Time,  UTC   to a 2-part Julian Date in the International Atomic Time,  TAI  scale. Note utc1 + utc2  is quasi Julian Date (see Note 2), apportioned in any convenient way between the two arguments, for example such that  utc1  is the Julian Day Number and  utc2  is the fraction of a day. Note JD cannot unambiguously represent UTC during a leap second unless special measures are taken.  The convention in the present function is that the JD day represents UTC days whether the length is 86399, 86400 or 86401 SI seconds.   References Seidelmann P. K., (1992), Explanatory Supplement to the Astronomical Almanac,   University Science Books, Section 12.92 (p604). McCarthy, D. D., Petit, G. (eds.), IERS Conventions (2003),   IERS Technical Note No. 32, BKG (2004) ERFA software library source"},{"id":107,"pagetitle":"Low-level API","title":"Leapseconds","ref":"/Tempo/stable/lapi/#Leapseconds","content":" Leapseconds"},{"id":108,"pagetitle":"Low-level API","title":"Tempo.Leapseconds","ref":"/Tempo/stable/lapi/#Tempo.Leapseconds","content":" Tempo.Leapseconds  —  Type Leapseconds{T} Stores information about the leap seconds that have been added to Coordinated Universal Time  (UTC). Fields lastupdate : a  DatesDateTime  object representing the date and time when the Leapseconds    struct was last updated. jd2000 : a vector storing the Julian Date, in days since J2000, of each leap second. leap : a vector storing the number of leap seconds at each corresponding entry of the         jd2000  field. source"},{"id":109,"pagetitle":"Low-level API","title":"Tempo.LEAPSECONDS","ref":"/Tempo/stable/lapi/#Tempo.LEAPSECONDS","content":" Tempo.LEAPSECONDS  —  Constant LEAPSECONDS Leapseconds data. source"},{"id":110,"pagetitle":"Low-level API","title":"Tempo.get_leapseconds","ref":"/Tempo/stable/lapi/#Tempo.get_leapseconds","content":" Tempo.get_leapseconds  —  Function get_leapseconds() Parse leapseconds data and return a  Leapseconds  type.  Note The leapsecond kernel is retrieved from the artifacts of this package. This artifact  will be updated whenever a new leapsecond is added. source"},{"id":111,"pagetitle":"Low-level API","title":"Tempo.leapseconds","ref":"/Tempo/stable/lapi/#Tempo.leapseconds","content":" Tempo.leapseconds  —  Function leapseconds(jd2000::Number) For a given UTC date, in Julian days since  J2000 , calculate Delta(AT) = TAI - UTC. source"},{"id":112,"pagetitle":"Low-level API","title":"Miscellaneous","ref":"/Tempo/stable/lapi/#Miscellaneous","content":" Miscellaneous"},{"id":113,"pagetitle":"Low-level API","title":"Tempo.find_year","ref":"/Tempo/stable/lapi/#Tempo.find_year","content":" Tempo.find_year  —  Function find_year(d::Integer) Return the Gregorian year associated to the given Julian Date day  d  since  J2000 . source"},{"id":114,"pagetitle":"Low-level API","title":"Tempo.find_month","ref":"/Tempo/stable/lapi/#Tempo.find_month","content":" Tempo.find_month  —  Function find_month(dayinyear::Integer, isleap::Bool) Find the month from the day of the year, depending on whether the year is leap or not. source"},{"id":115,"pagetitle":"Low-level API","title":"Tempo.find_day","ref":"/Tempo/stable/lapi/#Tempo.find_day","content":" Tempo.find_day  —  Function find_day(dayinyear::Integer, month::Integer, isleap::Bool) Find the day of the month from the day in the year and the month, depending on whether the  year is leap or not. source"},{"id":116,"pagetitle":"Low-level API","title":"Tempo.fraction_of_day","ref":"/Tempo/stable/lapi/#Tempo.fraction_of_day","content":" Tempo.fraction_of_day  —  Function fraction_of_day(t::Time)\nhms2fd(t::Time) Find the fraction of the day. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.fraction_of_day(t)\n0.5213002592592593 source"},{"id":117,"pagetitle":"Low-level API","title":"Tempo.fraction_of_second","ref":"/Tempo/stable/lapi/#Tempo.fraction_of_second","content":" Tempo.fraction_of_second  —  Function fraction_of_second(t::Time) Find the fraction of seconds. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.fraction_of_second(t)\n0.3423999999999978 source fraction_of_second(d::DateTime) Get the fraction of seconds associated to a  DateTime  object. source"},{"id":118,"pagetitle":"Low-level API","title":"Tempo.isleapyear","ref":"/Tempo/stable/lapi/#Tempo.isleapyear","content":" Tempo.isleapyear  —  Function isleapyear(year::Integer) Return  true  if the given Gregorian year is leap. source isleapyear(d::Date) True if  Date  is within a leap year. source"},{"id":119,"pagetitle":"Low-level API","title":"Tempo.lastj2000dayofyear","ref":"/Tempo/stable/lapi/#Tempo.lastj2000dayofyear","content":" Tempo.lastj2000dayofyear  —  Function lastj2000dayofyear(year::Integer) source"},{"id":120,"pagetitle":"Low-level API","title":"Tempo.second_in_day","ref":"/Tempo/stable/lapi/#Tempo.second_in_day","content":" Tempo.second_in_day  —  Function second_in_day(t::Time) Find the second in the day. Example julia> t = Time(12, 30, 40.3424)\n12:30:40.3423\n\njulia> Tempo.second_in_day(t)\n45040.3424 source"},{"id":123,"pagetitle":"-","title":"Overview","ref":"/Tempo/stable/tmp/#Overview","content":" Overview There are different ways to represent an epoch within  Tempo , depending on the specific application. This section is here to help you choose the proper time representation and to present the capabilities of the module in transforming time between different representations. First of all, there is a deep difference in the way time is thought in the everyday life and  when dealing with space-related applications.  Whenever we say  the 12:35 of the 1st of January 2023 , we are merging three concepts:  the  calendar  ( 1st January 2023 ) and the  time representation  ( 12:35 ) together with its  scale . Calculations in any scientific discipline may involve precise time, but what  sets astronomy apart is the number and variety of  time scales  that have to be used. In fact, in astronomical applications the physical context of the “clock” matters, whether it is on Earth, moving or stationary, or on a spacecraft.  Time Conversions - The difference in each timescale is shown with \n    respect to TAI.  The most relevant time scales for these applications are: UT1  (Universal Time 1): UT1 is a time scale based on the rotation of the Earth.    It is used to measure the positions of celestial objects relative to the Earth's    surface. UT1 is closely related to  Greenwich Mean Time (GMT) , and the two time    scales are often used interchangeably. TAI  (International Atomic Time): TAI is a time scale based on the average    frequency of a set of atomic clocks. It is used to measure the positions of    celestial objects relative to the Earth's surface. TT  (Terrestrial Time): TT is a time scale based on the motion of celestial    objects around the solar system barycenter (the center of mass of the solar system).    It is used to measure the positions of celestial objects relative to the Earth's surface. TDB  (Barycentric Dynamical Time): TDB is a time scale based on the motion of    celestial objects around the solar system barycenter (the center of mass of the    solar system). It is used to measure the positions of celestial objects relative    to the solar system barycenter. TCB  (Barycentric Coordinate Time): TCB is a time scale based on the motion of    celestial objects around the solar system barycenter (the center of mass of the    solar system). It is used to measure the positions of celestial objects relative    to the solar system barycenter. TCG  (Geocentric Coordinate Time): TCG is a time scale based on the rotation of    the Earth. It is used to measure the positions of celestial objects relative to the    Earth's surface. Teph  (Ephemeris Time): Teph is a time scale based on the motion of celestial    objects around the solar system barycenter (the center of mass of the solar    system). It is used to measure the positions of celestial objects relative to    the solar system barycenter – here considered equivalent of  TDB . Of the seven time scales to be described here, one is atomic time (TAI),  one is solar time (UT1), one is an atomic/solar hybrid (UTC) and four are  dynamical times (TT, TCG, TCB, TDB). Other time scales of interest may also be the  ones associated to the different positioning systems. In particular:  GPS  (Global  Positioning System),  GLONASS  (Global Navigation Satellite System) and  GALILEO   (Global Navigation Satellite System) times could be defined as a constant offset with respect to TAI."},{"id":124,"pagetitle":"-","title":"Time in  JSMD","ref":"/Tempo/stable/tmp/#Time-in-JSMD","content":" Time in  JSMD Within  Tempo , the way in which time is represented in  Tempo  is through the use of   Epoch s.  Epoch s are an efficient, differentiable and precise way to represent  astronomical time. To parse an epoch object, two parameters shall be assigned: Timescale : This parameter determines the timescale that the epoch is based on.    For example, it can be set to UTC, TAI, TDB, or TCB. This allows the user to convert    the epoch between different timescales if necessary. Origin : This parameter determines the origin of the epoch, which is the point in time    from which the epoch is measured. This can be in the form of a Julian date, a   Modified Julian date or any user-defined origin.    The origin can also be set to a specific event, such as J2000.0 or B1950.0. By assigning these two parameters,  Epoch s can be used to represent time in a precise  manner, which is crucial for accurate timekeeping and coordination of events in a universe model."},{"id":127,"pagetitle":"Epochs","title":"Epochs Handling and Conversions","ref":"/Tempo/stable/tutorials/t01_epochs/#tutorial_01_epochs","content":" Epochs Handling and Conversions In this tutorial, the general workflow to be followed when dealing with time representations and their transformations is presented. In particular, most of the features of this package are designed around the  Epoch  data type, which differently from the  DateTime  object, provides the capability to represent time in different standard and user-define time scales."},{"id":128,"pagetitle":"Epochs","title":"Creating Epochs","ref":"/Tempo/stable/tutorials/t01_epochs/#Creating-Epochs","content":" Creating Epochs Time representions for space applications embed three different concepts:  The representation type (e.g. Gregorian or Julian calendar representation) The origin (e.g. J2000, JD, MJD, ...) The time scale (e.g. TAI, TT, TDB, UTC, UT, ...) All three infromation are considered when building an  Epoch . In particular, within  Tempo , the (interal) time representation is always based upon the Julian calendar, with the origin fixed at  J2000 , i.e., the 1st of January 2000 at noon. Different timescales are instead available, with the default one being the  TDB . The set of pre-defined time scales supported by this package is:  TT :  Terrestrial Time , is a time scale that is used for the prediction or recording of the positions of celestial bodies as measured by an observer on Earth.  TDB :  Barycentric Dynamical Time  is a relativistic time scale that is used for the prediction or recording of the positions of celestial bodies relative to the solar system's barycenter. TAI :  International Atomic Time  is a time scale based on the average frequency of a set of atomic clocks. TCG :  Geocentric Coordinate Time  is a relativistic coordinate time scale that is used for precise calculations of objects relative to the Earth.  TCB :  Barycentric Coordinate Time  is a relativistic coordinate time scale that is used for precise calculations of objects in the Solar System. UTC :  Coordinated Universal Time  is the primary civil time standard which is kept within one second from the mean solar time (UT1). However, since the rotation of the Earth is irregular, leap seconds are periodically inserted to keep UTC within 0.9 seconds of UT1.  TDBH : Although TDBH is not an official time scale, it is here used to provide a more accurate transformation between  TT  and  TDB , with a maximum error fo about 10 μs between 1600 and 2200. See  Tempo.offset_tt2tdbh  for more details.  GPS :  GPS Time  is a continuous time scale defined by the GPS Control segment defined as a constant offset of 19s from  TAI ."},{"id":129,"pagetitle":"Epochs","title":"ISO Strings","ref":"/Tempo/stable/tutorials/t01_epochs/#ISO-Strings","content":" ISO Strings With this in mind, many different ways are available to create a new  Epoch  object. The first is based upon the  ISO 8601  concept, an international standard to represent dates and times. The desired timescale can be either specified by appending its acronym to the string or as a second argument, as follows: julia> e = Epoch(\"2022-01-02T06:30:00.0 TT\") 2022-01-02T06:29:59.9999 TT julia> e = Epoch(\"2022-01-02T06:30:00.0\") 2022-01-02T06:29:59.9999 TDB julia> e = Epoch(\"2022-01-02T06:30:00.0\", TAI) 2022-01-02T06:29:59.9999 TAI As you can see, when we did not specify a timescale,  TDB  has been used by default. The usage of partial ISO strings is also supported: julia> e = Epoch(\"2020-01-01\") 2020-01-01T00:00:00.0000 TDB julia> e = Epoch(\"2021-01-30T01\") 2021-01-30T01:00:00.0000 TDB julia> e = Epoch(\"2022-06-12 UTC\") 2022-06-12T00:00:00.0000 UTC"},{"id":130,"pagetitle":"Epochs","title":"Julian Dates","ref":"/Tempo/stable/tutorials/t01_epochs/#Julian-Dates","content":" Julian Dates Epoch  objects can also be created from Julian Dates, Modified Julian Dates as well as Julian days or seconds since  J2000 . To parse a Julian Date, in days, the input string must be in the format  JD DDDDDDDDD.ffffff : julia> e = Epoch(\"JD 2451545.04\") 2000-01-01T12:57:36.0000 TDB julia> e = Epoch(\"JD 2451545.04 TT\") 2000-01-01T12:57:36.0000 TT Similarly, for Modified Julian Dates, the string format is  MJD DDDDDDDDD.ffffff : julia> e = Epoch(\"MJD 51544.54\") 2000-01-01T12:57:36.0000 TDB julia> e = Epoch(\"MJD 51544.54 TT\") 2000-01-01T12:57:36.0000 TT When a prefix is not specified, the epoch constructor assumes the input is expressed as Julian days since  J2000 : julia> e = Epoch(\"9.0\") 2000-01-10T12:00:00.0000 TDB julia> e = Epoch(\"9.0 TT\") 2000-01-10T12:00:00.0000 TT As you can see, the timescale acronym can always be appended to the predefined string format to override the default time scale. Finally, it is also possible to create an epoch by specifing the number of seconds since  J2000 . In the latter case, the constructor has a slightly different form and always requires the timescale argument: julia> e = Epoch(60.0, TT) 2000-01-01T12:01:00.0000 TT julia> e = Epoch(60.0, TerrestrialTime) 2000-01-01T12:01:00.0000 TT julia> e = Epoch{TerrestrialTime}(60.0) 2000-01-01T12:01:00.0000 TT"},{"id":131,"pagetitle":"Epochs","title":"DateTime","ref":"/Tempo/stable/tutorials/t01_epochs/#DateTime","content":" DateTime Finally, an  Epoch  can also be constructed from the  DateTime  object defined within this package: julia> dt = DateTime(2001, 6, 15, 0, 0, 0, 0.0) 2001-06-15T00:00:00.0000 julia> e = Epoch(dt, TT) 2001-06-15T00:00:00.0000 TT julia> e = Epoch(dt, TerrestrialTime) 2001-06-15T00:00:00.0000 TT"},{"id":132,"pagetitle":"Epochs","title":"Working with Epochs","ref":"/Tempo/stable/tutorials/t01_epochs/#Working-with-Epochs","content":" Working with Epochs"},{"id":133,"pagetitle":"Epochs","title":"Basic Operations","ref":"/Tempo/stable/tutorials/t01_epochs/#Basic-Operations","content":" Basic Operations The  Epoch  type supports a limited subset of basic mathematical and logical operations on it. For example, the offset, in seconds, between two epochs can be computed by subtracting them:  julia> e1 = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> e2 = Epoch(50.0, TT) 2000-01-01T12:00:50.0000 TT julia> e1 - e2 40.0 julia> e3 = Epoch(40, TAI) 2000-01-01T12:00:40.0000 TAI julia> e1 - e3 ERROR: only epochs defined in the same timescale can be subtracted. Notice that this operation can be performed only if the two epochs are defined on the same timescale. Epochs can also be shifted forward and backwards in time by adding or subtracting an arbitrary number of seconds:  julia> e1 = Epoch(30.0, TDB) 2000-01-01T12:00:30.0000 TDB julia> e1 += 50 2000-01-01T12:01:20.0000 TDB julia> e1 -= 30.42 2000-01-01T12:00:49.5800 TDB You can check whether an epoch is greater than an other with the logical operators: julia> e1 = Epoch(50.0, UTC) 2000-01-01T12:00:50.0000 UTC julia> e2 = Epoch(50.0, UTC) 2000-01-01T12:00:50.0000 UTC julia> e1 > e2 false julia> e1 == e2 true Again, the operations are supported only if the two epochs belong to the same timescale. Finally, it is also possible to construct ranges with  Epoch s, with a default timestep of one Julian day. User-defined timesteps are assumed to be expressed in seconds. julia> e1 = Epoch(\"2024-01-01T12:00:00\") 2024-01-01T12:00:00.0000 TDB julia> e2 = Epoch(\"2024-01-05T12:00:00\") 2024-01-05T12:00:00.0000 TDB julia> collect(e1:e2) 5-element Vector{Epoch{BarycentricDynamicalTime, Float64}}:\n 2024-01-01T12:00:00.0000 TDB\n 2024-01-02T12:00:00.0000 TDB\n 2024-01-03T12:00:00.0000 TDB\n 2024-01-04T12:00:00.0000 TDB\n 2024-01-05T12:00:00.0000 TDB julia> collect(e1:172800:e2) 3-element Vector{Epoch{BarycentricDynamicalTime, Float64}}:\n 2024-01-01T12:00:00.0000 TDB\n 2024-01-03T12:00:00.0000 TDB\n 2024-01-05T12:00:00.0000 TDB"},{"id":134,"pagetitle":"Epochs","title":"Julian Dates","ref":"/Tempo/stable/tutorials/t01_epochs/#Julian-Dates-2","content":" Julian Dates A predefined set of functions is also provided to easily convert [ Epoch ] objects to Julian seconds, days and centuries since  J2000 : julia> e = Epoch(\"2024-01-01T12:00:00 TAI\") 2024-01-01T12:00:00.0000 TAI julia> j2000(e) 8766.0 julia> j2000s(e) 7.573824e8 julia> j2000c(e) 0.24"},{"id":135,"pagetitle":"Epochs","title":"Converting Between Time Scales","ref":"/Tempo/stable/tutorials/t01_epochs/#Converting-Between-Time-Scales","content":" Converting Between Time Scales Epoch transformations between the standard and user-defined timescales are simply performed through the  convert  method by specifying the target time scale julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eTAI = convert(TAI, e) 2000-01-01T12:00:57.8160 TAI julia> eTCG = convert(TCG, e) 2000-01-01T12:01:30.5058 TCG These transformations are based on a  directed  graph of timescales ( TIMESCALES ) existing within  Tempo . Set of functions provide then the offsets in seconds between each pair of connected timescales, offering a simple, effective and efficient way to compute these transformations. julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eTAI = convert(TAI, e) 2000-01-01T12:00:57.8160 TAI"},{"id":136,"pagetitle":"Epochs","title":"UTC and Leap Seconds","ref":"/Tempo/stable/tutorials/t01_epochs/#UTC-and-Leap-Seconds","content":" UTC and Leap Seconds A special remark must be made on the conversion between TAI and UTC. The offset between these two timescales is defined by a leap seconds, which are introduced to keep the UTC time scale within 0.9 seconds from UT1. Since the rotation of the Earth is irregular, it is not possible to predict when a new leap second will be introduced in the future.  The latest NAIF's leap second kernel ( LSK ) is embedded within  Tempo  as a package artifact, which will be manually updated each time a new kernel is released, so that the user effort is minimised. Indeed, transforming an  Epoch  from a generic timescale to UTC is a simple as: julia> e = Epoch(90.0, TT) 2000-01-01T12:01:30.0000 TT julia> eUTC = convert(UTC, e) 2000-01-01T12:00:25.8159 UTC"},{"id":137,"pagetitle":"Epochs","title":"UTC to UT1","ref":"/Tempo/stable/tutorials/t01_epochs/#UTC-to-UT1","content":" UTC to UT1 The offset between UT1 and UTC, which depends upon the rotation of the Earth, is available in the Earth Orientation Parameters (EOP) provided by the International Earth Rotation and Reference System Service ( IERS ). Since those parameters are also required to compute the orientation of the ITRF with respect to the ICRF, a decision has been made to define the UT1 timescale in  FrameTransformations.jl , a different package which enhances  Tempo  with the capability to transform from and to UT1."},{"id":140,"pagetitle":"Custom Timescales","title":"Creating Custom Timescales","ref":"/Tempo/stable/tutorials/t02_scales/#tutorial_02_scales","content":" Creating Custom Timescales In Tempo.jl, all timescales connections and epoch conversions are handled through a  directed graph .  A default graph ( TIMESCALES ), containing a set of predefined timescales is provided by this package. However, this package also provided a set of routines to either extend such graph or create a completely custom one. In this tutorial, we will explore both alternatives."},{"id":141,"pagetitle":"Custom Timescales","title":"Defining a New Timescale","ref":"/Tempo/stable/tutorials/t02_scales/#Defining-a-New-Timescale","content":" Defining a New Timescale Custom timescales can be created with the  @timescale  macro, which automatically creates the required types and structures, given the timescale acronym, an integer ID and, eventually, the full name of the timescale.  julia> @timescale ET 15 EphemerisTime The ID is an integer that is internally used to uniquely represent the timescale, whereas the acronym is used to alias such ID. It is also possible to define multiple acronyms associated to the same ID but you cannot assign multiple IDs to the same acronym. In case a full name is not provided, a default one will be built by appending  TimeScale  to the acronym. Warning The IDs from 1 to 10 are used to define the standard timescales of the package. To avoid unexpected behaviors, custom timescales should be registered with higher IDs. In the previous example, we have created a custom timescale named  EphemerisTime , with ID 15. We are now able to define epochs with respect to ET, but we cannot perform conversions towards other timescales until we register it in a graph system: julia> ep = Epoch(20.425, ET) 2000-01-01T12:00:20.4249 ET julia> convert(TT, ep) ERROR: EpochConversionError: cannot convert Epoch from the timescale Main.EphemerisTime to TerrestrialTime."},{"id":142,"pagetitle":"Custom Timescales","title":"Extending the Default Graph","ref":"/Tempo/stable/tutorials/t02_scales/#Extending-the-Default-Graph","content":" Extending the Default Graph In this section, the goal is to register ET as a zero-offset scale with respect to  TDB . To register this timescale in the default graph, we first need to define the offset functions of ET with respect to TDB:  julia> offset_tdb2et(sec::Number) = 0 offset_tdb2et (generic function with 1 method) julia> offset_et2tdb(sec::Number) = 0 offset_et2tdb (generic function with 1 method) Since we have assumed that the two scales are identical, our functions will always return a zero offset. Rememeber that timescales graph is  directed , meaning that if the user desires to go back and forth between two timescales, both transformations must be defined. The input argument of such functions is always the number of seconds since J2000 expressed in the origin timescale. Finally, the  add_timescale!  method can be used to register ET within the default graph: julia> add_timescale!(TIMESCALES, ET, offset_tdb2et, parent=TDB, ftp=offset_et2tdb) If the inverse transformation (from ET to TDB) is not provided, only one-way epoch conversions will be allowed. We can now check that the desired timescale has been properly registered and performs the same as TDB:  julia> ep = Epoch(\"200.432 TT\") 2000-07-19T22:22:04.8000 TT julia> convert(TDB, ep) 2000-07-19T22:22:04.7995 TDB julia> convert(ET, ep) 2000-07-19T22:22:04.7995 ET"},{"id":143,"pagetitle":"Custom Timescales","title":"Creating a Custom Graph","ref":"/Tempo/stable/tutorials/t02_scales/#Creating-a-Custom-Graph","content":" Creating a Custom Graph To create a custom directed graph to handle timescales, Tempo.jl provides the  TimeSystem  type. Therefore, let us define a new time transformation system called  TIMETRANSF : julia> const TIMETRANSF = TimeSystem{Float64}() TimeSystem{Float64}(SMDGraphs.MappedNodeGraph{Tempo.TimeScaleNode{Float64}, Graphs.SimpleGraphs.SimpleDiGraph{Int64}}(Graphs.SimpleGraphs.SimpleDiGraph{Int64}(0, Vector{Int64}[], Vector{Int64}[]), Dict{Int64, Int64}(), Tempo.TimeScaleNode{Float64}[], Dict{Int64, Dict{Int64, Vector{Int64}}}(), Dict{Int64, Dict{Int64, Int64}}())) This object contains a graph and the properties associated to the new time-system defined in  TIMETRANSF . At the moment, the computational graph is empty and we need to manually populate it with the new transformations. We begin by creating a new timescale:  julia> @timescale DTS 1 DefaultTimeScale Once created, the new timescale is ready to be registered. If it is the first scale registered in the computational graph, nothing else than the type alias is needed and the registration can be performed as follows: julia> add_timescale!(TIMETRANSF, DTS) julia> TIMETRANSF.scales.nodes 1-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1) Instead, in case the timescale is linked to a parent one, offset functions shall be defined. In this example, assume we want to register the timescales  NTSA  and  NTSB  such that  NTSA  has  DTS  as parent and a constant offset of 1 second, whereas NTSB  has  NTSA  as parent and a linear offset with slope of 1/86400. We begin by creating the first timescale: julia> @timescale NTSA 2 NewTimeScaleA We then define its offset functions and register it in  TIMETRANSF  via the  add_timescale!  method: julia> const OFFSET_DTS_TO_NTSA = 1.0 1.0 julia> offset_dts2ntsa(sec::Number) = OFFSET_DTS_TO_NTSA offset_dts2ntsa (generic function with 1 method) julia> offset_ntsa2dts(sec::Number) = -OFFSET_DTS_TO_NTSA offset_ntsa2dts (generic function with 1 method) julia> add_timescale!(TIMETRANSF, NTSA, offset_dts2ntsa, parent=DTS, ftp=offset_ntsa2dts) Now, if we have a look to the computational graph, we'll see that  NTSA  is registered: julia> TIMETRANSF.scales.nodes 2-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1)\n\n TimeScaleNode{Float64}(name=NTSA, id=2, parent=1) If now we create a  DTS  epoch, we can leverage our custom time transformation system to convert it to an epoch in the  NTSA  timescale: julia> e = Epoch(0.0, DTS) 2000-01-01T12:00:00.0000 DTS julia> convert(NTSA, e, system=TIMETRANSF) 2000-01-01T12:00:01.0000 NTSA Whenever the conversions are based on a custom time system, the graph must be provided as an additional argument to the  convert  method.  To conclude the example, we will now add the  NTSB  scale but only register the  NTSA -> NTSB  transformation: julia> @timescale NTSB 3 NewTimeScaleB julia> offset_ntsa2ntsb(sec::Number) = sec/86400.0 offset_ntsa2ntsb (generic function with 1 method) julia> add_timescale!(TIMETRANSF, NTSB, offset_ntsa2ntsb, parent=NTSA) Now, let's have a look to the nodes in the graph: julia> TIMETRANSF.scales.nodes 3-element Vector{Tempo.TimeScaleNode{Float64}}:\n TimeScaleNode{Float64}(name=DTS, id=1)\n\n TimeScaleNode{Float64}(name=NTSA, id=2, parent=1)\n\n TimeScaleNode{Float64}(name=NTSB, id=3, parent=2) You can see that the new timescale has been registered with the desired integer ID  3 . To test the complete system, we will translate forwad of 2 days the previous epoch  e  and transform it in both timescales:  julia> e += 2*86400 2000-01-03T12:00:00.0000 DTS julia> ea = convert(NTSA, e, system=TIMETRANSF) 2000-01-03T12:00:01.0000 NTSA julia> eb = convert(NTSB, e, system=TIMETRANSF) 2000-01-03T12:00:03.0000 NTSB As expected, we obtain translations of 1 and 3 seconds, respectively."},{"id":146,"pagetitle":"Home","title":"Welcome to Ephemerides.jl!","ref":"/Ephemerides/stable/#Welcome-to-Ephemerides.jl!","content":" Welcome to Ephemerides.jl! Ephemerides.jl is a Julia library that provides fast, thread-safe and allocation-free access to binary JPL  SPK  and  PCK  ephemeris files. Completely written in Julia, it enables Automatic-Differentiation (AD) via  ForwardDiff.jl  across all of its function calls.  It outperforms both  SPICE.jl  and  CALCEPH.jl  calls for most types of SPK segments and supports state vector and orientation angles computation up to order 3 (jerk). Note This package is meant to be used in combination with  FrameTransformations.jl , which enables transformations between different point and axes. Indeed, differently from traditional ephemeris readers such as  CALCEPH  and  SPICE , this package is only meant to read the data stored in the binary kernels. It does not perform transformations between reference frames nor concatenations of state vectors. For example, if ephemeris data for point 399 (Earth) is defined with respect to point 3 (Earth-Moon Barycenter) in the ICRF axes, with this package we will only be able to compute the state vector from 399 to 3 or viceversa.  Note All the package routines have been extensively tested against both SPICE and CALCEPH."},{"id":147,"pagetitle":"Home","title":"Installation","ref":"/Ephemerides/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg\n\njulia> Pkg.add(\"Ephemerides.jl\");"},{"id":148,"pagetitle":"Home","title":"Quickstart","ref":"/Ephemerides/stable/#Quickstart","content":" Quickstart Load SPK and PCK ephemeris kernels:  using Ephemerides \n\n# Load a single SPK kernel \neph_spk = EphemerisProvider(\"de440.bsp\")\n\n# Load a single PCK kernel\neph_pck = EphemerisProvider(\"pa440.bsp\")\n\n# Load multiple SPK and PCK kernels\neph = EphemerisProvider([\"de440.bsp\", \"pa440.bsp\"]) Inspect the kernels properties: # Retrieve the list of NAIF ID for all the available points \npoints = ephem_available_points(eph)\n\n# Retrieve the list of NAIF ID for all the available axes\naxes = ephem_available_axes(eph) Retrieve state and orientation data: # TDB seconds at 2000-01-01T12:00:00 (J2000)\ntime = 0.0\n\n# Compute the position of point 399 with respect to 3 at J2000\npos = ephem_vector3(eph, 3, 399, time)\n\n# Compute the position and its derivatives for point 299 with respect to 2\npvaj = ephem_vector12(eph, 2, 299, time)\n\n# Compute the orientation of axes 31006 (PA440) with respect to 1 (ICRF) at J2000\nangles = ephem_rotation3(eph, 1, 31006, time)"},{"id":149,"pagetitle":"Home","title":"Current Limitations","ref":"/Ephemerides/stable/#Current-Limitations","content":" Current Limitations The supported JPL binary SPK/PCK segments types are: 1, 2, 3, 5, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, 21.  Binary INPOP kernels are not supported.  Acceleration and jerk computations are unavailable for SPK segments of type 1, 5, 15, 17 and 21."},{"id":152,"pagetitle":"Public API","title":"Public Documentation","ref":"/Ephemerides/stable/api/api/#ephemerides_api","content":" Public Documentation"},{"id":153,"pagetitle":"Public API","title":"Kernels Loading and Inspection Functions","ref":"/Ephemerides/stable/api/api/#Kernels-Loading-and-Inspection-Functions","content":" Kernels Loading and Inspection Functions"},{"id":154,"pagetitle":"Public API","title":"Ephemerides.EphemerisProvider","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemerisProvider","content":" Ephemerides.EphemerisProvider  —  Type EphemerisProvider(file::String)\nEphemerisProvider(files::Vector{String}) Create an  EphemerisProvider  instance by loading a single or multiple binary ephemeris  kernel files specified by  files . Currently, only NAIF Double precision Array File (DAF) kernels (i.e., SPK and PCK) are accepted. Example julia> eph = EphemerisProvider(\"PATH_TO_KERNEL\")\nEphemerisProvider([...])\n\njulia> eph = EphemerisProvider([\"PATH_TO_KERNEL_1\", \"PATH_TO_KERNEL_2\"])\nEphemerisProvider([]) source"},{"id":155,"pagetitle":"Public API","title":"Ephemerides.EphemRecordSPK","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemRecordSPK","content":" Ephemerides.EphemRecordSPK  —  Type EphemRecordSPK <: AbstractEphemRecord Store the SPK metadata relative to a given (target, center) objects pair. Fields target  –  Int  target object NAIF ID center  –  Int  center object NAIF ID axes  –  Int  reference axes ID  t_start  – start times of each sub-window, in TDB seconds since J2000 t_end  – final times of each sub-window, in TDB seconds since J2000 source"},{"id":156,"pagetitle":"Public API","title":"Ephemerides.EphemRecordPCK","ref":"/Ephemerides/stable/api/api/#Ephemerides.EphemRecordPCK","content":" Ephemerides.EphemRecordPCK  —  Type EphemRecordPCK <: AbstractEphemRecord Store the PCK metadata relative to a given (target, center) axes pair. Fields target  –  Int  target axes NAIF ID center  –  Int  center axes NAIF ID t_start  – start times of each sub-window, in TDB seconds since J2000 t_end  – final times of each sub-window, in TDB seconds since J2000 source"},{"id":157,"pagetitle":"Public API","title":"Ephemerides.ephem_timescale_id","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_timescale_id","content":" Ephemerides.ephem_timescale_id  —  Function ephem_timescale_id(eph::EphemerisProvider) Retrieve a timescale ID associated with the ephemeris handler  eph .  It returns 1 for Barycentric Dynamical Time (TDB) and 2 for Barycentric Coordinate Time (TCB). Warning Ephemeris providers with mixed timescales are not supported. An error is thrown if in  the ephemeris handler some segments are defined in TDB and some other segments in TCB. source"},{"id":158,"pagetitle":"Public API","title":"Ephemerides.ephem_spk_timespan","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_spk_timespan","content":" Ephemerides.ephem_spk_timespan  —  Function ephem_spk_timespan(eph::EphemerisProvider) Return the minimum and maximum time available in the SPK kernels loaded within  eph , in  TDB seconds since J2000, together with a continuity parameter defined as follows:  0  no SPK data is available. 1  the quantities of all bodies are available for any time between the first and last time. 2  the quantities of some bodies are available on discontinuous time intervals between the    first and last time. 3  the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time. References CALCEPH  C++ library See Also See also  ephem_pck_timespan . source"},{"id":159,"pagetitle":"Public API","title":"Ephemerides.ephem_pck_timespan","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_pck_timespan","content":" Ephemerides.ephem_pck_timespan  —  Function ephem_pck_timespan(eph::EphemerisProvider) Return the minimum and maximum time available in the PCK kernels loaded within  eph , in  TDB seconds since J2000, together with a continuity parameter defined as follows:  0  no PCK data is available. 1  the quantities of all axes are available for any time between the first and last time. 2  the quantities of some axes are available on discontinuous time intervals between the    first and last time. 3  the quantities of each axis are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time. References CALCEPH  C++ library See Also See also  ephem_spk_timespan . source"},{"id":160,"pagetitle":"Public API","title":"Ephemerides.ephem_spk_records","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_spk_records","content":" Ephemerides.ephem_spk_records  —  Function ephem_spk_records(eph::EphemerisProvider) Return a list of  EphemRecordSPK  storing metadata relative to each (target, center) object pairs in the loaded SPK kernels.  source"},{"id":161,"pagetitle":"Public API","title":"Ephemerides.ephem_pck_records","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_pck_records","content":" Ephemerides.ephem_pck_records  —  Function ephem_pck_records(eph::EphemerisProvider) Return a list of  EphemRecordPCK  storing metadata relative to each (target, center) axes pairs in the loaded PCK kernels.  source"},{"id":162,"pagetitle":"Public API","title":"Ephemerides.ephem_get_points","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_get_points","content":" Ephemerides.ephem_get_points  —  Function ephem_get_points(eph::EphemerisProvider) Return a list of NAIFIds representing bodies with available ephemeris data.  source"},{"id":163,"pagetitle":"Public API","title":"Ephemerides.ephem_get_axes","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_get_axes","content":" Ephemerides.ephem_get_axes  —  Function ephem_get_axes(eph::EphemerisProvider) Return a list of Frame IDs representing axes with available orientation data.  source"},{"id":164,"pagetitle":"Public API","title":"Computing Positions","ref":"/Ephemerides/stable/api/api/#Computing-Positions","content":" Computing Positions"},{"id":165,"pagetitle":"Public API","title":"Ephemerides.ephem_vector3","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector3","content":" Ephemerides.ephem_vector3  —  Function ephem_vector3(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 3-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":166,"pagetitle":"Public API","title":"Ephemerides.ephem_vector6","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector6","content":" Ephemerides.ephem_vector6  —  Function ephem_vector6(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 6-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":167,"pagetitle":"Public API","title":"Ephemerides.ephem_vector9","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector9","content":" Ephemerides.ephem_vector9  —  Function ephem_vector9(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 9-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":168,"pagetitle":"Public API","title":"Ephemerides.ephem_vector12","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_vector12","content":" Ephemerides.ephem_vector12  —  Function ephem_vector12(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 12-elements state of one body (to) relative to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance with the kernel timescale. source"},{"id":169,"pagetitle":"Public API","title":"Computing Orientation","ref":"/Ephemerides/stable/api/api/#Computing-Orientation","content":" Computing Orientation"},{"id":170,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation3","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation3","content":" Ephemerides.ephem_rotation3  —  Function ephem_rotation3(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 3-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":171,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation6","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation6","content":" Ephemerides.ephem_rotation6  —  Function ephem_rotation6(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 6-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":172,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation9","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation9","content":" Ephemerides.ephem_rotation9  —  Function ephem_rotation9(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 9-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":173,"pagetitle":"Public API","title":"Ephemerides.ephem_rotation12","ref":"/Ephemerides/stable/api/api/#Ephemerides.ephem_rotation12","content":" Ephemerides.ephem_rotation12  —  Function ephem_rotation12(eph::EphemerisProvider, from::Int, to::Int, time::Number) Compute the 12-elements orientation angles of one set of axes (to) relative  to another (from) at  time , expressed in TDB/TCB seconds since J2000, in accordance  with the kernel timescale. Note For the orientation angles, it is not possible to automatically compute the  reverse transformation , i.e., if the orientation of PA440 is defined  with respect to the ICRF, it is not possible to compute the rotation from the  PA440 to the ICRF with this routine. source"},{"id":176,"pagetitle":"Low-level API","title":"Low-level API","ref":"/Ephemerides/stable/api/lapi/#ephemerides_api","content":" Low-level API These functions are not meant to be used outside of the package. They are documented  only to aid future developments of the package."},{"id":177,"pagetitle":"Low-level API","title":"Ephemeris Provider","ref":"/Ephemerides/stable/api/lapi/#Ephemeris-Provider","content":" Ephemeris Provider"},{"id":178,"pagetitle":"Low-level API","title":"Ephemerides.get_daf","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_daf","content":" Ephemerides.get_daf  —  Function daf(eph::EphemerisProvider) Return the  DAF  files stored in the ephemeris provider.  source daf(eph::EphemerisProvider, id::Int) Return the  DAF  file in the ephemeris provider at index  id . source"},{"id":179,"pagetitle":"Low-level API","title":"Ephemerides.spk_links","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.spk_links","content":" Ephemerides.spk_links  —  Function spk_links(eph::EphemerisProvider) Return the [ SPKLinkTable ] for the SPK segments. source"},{"id":180,"pagetitle":"Low-level API","title":"Ephemerides.pck_links","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.pck_links","content":" Ephemerides.pck_links  —  Function pck_links(eph::EphemerisProvider) Return the  SPKLinkTable  for the PCK segments. source"},{"id":181,"pagetitle":"Low-level API","title":"DAF Routines","ref":"/Ephemerides/stable/api/lapi/#DAF-Routines","content":" DAF Routines"},{"id":182,"pagetitle":"Low-level API","title":"DAF Header","ref":"/Ephemerides/stable/api/lapi/#DAF-Header","content":" DAF Header"},{"id":183,"pagetitle":"Low-level API","title":"Ephemerides.DAFHeader","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAFHeader","content":" Ephemerides.DAFHeader  —  Type DAFHeader The DAF header, or file record, is the first physical record in a DAF and stores general  information about the content of the file.  Fields nd  –  Int32  number of double components in each array summary ni  –  Int32  number of integer components in each array summary fwd  –  Int32  record number of initial summary record bwd  –  Int32  record number of final summary record ffa  –  Int32  first free address of the file  name  –  String  internal name of the file lend  –  Bool  true if the file was generated in little endian  References DAF Required Reading See Also See also  DAF  and  EphemerisProvider source"},{"id":184,"pagetitle":"Low-level API","title":"Ephemerides.initial_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_record","content":" Ephemerides.initial_record  —  Function initial_record(head::DAFHeader) Return the record number of the initial summary record in the DAF  source initial_record(daf::DAF) Return the record number of the initial summary record in the DAF. source"},{"id":185,"pagetitle":"Low-level API","title":"Ephemerides.final_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_record","content":" Ephemerides.final_record  —  Function final_record(head::DAFHeader) Return the record number of the final summary record in the DAF  source final_record(daf::DAF) Return the record number of the final summary record in the DAF. source"},{"id":186,"pagetitle":"Low-level API","title":"Ephemerides.free_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.free_address","content":" Ephemerides.free_address  —  Function free_address(head::DAFHeader) Return the first free address in the file, i.e., the address at which the first element of  the next array is to be added. source free_address(daf::DAF) Return the first free address in the file, i.e., the address at which the first element of  the next array is to be added. source"},{"id":187,"pagetitle":"Low-level API","title":"Ephemerides.endian","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.endian","content":" Ephemerides.endian  —  Function endian(head::DAFHeader) Return  true  if the DAF file is in little-endian. source endian(daf::DAF) Return  true  if the DAF is in little-endian. source"},{"id":188,"pagetitle":"Low-level API","title":"Ephemerides.filename","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.filename","content":" Ephemerides.filename  —  Function filename(head::DAFHeader) Return the internal description of the DAF. source"},{"id":189,"pagetitle":"Low-level API","title":"Ephemerides.summary_size","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.summary_size","content":" Ephemerides.summary_size  —  Function summary_size(head::DAFHeader) Compute the size of a single summary record of a DAF file, in bytes. source"},{"id":190,"pagetitle":"Low-level API","title":"DAF Descriptor","ref":"/Ephemerides/stable/api/lapi/#DAF-Descriptor","content":" DAF Descriptor"},{"id":191,"pagetitle":"Low-level API","title":"Ephemerides.DAFSegmentDescriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAFSegmentDescriptor","content":" Ephemerides.DAFSegmentDescriptor  —  Type DAFSegmentDescriptor A container object to store both SPK and PCK descriptors information. Fields segtype  –  Int32  SPK/PCK segment type tstart  –  Float64  initial segment type, in TDB seconds since J2000.0 tend  –  Float64  final segment type, in TDB seconds since J2000.0 tid  –  Int32  target object NAIF ID cid  –  Int32  center object NAIF ID axesid  –  Int32  reference axes ID. Defaults to -1 for PCKs iaa  –  Int32  initial array address faa  –  Int32  final array address References SPK Required Reading PCK Required Reading source"},{"id":192,"pagetitle":"Low-level API","title":"Ephemerides.segment_type","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.segment_type","content":" Ephemerides.segment_type  —  Function segment_type(desc::DAFSegmentDescriptor) Return the SPK/PCK segment type. source"},{"id":193,"pagetitle":"Low-level API","title":"Ephemerides.initial_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_time","content":" Ephemerides.initial_time  —  Function initial_time(desc::DAFSegmentDescriptor) Return the initial epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0 source initial_time(link::SPKLink) Return the initial epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0 source"},{"id":194,"pagetitle":"Low-level API","title":"Ephemerides.final_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_time","content":" Ephemerides.final_time  —  Function final_time(desc::DAFSegmentDescriptor) Return the final epoch of the interval for which ephemeris data are contained in the  segment, in seconds since J2000.0 source final_time(link::SPKLink) Return the final epoch of the interval for which ephemeris data are contained in the  segment associated to this link, in seconds since J2000.0 source"},{"id":195,"pagetitle":"Low-level API","title":"Ephemerides.center","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.center","content":" Ephemerides.center  —  Function center(desc::DAFSegmentDescriptor) Return the NAIF integer code for the reference object or axes for SPK and PCK, respectively. source"},{"id":196,"pagetitle":"Low-level API","title":"Ephemerides.target","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.target","content":" Ephemerides.target  —  Function target(desc::DAFSegmentDescriptor) Return the NAIF integer code for the target object or axes for SPK and PCK, respectively. source"},{"id":197,"pagetitle":"Low-level API","title":"Ephemerides.axes","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.axes","content":" Ephemerides.axes  —  Function axes(desc::DAFSegmentDescriptor) Return the NAIF integer code for the reference axes. It is valid only for SPK files and  defaults to -1 for PCKs.  source"},{"id":198,"pagetitle":"Low-level API","title":"Ephemerides.initial_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_address","content":" Ephemerides.initial_address  —  Function initial_address(desc::DAFSegmentDescriptor) Return the initial address of the segment array in the DAF. source"},{"id":199,"pagetitle":"Low-level API","title":"Ephemerides.final_address","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_address","content":" Ephemerides.final_address  —  Function final_address(desc::DAFSegmentDescriptor) Return the final address of the segment array in teh DAF. source"},{"id":200,"pagetitle":"Low-level API","title":"Ephemerides.get_segment_boundaries","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_segment_boundaries","content":" Ephemerides.get_segment_boundaries  —  Function get_segment_boundaries(desclist::Vector{DAFSegmentDescriptor}) Parse all the segment descriptors of a given (center, target) pair and return a set of  initial and final times, in TDB seconds since J2000, representing all the time  sub-windows in which the ephemeris data for this pair is defined.  source"},{"id":201,"pagetitle":"Low-level API","title":"Ephemerides.parse_spk_segment_descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_spk_segment_descriptor","content":" Ephemerides.parse_spk_segment_descriptor  —  Function parse_spk_segment_descriptor(summary::Vector{UInt8}, lend::Bool) Create a  DAFSegmentDescriptor  object by parsing a binary SPK segment descriptor. References SPK Required Reading source"},{"id":202,"pagetitle":"Low-level API","title":"Ephemerides.parse_pck_segment_descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_pck_segment_descriptor","content":" Ephemerides.parse_pck_segment_descriptor  —  Function parse_pck_segment_descriptor(summary::Vector{UInt8}, lend::Bool) Create a  DAFSegmentDescriptor  object by parsing a binary PCK segment descriptor.  A default value of -1 is used to fill the reference frame field. The target and center fields are used for the actual target and center axes. References PCK Required Reading source"},{"id":203,"pagetitle":"Low-level API","title":"DAF","ref":"/Ephemerides/stable/api/lapi/#DAF","content":" DAF"},{"id":204,"pagetitle":"Low-level API","title":"Ephemerides.DAF","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAF","content":" Ephemerides.DAF  —  Type DAF Container to hold the information of NAIF's Double precision Array File (DAF).  Fields filepath  –  String  system filepath of the DAF  array  –  Vector{UInt8}  binary content of the DAF header  –  DAFHeader  file record of the DAF comment  –  String  text within the DAF comment area  ftype  –  Int  file type, equals 1 for SPK and 2 for PCK desc  – DAF PCK/SPK segment descriptors seglist  –  SPKSegmentList  list of the SPK/PCK segments within the DAF References DAF Required Reading See Also See also  DAFHeader ,  Ephemerides.SPKSegmentList  and  EphemerisProvider source"},{"id":205,"pagetitle":"Low-level API","title":"Ephemerides.DAF_RECORD_LENGTH","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.DAF_RECORD_LENGTH","content":" Ephemerides.DAF_RECORD_LENGTH  —  Constant DAF_RECORD_LENGTH DAF record length, in bytes. References DAF Required Reading source"},{"id":206,"pagetitle":"Low-level API","title":"Ephemerides.FTPSTR","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.FTPSTR","content":" Ephemerides.FTPSTR  —  Constant FTPSTR Validation string that guarantees the integrity of a DAF file.  References DAF Required Reading source"},{"id":207,"pagetitle":"Low-level API","title":"Ephemerides.comment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.comment","content":" Ephemerides.comment  —  Function get_comment(daf::DAF) Return the comment written in the DAF comment section.  source"},{"id":208,"pagetitle":"Low-level API","title":"Ephemerides.header","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.header","content":" Ephemerides.header  —  Function header(spk::AbstractSPKSegment) Return the segment header. source get_header(daf::DAF) Return the  DAFHeader  header of the DAF. source"},{"id":209,"pagetitle":"Low-level API","title":"Ephemerides.array","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.array","content":" Ephemerides.array  —  Function get_array(daf::DAF) Return the byte content of the DAF file. source"},{"id":210,"pagetitle":"Low-level API","title":"Ephemerides.descriptors","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.descriptors","content":" Ephemerides.descriptors  —  Function get_descriptors(daf::DAF) Return the SPK/PCK segment descriptors contained in the DAF. source"},{"id":211,"pagetitle":"Low-level API","title":"Ephemerides.segment_list","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.segment_list","content":" Ephemerides.segment_list  —  Function get_segment_list(daf::DAF) Return the  Ephemerides.SPKSegmentList  list of segments stored in the DAF. source"},{"id":212,"pagetitle":"Low-level API","title":"Ephemerides.filepath","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.filepath","content":" Ephemerides.filepath  —  Function filepath(daf::DAF) Return the system path of the DAF. source"},{"id":213,"pagetitle":"Low-level API","title":"Ephemerides.is_spk","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_spk","content":" Ephemerides.is_spk  —  Function is_spk(daf::DAF) Return  true  if the DAF stores SPK data. source"},{"id":214,"pagetitle":"Low-level API","title":"Ephemerides.is_pck","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_pck","content":" Ephemerides.is_pck  —  Function is_pck(daf::DAF) Return  true  if the DAF stores PCK data. source"},{"id":215,"pagetitle":"Low-level API","title":"Ephemerides.parse_daf_comment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_daf_comment","content":" Ephemerides.parse_daf_comment  —  Function parse_daf_comment(array::Vector{UInt8}, header::DAFHeader) Retrieve the comment section of a binary DAF. References DAF Required Reading See Also See also  DAF ,  DAFHeader  and  parse_daf_summaries source"},{"id":216,"pagetitle":"Low-level API","title":"Ephemerides.parse_daf_summaries","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.parse_daf_summaries","content":" Ephemerides.parse_daf_summaries  —  Function parse_daf_summaries(array::Vector{UInt8}, head::DAFHeader) Parse the DAF binary content and retrieve all the summary records. References DAF Required Reading See Also See also  DAF ,  DAFHeader  and  parse_daf_comment source"},{"id":217,"pagetitle":"Low-level API","title":"Ephemerides.initialise_segments!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initialise_segments!","content":" Ephemerides.initialise_segments!  —  Function initialise_segments!(daf::DAF) Fill the  Ephemerides.SPKSegmentList  by initialising the SPK/PCK segments associated to all  the descriptors stores within the DAF. See Also See also  DAF  and  create_spk_segment source"},{"id":218,"pagetitle":"Low-level API","title":"Ephemerides.create_spk_segment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.create_spk_segment","content":" Ephemerides.create_spk_segment  —  Function create_spk_segment(daf::DAF, desc::DAFSegmentDescriptor) Initialise an SPK segment according to the segment type defined in the   DAFSegmentDescriptor desc . source"},{"id":219,"pagetitle":"Low-level API","title":"Ephemerides.get_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_record","content":" Ephemerides.get_record  —  Function get_record(array::Vector{UInt8}, index::Integer) Retrieve a whole DAF record at position  index . source"},{"id":220,"pagetitle":"Low-level API","title":"Ephemerides.is_little_endian","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.is_little_endian","content":" Ephemerides.is_little_endian  —  Function is_little_endian(array::Vector{UInt8}) Return true if the array corresponds to the string indicating a little-endian format. source"},{"id":221,"pagetitle":"Low-level API","title":"SPK Links","ref":"/Ephemerides/stable/api/lapi/#SPK-Links","content":" SPK Links"},{"id":222,"pagetitle":"Low-level API","title":"Ephemerides.SPKLink","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKLink","content":" Ephemerides.SPKLink  —  Type SPKLink A link object to create a mapping between  DAFSegmentDescriptor  and its actual  location within an  EphemerisProvider  object.  Fields desc  –  DAFSegmentDescriptor  for the segment associated to this link fid  –  Int  index of the DAF containg the link data. lid  –  Int  field number in the  SPKSegmentList  for this segment type. eid  –  Int  index of the inner segment list that stores this SPK segment. fct  –  Int  1 or -1 depending on whether the (from, to) directions must be reversed. See Also See also  SPKLinkTable ,  SPKSegmentList  and  add_spklinks! . source"},{"id":223,"pagetitle":"Low-level API","title":"Ephemerides.SPKLinkTable","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKLinkTable","content":" Ephemerides.SPKLinkTable  —  Type SPKLinkTable Dictionary object providing all the  SPKLink  available between a set of (from, to) objects source"},{"id":224,"pagetitle":"Low-level API","title":"Ephemerides.descriptor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.descriptor","content":" Ephemerides.descriptor  —  Function descriptor(link::SPKLink) Return the SPK/PCK segment descriptor associated to this link. source"},{"id":225,"pagetitle":"Low-level API","title":"Ephemerides.file_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.file_id","content":" Ephemerides.file_id  —  Function file_id(link::SPKLink) Return the DAF file index. source"},{"id":226,"pagetitle":"Low-level API","title":"Ephemerides.list_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.list_id","content":" Ephemerides.list_id  —  Function list_id(link::SPKLink) Return the index of the list containing the segments of the given SPK/PCK type. source"},{"id":227,"pagetitle":"Low-level API","title":"Ephemerides.element_id","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.element_id","content":" Ephemerides.element_id  —  Function element_id(link::SPKLink) Return the segment index in the inner SPK/PCK segment list. source"},{"id":228,"pagetitle":"Low-level API","title":"Ephemerides.factor","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.factor","content":" Ephemerides.factor  —  Function factor(link::SPKLink) Return the direction multiplicative factor. source"},{"id":229,"pagetitle":"Low-level API","title":"Ephemerides.reverse_link","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.reverse_link","content":" Ephemerides.reverse_link  —  Function reverse_link(link::SPKLink) Reverse the sign, i.e. change the sign of the multiplicative factor, of the link. source"},{"id":230,"pagetitle":"Low-level API","title":"Ephemerides.create_linktables","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.create_linktables","content":" Ephemerides.create_linktables  —  Function create_linktables(dafs::Vector{DAF}) Create the SPK and PCK  SPKLinkTable  for all the segments stores in the input DAFs. source"},{"id":231,"pagetitle":"Low-level API","title":"Ephemerides.add_spklinks!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.add_spklinks!","content":" Ephemerides.add_spklinks!  —  Function add_spklinks!(table::SPKLinkTable, daf::DAF, fid::Int) Insert in the input  SPKLinkTable  all the SPK or PCK links associated to  the segment descriptors of the input DAF. source"},{"id":232,"pagetitle":"Low-level API","title":"SPK Segment List","ref":"/Ephemerides/stable/api/lapi/#SPK-Segment-List","content":" SPK Segment List"},{"id":233,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentList","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentList","content":" Ephemerides.SPKSegmentList  —  Type SPKSegmentList A container object to efficiently store all the different SPK segments that are contained  within a single DAF file. SPKSegmentList() Initialises an empty  SPKSegmentList  object. See also See also  Ephemerides.add_segment! source"},{"id":234,"pagetitle":"Low-level API","title":"Ephemerides.add_segment!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.add_segment!","content":" Ephemerides.add_segment!  —  Function add_segment!(list::SPKSegmentList, spk::AbstractSPKSegment) Add the SPK segment to the proper vector within the given  Ephemerides.SPKSegmentList list source"},{"id":235,"pagetitle":"Low-level API","title":"Ephemerides.get_segment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_segment","content":" Ephemerides.get_segment  —  Function get_segment(list::SPKSegmentList, lid::Int, eid::Int) Return the segment contained in the  lid  list at index  eid . source"},{"id":236,"pagetitle":"Low-level API","title":"Ephemerides.SPK_SEGMENTLIST_MAPPING","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPK_SEGMENTLIST_MAPPING","content":" Ephemerides.SPK_SEGMENTLIST_MAPPING  —  Constant SPK_SEGMENT_MAPPING A dictionary mapping SPK segment types to the field index of the  SPKSegmentList . source"},{"id":237,"pagetitle":"Low-level API","title":"Ephemerides.TCB_SEGMENTS","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TCB_SEGMENTS","content":" Ephemerides.TCB_SEGMENTS  —  Constant TCB_SEGMENTS List of the SPK/PCK segment types for which the time argument is expressed in the TCB scale. source"},{"id":238,"pagetitle":"Low-level API","title":"Ephemerides.TDB_SEGMENTS","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TDB_SEGMENTS","content":" Ephemerides.TDB_SEGMENTS  —  Constant TDB_SEGMENTS List of the SPK/PCK segment types for which the time argument is expressed in the TDB scale.  source"},{"id":239,"pagetitle":"Low-level API","title":"SPK Segment Types","ref":"/Ephemerides/stable/api/lapi/#SPK-Segment-Types","content":" SPK Segment Types"},{"id":240,"pagetitle":"Low-level API","title":"Abstract SPK Types","ref":"/Ephemerides/stable/api/lapi/#Abstract-SPK-Types","content":" Abstract SPK Types"},{"id":241,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKHeader","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKHeader","content":" Ephemerides.AbstractSPKHeader  —  Type AbstractSPKHeader Abstract type for all SPK segment type headers.  source"},{"id":242,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKCache","content":" Ephemerides.AbstractSPKCache  —  Type AbstractSPKCache Abstract type for all SPK segment type caches. source"},{"id":243,"pagetitle":"Low-level API","title":"Ephemerides.AbstractSPKSegment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractSPKSegment","content":" Ephemerides.AbstractSPKSegment  —  Type AbstractSPKSegment Abstract type for all SPK segment types. source"},{"id":244,"pagetitle":"Low-level API","title":"Ephemerides.cache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.cache","content":" Ephemerides.cache  —  Function cache(spk::AbstractSPKSegment) Return the segment cache data. source"},{"id":245,"pagetitle":"Low-level API","title":"Ephemerides.spk_field","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.spk_field","content":" Ephemerides.spk_field  —  Function spk_field(spk::AbstractSPKSegment) Return the field number in the  Ephemerides.SPKSegmentList  associated to the given SPK  segment type. source"},{"id":246,"pagetitle":"Low-level API","title":"SPK Type 1 and 21","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-1-and-21","content":" SPK Type 1 and 21"},{"id":247,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader1","content":" Ephemerides.SPKSegmentHeader1  —  Type SPKSegmentHeader1 <: AbstractSPKHeader Header instance for SPK segments of type 1 and 21. Fields n  –  Int  number of records in the segment  ndirs  –  Int  number of directory epochs epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the MDA records) recsize  -  Int  Number of double numbers stored in each MDA record maxdim  -  Int  MDA dimension (fixed to 15 for type 1) source"},{"id":248,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache1","content":" Ephemerides.SPKSegmentCache1  —  Type SPKSegmentCache1 <: AbstractSPKCache Cache instance for SPK segments of type 1 and 21. The fields contained within this cache  are taken from the FORTRAN NAIF's SPICE implementation for type 1 SPK segments.  Fields tl  – Reference epoch of the difference line. g  – Stepsize function vector. refpos  – Reference position vector. refvel  – Reference velocity vector. dt  – Modified Divided Difference arrays, with size (maxdim, 3) kqmax  – Maximum integration order plus 1. kq  – Integration order array. id  – Index of the currently loaded logical record. fc  – Buffer for the MDA computations. wc  – Buffer for the MDA computations. w  – Buffer for the MDA computations. vct  – Buffer for the MDA computations. source"},{"id":249,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType1","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType1","content":" Ephemerides.SPKSegmentType1  —  Type SPKSegmentType1 <: AbstractSPKSegment Segment instance for SPK segments of type 1 and 21, which contain Modified Difference Arrays  (MDA). This data type is normally used for spacecraft whose ephemerides are produced by JPL's  principal trajectory integrator DPTRAJ.  Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":250,"pagetitle":"Low-level API","title":"Ephemerides.compute_mda_position","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.compute_mda_position","content":" Ephemerides.compute_mda_position  —  Function compute_mda_position(cache::SPKSegmentCache1, Δ::Number) source"},{"id":251,"pagetitle":"Low-level API","title":"Ephemerides.compute_mda_velocity","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.compute_mda_velocity","content":" Ephemerides.compute_mda_velocity  —  Function compute_mda_velocity(cache::SPKSegmentCache1, Δ::Number) source"},{"id":252,"pagetitle":"Low-level API","title":"SPK Type 2 and 3","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-2-and-3","content":" SPK Type 2 and 3"},{"id":253,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader2","content":" Ephemerides.SPKSegmentHeader2  —  Type SPKSegmentHeader2 <: AbstractSPKHeader Header instance for SPK segments of type 2 and 3. Fields tstart  –  Float64  initial epoch of the first record, in seconds since J2000 tlen  –  Float64  interval length covered by each record, in seconds order  –  Int  polynomial order  N  –  Int  number of coefficients in each window n  –  Int  number of records in the segment recsize  –  Int  byte size of each logical record ncomp  –  Int  number of vector components iaa  –  Int  initial segment file address type  –  Int  SPK segment type, either 2 or 2 source"},{"id":254,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache2","content":" Ephemerides.SPKSegmentCache2  —  Type SPKSegmentCache2 <: AbstractSPKCache Cache instance for SPK segments of type 2 and 3. Fields A  – Chebyshev's polynomial coefficients, with size (ncomp, order) p  – Stores the record mid point and radius and scale factor buff  – Stores the buffers for the Chebyshev polynomials id  – Index of the currently loaded logical record source"},{"id":255,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType2","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType2","content":" Ephemerides.SPKSegmentType2  —  Type SPKSegmentType2 <: AbstractSPKSegment Segment instance for SPK segments of type 2 and 3, which contain Chebyshev polynomial  coefficients for the position and/or state of the body as function of time. This data type  is normally used for planet barycenters, and for satellites whose ephemerides are integrated. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":256,"pagetitle":"Low-level API","title":"SPK Type 5","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-5","content":" SPK Type 5"},{"id":257,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader5","content":" Ephemerides.SPKSegmentHeader5  —  Type SPKSegmentHeader5 <: AbstractSPKHeader Header instance for SPK segments of type 5. Fields GM  –  Float64  Gravitational constant  n  –  Int  number of states  ndirs  –  Int  number of epoch directories etid  –  Int  initial address for the epoch table (after all the state data) epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  source"},{"id":258,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache5","content":" Ephemerides.SPKSegmentCache5  —  Type SPKSegmentCache5 <: AbstractSPKCache Cache instance for SPK segments of type 5. Fields c1  – Twobody propagation cache for the left state. c2  – Twobody propagation cache for the right state. epochs  – Epochs associated to the two states. id  – Index of the currently loaded logical record. source"},{"id":259,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType5","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType5","content":" Ephemerides.SPKSegmentType5  —  Type SPKSegmentType5 <: AbstractSPKSegment Segment instance for SPK segments of type 5.  Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":260,"pagetitle":"Low-level API","title":"SPK Type 8 and 12","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-8-and-12","content":" SPK Type 8 and 12"},{"id":261,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader8","content":" Ephemerides.SPKSegmentHeader8  —  Type SPKSegmentHeader8 <: AbstractSPKHeader Header instance for SPK segments of type 8 and 12. Fields tstart  –  Float64  segment starting epoch, in TDB seconds since J2000  tlen  –  Float64  interval length, in seconds order  –  Int  interpolating polynomial degree N  –  Int  group size n  –  Int  number of states in the segment iaa  -  Int  initial segment file address  iseven  –  Bool  true for even group size type  –  Int  SPK type (either 8 or 12) source"},{"id":262,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache8","content":" Ephemerides.SPKSegmentCache8  —  Type SPKSegmentCache8 <: AbstractSPKCache Cache instance for SPK segments of type 8 and 12. Fields states  – Matrix storing the states of the interpolating points. buff  – Buffers to compute the interpolating polynomials. id  – Index of the currently loaded logical record. source"},{"id":263,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType8","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType8","content":" Ephemerides.SPKSegmentType8  —  Type SPKSegmentType8 <: AbstractSPKSegment Segment instance for SPK segments of type 8 and 12. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":264,"pagetitle":"Low-level API","title":"SPK Type 9 and 13","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-9-and-13","content":" SPK Type 9 and 13"},{"id":265,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader9","content":" Ephemerides.SPKSegmentHeader9  —  Type SPKSegmentHeader9 <: AbstractSPKHeader Header instance for SPK segments of type 9 and 13. Fields n  –  Int  number of states in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the state data) order  –  Int  interpolating polynomial degree N  –  Int  group size  iseven  –  Bool  true for even group size type  –  Int  SPK type (either 9 or 13) source"},{"id":266,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache9","content":" Ephemerides.SPKSegmentCache9  —  Type SPKSegmentCache9 <: AbstractSPKCache Cache instance for SPK segments of type 9 and 13. Fields epochs  – Epochs of the interpolating points.  states  – Matrix storing the states of the interpolating points.  buff  – Buffers to compute the interpolating polynomials. id  – Index of the currently loaded logical record. source"},{"id":267,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType9","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType9","content":" Ephemerides.SPKSegmentType9  —  Type SPKSegmentType9 <: AbstractSPKSegment Segment instance for SPK segments of type 9 and 13. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":268,"pagetitle":"Low-level API","title":"SPK Type 14","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-14","content":" SPK Type 14"},{"id":269,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader14","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader14","content":" Ephemerides.SPKSegmentHeader14  —  Type SPKSegmentHeader14 <: AbstractSPKHeader Header instance for SPK segments of type 14. Fields order  –  Int  interpolating polynomial degree n  –  Int  number of packets in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) etid  –  Int  initial address for the epoch table (after all the state data) ptid  –  Int  initial address for the packet table (after the constants) pktsize  –  Int  size of each data packet excluding the packet information area. pktoff  –  Int  offset of the packet data from the packet start  ncomp  –  Int  number of states coefficients (= 6 for SPK 14) N  –  Int  number of polynomial coefficients source"},{"id":270,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType14","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType14","content":" Ephemerides.SPKSegmentType14  —  Type SPKSegmentType14 <: AbstractSPKSegment Segment instance for SPK segments of type 14. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source Note SPK segments of type 14 have the same cache structure of SPK type 2 and 3."},{"id":271,"pagetitle":"Low-level API","title":"SPK Type 15","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-15","content":" SPK Type 15"},{"id":272,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader15","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader15","content":" Ephemerides.SPKSegmentHeader15  —  Type SPKSegmentHeader15 <: AbstractSPKHeader Header instance for SPK segments of type 15. Fields epoch  – Epoch of periapsis  tp  – Trajectory pole, i.e., vector parallel to the angular momentum of the orbit pv  – Central body north pole unit vector  pa  – Periapsis unit vector at epoch  p  – Semi-latus rectum  ecc  – Eccentricity  j2f  – J2 processing flag  vj2  – J2 validation flag, true if the orbit shape is compliant with J2 pertubations. GM  – Central body gravitational constant (km³/s²) J2  – Central body J2  R  – Central body radius (km) dmdt  – Mean anomaly rate of change (rad/s) kn  – Gain factor for the regression of the nodes  kp  – Gain factor for the precession of the pericenter source"},{"id":273,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType15","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType15","content":" Ephemerides.SPKSegmentType15  —  Type SPKSegmentType15 <: AbstractSPKSegment Segment instance for SPK segments of type 15. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source Note The cache of SPK Type 15 segments is made of  Ephemerides.TwoBodyUniversalCache  objects."},{"id":274,"pagetitle":"Low-level API","title":"SPK Type 17","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-17","content":" SPK Type 17"},{"id":275,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader17","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader17","content":" Ephemerides.SPKSegmentHeader17  —  Type SPKSegmentHeader17 <: AbstractSPKHeader Header instance for SPK segments of type 17. Fields epoch : epoch of periapsis (s) sma : semi-major axis (km) h : H term of the equinoctial elements k : K term of the equinoctial elements  lon : mean longitude at epoch (rad) p : P term of the equinoctial elements  q : Q term of the equinoctial elements  dlpdt : rate of longitude of the periapse (rad/s) dmldt : mean longitude rate (mean motion rate), (rad/s) dnodedt : longitude of the ascending node rate (rad/s) ra : equatorial pole right ascension (rad) de : equatorial pole declination (rad) R : Rotation matrix from planetary equator to inertial reference frame source"},{"id":276,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType17","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType17","content":" Ephemerides.SPKSegmentType17  —  Type SPKSegmentType17 <: AbstractSPKSegment Segment instance for SPK segments of type 17. Fields head  – Segment header  Note SPK segments of type 17 do not require a cache because they do not extract any  additional coefficients at runtime. References SPK Required Reading SPICE Toolkit source Note SPK segments of type 17 do not require a cache structure."},{"id":277,"pagetitle":"Low-level API","title":"SPK Type 18 and 19","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-18-and-19","content":" SPK Type 18 and 19"},{"id":278,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader18","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader18","content":" Ephemerides.SPKSegmentHeader18  —  Type SPKSegmentHeader18 <: AbstractSPKHeader Header instance for SPK segments of type 18. Fields n  –  Int  number of states in the segment ndirs  –  Int  number of epoch directories epochs  – Storage for directory epochs or epochs (when ndirs = 0) iaa  -  Int  initial segment file address  etid  –  Int  initial address for the epoch table (after all the state data) order  –  Int  interpolating polynomial degree N  –  Int  group size  subtype  –  Int  type 18 subtype, either 0 (Hermite) or 1 (Lagrange) packetsize  –  Int  packet size for each point, either 12 (Hermite) or 6 (Lagrange) source"},{"id":279,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache18","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache18","content":" Ephemerides.SPKSegmentCache18  —  Type SPKSegmentCache18 <: AbstractSPKCache Cache instance for SPK segments of type 18. Fields p  – Vector storing indexes of the first and last points as well as the window size. epochs  – Epochs of the interpolating points.  states  – Matrix storing the states of the interpolating points.  buff  – Buffers to compute the interpolating polynomials. source"},{"id":280,"pagetitle":"Low-level API","title":"Ephemerides.reset_indexes!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.reset_indexes!","content":" Ephemerides.reset_indexes!  —  Function reset_indexes!(cache::SPKSegmentCache18) Reset the cache indexes to force the coefficients reload. source"},{"id":281,"pagetitle":"Low-level API","title":"Ephemerides.update_header!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.update_header!","content":" Ephemerides.update_header!  —  Function update_header!(head::SPKSegmentHeader18, daf::DAF, iaa, faa, type) Update the header of type 18 segments. source"},{"id":282,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader19","content":" Ephemerides.SPKSegmentHeader19  —  Type SPKSegmentHeader19 <: AbstractSPKHeader Header instance for SPK segments of type 19. Fields n  –  Int  number of states in the segment. ndirs  –  Int  number of epoch directories. times  – Storage for interval directories or start times (when ndirs = 0). iaa  -  Int  initial segment file address. etid  –  Int  byte address for the interval table (after all the minisegment data). ptid  –  Int  byte for the pointer table. usefirst  –  Bool  boundary flag, true if the preceding segment should be used. type  –  Int  either type 18 or 19. source"},{"id":283,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache19","content":" Ephemerides.SPKSegmentCache19  —  Type SPKSegmentCache19 <: AbstractSPKCache Cache instance for SPK segments of type 19. Fields minihead  – Header with the mini-segment properties. minidata  – Cache for the mini-segment. id  – Index of the currently loaded mini-segment. source"},{"id":284,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType19","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType19","content":" Ephemerides.SPKSegmentType19  —  Type SPKSegmentType19 <: AbstractSPKSegment Segment instance for SPK segments of type 18 and 19. Type 18 segments are treated as  special cases of a type 19 with a single mini-segment. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":285,"pagetitle":"Low-level API","title":"Ephemerides.find_minisegment","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.find_minisegment","content":" Ephemerides.find_minisegment  —  Function find_minirecord(daf::DAF, head::SPKSegmentHeader19, time::Number) source"},{"id":286,"pagetitle":"Low-level API","title":"Ephemerides.load_minisegment!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.load_minisegment!","content":" Ephemerides.load_minisegment!  —  Function load_minisegment!(daf::DAF, head::SPKSegmentHeader19, cache::SPKSegmentCache19, index::Int) source Note SPK segments of type 18 are the only ones that do not posses a dedicated SPK segment type structure, because they are treated as special cases (i.e., single minisegments) of the type 19."},{"id":287,"pagetitle":"Low-level API","title":"SPK Type 20","ref":"/Ephemerides/stable/api/lapi/#SPK-Type-20","content":" SPK Type 20"},{"id":288,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentHeader20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentHeader20","content":" Ephemerides.SPKSegmentHeader20  —  Type SPKSegmentHeader20 <: AbstractSPKHeader Header instance for SPK segments of type 20. Fields dscale  –  Float64  length conversion factor tscale  –  Float64  time conversion factor tstart  –  Float64  initial epoch of the first record, in seconds since J2000 tlen  –  Float64  interval length covered by each record, in seconds recsize  –  Int  byte size of each logical record order  –  Int  polynomial order  N  –  Int  number of coefficients in each window n  –  Int  number of records in the segment iaa  –  Int  initial segment file address source"},{"id":289,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentCache20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentCache20","content":" Ephemerides.SPKSegmentCache20  —  Type SPKSegmentCache20 <: AbstractSPKCache Cache instance for SPK segments of type 20. Fields id  – Index of the currently loaded logical record p  – Stores the record position constants A  – Chebyshev's polynomial coefficients, with size (ncomp, order) buff  – Stores the buffers for the Chebyshev polynomials source"},{"id":290,"pagetitle":"Low-level API","title":"Ephemerides.SPKSegmentType20","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.SPKSegmentType20","content":" Ephemerides.SPKSegmentType20  —  Type SPKSegmentType2 <: AbstractSPKSegment Segment instance for SPK segments of type 20, which contain Chebyshev polynomial coefficients  for the position and/or state of the body as function of time. This data type is normally  used for planet barycenters, and for satellites whose ephemerides are integrated. Fields head  – Segment header  cache  – Segment cache  References SPK Required Reading SPICE Toolkit source"},{"id":291,"pagetitle":"Low-level API","title":"SPK Utility Functions","ref":"/Ephemerides/stable/api/lapi/#SPK-Utility-Functions","content":" SPK Utility Functions"},{"id":292,"pagetitle":"Low-level API","title":"Ephemerides.normalise_time","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.normalise_time","content":" Ephemerides.normalise_time  —  Function normalise_time(cache::SPKSegmentCache2, time::Number) Transform  time  in an interval between [-1, 1] for compliance with Chebyshev polynomials. source normalise_time(head::SPKSegmentHeader8, time::Number, index::Int) Returned a normalised time that starts at 1 at the beginning of the interval. source normalise_time(head::SPKSegmentHeader20, time::Number, index::Int) source"},{"id":293,"pagetitle":"Low-level API","title":"Ephemerides.find_logical_record","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.find_logical_record","content":" Ephemerides.find_logical_record  —  Function find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number) source find_logical_record(head::SPKSegmentHeader2, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader5, time::Number) source find_logical_record(head::SPKSegmentHeader8, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader1, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader14, time::Number) source find_logical_record(daf::DAF, head::SPKSegmentHeader18, time::Number) source find_logical_record(head::SPKSegmentHeader20, time::Number) source"},{"id":294,"pagetitle":"Low-level API","title":"Ephemerides.get_coefficients!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_coefficients!","content":" Ephemerides.get_coefficients!  —  Function get_coefficients!(daf::DAF, head::SPKSegmentHeader1, cache::SPKSegmentCache1, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader2, cache::SPKSegmentCache2, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader5, cache::SPKSegmentCache5, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader8, cache::SPKSegmentCache8, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader9, cache::SPKSegmentCache9, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader14, cache::SPKSegmentCache14, index::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader18, cache::SPKSegmentCache18, first::Int, last::Int) source get_coefficients!(daf::DAF, head::SPKSegmentHeader20, cache::SPKSegmentCache20, index::Int) source"},{"id":295,"pagetitle":"Low-level API","title":"Interpolating Functions","ref":"/Ephemerides/stable/api/lapi/#Interpolating-Functions","content":" Interpolating Functions"},{"id":296,"pagetitle":"Low-level API","title":"Caches","ref":"/Ephemerides/stable/api/lapi/#Caches","content":" Caches"},{"id":297,"pagetitle":"Low-level API","title":"Ephemerides.InterpCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.InterpCache","content":" Ephemerides.InterpCache  —  Type InterpCache{T} source"},{"id":298,"pagetitle":"Low-level API","title":"Ephemerides.get_buffer","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.get_buffer","content":" Ephemerides.get_buffer  —  Function get_buffer(c::InterpCache, idx::int, x::Number) Return the  idx -th buffer from the corresponding  DiffCache  depending on the type of  x .  source"},{"id":299,"pagetitle":"Low-level API","title":"Chebyshev Polynomials","ref":"/Ephemerides/stable/api/lapi/#Chebyshev-Polynomials","content":" Chebyshev Polynomials"},{"id":300,"pagetitle":"Low-level API","title":"Ephemerides.chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.chebyshev","content":" Ephemerides.chebyshev  —  Function chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, ibuff::Int) Evaluate a sum of Cheybyshev polynomials of the first kind at  t  using a  recursive algorithm. It simultenously evalutes the 3 state components.  idx  is the  index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  ∂chebyshev ,  ∂²chebyshev  and  ∂³chebyshev source"},{"id":301,"pagetitle":"Low-level API","title":"Ephemerides.∂chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂chebyshev","content":" Ephemerides.∂chebyshev  —  Function ∂chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its derivative at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂²chebyshev  and  ∂³chebyshev source"},{"id":302,"pagetitle":"Low-level API","title":"Ephemerides.∂²chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²chebyshev","content":" Ephemerides.∂²chebyshev  —  Function ∂²chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its two derivatives at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂chebyshev  and  ∂³chebyshev source"},{"id":303,"pagetitle":"Low-level API","title":"Ephemerides.∂³chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂³chebyshev","content":" Ephemerides.∂³chebyshev  —  Function ∂³chebyshev(cache::InterpCache, cₖ, t::Number, idx::Int, N::Int, Δt, ibuff=1) Evaluate a sum of Cheybyshev polynomials of the first kind and its three derivatives at  t   using a recursive algorithm. It simultenously evalutes the 3 state components.  idx   is the index of the starting row (in 0-based notation) in the matrix of coefficients  cₖ .  ibuff  is the index of the first free buffer.  Note x  is a re-work of the actual ascissa value that lies between [-1, 1] See Also See also  chebyshev ,  ∂chebyshev  and  ∂²chebyshev source"},{"id":304,"pagetitle":"Low-level API","title":"Ephemerides.∫chebyshev","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∫chebyshev","content":" Ephemerides.∫chebyshev  —  Function ∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀) Evaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. It assumes the Chebyshev polynomials  up to degree N have already been computed and are stored in the buffer with index  ibuff .   tlen  is the size of the record interval,  Δt  is the timescale factor, and  p₀  is a  vector containing the position coefficients at the midpoint (i.e., when the integral is  evaluated at t = 0). Note x  is a re-work of the actual ascissa value that lies between [-1, 1] source ∫chebyshev(cache::InterpCache, cₖ, t::Number, N::Int, Δt, tlen, p₀) Evaluate the integral of a sum of Cheybyshev polynomials of the first kind using a recursive  algorithm. It simultenously evalutes the 3 state components. This function simultaneously  computes both the Chebyshev polynomials as well as their integrals. source"},{"id":305,"pagetitle":"Low-level API","title":"Lagrange Polynomials","ref":"/Ephemerides/stable/api/lapi/#Lagrange-Polynomials","content":" Lagrange Polynomials"},{"id":306,"pagetitle":"Low-level API","title":"Ephemerides.lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.lagrange","content":" Ephemerides.lagrange  —  Function lagrange(cache::InterpCache, states, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial at  x  by using Neville's algorithm. This  function is valid only for equally-spaced polynomials.  idx  is the index of the desired  state and  N  is the number of coefficients of the polynomial.  Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  ∂lagrange  and  ∂²lagrange . source lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial at  x  by using Neville's algorithm. This  function handles unequally-spaced polynomials, where the coefficients in  states  are  interpolated at  epochs . source"},{"id":307,"pagetitle":"Low-level API","title":"Ephemerides.∂lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂lagrange","content":" Ephemerides.∂lagrange  —  Function ∂lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Recursively evaluate a Lagrange polynomial and its derivative at  x  by using  Neville's algorithm. This function is valid only for equally-spaced polynomials.  idx   is the index of the desired state,  N  is the number of coefficients of the polynomial and   Δt is the length of the polynomial interval Note x  is a re-work of the actual ascissa value that starts at 1 See Also See also  lagrange  and  ∂²lagrange source ∂lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial and its derivative at  x  by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in  states  are interpolated at  epochs . source"},{"id":308,"pagetitle":"Low-level API","title":"Ephemerides.∂²lagrange","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²lagrange","content":" Ephemerides.∂²lagrange  —  Function ∂²lagrange(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Recursively evaluate a Lagrange polynomial and its two derivatives at  x  by using  Neville's algorithm. This function is valid only for equally-spaced polynomials.  idx   is the index of the desired state,  N  is the number of coefficients of the polynomial and   Δt is the length of the polynomial interval Note x  is a re-work of the actual ascissa value that starts at 1 See Also See also  lagrange  and  ∂lagrange source ∂²lagrange(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Recursively evaluate a Lagrange polynomial and its two derivatives at  x  by using  Neville's algorithm. This function handles unequally-spaced polynomials, where the  coefficients in  states  are interpolated at  epochs . See Also See also  lagrange  and  ∂lagrange source"},{"id":309,"pagetitle":"Low-level API","title":"Hermite Polynomials","ref":"/Ephemerides/stable/api/lapi/#Hermite-Polynomials","content":" Hermite Polynomials"},{"id":310,"pagetitle":"Low-level API","title":"Ephemerides.hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.hermite","content":" Ephemerides.hermite  —  Function hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial at  x  using a recursive algorithm. This function is valid  only for equally-spaced polynomials.  idx  is the index of the desired state,  N   is the number of coefficients of the polynomial and  Δt  is the length of the polynomial  interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  ∂hermite ,  ∂²hermite  and  ∂³hermite . source hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial at  x  using a recursive algorithm. This function handles  unequally-spaced polynomials, where the coefficients in  states  are interpolated  at  epochs . source"},{"id":311,"pagetitle":"Low-level API","title":"Ephemerides.∂hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂hermite","content":" Ephemerides.∂hermite  —  Function ∂hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its derivative at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂²hermite  and  ∂³hermite . source ∂hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its derivative at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":312,"pagetitle":"Low-level API","title":"Ephemerides.∂²hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂²hermite","content":" Ephemerides.∂²hermite  —  Function ∂²hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its two derivatives at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂hermite  and  ∂³hermite . source ∂²hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its two derivatives at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":313,"pagetitle":"Low-level API","title":"Ephemerides.∂³hermite","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.∂³hermite","content":" Ephemerides.∂³hermite  —  Function ∂³hermite(cache::InterpCache, states, x, idx::Int, N::Int, Δt::Number) Evalute a Hermite polynomial and its three derivatives at  x  using a recursive algorithm.  This function is valid only for equally-spaced polynomials.  idx  is the index of the  desired state,  N  is the number of coefficients of the polynomial and  Δt  is the length  of the polynomial interval. Note x  is a re-work of the actual ascissa value that starts at 1  See Also See also  hermite ,  ∂hermite  and  ∂²hermite . source ∂³hermite(cache::InterpCache, states, epochs, x, idx::Int, N::Int) Evalute a Hermite polynomial and its three derivatives at  x  using a recursive algorithm.  This function handles unequally-spaced polynomials, where the coefficients in  states   are interpolated at  epochs . source"},{"id":314,"pagetitle":"Low-level API","title":"Introspection","ref":"/Ephemerides/stable/api/lapi/#Introspection","content":" Introspection"},{"id":315,"pagetitle":"Low-level API","title":"Ephemerides.AbstractEphemRecord","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.AbstractEphemRecord","content":" Ephemerides.AbstractEphemRecord  —  Type AbstractEphemRecord Abstract type for ephemeris segment records. source"},{"id":316,"pagetitle":"Low-level API","title":"Ephemerides.initial_times","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.initial_times","content":" Ephemerides.initial_times  —  Function initial_times(record::AbstractEphemRecord) Recover the initial times of each sub-window in which the ephemeris data of  record  is  defined, expressed in TDB seconds since J2000 source"},{"id":317,"pagetitle":"Low-level API","title":"Ephemerides.final_times","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.final_times","content":" Ephemerides.final_times  —  Function final_times(record::AbstractEphemRecord) Recover the final times of each sub-window in which the ephemeris data of  record  is  defined, expressed in TDB seconds since J2000 source"},{"id":318,"pagetitle":"Low-level API","title":"Ephemerides.analyse_timespan","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.analyse_timespan","content":" Ephemerides.analyse_timespan  —  Function analyse_timespan(records) Analyse a set of  AbstractEphemRecord , returning the minimum and maximum covered  times, in TDB seconds since J2000, together with a continuity parameter. References CALCEPH  C++ library See Also See also  ephem_spk_timespan  and  ephem_pck_timespan . source"},{"id":319,"pagetitle":"Low-level API","title":"TwoBody Routines","ref":"/Ephemerides/stable/api/lapi/#TwoBody-Routines","content":" TwoBody Routines"},{"id":320,"pagetitle":"Low-level API","title":"Ephemerides.TwoBodyUniversalCache","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.TwoBodyUniversalCache","content":" Ephemerides.TwoBodyUniversalCache  —  Type TwoBodyUniversalCache A container to store precomputed quantities required for the two-body propagation based on  universal variables. Only the quantities that depend on the initial state are computed. source"},{"id":321,"pagetitle":"Low-level API","title":"Ephemerides.update_cache!","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.update_cache!","content":" Ephemerides.update_cache!  —  Function update_cache!(c::TwoBodyUniversalCache) Update the precomputed values in the cache using the position and velocity in  c . source"},{"id":322,"pagetitle":"Low-level API","title":"Ephemerides.propagate_twobody","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.propagate_twobody","content":" Ephemerides.propagate_twobody  —  Function propagate_twobody(cache::TwoBodyUniversalCache, Δt::Number) Propagate the state vector in  cache  of  Δt  using the universal variables formulation for  Kepler's Equation and the Lagrange coefficients f and g. Note This routine is valid for any type of orbit and uses a bisection method to find the  root of the universal variables Kepler's equation. The algorithm has been directly  taken from the SPICE toolkit  prob2b.f . References SPICE Toolkit source"},{"id":323,"pagetitle":"Low-level API","title":"Ephemerides.stumpff","ref":"/Ephemerides/stable/api/lapi/#Ephemerides.stumpff","content":" Ephemerides.stumpff  —  Function stumpff(x::Number, p::AbstractVector) Compute Stumpff's functions from C₀ up to C₃ at  x .  Note This routine uses the trigonometrical expressions of the functions when the absolute  value of  x  is greater or equal to 1. If that is not the case, the C₂ and C₃ functions  are computed from a truncated expression of the Maclaurin series at order 11, which  guarantees a higher precision and avoid overflow errors when  x  is null. References SPICE Toolkit source"},{"id":326,"pagetitle":"Benchmarks","title":"Performance Benchmarks","ref":"/Ephemerides/stable/benchmarks/#Performance-Benchmarks","content":" Performance Benchmarks The performance of this package have been tested against both CALCEPH and SPICE, two of the most-popular open-source ephemeris readers used in the space industry. The results show that  Ephemerides.jl  largely outperforms SPICE as well as CALCEPH for most SPK segment types. For example, for state vector computations (i.e., position and velocity) the mean execution times are the following: Additionally, it is better optimised to compute higher order derivatives (i.e., acceleration and jerk) with respect to CALCEPH.  Note These time benchmarks have been obtained on an Intel Core i7-6700 CPU @ 3.40 GHz with 16 GB of RAM"},{"id":329,"pagetitle":"Kernels Inspection","title":"Kernels Inspection","ref":"/Ephemerides/stable/tutorials/inspect/#Kernels-Inspection","content":" Kernels Inspection This tutorial will walk you through the basic features and interfaces that allow you to inspect the properties of binary ephemeris kernels."},{"id":330,"pagetitle":"Kernels Inspection","title":"Available Times","ref":"/Ephemerides/stable/tutorials/inspect/#Available-Times","content":" Available Times"},{"id":331,"pagetitle":"Kernels Inspection","title":"Timescale","ref":"/Ephemerides/stable/tutorials/inspect/#Timescale","content":" Timescale SPK and PCK segments support two types of ephemeris timescales, namely, TDB and TCB. The timescale of the loaded kernels can be retrieved as follows:  using Ephemerides \n\n# Load the kernel\neph = EphemerisProvider(\"kernel.bsp\")\n\n# Retrieve the ID of the kernel timescales\nid = ephem_timescale_id(eph) The retrieved ID is 1 for TDB and 2 for TCB. A value of -1 is returned if the kernels are empty.  Note Only one timescale is admissed within a single  EphemerisProvider  object, "},{"id":332,"pagetitle":"Kernels Inspection","title":"Timespan","ref":"/Ephemerides/stable/tutorials/inspect/#Timespan","content":" Timespan To retrieve the first and last available time in the ephemeris files associated to a provider  object, two functions are available to distinguish between SPK and PCK data:  ephem_spk_timespan(eph)\nephem_pck_timespan(eph) where  eph  is an  EphemerisProvider  instance. Both functions return the minimum and maximum available time in TDB seconds since J2000, as well as a continuity parameter defined as follows:  0  no SPK or PCK data is available. 1  the quantities of all bodies are available for any time between the first and last time. 2  the quantities of some bodies are available on discontinuous time intervals between the    first and last time. 3  the quantities of each body are available on a continuous time interval between the first    and the last time, but not available for any time between the first and last time."},{"id":333,"pagetitle":"Kernels Inspection","title":"Available Points and Axes","ref":"/Ephemerides/stable/tutorials/inspect/#Available-Points-and-Axes","content":" Available Points and Axes To retrieve the list of NAIF IDs with the points or axes that have available ephemeris data, these function should be called on an  EphemerisProvider  instance: ephem_get_points(eph)\nephem_get_axes(eph)"},{"id":334,"pagetitle":"Kernels Inspection","title":"Segment Records","ref":"/Ephemerides/stable/tutorials/inspect/#Segment-Records","content":" Segment Records Position and orientation metadata relative to the records loaded in the ephemeris kernels can be retrieved with the following two functions, respectively: ephem_spk_records(eph)\nephem_pck_records(eph) Both functions return a vector of  Ephemerides.EphemRecordSPK  or  Ephemerides.EphemRecordPCK  ordered by priority, i.e., they use the highest priority records when there are multiple records that could satisfy the same target, center pair for a given epoch. In particular SPK records contain the following information:  target: NAIF ID of the target object center: NAIF ID of the center object axes: NAIF ID of the reference axes t_start: start times of each sub-window, in TDB seconds since J2000 t_end: final times of each sub-window, in TDB seconds since J2000 Similarly, PCK records contain these information: target: NAIF ID of the target axes center: NAIF ID of the reference axes t_start: start times of each sub-window, in TDB seconds since J2000 t_end: final times of each sub-window, in TDB seconds since J2000 For PCK records, the reference axes ID is set into the  center  field. Please notice that whenever a gap between the data of a given pair of (center, target) objects is present,  t_start  and  t_end  will store the start and end times of each window with available data, respectively."},{"id":337,"pagetitle":"Loading Kernels","title":"Loading Kernels","ref":"/Ephemerides/stable/tutorials/load/#Loading-Kernels","content":" Loading Kernels This tutorial will walk you through the basic features and interfaces that allow you to load binary ephemeris kernels. The supported sources of ephemerides are currently limited to binary PCK and SPK segments of type: 1, 2, 3, 5, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, and 21.  Note Support for IMCCE INPOP ephemerides is yet to be implemented. Before retrieving position and orientation data of celestial objects, the user is first required to load the ephemerides files into an  EphemerisProvider  object.  using Ephemerides \n\n# Load a single ephemeris file \neph1 = EphemerisProvider(\"kernel1.bsp\")\n\n# Load multiple ephemeris files simultaneously\neph2 = EphemerisProvider([\"kernel1.bsp\", \"kernel2.bsp\"]) You must specify the relative or absolute path(s) of the file(s) to load. Either one or multiple ephemeris files can be simultaneously loaded into a single  EphemerisProvider  object. However,  once a provider has been created, no more kernels can be loaded inside it. "},{"id":340,"pagetitle":"Reading Ephemeris Data","title":"Reading Ephemeris Data","ref":"/Ephemerides/stable/tutorials/position/#Reading-Ephemeris-Data","content":" Reading Ephemeris Data This tutorials will walk you through the basic features and interfaces that allow you to compute translation and orientation data from binary ephemeris kernels."},{"id":341,"pagetitle":"Reading Ephemeris Data","title":"Computing state vectors","ref":"/Ephemerides/stable/tutorials/position/#Computing-state-vectors","content":" Computing state vectors Ephemerides.jl  allows the computation of a relative position between two points and its higher order derivatives up to order 3 (i.e., velocity, acceleration and jerk). All these computations are natively  thread-safe and compatible with Automatic Differentiation (AD) with respect to time via  ForwardDiff.jl . In particular, the following methods are available to compute translation data:  ephem_vector3(eph, from, to, time)\nephem_vector6(eph, from, to, time)\nephem_vector9(eph, from, to, time)\nephem_vector12(eph, from, to, time) They all share the same interface, requiring an  EphemerisProvider  object as the first input.  from  and  to  are integer numbers representing the ID of the center and target points that we desired. The  time  argument is expressed in TDB seconds since J2000.0. Note Differently, from traditional ephemerides readers,  Ephemerides.jl  is only meant to read the data stored in the binary kernels and it does not perform any concatenation of state vectors. This means that if data from point 399 is expressed with respect to point 3, we will only be able to compute the relative position of 339 with respect to 3 or viceversa, but not of 399 with respect to another point. The reason behind this is that  Ephemerides.jl  is meant to be used in combination with  FrameTransformations.jl , which already enables tranformations between different user-defined point and axes. An example to compute the position of the Moon (399) with respect to the Earth-Moon Barycenter (3) at J2000 (time = 0), is the following:  using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_de440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\npos = ephem_vector3(eph, 3, 399, 0) Instead, if one desires the whole state vector, up to the jerk components, the functions become:  # Compute position and velocity \npv = ephem_vector6(eph, 3, 399, 0)\n\n# Compute position, velocity and acceleration\npva = ephem_vector9(eph, 3, 399, 0)\n\n# Compute position, velocity, acceleration and jerk\npvaj = ephem_vector12(eph, 3, 399, 0) In all these examples, the returned data is always in the form of a  StaticArray  in order to minimise memory allocations. Warning SPK segments of types 1 5, 15, 17 and 21 do not natively support acceleration and jerk computations. However, these values can be computed by Automatic Differentiation (AD) of the position and/or velocity components."},{"id":342,"pagetitle":"Reading Ephemeris Data","title":"Computing orientation angles","ref":"/Ephemerides/stable/tutorials/position/#Computing-orientation-angles","content":" Computing orientation angles Similarly to position components,  Ephemerides.jl  also allows the computation of orientation angles and their derivatives up to order 3. All these computations are natively thread-safe and compatible with Automatic Differentiation (AD) with respect to time via  ForwardDiff.jl . In particular, the following methods are available to compute orientation data:  ephem_rotation3(eph, from, to, time)\nephem_rotation6(eph, from, to, time)\nephem_rotation9(eph, from, to, time)\nephem_rotation12(eph, from, to, time) Again, they all share the same interface, requiring an  EphemerisProvider  object as the first input.  from  and  to  are integer numbers representing the ID of the reference and target axes that we desired. The  time  argument is expressed in TDB seconds since J2000.0. An example to compute the Euler angles of the PA440 axes (31008) with respect to the ICRF (1) at J2000 (time = 0), is the following:  using Ephemerides\n\n# Load an ephemeris kernel containing the requested data\nkernel = \"path_to_pa440\"\neph = EphemerisProvider(kernel)\n\n# Compute the position\nang = ephem_rotation3(eph, 1, 31008, 0) Instead, if one desires the whole vector, up to the 3rd order derivative, the functions become:  # Compute angles and derivatives \npv = ephem_rotation6(eph, 1, 31008, 0)\npva = ephem_rotation9(eph, 1, 31008, 0)\npvaj = ephem_rotation12(eph, 1, 31008, 0) The returned orientation data is always in the form of a  StaticArray  in order to minimise memory allocations. Note Differently from the translational data contained in SPK kernels, the orientation angles can only be computed in one direction, i.e., if the orientation of the Moon's Principal Axes (PA) is defined with respect to the ICRF, it is not possible to compute the rotation from the PA to the ICRF with this routine. "},{"id":345,"pagetitle":"Home","title":"CalcephEphemeris.jl API","ref":"/CalcephEphemeris/stable/#CalcephEphemeris.jl-API","content":" CalcephEphemeris.jl API A lightweight CALCEPH wrapper for the JSMD ecosystem. This package is a lightweight wrapper around  CALCEPH_jll.jl  that implements the  JSMDInterfaces.jl  interfaces to extract data from SPICE and INPOP ephemeris kernels.  The CALCEPH is a C++ library written by the research team Astronomie et systèmes dynamiques  (CNRS/Observatoire de Paris/IMCCE). For further information on CALCEPH visit its   official website . Inspiration for this package has been taken from the original Julia's  CALCEPH.jl   wrapper."},{"id":346,"pagetitle":"Home","title":"Installation","ref":"/CalcephEphemeris/stable/#Installation","content":" Installation This package can be installed using Julia's package manager: julia> import Pkg; \n\njulia> Pkg.add(\"CalcephEphemeris.jl\")"},{"id":349,"pagetitle":"API","title":"API","ref":"/CalcephEphemeris/stable/api/#API","content":" API This package implements all of the required JSMD Interfaces for Ephemeris files, which  are already well-documented in  JSMDInterfaces ."},{"id":350,"pagetitle":"API","title":"CalcephEphemeris.CalcephProvider","ref":"/CalcephEphemeris/stable/api/#CalcephEphemeris.CalcephProvider","content":" CalcephEphemeris.CalcephProvider  —  Type CalcephProvider(file::String)\nCalcephProvider(files::Vector{String}) Create a  CalcephProvider  instance by loading a single or multiples ephemeris kernel  files specified by  files . Note Once the object is created kernels cannot be added nor removed from the  generated  CalcephProvider  instance.   Example julia> eph1 = CalcephProvider(\"PATH_TO_KERNEL\")\n1-kernel CalcephProvider\n \"PATH_TO_KERNEL\"\n\njulia> eph2 = CalcephProvider([\"PATH_TO_KERNEL_1\", \"PATH_TO_KERNEL_2\"])\n2-kernel CalcephProvider:\n \"PATH_TO_KERNEL_1\"\n \"PATH_TO_KERNEL_2\" source"},{"id":353,"pagetitle":"Home","title":"Welcome to FrameTransformations.jl!","ref":"/FrameTransformations/stable/#Welcome-to-FrameTransformations.jl!","content":" Welcome to FrameTransformations.jl! A modern, high-performance and comprehensive set of tools for transformations between any standard and user-defined reference frame. Are you in search of fundamental routines for efficient and extensible frames transformations?   If so, this package is the ideal starting point. FrameTransformations.jl is designed to  provide users with  the ability to create a customized, efficient, flexible, and  extensible axes/point graph models for mission analysis and space mission design purposes. "},{"id":354,"pagetitle":"Home","title":"Features","ref":"/FrameTransformations/stable/#Features","content":" Features Convert between different time scales and representations (via  Tempo.jl ); Read binary ephemeris files (via  Ephemerides.jl  or  CalcephEphemeris.jl ) Create custom reference frame systems with both standard and user-defined points and axes. Transform states and their higher-order derivatives between different frames (up to jerk) All of this seamlessly integrated with  ForwardDiff.jl ."},{"id":355,"pagetitle":"Home","title":"Installation","ref":"/FrameTransformations/stable/#Installation","content":" Installation This package can be installed using Julia's package manager:  julia> import Pkg\n\njulia> Pkg.add(\"FrameTransformations.jl\");"},{"id":358,"pagetitle":"CR3BP","title":"Use Case: CR3BP","ref":"/FrameTransformations/stable/Examples/gen/e01_cr3bp/#example_01_cr3bp","content":" Use Case: CR3BP This example was generated on 2024-01-05T20:08:57.819. The power of the  FrameSystem  is its capability to handle axes transformations and point translations of both high-accuracy and simplified models. The use-case here presented includes the case of the Circular-Restricted Three-Body Problem (CR3BP) rotating frame transformation handling. In particular, when dealing with the  CR3BP , mission analysis are used to exploit non-dimensional, rotating coordinates to express the equations of motion and perform the computations. In this tutorial, we create a  FrameSystem  to handle transformations within the Earth-Moon CR3BP, which is characterized by a mass ratio of approximately  μ = 0.012 . We start off by creating a frame system without any ephemeris provider, since we are using a simplified model. using FrameTransformations\n\nCR3BP = FrameSystem{2, Float64}() FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n)\n As always, the first step requires the definition of the root axes and points. In this case, we use the a generic set of  inertial axes  and the Earth-Moon Barycenter (EMB). @axes InertialAx 1 InertialFrame\n\nadd_axes_inertial!(CR3BP, InertialAx)\n\n@point EMBc 1 EarthMoonBarycenterCr3bp\n\nadd_point_root!(CR3BP, EMBc, InertialAx) We now proceed to add our synodic axes: in the CR3BP these are uniformly rotating with respect to the  InertialAx  about the Z-axis. Therefore, we leverage the  rotating axes  type: using ReferenceFrameRotations\n\nf(t) = angle_to_dcm(t, :Z)\n\n@axes SynodicAx 2 SynodicFrame\n\nadd_axes_rotating!(CR3BP, SynodicAx, InertialAx, f) Note that there is no need to specify the rotation derivatives, as they'll be computed by  automatic differentiation via the  ForwardDiff  package. For performace-critical transformations, however, it is reccomended to manually define these derivatives. Now, let's assume we have our spacecraft. Most likely, its states will be expressed in the synodic frame. In this case, we leverage  updatable points , since we desire to manually update its state at each time. @point Spacecraft -1_900_000\n\nadd_point_updatable!(CR3BP, Spacecraft, EMBc, SynodicAx) We know assume that at  t = 0.8  our spacecraft is at L4, therefore we update its state accordingly: μ = 0.012\nxL4 = [1/2-μ, sqrt(3)/2, 0.0, 0.0, 0.0, 0.0]\nt = 0.8\n\nupdate_point!(CR3BP, Spacecraft, xL4, t) Finally we can retrieve the spacecraft state in both the synodic as well as the inertial axes: vector6(CR3BP, EMBc, Spacecraft, SynodicAx, t) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 0.488\n 0.8660254037844386\n 0.0\n 0.0\n 0.0\n 0.0 vector6(CR3BP, EMBc, Spacecraft, InertialAx, t) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -0.28125572411706895\n  0.9534354816406735\n  0.0\n -0.9534354816406735\n -0.28125572411706895\n  0.0 This page was generated using  Literate.jl ."},{"id":361,"pagetitle":"High-Fidelity Earth-Moon Environment","title":"Use Case: High Fidelity","ref":"/FrameTransformations/stable/Examples/gen/e02_hifi/#example_02_hifi","content":" Use Case: High Fidelity This example was generated on 2024-01-05T20:08:57.824. Once the general structure of the  FrameSystem  is understood, we can pass to a use case in which we want to build and exploit our frame system to perform computations in a high-fidelity environment."},{"id":362,"pagetitle":"High-Fidelity Earth-Moon Environment","title":"Frame system setup","ref":"/FrameTransformations/stable/Examples/gen/e02_hifi/#Frame-system-setup","content":" Frame system setup In this example, we plan on using ephemeris data to retrieve accurate positions of the planets and the orientation of certain reference frames. Therefore, we create an ephemeris provider object leveraging our own  Ephemerides.jl  package and use it to generate a frame system instance: using FrameTransformations\nusing Ephemerides\nusing LinearAlgebra\nusing ReferenceFrameRotations\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/de432s.bsp\";\n\neph = EphemerisProvider([download(url_spk), download(url_pck)])\n\nFRAMES = FrameSystem{3, Float64}(eph) FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 2-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n)\n Once the graph is created, we assign the  GCRF  (Geocentric Celestial Reference Frame) as our set of inertial root-axes: @axes GCRF 1 GeocentricCelestialReferenceFrame\n\nadd_axes_inertial!(FRAMES, GCRF) These axes are practically coincident with the  ICRF . In this scenario, we will be working within the Cislunar environment, therefore we will need the major bodies that influence this dynamic regime, i..e, the Earth, the Moon and the Sun. To do so, we also define the Solar System Barycenter (SSB) and the Earth-Moon Barycenter (EMB) as the ephemeris data of the remaining bodies is expressed with respect to those. For this example, we will assume the SSB is our root point: @point SSB 0\n@point EMB 3\n@point Sun 10\n@point Earth 399\n@point Moon 301\n\nadd_point_root!(FRAMES, SSB, GCRF)\nadd_point_ephemeris!(FRAMES, EMB)\nadd_point_ephemeris!(FRAMES, Earth)\nadd_point_ephemeris!(FRAMES, Moon)\nadd_point_ephemeris!(FRAMES, Sun)"},{"id":363,"pagetitle":"High-Fidelity Earth-Moon Environment","title":"Registering body-fixed axes","ref":"/FrameTransformations/stable/Examples/gen/e02_hifi/#Registering-body-fixed-axes","content":" Registering body-fixed axes At this point, we want to be able to transform back and forth from body-fixed axes of the Earth and the Moon to the  GCRF . The Earth and the Moon cases are actually  special cases  because they have both high-accuracy and low-precision body-fixed rotation models. Let's start with the low precision ones:  IAU_EARTH  and  IAU_MOON . To register such frames, we first need to parse a  TPC  file with the required constants: tpc = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/pck00011.tpc\"\niau = load(TPC(download(tpc)));\n\n@axes IAU_EARTH 3\n@axes IAU_MOON 4\n\nadd_axes_bcrtod!(FRAMES, IAU_EARTH, Earth, iau)\nadd_axes_bcrtod!(FRAMES, IAU_MOON, Moon, iau) The registration of this type of axes requires either an alias or the ID of the point associated to the body. For convenience, let us also insert a set of inertial axes for the Moon. This can be done using the IAU-based Body-Centric Inertial J2000 axes available through the  add_axes_bci2000!  function, which defines a rotation from the  ICRF  to the local equatorial plane of the body at the J2000 epoch. @axes LME2000 5\n\nadd_axes_bci2000!(FRAMES, LME2000, Moon, iau); Finally, we complete the axes definition by inserting the high-precision Earth and Lunar body-fixed rotation models. Warning In order to use  IERS  associated reference frames, EOP must be loaded. See also  Orient.prepare_eop ,  Orient.init_eop . url_eop = \"https://datacenter.iers.org/data/csv/finals2000A.data.csv\"\neopfile = \"iau2000a\"\n\nOrient.prepare_eop(download(url_eop), eopfile)\nOrient.init_eop(eopfile * \".eop.dat\") [ Info:  IERS EOP file '/tmp/jl_RKlw9EX4Tw' converted to 'iau2000a.eop.dat'.\n [ Info:  EOP initialized from file 'iau2000a.eop.dat'. For this purpose,  FrameTransformations  provides two  high-level functions that can be used to ease these definitions:  add_axes_itrf!  and  add_axes_pa421! . @axes ITRF 6\n@axes MOONPA_DE421 31006\n\nadd_axes_itrf!(FRAMES, ITRF, GCRF)\nadd_axes_pa421!(FRAMES, MOONPA_DE421) ┌ Warning:  ignoring #223, frame system order is less than 4\n └  @ FrameTransformations.Frames ~/work/FrameTransformations.jl/FrameTransformations.jl/src/Frames/axes.jl:512 The default ITRF model is the  iau2006b , but other approximations are also  available . If one was interested in the Moon's PA440 axes, a similar function named  add_axes_pa440!  is available. Note To correctly use the  add_axes_pa421!  function, the frame system must contain an ephemeris provider that has loaded the necessary PCK kernels with the DE421 data. FRAMES FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 2-kernel EphemerisProvider,\n  points: \t \n\t SSB\n\t  ├── EMB \n\t   ├── Earth \n\t   ├── Moon \n\t  ├── Sun \n\t \n  axes: \t\n\tGCRF\n\t ├── IAU_EARTH \n\t ├── IAU_MOON \n\t ├── LME2000 \n\t ├── ITRF \n\t ├── MOONPA_DE421 \n\t\n)\n To begin exploiting our newly completed frame system, we assumed that our  SC  is on a circular equatorial orbit around the Moon at an altitude of 500 km, so that at the epoch  e , the spacecraft state vector is updated as: @point SC -1_900_000\n\nadd_point_updatable!(FRAMES, SC, Moon, LME2000)\n\ne = Epoch(\"2020-01-01T12:45:30.0 TDB\");\nx = [2274.0, 0.0, 0.0, 0.0, sqrt(4904.87/2274.0), 0.0];\n\nupdate_point!(FRAMES, SC, x, e) Note The timescale used for the  Epoch  must be the same used in the  FrameSystem . At this point, we are completely free to compute the state of the spacecraft with respect to any other point registered in the frame system with respect to any known set of axes at the epoch  e . For example, the state in the  LME2000  is: vector6(FRAMES, Moon, SC, LME2000, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 2274.0\n    0.0\n    0.0\n    0.0\n    1.4686507128813133\n    0.0 The spacecraft state with respect to the Earth in the  GCRF ,  IAU_EARTH  and  ITRF  is instead: vector6(FRAMES, Earth, SC, GCRF, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 401327.3105864163\n -36183.16662923372\n -54688.10779533886\n      0.21054873609459027\n      2.2235437514768055\n      0.9632321086029556 vector6(FRAMES, Earth, SC, IAU_EARTH, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 180191.3156429707\n 360539.43900980003\n -53907.54668349596\n     24.296925172130727\n    -12.133987802430006\n      0.9636312214363585 vector6(FRAMES, Earth, SC, ITRF, e) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n 180632.14381592075\n 360316.9074399868\n -53920.08658587134\n     24.281930057066063\n    -12.16366463518875\n      0.9635795943144946 while the position with respect to the Moon in the  IAU_MOON  and  PA421  axes: vector3(FRAMES, Moon, SC, IAU_MOON, e) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -2265.003321467859\n  -201.71716040981087\n   -12.088876530484503 vector3(FRAMES, Moon, SC, MOONPA_DE421, e) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -2265.0607532005547\n  -201.0240734585426\n   -12.84936576926891 These last examples are intended to show how easily the state of a spacecraft with respect to any other body can be retrieved by properly leveraging the  FrameSystem  and the high-level routines provided by this package. This page was generated using  Literate.jl ."},{"id":366,"pagetitle":"Custom Orbit Representation","title":"Use Case: Custom spacecraft orbit","ref":"/FrameTransformations/stable/Examples/gen/e03_customorb/#example_03_orb","content":" Use Case: Custom spacecraft orbit This example was generated on 2024-01-05T20:08:57.829. Once the general structure of the  FrameSystem  is understood, we can pass to a use case in which we want to build and exploit our frame system to perform computations inserting a custom orbit. This becomes especially crucial in complex cases like Trajectory Optimization and Navigation Analysis. In such scenarios, the trajectory is under design, and the trajectory information might not be completely available. Moreover, in these cases derivatives could be required for various quantities such as time, states, and parameters. In this context, we shall remember that  FrameTransformations  is able to perform operations, including AD, on the frames  independent variable , e.g. only time. A proper orbit representation is essential to avoid perturbation confusion and ensure proper custom orbit handling. For this purpose, two point types can seems suitable:  updatable  and  dynamical  points. In this case, however,  updatable  points are not well-suited as they are essentially constants for the AD system. Then,  dynamical  points can effectively handle this scenario."},{"id":367,"pagetitle":"Custom Orbit Representation","title":"Frame system setup","ref":"/FrameTransformations/stable/Examples/gen/e03_customorb/#Frame-system-setup","content":" Frame system setup First of all, a new  FrameSystem  shall be created. using FrameTransformations\n\nG = FrameSystem{4, Float64}()\n\nadd_axes_inertial!(G, :ICRF, 1)\nadd_point_root!(G, :Earth, 399, 1) Note As the orbit considered in this example is custom, there is no requirement to load ephemeris."},{"id":368,"pagetitle":"Custom Orbit Representation","title":"Custom orbit model","ref":"/FrameTransformations/stable/Examples/gen/e03_customorb/#Custom-orbit-model","content":" Custom orbit model A custom orbit model is then required. In this case two dummy orbits are created and stored in a  CubicSpline  object. using JSMDInterfaces.Math: interpolate\nusing JSMDUtils.Math: InterpCubicSplines\n\nc = 2π/86400\nde = 0:3600:2*86400;\nfv(t) = [cos(c*t), sin(c*t), 0, -c*sin(c*t), c*cos(c*t), 0];\nfv2(t) = [sin(c*t), cos(c*t), 0];\nconst ORB1 = InterpCubicSplines(de, hcat([fv(e) for e in de]...));\nconst ORB2 = InterpCubicSplines(de, hcat([fv2(e) for e in de]...));"},{"id":369,"pagetitle":"Custom Orbit Representation","title":"Custom orbit handling","ref":"/FrameTransformations/stable/Examples/gen/e03_customorb/#Custom-orbit-handling","content":" Custom orbit handling Given the custom orbit model,  add_point_dynamical!  could be used to link it to the frame system. Insert dynamical points add_point_dynamical!(G, :SC1, -1, 399, 1, t->interpolate(ORB1, t)[1:3], t->interpolate(ORB1, t))\nadd_point_dynamical!(G, :SC2, -2, 399, 1, t->interpolate(ORB2, t)) Once in the frame system, AD could be exploited to retrieve states+gradients w.r.t. time in any registered frame: vector12(G, 399, -1, 1, 12345.0) 12-element StaticArraysCore.SVector{12, Float64} with indices SOneTo(12):\n  0.6234251537650443\n  0.7819190317829632\n  0.0\n -5.68627566192454e-5\n  4.533675655396644e-5\n  0.0\n -3.3348312757462196e-9\n -4.123692961414662e-9\n  0.0\n  2.998834146583374e-13\n -2.425157740010603e-13\n  0.0 It is also possible to use the computational graph to compute quantities between completely custom states representations: vector12(G, -1, -2, 1, 12345.0) 12-element StaticArraysCore.SVector{12, Float64} with indices SOneTo(12):\n  0.15849387801791892\n -0.15849387801791892\n -0.0\n  0.0001021927816025746\n -0.00010221185001107677\n -0.0\n -7.888616856684427e-10\n  7.888616856684427e-10\n -0.0\n -5.346755727700305e-13\n  5.845414794974355e-13\n -0.0 This page was generated using  Literate.jl ."},{"id":372,"pagetitle":"Public API","title":"Frames's Public Documentation","ref":"/FrameTransformations/stable/Modules/frames_api/#basic_frames_api","content":" Frames's Public Documentation"},{"id":373,"pagetitle":"Public API","title":"Frame System","ref":"/FrameTransformations/stable/Modules/frames_api/#Frame-System","content":" Frame System"},{"id":374,"pagetitle":"Public API","title":"FrameTransformations.Frames.FrameSystem","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.FrameSystem","content":" FrameTransformations.Frames.FrameSystem  —  Type FrameSystem{O, T, S, E} A  FrameSystem  instance manages a collection of user-defined  FramePointNode  and   FrameAxesNode  objects, enabling efficient computation of arbitrary transformations  between them. It is created by specifying the maximum transformation order  O , the outputs  datatype  T  and an  AbstractTimeScale  instance  S . Additionally, an  AbstractEphemerisProvider   instance  E  can be provided to compute transformations that require ephemeris data.  The following transformation orders are accepted:  1 : position  2 : position and velocity  3 : position, velocity and acceleration 4 : position, velocity, acceleration and jerk By specifying the maximum transformation the  FrameSystem  memory usage and performance can  be optimised and tailored to the user's needs. FrameSystem{O, T}() Create a  FrameSystem  object of order  O  and datatype  T . The  BarycentricDynamicalTime   is automatically assigned as the default time scale. The resulting object is constructed  with a  NullEphemerisProvider , which does not allow the computation of transformation that  involve ephemeris files. Examples julia> F = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> rotation6(F, ICRF, ECLIPJ2000, 0.0)\nRotation{2, Float64}\n[...]\n\njulia> rotation9(F, ICRF, ECLIPJ2000, 0.0)\nERROR: Insufficient frame system order: transformation requires at least order 3.\n FrameSystem{O, T, S}() Create a  FrameSystem  object of order  O , datatype  T  and time scale  S . The resulting  object is constructed with a  NullEphemerisProvider , which does not allow the computation  of transformation that involve ephemeris files. Examples julia> F = FrameSystem{1, Float64, TerrestrialTime}();\n\njulia> @axes ICRF 1 \n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(F, ICRF)\n\njulia> add_axes_eclipj2000!(F, ECLIPJ2000, ICRF)\n\njulia> ep_tt = Epoch(\"2023-02-10T12:00:00 TT\")\n2023-02-10T12:00:00.000 TT\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tt)\nRotation{1,Float64}([...])\n\njulia> ep_tdb = Epoch(\"2023-02-10T12:00:00 TDB\")\n2023-02-10T12:00:00.000 TDB\n\njulia> rotation3(F, ICRF, ECLIPJ2000, ep_tdb)\nERROR: ArgumentError: Incompatible epoch timescale: expected TerrestrialTime, found BarycentricDynamicalTime.\n[...] FrameSystem{O, T}(eph::AbstractEphemerisProvider) Create a  FrameSystem  object of order  O  and datatype  T  by providing an instance of an   AbstractEphemerisProvider  subtype. The timescale is automatically set to the one associated  to the ephemeris files loaded in  eph . This constructor shall be used when the user desires  to compute transformations that involve ephemeris data.  Note All the kernels that will be used must be loaded within  eph . Once the  FrameSystem   has been created, no additional kernel can be added nor removed. Examples julia> using Ephemerides \n\njulia> eph = EphemerisProvider(DE440_KERNEL_PATH);\n\njulia> F = FrameSystem{2, Float64}(eph)\nFrameSystem{2, Float64, BarycentricDynamicalTime, EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n) See also See also  add_axes_inertial! ,  add_point_root! ,  vector3  and  rotation3 source"},{"id":375,"pagetitle":"Public API","title":"Axes","ref":"/FrameTransformations/stable/Modules/frames_api/#Axes","content":" Axes"},{"id":376,"pagetitle":"Public API","title":"FrameTransformations.Frames.@axes","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.@axes","content":" FrameTransformations.Frames.@axes  —  Macro @axes(name, id, type=nothing) Define a new axes instance to alias the given  id . This macro creates an   AbstractFrameAxes  subtype and its singleton instance callen  name . Its type name  is obtained by appending  Axes  to either  name  or  type  (if provided).  Examples julia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> typeof(ICRF)\nInternationalCelestialReferenceFrameAxes\n\njulia> axes_alias(ICRF) \n1\n\njulia> @axes IAU_EARTH 10013\n\njulia> typeof(IAU_EARTH)\nIauEarthAxes See also See also  @point  and  axes_alias . source"},{"id":377,"pagetitle":"Public API","title":"FrameTransformations.Frames.axes_alias","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.axes_alias","content":" FrameTransformations.Frames.axes_alias  —  Function axes_alias(ax::AbstractFrameAxes) Return the axes ID.  source"},{"id":378,"pagetitle":"Public API","title":"FrameTransformations.Frames.is_inertial","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.is_inertial","content":" FrameTransformations.Frames.is_inertial  —  Function is_inertial(frame::FrameSystem, axes::AbstractFrameAxes)\nis_inertial(frame::FrameSystem, axesid::Int) Return true if the given axes are inertial, i.e., non rotating with respect to the root inertial  axes. Note FixedOffsetAxes with respect to an inertial set of axes, are also consired inertial. source"},{"id":379,"pagetitle":"Public API","title":"FrameTransformations.Frames.is_timefixed","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.is_timefixed","content":" FrameTransformations.Frames.is_timefixed  —  Function is_timefixed(frame::FrameSystem, axes::AbstractFrameAxes)\nis_timefixed(frame::FrameSystem, axesid::Int) Return true if the given axes are time-fixed, i.e., their orientation does not change in  time with respect to the root inertial axes.  Note Only  :InertialAxes  and  :FixedOffsetAxes  defined with respect to other inertial axes  are here considered as time fixed.  source"},{"id":380,"pagetitle":"Public API","title":"FrameTransformations.Frames.ComputableAxesVector","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.ComputableAxesVector","content":" FrameTransformations.Frames.ComputableAxesVector  —  Type ComputableAxesVector(from, to, order::Int) Store the properties required to retrieve the i-th order components of a  desired vector. Arguments  from  and  to  are the NAIFIDs or  AbstractFramePoint  instances  that define the observer and target points. Only orders between 1 and 3 are supported. Example julia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> ComputableAxesVector(SSB, Sun, 1)\nComputableAxesVector(0, 10, 1)\n\njulia> ComputableAxesVector(0, 10, 1)\nComputableAxesVector(0, 10, 1) source"},{"id":381,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_bci2000!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_bci2000!","content":" FrameTransformations.Frames.add_axes_bci2000!  —  Function add_axes_bci2000!(frames, axes::AbstractFrameAxes, center, data) Add  axes  as a set of Body-Centered Inertial (BCI) axes at J2000 relative to the  frames   system. The center point (i.e., the reference body) is  center  and can either be the point  ID or an  AbstractFramePoint  instance.  data  is a dictionary containing a parsed   TPC  file.  Warning The parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in  frames , an error is thrown. add_axes_bci2000!(frames, name::Symbol, axesid::Int, cid::Int, data) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_fixedoffset! ,  add_axes_bcrtod!  and  Orient.AXESID_ICRF . source"},{"id":382,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_bcrtod!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_bcrtod!","content":" FrameTransformations.Frames.add_axes_bcrtod!  —  Function add_axes_bcrtod!(frames, axes::AbstractFrameAxes, center::AbstractFramePoint, data) Add  axes  as a set of Body-Centered Rotating (BCR), True-of-Date (TOD) axes to the   frames  system. The center point (i.e., the reference body) is  center .  data  is a dictionary  containing a parsed  TPC  file. These axes are the equivalent of SPICE's  IAU_<BODY_NAME>  frames. Warning The parent axes are automatically set to the ICRF (ID = 1). If the  ICRF is not defined in  frames , an error is thrown. add_axes_bcrtod!(frames, name::Symbol, axesid::Int, cname::Symbol, cid::Int, data) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro and of an  AbstractFramePoint  via the  @point  macro. See also See also  add_axes_rotating! ,  add_axes_bci2000!  and  Orient.AXESID_ICRF . source"},{"id":383,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_computable!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_computable!","content":" FrameTransformations.Frames.add_axes_computable!  —  Function add_axes_computable!(frames, axes, parent, v1, v2, seq::Symbol) Add  axes  as a set of computable axes to  frames . Computable axes differ from rotating axes  because they are computed through two vectors that are defined within the frame system itself.  Computable axes are the equivalent of SPICE's parameterized two-vector frames.  These axes are built such that the first vector, known as the primary vector, is parallel to  one axis of the frame; the component of the secondary vector orthogonal to the first is parallel to another axis of the frame, and the cross product of the two vectors is parallel to the  remaining axis.  The primary and secondary vectors,  v1  and  v2  are instances of  ComputableAxesVector ,  which is used to define the NAIF IDs of the vector origin and target, and its order. Current  accepted order values are: 1 (position), 2 (velocity) and 3 (acceleration).  For example, to define a primary vector that is parallel to the Sun's (NAIF ID = 10) velocity  with respect to the Solary system barycenter (NAIF ID = 0),  v1  must be set as:   v1 = ComputableAxesVector(10, 0, 1) . seq  is a combination of two letters that is used to identify the desired pointing  directions of the primary and secondary vectors. Accepted sequences are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ  and  :ZY .  Given a spacecraft registered as a point in the frame system, an example of a set of computable  axes is the Local Vertical Local Horizon (LVLH), where the spacecraf's nadir direction and  velocity direction define the axes orientation.   Note Regardless of the original set of axes in which the primary and secondary vectors are  defined, the axes orientation is automatically computed by rotating them to  parent . add_axes_computable!(frames, name::Symbol, axesid::Int, parentid::Int, v1, v2, seq) Low-level function to add axes  name  with id  axesid  to  frames  as computable axes without  requiring the creation of an  AbstractFrameAxes  type via the  @axes  macro. Examples julia> using Ephemerides \n\njulia> eph = EphemerisProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{4, Float64}(eph);\n\njulia> @point SSB 0 SolarySystemBarycenter \n\njulia> @point Sun 10 \n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @axes SunFrame 2\n\njulia> v1 = ComputableAxesVector(10, 0, 1)\nComputableAxesVector(10, 0, 1)\n\njulia> v2 = ComputableAxesVector(10, 0, 2)\nComputableAxesVector(10, 0, 2)\n\njulia> add_axes_computable!(FRAMES, SunFrame, ICRF, v1, v2, :XY) See also See also  ComputableAxesVector ,  add_axes_fixedoffset! ,  add_axes_inertial!   and  add_axes_computable! source"},{"id":384,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_eclipj2000!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_eclipj2000!","content":" FrameTransformations.Frames.add_axes_eclipj2000!  —  Function add_axes_eclipj2000!(frames, axes::AbstractFrameAxes, parent, iau_model::IAUModel=iau1980) Add  axes  as a set of inertial axes representing the Ecliptic Equinox of J2000 (ECLIPJ2000) to  frames . The obliquity of the ecliptic is computed using the IAU Model  iau_model . The admissed  parent  set of axes are the following:  ICRF : for the International Celestial Reference Frame, with ID = 1 MEME2000 : the Mean Earth/Moon Ephemeris of J2000, with ID = 22 add_axes_eclipj2000!(frames, name::Symbol, parentid::Int, iau_model::IAUModel=iau1980, \n    axesid::Int = Orient.AXESID_ECLIPJ2000) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. Examples julia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes ECLIPJ2000 17 EclipticEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_eclipj2000!(FRAMES, ECLIPJ2000, ICRF) See also See also  add_axes_inertial!  and  Orient.DCM_ICRF_TO_MEME2000 source"},{"id":385,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_ephemeris!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_ephemeris!","content":" FrameTransformations.Frames.add_axes_ephemeris!  —  Function add_axes_ephemeris!(frames, axes, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, axes, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Add  axes  as a set of ephemeris axes to  frames . The orientation of these axes is computed  with a series of 3 rotations specified by  rot_seq . The euler angles and their derivatives  needed by the rotation are extracted from the ephemeris kernels loaded in  frames . The parent axes are automatically assigned to the axes with respect to which the orientation  data has been written in the kernels. This operation is only possible if the ephemeris kernels loaded within  frames  contain  orientation data for the AXES ID associated to  axes . An error is returned if the parent  axes ID is yet to be added to  frames. The rotation sequence is defined by a  Symbol  specifing the rotation axes. This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i-th  rotation.  The possible  rot_seq  values are:  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,  :YXZ ,  :YZX ,   :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ . Alternatively, one can provide custom functions that take a vector of euler angles and their  derivatives and return the DCM and its derivatives.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a Direction Cosine Matrix (DCM). δfun : return the DCM and its 1st order time derivative. δ²fun : return the DCM and its 1st and 2nd order time derivatives. δ³fun : return the DCM and its 1st, 2nd and 3rd order time derivatives. Warning It is expected that the axes ID assigned by the user are aligned with those used to  generate the ephemeris kernels. No check are performed on whether these IDs represent  the same physical axes that are intended in the kernels. add_axes_ephemeris!(frames, name::Symbol, axesid::Int, rot_seq::Symbol)\nadd_axes_ephemeris!(frames, name::Symbol, axesid::Int, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Low-level functions to add axes  name  with id  axesid  to  frames  as ephemeris axes without  requiring the creation of an  AbstractFrameAxes  type via the  @axes  macro. See also See also  ComputableAxesVector ,  add_axes_fixedoffset! ,  add_axes_inertial!   and  add_axes_computable! source"},{"id":386,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_fixedoffset!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_fixedoffset!","content":" FrameTransformations.Frames.add_axes_fixedoffset!  —  Function add_axes_fixedoffset!(frames::FrameSystem, axes, parent, dcm::DCM) Add  axes  as a set of fixed offset axes to  frames . Fixed offset axes have a constant  orientation with respect to their  parent  axes, represented by  dcm , a  Direction Cosine Matrix (DCM). Note While inertial axes do not rotate with respect to the star background, fixed offset axes  are only constant with respect to their parent axes, but might be rotating with respect  to some other inertial axes. add_axes_fixedoffset!(frames, name::Symbol, axesid::Int, parentid::Int, dcm:DCM) Low-level function to add axes  name  with id  axesid  to  frames  with a fixed-offset from   parentid  without requiring the creation of an  AbstractFrameAxes  type via the   @axes  macro. Examples julia> FRAMES = FrameSystem{1, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_fixedoffset!(FRAMES, ECLIPJ2000, ICRF, angle_to_dcm(π/3, :Z)) See also See also  add_axes_rotating! ,  add_axes_inertial!  and  add_axes_computable! source"},{"id":387,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_gcrf!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_gcrf!","content":" FrameTransformations.Frames.add_axes_gcrf!  —  Function add_axes_gcrf!(frames::FrameSystem) Add the Geocentric Celestial Reference Frame (GCRF) to the frames graph. The axes are  automatically named  GCRF  and assigned the 23 ID. These axes can only  be defined as a set of root axes or as child of the ICRF (ID = 1). See also See also  add_axes_inertial! ,  add_axes_icrf!  and  Orient.AXESID_GCRF . source"},{"id":388,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_inertial!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_inertial!","content":" FrameTransformations.Frames.add_axes_inertial!  —  Function add_axes_inertial!(frames, axes; parent=nothing, dcm=nothing) Add  axes  as a set of inertial axes to  frames . Only inertial axes can be used as root axes  to initialise the axes graph. Only after the addition of a set of inertial axes, other axes  classes may be added aswell. Once a set of root-axes has been added,  parent  and  dcm   become mandatory fields. Note The parent of a set of inertial axes must also be inertial. FixedOffset axes that are  that only have inertial parents are also accepted. add_axes_inertial!(frames, name::Symbol, axesid::Int; parentid=nothing, dcm=nothing) Low-level function to add axes  name  with id  axesid  to  frames  without requiring the  creation of an  AbstractFrameAxes  type via the  @axes  macro. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @axes ECLIPJ2000 17 \n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000)\nERROR: A set of parent axes for ECLIPJ2000 is required\n[...]\n\njulia> add_axes_inertial!(FRAMES, ECLIPJ2000; parent=ICRF, dcm=angle_to_dcm(π/3, :Z)) See also See also  add_axes_rotating! ,  add_axes_fixedoffset!  and  add_axes_computable! source"},{"id":389,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_icrf!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_icrf!","content":" FrameTransformations.Frames.add_axes_icrf!  —  Function add_axes_icrf!(frames::FrameSystem) Add the International Celestial Reference Frame (ICRF) as the root axes of the frames graph. The axes are automatically named  ICRF  and assigned the 1 ID.  See also See also  add_axes_inertial! ,  add_axes_gcrf!  and  Orient.AXESID_ICRF . source"},{"id":390,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_itrf!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_itrf!","content":" FrameTransformations.Frames.add_axes_itrf!  —  Function add_axes_itrf!(frames, axes::AbstractFrameAxes, parent, model::IAU2006Model=iau2006b) Add  axes  as a set of axes representing the International Terrestrial Reference Frame (ITRF) to  frames . Use the  model  argument to specify which IAU model model should be used for  the computations. The default is set to  iau2006b . Warning If the ID of the parent set of  axes  is neither the ICRF (ID = 1) nor the GCRF (ID = 23), an error is thrown.  add_axes_itrf!(frames, name::Symbol, parentid::Int, model::IAU2006Model=iau2006b, \n    axesid::Int = Orient.AXESID_ITRF) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_rotating!  and  orient_rot3_itrf_to_gcrf . source"},{"id":391,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_me421!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_me421!","content":" FrameTransformations.Frames.add_axes_me421!  —  Function add_axes_me421!(frames, axes::AbstractFrameAxes, parent) Add  axes  as fixed offset axes representing the DE421 Moon's Mean Earth/Mean Rotation (ME)  to  frames . Warning The  parent  set of axes must either the DE440 Principal Axes (PA440, ID =  or the DE421 Principal Axes (PA421, ID =  31006), otherwise an error is thrown. Depending on that, the  relative axes orientation will be automatically selected by this function.  add_axes_me421!(frames, name::Symbol, parentid::Int, axesid::Int = Orient.AXESID_MOONME_DE421) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_pa440! , and  add_axes_pa421! ,   Orient.DCM_MOON_PA421_TO_ME421  and  Orient.DCM_MOON_PA421_TO_ME421 ,  source"},{"id":392,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_meme2000!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_meme2000!","content":" FrameTransformations.Frames.add_axes_meme2000!  —  Function add_axes_meme2000!(frames, axes::AbstractFrameAxes, parent) Add  axes  as a set of inertial axes representing the Mean Equator Mean Equinox of J2000  to  frames .  Warning The the axes ID of the parent set of axes must be 1 (ICRF) or  17 (ECLIPJ2000) otherwise and error is thrown. add_axes_meme2000!(frames, name::Symbol, parentid::Int, axesid::Int = Orient.AXESID_MEME2000) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. Examples julia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> @axes MEME2000 22 MeanEquatorMeanEquinoxJ2000 \n\njulia> FRAMES = FrameSystem{1, Float64}();\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> add_axes_meme2000!(FRAMES, MEME2000, ICRF) See also See also  add_axes_inertial!  and  Orient.DCM_ICRF_TO_MEME2000 source"},{"id":393,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_mod!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_mod!","content":" FrameTransformations.Frames.add_axes_mod!  —  Function add_axes_mod!(frames, axes::AbstractFrameAxes, parent) Add  axes  as a set of projected axes representing the Mean Equator and Equinox of Date (MOD) to  frames .  Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF),  otherwise an error is thrown.  add_axes_mod!(frames, name::Symbol, axesid::Int, parentid::Int) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_projected!  and  Orient.orient_rot3_icrf_to_mod source"},{"id":394,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_tod!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_tod!","content":" FrameTransformations.Frames.add_axes_tod!  —  Function add_axes_tod!(frames, axes::AbstractFrameAxes, parent) Add  axes  as a set of projected axes representing the True Equator of Date (TOD) to  frames .  Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF),  otherwise an error is thrown.  add_axes_tod!(frames, name::Symbol, axesid::Int, parentid::Int) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_projected!  and  Orient.orient_rot3_icrf_to_tod source"},{"id":395,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_teme!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_teme!","content":" FrameTransformations.Frames.add_axes_teme!  —  Function add_axes_teme!(frames, axes::AbstractFrameAxes, parent) Add  axes  as a set of projected axes representing the True Equator, Mean Equinox (TEME) to  frames .  Note Despite this class of axes has a rotation matrix that depends on time, its derivatives  are assumed null. Warning The ID of the  parent  set of axes must be 1 (ICRF),  otherwise an error is thrown.  add_axes_teme!(frames, name::Symbol, axesid::Int, parentid::Int) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_projected!  and  Orient.orient_rot3_icrf_to_teme source"},{"id":396,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_pef!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_pef!","content":" FrameTransformations.Frames.add_axes_pef!  —  Function add_axes_pef!(frames, axes::AbstractFrameAxes, parent) Add  axes  as a set of rotating axes representing the Pseudo Earth Fixed (PEF) axes to  frames .  Warning The ID of the  parent  set of axes must be 1 (ICRF),  otherwise an error is thrown.  add_axes_pef!(frames, name::Symbol, axesid::Int, parentid::Int) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  add_axes_rotating! ,  Orient.orient_rot3_icrf_to_pef  and   Orient.orient_rot6_icrf_to_pef . source"},{"id":397,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_pa421!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_pa421!","content":" FrameTransformations.Frames.add_axes_pa421!  —  Function add_axes_pa421!(frames, axes::AbstractFrameAxes) Add  axes  as a set of ephemeris axes representing the DE421 Moon's Principal Axes (PA) to   frames . The libration angles are extracted from the ephemeris kernels loaded within  frames ,  an error is thrown if such orientation data is not available.  Warning The parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown. Warning To properly read the ephemeris kernels, the ID associated to the input  axes  must match  NAIF's FRAME ID for the Moon PA DE421 axes (31006). add_axes_pa421!(frames, name::Symbol, axesid::Int = Orient.AXESID_MOONPA_DE421) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  Orient.AXESID_MOONPA_DE421 ,  Orient.orient_rot3_icrf_to_pa421 ,   add_axes_pa440! , and  add_axes_me421! source"},{"id":398,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_pa440!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_pa440!","content":" FrameTransformations.Frames.add_axes_pa440!  —  Function add_axes_pa440!(frames, axes::AbstractFrameAxes) Add  axes  as a set of ephemeris axes representing the DE440 Moon's Principal Axes (PA) to   frames . The libration angles are extracted from the ephemeris kernels loaded within  frames ,  an error is thrown if such orientation data is not available.  Warning The parent axes are automatically set to the ICRF (ID = 1). If such  axes are not registered in the frame system, an error is thrown. Warning To properly read the ephemeris kernels, the ID associated to the input  axes  must match  NAIF's FRAME ID for the Moon PA DE440 axes (31008). add_axes_pa440!(frames, name::Symbol, axesid::Int = Orient.AXESID_MOONPA_DE440) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  type  via the  @axes  macro. See also See also  Orient.AXESID_MOONPA_DE440 ,  Orient.orient_rot3_icrf_to_pa440  and  add_axes_pa421! . source"},{"id":399,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_projected!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_projected!","content":" FrameTransformations.Frames.add_axes_projected!  —  Function add_axes_projected!(frames, axes, parent, fun) Add  axes  as a set of projected axes to  frames . The orientation of these axes depends only  on time and is computed through the custom functions provided by the user.  Projected axes are similar to rotating axis, except that all the positions, velocity, etc ...  are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null,  despite the rotation depends on time). Warning It is expected that the input function and their outputs have the correct signature. This  function does not perform any checks on the output types.  add_axes_projected!(frames, name::Symbol, axesid::Int, parentid::Int, fun) Low-level function to add axes  name  with id  axesid  to  frames  as projected axes without  requiring the creation of an  AbstractFrameAxes  type via the  @axes  macro. source"},{"id":400,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_rotating!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_rotating!","content":" FrameTransformations.Frames.add_axes_rotating!  —  Function add_axes_rotating!(frames, axes, parent, fun, δfun=nothing, δ²fun=nothing, δ³fun=nothing) Add  axes  as a set of rotating axes to  frames . The orientation of these axes depends only  on time and is computed through the custom functions provided by the user.  The input functions must accept only time as argument and their outputs must be as follows:  fun : return a Direction Cosine Matrix (DCM). δfun : return the DCM and its 1st order time derivative. δ²fun : return the DCM and its 1st and 2nd order time derivatives. δ³fun : return the DCM and its 1st, 2nd and 3rd order time derivatives. If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed via automatic differentiation. Warning It is expected that the input functions and their outputs have the correct signature. This  function does not perform any checks on the output types.  add_axes_rotating!(frames, name::Symbol, axesid::Int, parentid::Int, fun, δfun=nothing, \n    δ²fun=nothing, δ³fun=nothing) Low-level function to add axes  name  with id  axesid  to  frames  as rotating axes without  requiring the creation of an  AbstractFrameAxes  type via the  @axes  macro. Examples julia> FRAMES = FrameSystem{3, Float64}();\n\njulia> @axes Inertial 1\n\njulia> add_axes_inertial!(FRAMES, Inertial)\n\njulia> @axes Synodic 2 \n\njulia> fun(t) = angle_to_dcm(t, :Z);\n\njulia> add_axes_rotating!(FRAMES, Synodic, Inertial, fun)\n\njulia> R = rotation6(FRAMES, Inertial, Synodic, π/6);\n\njulia> R[1]\nDCM{Float64}:\n  0.866025  0.5       0.0\n -0.5       0.866025  0.0\n  0.0       0.0       1.0\n\njulia> R[2]\nDCM{Float64}:\n -0.5        0.866025  0.0\n -0.866025  -0.5       0.0\n  0.0        0.0       0.0 See also See also  add_axes_fixedoffset! ,  add_axes_inertial!  and  add_axes_computable! source"},{"id":401,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_axes_topocentric!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_axes_topocentric!","content":" FrameTransformations.Frames.add_axes_topocentric!  —  Function add_axes_topocentric!(frames, axes::AbstractFrameAxes, parent, λ::Number, ϕ::Number, type::Symbol) Add  axes  as a set of fixed-offset topocentric axes to  frames . The orientation relative  to the parent axes  parent  is defined throuh the longitude  λ , the geodetic latitude  ϕ   and the type  type , which may be any of the following:  :NED  (North, East, Down): the X-axis points North, the Y-axis is directed eastward and    the Z-axis points inwards towards the nadir. :SEZ  (South, East, Zenith): the X-axis points South, the Y-axis is directed East, and    the Z-axis points outwards towards the zenith. :ENU  (East, North, Up): the X-axis points East, the Y-axis is directed North and the    Z-axis points outwards towards the zenith.  Warning The  parent  axes must be a set of body-fixed reference axes. When this constraint is  not satisfied, the results may be fundamentally wrong.  add_axes_topocentric!(frames, name::Symbol, axesid::Int, parentid::Int, λ, ϕ, type) Low-level function to avoid requiring the creation of an  AbstractFrameAxes  via  the  @axes  macro. See also See also  add_axes_fixedoffset!  and  add_point_surface! . source"},{"id":402,"pagetitle":"Public API","title":"Points","ref":"/FrameTransformations/stable/Modules/frames_api/#Points","content":" Points"},{"id":403,"pagetitle":"Public API","title":"FrameTransformations.Frames.@point","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.@point","content":" FrameTransformations.Frames.@point  —  Macro @point(name, id, type=nothing) Define a new point instance to alias the given NAIFID  id . This macro creates an   AbstractFramePoint  subtype and its singleton instance called  name . Its type name  is obtained by appending  Point  to either  name  or  type  (if provided). Examples julia> @point Venus 299\n\njulia> typeof(Venus)\nVenusPoint \n\njulia> point_alias(Venus)\n299\n\njulia> @point EMB 3 EarthMoonBarycenter\n\njulia> typeof(EMB) \nEarthMoonBarycenterPoint\n\njulia> point_alias(EMB) \n3  See also See also  @axes  and  point_alias . source"},{"id":404,"pagetitle":"Public API","title":"FrameTransformations.Frames.point_alias","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.point_alias","content":" FrameTransformations.Frames.point_alias  —  Function point_alias(ax::AbstractFramePoint) Return the NAIF ID associated to the input point.  source"},{"id":405,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_dynamical!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_dynamical!","content":" FrameTransformations.Frames.add_point_dynamical!  —  Function add_point_dynamical!(frames, point::AbstractFramePoint, parent, axes, fun, δfun=nothing, \n    δ²fun=nothing, δ³fun=nothing) Add  point  as a time point to  frames . The state vector for these points depends only on  time and is computed through the custom functions provided by the user.  axes  is the ID or   AbstractFrameAxes  instance in which the point state-vector is expressed. The input functions must accept only time as argument and their outputs must be as follows:  fun : return a 3-elements vector: position δfun : return a 6-elements vector: position and velocity δ²fun : return a 9-elements vector: position, velocity and acceleration δ³fun : return a 12-elements vector: position, velocity, acceleration and jerk If  δfun ,  δ²fun  or  δ³fun  are not provided, they are computed with automatic differentiation.  Warning It is expected that the input functions and their ouputs have the correct signature. This  function does not perform any checks on whether the returned vectors have the appropriate  dimensions.  add_point_dynamical!(frames, name::Symbol, pointid::Int, parentid::Int, axes, fun, \n    δfun=nothing, δ²fun=nothing, δ³fun=nothing) Low-level function to add point  name  with ID  id  to  frames  as a dynamical point without  requiring the creation of an  AbstractFramePoint  type via the  @point  macro.  axes  is the ID or  AbstractFrameAxes  instance in which the point state-vector is  expressed. Examples julia> FRAMES = FrameSystem{2, Float64}()\n\njulia> @axes ICRF 1 \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> @point Satellite 1 \n\njulia> satellite_pos(t::T) where T = [cos(t), sin(t), 0]\n\njulia> add_point_dynamical!(FRAMES, Satellite, Origin, ICRF, satellite_pos)\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, π/6)\n6-element SVector{6, Float64} with indices SOneTo(6):\n  0.8660254037844387\n  0.49999999999999994\n  0.0\n -0.49999999999999994\n  0.8660254037844387\n  0.0 See also See also  add_point_root! ,  add_point_ephemeris! , add_point_fixed!  and  add_point_updatable! source"},{"id":406,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_ephemeris!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_ephemeris!","content":" FrameTransformations.Frames.add_point_ephemeris!  —  Function add_point_ephemeris!(frames::FrameSystem, point::AbstractFramePoint) Add  point  as an ephemeris point to  frames . This function is intended for points whose  state-vector is read from ephemeris kernels (i.e., de440.bsp). The parent point is  automatically assigned to the point with respect to which the ephemeris data is written  in the kernels. If that point is not available as an ephemeris point in the frame system,  an error is thrown. Note The axes in which the state-vector is expressed are taken from the ephemeris data: an  error is returned if the axes ID is yet to be added to  frames . Warning It is expected that the NAIF ID and the axes ID assigned by the user are aligned with  those used to generate the ephemeris kernels. No check are performed on whether these IDs represent the same physical bodies and axes that are intended in the kernels. add_point_ephemeris!(frames::FrameSystem, name::Symbol, naifid::Int) Low-level function to add point  name  with ID  id  to  frames  as an ephemeris point without  requiring the creation of an  AbstractFramePoint  type via the  @point  macro. Examples julia> using Ephemerides \n\njulia> eph = EphemerisProvider(DE440_KERNEL_PATH);\n\njulia> FRAMES = FrameSystem{2, Float64}(eph);\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter\n\njulia> @point Sun 10 \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> add_point_ephemeris!(FRAMES, Sun)\n\njulia> @point Jupiter 599\n\njulia> add_point_ephemeris!(FRAMES, Jupiter)\nERROR: ArgumentError: Ephemeris data for NAIFID 599 is not available in the kernels loaded in the given FrameSystem.\n[...] See also See also  add_point_root! ,  add_point_fixed! ,  add_point_dynamical!  and  add_point_updatable! source"},{"id":407,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_fixed!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_fixed!","content":" FrameTransformations.Frames.add_point_fixed!  —  Function add_point_fixed!(frames, point::AbstractFramePoint, parent, axes, offset::AbstractVector) Add  point  as a fixed point to  frames . Fixed points are those whose positions have a  constant  offset  with respect their  parent  points in the given set of  axes . Thus, points  eligible for this class must have null velocity and acceleration with respect to  parent .  axes  is the ID or  AbstractFrameAxes  instance in which the point state-vector is  expressed. add_point_fixed!(frames, name::Symbol, pointid::Int, parentid::Int, axes, offset::AbstractVector) Low-level function to add point  name  with ID  id  to  frames  as a fixed-point with respect  to point  parentid  without requiring the creation of an  AbstractFramePoint  type  via the  @point  macro.  axes  is the ID or  AbstractFrameAxes  instance in  which the point state-vector is expressed. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes SF -3000 SatelliteFrame\n\njulia> add_axes_inertial!(FRAMES, SF)\n\njulia> @point SC -10000 Spacecraft\n\njulia> @point SolarArrayCenter -10001\n\njulia> add_point_root!(FRAMES, SC, SF)\n\njulia> sa_offset = [0.10, 0.15, 0.30];\n\njulia> add_point_fixed!(FRAMES, SolarArrayCenter, SC, SF, sa_offset) See also See also  add_point_root! ,  add_point_ephemeris! ,   add_point_dynamical!  and  add_point_updatable! source"},{"id":408,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_root!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_root!","content":" FrameTransformations.Frames.add_point_root!  —  Function add_point_root!(frames::FramesSystem, point::AbstractFramePoint, axes) Add  point  as a root point to  frames  to initialize the points graph. Only after the  addition of a root point, other points may be added aswell. This point is intended as the origin, i.e., its position will equal (0., 0., 0.).  axes  is the ID or  AbstractFrameAxes  instance in which the point state-vector is expressed. Note This operation can be performed only once per  FrameSystem  object: multiple root  points in the same graph are both inadmissible and meaningless. add_point_root!(frames::FrameSystem, name::Symbol, pointid::Int, axes) Low-level function to add point  name  with ID  pointid  to  frames  as a root-point without  requiring the creation of an  AbstractFramePoint  type via the  @point  macro.  axes  is the ID or  AbstractFrameAxes  instance in which the point state-vector is  expressed. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1 InternationalCelestialReferenceFrame\n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point SSB 0 SolarSystemBarycenter \n\njulia> add_point_root!(FRAMES, SSB, ICRF)\n\njulia> @point Sun 10\n\njulia> add_point_root!(FRAMES, Sun, ICRF)\nERROR: ArgumentError: A root-point is already registed in the given FrameSystem.\n[...] See also See also  add_point_ephemeris! ,  add_point_fixed! ,  add_point_dynamical!  and  add_point_updatable! source"},{"id":409,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_surface!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_surface!","content":" FrameTransformations.Frames.add_point_surface!  —  Function add_point_surface!(frames, point::AbstractFramePoint, parent, axes, λ::Number, \n    ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0) Add  point  to  frames  as a fixed point on the surface of the  parent  point body. The relative  position is specified by the longitude  λ , the geodetic latitude  ϕ , the reference radius  of the ellipsoid  R  and its flattening  f . The altitude over the reference surface of the  ellipsoid  h  defaults to 0.  Warning axes  must be a set of body-fixed reference axes for the body represented by  parent .  When this constraint is not satisfied, the results may be fundamentally wrong.  add_point_surface!(frames, point::AbstractFramePoint, parent, axes, pck,  λ, ϕ, h::Number=0.0) In this case, the ellipsoid parameters are extracted from the input TPC kernel  pck  using  the NAIFId associated to the  parent  point. add_point_surface!(frames, name::Symbol, pointid::Int, parentid::Int, axesid::Int, \n    λ::Number, ϕ::Number, R::Number, f::Number=0.0, h::Number=0.0,) Low-level function to avoid requiring the creation of an  AbstractFramePoint  via  the  @point  macro. See also See also  add_point_fixed!  and  add_axes_topocentric! . source"},{"id":410,"pagetitle":"Public API","title":"FrameTransformations.Frames.add_point_updatable!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.add_point_updatable!","content":" FrameTransformations.Frames.add_point_updatable!  —  Function add_point_updatable!(frames, point::AbstractFramePoint, parent, axes) Add  point  as an updatable point to  frames . Differently from all the other classes, the  state vector for updatable points (expressed in the set of input  axes ) must be manually  updated before being used for other computations.  axes  is the ID or   AbstractFrameAxes  instance in which the point state-vector is expressed.  Note This class of points becomes particularly useful if the state vector is not known a-priori,  e.g., when it is the output of an optimisation process which exploits the frame system. add_point_updatable!(frames, name::Symbol, pointid::Int, parentid::Int, axes) Low-level function to add point  name  with ID  id  to  frames  as an updatable point without  requiring the creation of an  AbstractFramePoint  type via the  @point  macro.  axes  is the ID or  AbstractFrameAxes  instance in which the point state-vector is  expressed. Examples julia> FRAMES = FrameSystem{2, Float64}();\n\njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.]\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2\n[...] See also See also  update_point! ,  add_point_root! ,  add_point_ephemeris! ,   add_point_dynamical!  and  add_point_fixed! source"},{"id":411,"pagetitle":"Public API","title":"FrameTransformations.Frames.update_point!","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.update_point!","content":" FrameTransformations.Frames.update_point!  —  Function update_point!(frames, point, stv::AbstractVector, epoch::Epoch) source update_point!(frames::FrameSystem, point, stv::AbstractVector, time) Update the state vector of  point  at the input  time  in  frames . The only  accepted length for the input vector  stv  are 3, 6, 9 or 12. The order is automatically  inferred from the vector length. Examples julia> FRAMES = FrameSystem{2, Float64}();\n  \njulia> @axes ICRF 1  \n\njulia> add_axes_inertial!(FRAMES, ICRF)\n\njulia> @point Origin 0\n\njulia> @point Satellite 1 \n\njulia> add_point_root!(FRAMES, Origin, ICRF)\n\njulia> add_point_updatable!(FRAMES, Satellite, Origin, ICRF)\n\njulia> y = [10000., 200., 300.];\n\njulia> update_point!(FRAMES, Satellite, y, 0.1)\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.1)\n3-element SVector{3, StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n 10000.0\n   200.0\n   300.0\n\njulia> vector3(FRAMES, Origin, Satellite, ICRF, 0.2)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.2 for order 1 \n[...]\n\njulia> vector6(FRAMES, Origin, Satellite, ICRF, 0.1)\nERROR: UpdatablePoint with NAIFId = 1 has not been updated at time 0.1 for order 2 \n[...]  See also See also  add_point_updatable! source"},{"id":412,"pagetitle":"Public API","title":"Rotations","ref":"/FrameTransformations/stable/Modules/frames_api/#rotation_api","content":" Rotations"},{"id":413,"pagetitle":"Public API","title":"FrameTransformations.Frames.Rotation","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.Rotation","content":" FrameTransformations.Frames.Rotation  —  Type Rotation{S, N} A container to efficiently compute  S -th order rotation matrices of type  N  between two  set of axes. It stores the Direction Cosine Matrix (DCM) and its time derivatives up to  the ( S -1)-th order. Since this type is immutable, the data must be provided upon  construction and cannot be mutated later. The rotation of state vector between two set of axes is computed with an ad-hoc overload  of the product operator. For example, a 3rd order Rotation object  R , constructed from the  DCM  A  and its time derivatives  δA  and  δ²A  rotates a vector  v  =  [p, v, a]  as:  ̂v = [A*p, δA*p + A*v, δ²A*p + 2δA*v + A*a] A  Rotation  object  R  call always be converted to a  SMatrix  or a  MMatrix  by invoking  the proper constructor.  Examples julia> A = angle_to_dcm(π/3, :Z)\nDCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> R = Rotation(A);\n\njulia> SM = SMatrix(R)\n3×3 SMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0\n\njulia> MM = MMatrix(R)\n3×3 MMatrix{3, 3, Float64, 9} with indices SOneTo(3)×SOneTo(3):\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0 Rotation(dcms::DCM...) Create a  Rotation  object from a Direction Cosine Matrix (DCM) and any of its time   derivatives. The rotation order is inferred from the number of inputs, while the rotation  type is obtained by promoting the DCMs types. Examples julia> A = angle_to_dcm(π/3, :Z); \n\njulia> δA = DCM(0.0I); \n\njulia> δ²A = DCM(0.0I); \n\njulia> R = Rotation(A, δA, δ²A); \n\njulia> typeof(R) \nRotation{3, Float64}\n\njulia> R2 = Rotation(A, B, C, DCM(0.0im*I)); \n\njulia> typeof(R2)\nRotation{4, ComplexF64} Rotation{S}(dcms::DCM...) where S Create a  Rotation  object of order  S . If the number of  dcms  is smaller than  S , the  remaining slots are filled with null DCMs, otherwise if the number of inputs is greater than   S , only the first  S  DCMs are used.  Warning Usage of this constructor is not recommended as it may yield unexpected results to  unexperienced users.  Rotation{S1}(dcms::NTuple{S2, DCM{N}}) where {S1, S2, N} Create a  Rotation  object from a tuple of Direction Cosine Matrix (DCM) and its time  derivatives. If  S1  <  S2 , only the first  S1  DCMs are considered, otherwise the  remaining orders are filled with null DCMs. Examples julia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R3 = Rotation{3}((A,B));\n\njulia> R3[1] == A\ntrue \n\njulia> R3[3] \nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Rotation{S}(u::UniformScaling{N}) where {S, N}\nRotation{S, N}(u::UniformScaling) where {S, N} Create an  S -order identity  Rotation  object of type  N  with identity position rotation  and null time derivatives. Examples julia> Rotation{1}(1.0I) \nRotation{1, Float64}(([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0],))\n\njulia> Rotation{1, Int64}(I)\nRotation{1, Int64}(([1 0 0; 0 1 0; 0 0 1],)) Rotation{S1}(rot::Rotation{S2, N}) where {S1, S2, N}\nRotation{S1, N}(R::Rotation{S2}) where {S1, S2, N} Transform a  Rotation  object of order  S2  to order  S1  and type  N . The behaviour of  these functions depends on the values of  S1  and  S2 :  S1  <  S2 : Only the first  S1  components of  rot  are considered. S1  >  S2 : The missing orders are filled with null DCMs. Examples julia> A = angle_to_dcm(π/3, :Z);\n\njulia> B = angle_to_dcm(π/4, π/6, :XY);\n\njulia> R1 = Rotation(A, B);\n\njulia> order(R1)\n2\n\njulia> R2 = Rotation{1}(R1);\n\njulia> order(R2)\n1\n\njulia> R2[1] == A \ntrue\n\njulia> R3 = Rotation{3}(R1);\n\njulia> R3[3]\nDCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Rotation(m::DCM{N}, ω::AbstractVector) where N Create a 2nd order  Rotation  object of type  N  to rotate between two set of axes  a  and   b  from a Direction Cosine Matrix (DCM) and the angular velocity vector  ω  of  b  with  respect to  a , expressed in  b See also See also  rotation3 ,  rotation6  and  rotation9 . source"},{"id":414,"pagetitle":"Public API","title":"FrameTransformations.Frames.order","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.order","content":" FrameTransformations.Frames.order  —  Function order(R::Rotation{S}) where S Return the rotation order S. source"},{"id":415,"pagetitle":"Public API","title":"Base.inv","ref":"/FrameTransformations/stable/Modules/frames_api/#Base.inv","content":" Base.inv  —  Function inv(rot::Rotation) Compute the invese of the rotation object  rot . The operation is efficiently performed by  taking the transpose of each rotation matrix within  rot . source"},{"id":416,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation3","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation3","content":" FrameTransformations.Frames.rotation3  —  Function rotation3(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 1. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 1. source rotation3(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 3-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":417,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation6","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation6","content":" FrameTransformations.Frames.rotation6  —  Function rotation6(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 2. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 2. source rotation6(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 6-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":418,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation9","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation9","content":" FrameTransformations.Frames.rotation9  —  Function rotation9(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 3. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 3. source rotation9(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 9-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":419,"pagetitle":"Public API","title":"FrameTransformations.Frames.rotation12","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.rotation12","content":" FrameTransformations.Frames.rotation12  —  Function rotation12(frame::FrameSystem, from, to, ep::Epoch) Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given epoch.  Requires a frame system of order ≥ 4. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the axes to transform from  to  – ID or instance of the axes to transform to  ep  –  Epoch  of the rotation. Its timescale must match that of the frame system.  Output A  Rotation  object of order 4. source rotation12(frame::FrameSystem, from, to, t::Number) Compute the rotation that transforms a 12-elements state vector from one  specified set of axes to another at a given time  t , expressed in seconds since   J2000  if ephemerides are used.  source"},{"id":420,"pagetitle":"Public API","title":"Transformations","ref":"/FrameTransformations/stable/Modules/frames_api/#Transformations","content":" Transformations"},{"id":421,"pagetitle":"Public API","title":"FrameTransformations.Frames.LightTime","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.LightTime","content":" FrameTransformations.Frames.LightTime  —  Constant LightTime The singleton instance of type  LightTimeCorrection , used to apply light-time (planetary  aberration) corrections when computing vectors from the  FrameSystem . See also See also  vector3  and  vector6 . source"},{"id":422,"pagetitle":"Public API","title":"FrameTransformations.Frames.PlanetaryAberration","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.PlanetaryAberration","content":" FrameTransformations.Frames.PlanetaryAberration  —  Constant PlanetaryAberration The singleton instance of type  PlanetaryAberrationCorrection , used to apply one-way  light-time and stellar aberration corrections when computing vectors from the  FrameSystem . See also See also  vector3  and  vector6 . source"},{"id":423,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector3","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector3","content":" FrameTransformations.Frames.vector3  —  Function vector3(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 1. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector3(frame, from, to, axes, t::Number) Compute 3-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source vector3(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch  ep ,  using the aberration flag  ltcorr , which may be any of the following  AbstractLightTimeCorrection : LightTimeCorrection : it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation.  PlanetaryAberrationCorrection : it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the  LightTimeCorrection  option to account for the observer velocity    with respect to the Solar System Barycenter.  The integer argument  dir  is used to specify the correction direction, as follows: -1 : for  Reception , in which photons depart from the target's location at the    light-time corrected epoch  ep-lt  and arrive at the observer's location at  ep . +1 : for  Transmission , in which photons depart from the observer's location at    ep  and arrive at the target's location at the light-time corrected epoch  ep+lt . Keyword Arguments iters::Int=1 : the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations. axescenter : ID or instance of the center point for  axes . This parameter is used        only when  axes  have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to  from . Note If the  PlanetaryAberrationCorrection  is applied, the frame system must be at  least one order higher than that of the requested transformation. See also See also  LightTime ,  PlanetaryAberration  and  vector6 . References CSPICE  Library source vector3(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 3-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time  t ,   expressed in seconds since  J2000 , using the aberration flag  ltcorr  and  the direction  dir . source"},{"id":424,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector6","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector6","content":" FrameTransformations.Frames.vector6  —  Function vector6(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 2. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector6(frame, from, to, axes, t::Number) Compute 6-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source vector6(frame, from, to, axes, ep::Epoch, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired epoch  ep ,  using the aberration flag  ltcorr , which may be any of the following  AbstractLightTimeCorrection : LightTimeCorrection : it applies the one-way light time (planetary aberration)    correction, using a Newtonian formulation.  PlanetaryAberrationCorrection : it applies the one-way light time and stellar    aberration corrections using a Newtonian fromulation. It modifies the vector    obtained with the  LightTimeCorrection  option to account for the observer velocity    with respect to the Solar System Barycenter.  The integer argument  dir  is used to specify the correction direction, as follows: -1 : for  Reception , in which photons depart from the target's location at the    light-time corrected epoch  ep-lt  and arrive at the observer's location at  ep . +1 : for  Transmission , in which photons depart from the observer's location at    ep  and arrive at the target's location at the light-time corrected epoch  ep+lt . Keyword Arguments iters::Int=1 : the number of iterations used to find the solution to the        light time equation. For the solar system bodies, a solution is usually        found in 3 iterations. axescenter : ID or instance of the center point for  axes . This parameter is used        only when  axes  have an orientation that depends on time. In these cases,        the point is used to find the time at which the orientation of the axes        should be computed. It defaults to  from . Note If the  PlanetaryAberrationCorrection  is applied, the frame system must be at  least one order higher than that of the requested transformation. See also See also  LightTime ,  PlanetaryAberration  and  vector6 . References CSPICE  Library source vector6(frame, from, to, axes, t::Number, ltcorr, dir; <keyword arguments>) Compute a light-time corrected 6-elements state vector of a target point  relative to an observing point, in a given set of axes, at the desired time  t ,   expressed in seconds since  J2000 , using the aberration flag  ltcorr  and  the direction  dir . source"},{"id":425,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector9","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector9","content":" FrameTransformations.Frames.vector9  —  Function vector9(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 3. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector9(frame, from, to, axes, t::Number) Compute 9-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source"},{"id":426,"pagetitle":"Public API","title":"FrameTransformations.Frames.vector12","ref":"/FrameTransformations/stable/Modules/frames_api/#FrameTransformations.Frames.vector12","content":" FrameTransformations.Frames.vector12  —  Function vector12(frame::FrameSystem, from, to, axes, ep::Epoch) Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired epoch  ep . Requires a frame system of order ≥ 4. Inputs frame  – The  FrameSystem  container object  from  – ID or instance of the observing point to  – ID or instance of the target point  axes  – ID or instance of the output state vector axes  ep  –  Epoch  of the observer. Its timescale must match that of the frame system.  source vector12(frame, from, to, axes, t::Number) Compute 12-elements state vector of a target point relative to  an observing point, in a given set of axes, at the desired time  t  expressed in  seconds since  J2000  if ephemerides are used.  source"},{"id":429,"pagetitle":"Low-level API","title":"Frames's Low-level API","ref":"/FrameTransformations/stable/Modules/frames_lapi/#low_frames_api","content":" Frames's Low-level API"},{"id":430,"pagetitle":"Low-level API","title":"Axes","ref":"/FrameTransformations/stable/Modules/frames_lapi/#Axes","content":" Axes"},{"id":431,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.AbstractFrameAxes","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.AbstractFrameAxes","content":" FrameTransformations.Frames.AbstractFrameAxes  —  Type AbstractFrameAxes Abstract type for all reference frames axes. source"},{"id":432,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.FrameAxesNode","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.FrameAxesNode","content":" FrameTransformations.Frames.FrameAxesNode  —  Type FrameAxesNode{O, T, N} <: AbstractJSMDGraphNode Define a set of axes. Fields name  – axes name  class  –  Symbol  representing the class of the axes  id  – axes ID (equivalent of NAIFId for axes) parentid  – ID of the parent axes  comp  – properties for computable axes  R  – rotation matrix for fixed relative axes  f  –  FrameAxesFunctions  container  angles  – vector storing the libration angles retrived from ephemerides source"},{"id":433,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.axes_name","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.axes_name","content":" FrameTransformations.Frames.axes_name  —  Function axes_name(axes::AbstractFrameAxes) Return the name of  axes . source"},{"id":434,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.axes_id","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.axes_id","content":" FrameTransformations.Frames.axes_id  —  Function axes_id(axes::AbstractFrameAxes) Return the ID associated to  axes . source"},{"id":435,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.build_axes","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.build_axes","content":" FrameTransformations.Frames.build_axes  —  Function build_axes(frames, name, id, class, funs; parentid, dcm, cax_prop) Create and add a  FrameAxesNode  to  frames  based on the input parameters. Current  supported classes are:  :InertialAxes ,  :FixedOffsetAxes ,  :RotatingAxes ,  :ProjectedAxes ,   :EphemerisAxes  and  :ComputableAxes . Inputs frames  – Target frame system  name  – Axes name, must be unique within  frames id  – Axes ID, must be unique within  frames class  – Axes class.   funs  –  FrameAxesFunctions  object storing the functions to compute the DCM and,            eventually, its time derivatives. It must match the type and order of  frames . Keywords parentid  – Axes ID of the parent axes. Not required only for the root axes. dcm  – DCM with respect to the parent axes. Required only for FixedOffsetAxes.  cax_prop  –  ComputableAxesProperties , required only by ComputableAxes. Warning This is a low-level function and is NOT meant to be directly used. Instead, to add a set of axes to the frame system, see  add_axes_inertial! ,  add_axes_rotating! ,   add_axes_computable! ,  add_axes_fixedoffset!  and  add_axes_projected! . source"},{"id":436,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.ComputableAxesProperties","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.ComputableAxesProperties","content":" FrameTransformations.Frames.ComputableAxesProperties  —  Type ComputableAxesProperties Store the properties required to retrieve all the vectors required by   a computable set of axes.  source"},{"id":437,"pagetitle":"Low-level API","title":"Points","ref":"/FrameTransformations/stable/Modules/frames_lapi/#Points","content":" Points"},{"id":438,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.AbstractFramePoint","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.AbstractFramePoint","content":" FrameTransformations.Frames.AbstractFramePoint  —  Type AbstractFramePoint Abstract type for all reference frames points. source"},{"id":439,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.FramePointNode","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.FramePointNode","content":" FrameTransformations.Frames.FramePointNode  —  Type FramePointNode{O, T, N} <: AbstractJSMDGraphNode Define a frame system point. Fields name  – point name  class  –  Symbol  representing the class of the point  axesid  – ID of the axes in which the point coordinates are expressed  parentid  – NAIF ID of the parent point  NAIFId  – NAIF ID of the point stv  – vector storing the point state vectors epochs  – vector storing the epochs associated to  stv nzo  – last order at which  stv  has been computed  f  –  FramePointFunctions  container  source"},{"id":440,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.point_name","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.point_name","content":" FrameTransformations.Frames.point_name  —  Function point_name(point::AbstractFramePoint) Return the name of  point . source"},{"id":441,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.point_id","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.point_id","content":" FrameTransformations.Frames.point_id  —  Function point_id(point::AbstractFramePoint) Return the NAIF ID associated to  point . source"},{"id":442,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.build_point","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.build_point","content":" FrameTransformations.Frames.build_point  —  Function build_point(frames, name, NAIFId, class, axesid, funs; parentid, offset) Create and add a  FramePointNode  to  frames  based on the input parameters.  Current supported point classes are:  :RootPoint ,  :TimePoint ,  :EphemerisPoint ,  :FixedPoint  and  :UpdatablePoint . Inputs frames  – Target frame system  name  – Point name, must be unique within  frames NAIFId  – Point NAIF ID, must be unique within  frames class  – Point class.  axesid  – ID of the axes in which the state vector of the point is expressed.  funs  –  FramePointFunctions  object storing the functions to update the state            vectors of the point. It must match the type and order of  frames Keywords parentid  – NAIF ID of the parent point. Not required only for the root point. offset  – Position offset with respect to a parent point. Required only for FixedPoints. Warning This is a low-level function and is NOT meant to be directly used. Instead, to add a point  to the frame system, see  add_point_ephemeris! ,  add_point_fixed! , etc... source"},{"id":443,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector3","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector3","content":" FrameTransformations.Frames._get_comp_axes_vector3  —  Function _get_comp_axes_vector3(frame, v::ComputableAxesVector, axesid, t) Compute a 3-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position 2 : velocity 3 : acceleration  source"},{"id":444,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector6","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector6","content":" FrameTransformations.Frames._get_comp_axes_vector6  —  Function _get_comp_axes_vector6(frame, v::ComputableAxesVector, axesid, t) Compute a 6-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position, velocity 2 : velocity, acceleration 3 : acceleration, jerk source"},{"id":445,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector9","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector9","content":" FrameTransformations.Frames._get_comp_axes_vector9  —  Function _get_comp_axes_vector9(frame, v::ComputableAxesVector, axesid, t) Compute a 9-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position, velocity, acceleration 2 : velocity, acceleration, jerk Warning This function does not support orders of `v' higher than 2, because it would  require the computation of vectors of order 5, which is currently not supported. source"},{"id":446,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._get_comp_axes_vector12","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._get_comp_axes_vector12","content":" FrameTransformations.Frames._get_comp_axes_vector12  —  Function _get_comp_axes_vector12(frame, v::ComputableAxesVector, axesid, t) Compute a 12-elements vector in the desired axes at the given time between two points of the  frame system. The returned vector depends on the order in  v  as follows:  1 : position, velocity, acceleration, jerk Warning This function does not support orders of `v' higher than 1, because it would  require the computation of vectors of order 5 and 6, which are currently not supported. source"},{"id":447,"pagetitle":"Low-level API","title":"Two Vectors","ref":"/FrameTransformations/stable/Modules/frames_lapi/#Two-Vectors","content":" Two Vectors"},{"id":448,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_dcm","content":" FrameTransformations.Frames.twovectors_to_dcm  —  Function twovectors_to_dcm(a, b, seq) Generate a direction cosine matrix from two time-dependent vectors  a  and  b ,  following the directions specified in  seq .  Inputs a  – The primary vector that will be aligned with the first directions specified in  seq .  b  – The secondary vector. The component of this vector that is orthogonal to the         primary vector is aligned with the second direction specified in the sequence  seq . seq  – Accepted sequence directions are:        :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY Warning The primary and secondary vectors do not have to be orthogonal. However, a great loss of precision happens when the two vectors are almost aligned. This function does not perform  any check on the angular separation of the two vectors. The user should ensure that the  primary and secondary vector differ of at least 1 milliradian. source"},{"id":449,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δdcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δdcm","content":" FrameTransformations.Frames.twovectors_to_δdcm  —  Function twovectors_to_δdcm(a, b, seq) Compute the time derivative of a direction cosine matrix generated from two time-dependent  state vectors  a  and  b , following the directions specified in  seq .  Inputs a  and  b  – 6-elements state vectors (position and velocity). seq  – Accepted sequence directions are:        :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY source"},{"id":450,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ³dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ³dcm","content":" FrameTransformations.Frames.twovectors_to_δ³dcm  —  Function twovectors_to_δ³dcm(a, b, seq) Compute the 3rd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors  a  and  b , following the directions specified in  seq .  Inputs a  and  b  – 12-elements state vectors (position, velocity, acceleration and jerk). seq  – Accepted sequence directions are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY source"},{"id":451,"pagetitle":"Low-level API","title":"FrameTransformations.Frames.twovectors_to_δ²dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames.twovectors_to_δ²dcm","content":" FrameTransformations.Frames.twovectors_to_δ²dcm  —  Function twovectors_to_δ²dcm(a, b, seq) Compute the 2nd-order time derivative of a direction cosine matrix generated from two  time-dependent state vectors  a  and  b , following the directions specified in  seq .  Inputs a  and  b  – 9-elements state vectors (position velocity and acceleration). seq  – Accepted sequence directions are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY source"},{"id":452,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._twovectors_to_dcm","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._twovectors_to_dcm","content":" FrameTransformations.Frames._twovectors_to_dcm  —  Function _twovectors_to_dcm(a, b, seq::Symbol, fc::Function, fn::Function, fk::Function) Generate a direction cosine matrix and/or its time derivatives from the vectors  a  and  b ,  according to the directions specifeid in  seq .  Notes fc  and  fn  are used to control the derivative order.  source"},{"id":453,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot6","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot6","content":" FrameTransformations.Frames._two_vectors_to_rot6  —  Function _two_vectors_to_rot6(a, b, seq::Symbol) Generate a direction cosine matrix and time-derivative, minimising  the number of repeated computations.  See also See  twovectors_to_dcm  and  twovectors_to_δdcm  for more information.  source"},{"id":454,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot9","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot9","content":" FrameTransformations.Frames._two_vectors_to_rot9  —  Function _two_vectors_to_rot9(a, b, seq::Symbol) Generate a direction cosine matrix and its 1st and 2nd-order time-derivatives, minimising  the number of repeated computations.  See also See  twovectors_to_dcm  and  twovectors_to_δ²dcm  for more information.  source"},{"id":455,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_to_rot12","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_to_rot12","content":" FrameTransformations.Frames._two_vectors_to_rot12  —  Function _two_vectors_to_rot12(a, b, seq::Symbol) Generate a direction cosine matrix and its 1st, 2nd and 3r-order time-derivatives, minimising  the number of repeated computations.  See also See  twovectors_to_dcm  and  twovectors_to_δdcm  for more information.  source"},{"id":456,"pagetitle":"Low-level API","title":"FrameTransformations.Frames._two_vectors_basis","ref":"/FrameTransformations/stable/Modules/frames_lapi/#FrameTransformations.Frames._two_vectors_basis","content":" FrameTransformations.Frames._two_vectors_basis  —  Function _two_vectors_basis(a, b, seq::Symbol, fc::Function, fk::Function) Generate a 3D right-handed orthogonal vector basis and/or its time derivatives from the  vectors  a  and  b , according to the directions specified in  seq  and the input cross  function  fc .  fk  is a function that filters  a  to guarantee type-stability. The accepted sequence directions are:  :XY ,  :YX ,  :XZ ,  :ZX ,  :YZ ,  :ZY The standard basis, its 1st, 2nd-order and 3rd order time derivatives can be computed by  passing  cross ,  cross6 ,  cross9  or  cross12  to  fc . The returned vectors will have  a length of 3, 6 or 9, respectively. source"},{"id":459,"pagetitle":"Public API","title":"Orient's Public Documentation","ref":"/FrameTransformations/stable/Modules/orient_api/#basic_orient_api","content":" Orient's Public Documentation"},{"id":460,"pagetitle":"Public API","title":"IAU Models","ref":"/FrameTransformations/stable/Modules/orient_api/#iers_models","content":" IAU Models This is a list of the supported IAU models and their approximations that can be used to select the desired procedure for the computation of the ITRF to GCRF rotation."},{"id":461,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2000a","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2000a","content":" FrameTransformations.Orient.iau2000a  —  Constant iau2000a The singleton instance of type  IAU2006a , representing the IAU 2000B family of models. source"},{"id":462,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2000b","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2000b","content":" FrameTransformations.Orient.iau2000b  —  Constant iau2000b The singleton instance of type  IAU2006a , representing the IAU 2000B family of models. source"},{"id":463,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2006a","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2006a","content":" FrameTransformations.Orient.iau2006a  —  Constant iau2006a The singleton instance of type  IAU2006a , representing the IAU 2006A family of models. source"},{"id":464,"pagetitle":"Public API","title":"FrameTransformations.Orient.iau2006b","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.iau2006b","content":" FrameTransformations.Orient.iau2006b  —  Constant iau2006b The singleton instance of type  IAU2006B , representing the IAU 2006B family of models. Note This is not an official IERS model. source"},{"id":465,"pagetitle":"Public API","title":"FrameTransformations.Orient.CPNc","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.CPNc","content":" FrameTransformations.Orient.CPNc  —  Constant CPNc The singleton instance of type  CPNC , representing the concise CPNc from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few mas. source"},{"id":466,"pagetitle":"Public API","title":"FrameTransformations.Orient.CPNd","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.CPNd","content":" FrameTransformations.Orient.CPNd  —  Constant CPNd The singleton instance of type  CPND , representing the concise CPNd from Capitaine &  Wallace, Concise CIO based precession-nutation formulations, (2008). This model truncates  the X, Y series to deliver an accuracy of few arcseconds. source"},{"id":467,"pagetitle":"Public API","title":"EOP Data","ref":"/FrameTransformations/stable/Modules/orient_api/#EOP-Data","content":" EOP Data"},{"id":468,"pagetitle":"Public API","title":"FrameTransformations.Orient.init_eop","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.init_eop","content":" FrameTransformations.Orient.init_eop  —  Function init_eop(filename) Initialize Earth Orientation Parameters (EOP) from file.   Warn This function must be called to initialize the EOP data used by frames, in case  Earth-associated frames are used.   Warn This function accept only  .eop.dat  files. Please use  prepare_eop  to transform  IERS EOP files in this format. source"},{"id":469,"pagetitle":"Public API","title":"FrameTransformations.Orient.prepare_eop","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.prepare_eop","content":" FrameTransformations.Orient.prepare_eop  —  Function prepare_eop(iers_file::AbstractString, output_filename::AbstractString=\"iau2000a\") Prepare Earth Orientation Parameters (EOP) data from IERS EOP C04 files to JSMD's  eop.dat   convenience format. The  output_filename  should not include the file extension, which is  automatically added by this function.  # Save a new file called: test.eop.dat\nprepare_eop(\"input.csv\", \"test\") source"},{"id":470,"pagetitle":"Public API","title":"FrameTransformations.Orient.eop_data_filename","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.eop_data_filename","content":" FrameTransformations.Orient.eop_data_filename  —  Function eop_data_filename() Get loaded Earth Orientation Parameters (EOP) filename. source"},{"id":471,"pagetitle":"Public API","title":"FrameTransformations.Orient.IERS_EOP","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.IERS_EOP","content":" FrameTransformations.Orient.IERS_EOP  —  Constant IERS_EOP Earth Orientation Parameters interpolators: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values  at 1-day intervals) with respect to IAU 2006/2000A precession-nutation model and consistent  with ITRF2014. See also:  EOPInterpolator source"},{"id":472,"pagetitle":"Public API","title":"IERS Transformations","ref":"/FrameTransformations/stable/Modules/orient_api/#IERS-Transformations","content":" IERS Transformations"},{"id":473,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot3_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot3_itrf_to_gcrf  —  Function orient_rot3_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  at time  t  expressed as  TT seconds since  J2000 , according to the IAU Model  m , as follows: IAU2000A : the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2000A model. IAU2000B : only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation    matrix is computed following the IAU 2000 model but with truncated expressions for the    nutation corrections.  IAU2006A : the pole coordinates (xₚ, yₚ) and the free-core nutation and time corrections    to the CIP coordinates (dX, dY) are interpolated from the latest released IERS EOP data.    The precession-nutation matrix is computed using the full IAU 2006/2000A model. IAU2006B : only the pole coordinates (xₚ, yₚ) are interpolated from the latest EOP data.    The Free Core Nutation (FCN) corrections dX, dY are neglected. The precession-nutation   matrix is computed following the IAU 2006A model but with truncated expressions for the    nutation corrections.  CPNc : a concise model with a cut-off at 2.5 mas of the X and Y series, delivering a    worst-case accuracy of about 15 mas between 1995-2050. It does not take into account the    Free Core Nutation (~0.2 mas).  CPNd : an extremely concise formulation with an accuracy of about 1 arcsec between 1995    and 2050. It neglects polar-motion (~0.25 arcsec), the FCN corrections and the CIO locator.  References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations source orient_rot3_itrf_to_gcrf(m::IAUModel, tt, ut1, xₚ, yₚ, dX=0.0, dY=0.0) Compute the rotation matrix from ITRF to GCRF according to the IAU Model  m , at time  tt   and  ut1  expressed in TT seconds and  UT1  days since  J2000 , respectively.   This function has been implemented for  IAU2000 ,  IAU2006  and  CPN  models. Note All the input quantities  xₚ ,  yₚ ,  dX  and  dY  must be expressed in radians source"},{"id":474,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot6_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot6_itrf_to_gcrf  —  Function orient_rot6_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  and its derivative at time  t   expressed as TT seconds since  J2000 , according to the the IAU Model  m . source"},{"id":475,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot9_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot9_itrf_to_gcrf  —  Function orient_rot9_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  and its time derivatives up to order 2 at  time  t  expressed as TT seconds since  J2000 , according to the IAU Model  m . source"},{"id":476,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot12_itrf_to_gcrf","content":" FrameTransformations.Orient.orient_rot12_itrf_to_gcrf  —  Function orient_rot12_itrf_to_gcrf(m::IAUModel, t::Number) Compute the rotation matrix from  ITRF  to  GCRF  and its time derivatives up to order 3 at  time  t  expressed as TT seconds since  J2000 , according to the IAU Model  m . source"},{"id":477,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_bias_precession","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession","content":" FrameTransformations.Orient.orient_bias_precession  —  Function orient_bias_precession(m::IAUModel, t::Number) Form the precession-frame bias (PB) matrix that transforms vectors from the GCRS to the  mean of date, following the IAU Model  m  at time  t  expressed as  TT  Julian centuries  since  J2000 . The function has been implemented for the  IAU2000  and  IAU2006  models. References: IAU: Trans. International Astronomical Union, Vol. XXIVB;  Proc. 24th General Assembly,  Manchester, UK.  Resolutions B1.3, B1.6. (2000) Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with IAU  2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  pmat06  function. ERFA  pmat00  function. source"},{"id":478,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_bias_precession_nutation","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_bias_precession_nutation","content":" FrameTransformations.Orient.orient_bias_precession_nutation  —  Function orient_bias_precession_nutation(m::IAUModel, t::Number) Compute the equinox-based bias-precession-nutation matrix using the IAU Model  m  procedures  at time  t  expressed in  TT  Julian centuries since  J2000 . The function has been implemented for the  IAU2000  and  IAU2006  models. Note The computed matrix rotates a vector from the GCRS to the true equatorial triad of date. References ERFA  pn06  function ERFA  pn00  function source"},{"id":479,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_gast","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_gast","content":" FrameTransformations.Orient.orient_gast  —  Function orient_gast(m::IAUModel, t::Number) Compute the Greenwich Apparent Sidereal Time (GAST), in radians, given time  t  as  TT  Julian  centuries since  J2000  according to the IAU Model  m . Note For the IAU2000B model, as an approximation ERFA uses UT1 instead of TDB (or TT) to  compute the precession component of GMST and the equation of the equinoxes. This  approximation is not performed in this framework. Note This function computes the Earth Rotation Angle (ERA) by automatically converting TT to  UT1. Lower-level interfaces are also available to minimise the number of repeated  computations.  See also See also  orient_gmst . source orient_gast(m::IAUModel, t::Number, θ::Number) Compute the Greenwich Apparent Sidereal Time (GAST), in radians, given time  t  as  TT   Julian centuries since  J2000  and the Earth Rotation Angle (ERA)  θ , in radians, according  to the IAU Model  m . The function has been implemented for the IAU2000 and IAU2006 models. References ERFA gst00a  routine. ERFA gst06a  routine. source"},{"id":480,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_gmst","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_gmst","content":" FrameTransformations.Orient.orient_gmst  —  Function orient_gmst(::IAUModel, t::Number) Compute the Greenwich Mean Sidereal Time (GMST), in radians, according to the IAU Model  m ,  given time  tt  expressed in  TT  Julian centuries since  J2000 .  Note This function is valid for the IAU2000 and IAU2006 models only. Note This function computes the Earth Rotation Angle (ERA) by automatically converting TT to  UT1. Lower-level interfaces are also available to minimise the number of repeated  computations.  See also See also  orient_gast . source orient_gmst(m::IAU1980Model, ut1::Number) Compute the Greenwich Mean Sidereal Time (GMST), in radians, according to the IAU 1980  models, given time  ut1  expressed in  UT1  Julian centuries since  J2000 .  References ERFA gmst82  routine. source orient_gmst(m::IAUModel, tt::Number, θ::Number) Compute the Greenwich Mean Sidereal Time (GMST), in radians, according to the IAU Model  m ,  given the Earth Rotation Angle (ERA)  θ , in radians and the time  tt  expressed in  TT   Julian centuries since  J2000 .  The function has been implemented for the IAU2000 and IAU2006 models. References ERFA gmst00  routine. ERFA gmst06  routine. source"},{"id":481,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_nutation","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_nutation","content":" FrameTransformations.Orient.orient_nutation  —  Function orient_nutation(m::IAUModel, t::Number) Compute the nutation components in longitude and obliquity for the IAU Model  m , in radians,  at time  t  expressed in  TT  Julian Centuries since  J2000 . Notes Due to their theoretical basis, the original developments required  t  expressed as TDB.  However, in practice, it is usually more convenient to use Terrestrial Time (TT) as it makes  no significant differences (< 0.01 μas) in the final result. For the  IAU 2006A  model, the function strictly follows the SOFA implementation. It first  computes the IAU 2000A nutation, then applies adjustments for the consequences of the change  in obliquity from the IAU 1980 ecliptic to the IAU 2006 ecliptic and (ii) for the secular  variation in the Earth's dynamical form factor J2. These corrections ensure that the IAU  2000A nutation is consistent with the IAU 2006 precession model. Please note that the  coefficients available on the IERS tables already include those corrections, and are  retrieved by multiplying the amplitudes of the SOFA nutation in longitude coefficients by  1.00000047.  The computation of the free-core nutation and time dependent effects are excluded from this  model. To achieve the < 1μas accuracy with the IAU 2006/2000 A precession-nutation models,  such effects must be included a-posteriori (through dX and dY) using the IERS EOP data. For the  IAU 2000B  model, the nutation series is truncated from nearly 1400 terms to only 77,  yet it still delivers results of 1 mas accuracy at present epochs. In particular, it delivers  a pole accurate to 1 mas from 1900 to 2100 (only very occasionally just outside 1 mas).  The coefficients are taken from SOFA's implementation, which slighlty differ from those  reported in McCarthy and Luzum (2003). Comparisons with IAU 2006A show that the SOFA version  between 1995 and 2050 delivers 0.283 mas RMSE (0.994 mas in the worst case), whereas the  IERS Conventions website version delivers 0.312 RMSE (1.125 mas in the worst case). The  IAU 2000B  model includes constant planetary bias terms that compensate for long-period  nutations. These amplitudes used in this implementation are optimised for a  rigorous  method,  where frame bias, precession and nutation are applied separately and in that order  (see SOFA's documentation for further insights). A simplified version of the Fundamental Arguments, taken from Simon et al (1994) is exploited  for IAU2000B as the error introduced is below the model accuracy ( ~0.1 mas). References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Simon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets. ERFA  nut06a  and   nut00b  functions  source"},{"id":482,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_obliquity","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_obliquity","content":" FrameTransformations.Orient.orient_obliquity  —  Function orient_obliquity(m::IAUModel, t::Number) Compute the mean obliquity of the ecliptic at epoch, in radians, at time  t  expressed  in  TT  Julian centuries since  J2000 .  Note This function is implemented only for  IAU1980  and  IAU2006  models. IAU 2000 Models  implement proper precession-rate corrections to the IAU1980 mean obliquity.  References ERFA  obl80  and   obl06  functions. source"},{"id":483,"pagetitle":"Public API","title":"Moon Transformations","ref":"/FrameTransformations/stable/Modules/orient_api/#Moon-Transformations","content":" Moon Transformations"},{"id":484,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa421","content":" FrameTransformations.Orient.orient_rot3_icrf_to_pa421  —  Function orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, t::Number) Compute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the given  input time  t , expressed in seconds since  J2000 .  Warning This function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions. source orient_rot3_icrf_to_pa421(eph::AbstractEphemerisProvider, ep::Epoch) Compute the rotation matrix from the ICRF to the DE421 Moon's Principal Axes at the input  epoch  ep . source"},{"id":485,"pagetitle":"Public API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pa440","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.orient_rot3_icrf_to_pa440","content":" FrameTransformations.Orient.orient_rot3_icrf_to_pa440  —  Function orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, t::Number) Compute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the given  input time  t , expressed in seconds since  J2000 .  Warning This function is not optimised for performance (it allocates!). The user is suggested  to retrieve the Principal axes orientation using the dedicated Frame System functions. source orient_rot3_icrf_to_pa440(eph::AbstractEphemerisProvider, ep::Epoch) Compute the rotation matrix from the ICRF to the DE440 Moon's Principal Axes at the input  epoch  ep . source"},{"id":486,"pagetitle":"Public API","title":"Geodesy","ref":"/FrameTransformations/stable/Modules/orient_api/#Geodesy","content":" Geodesy"},{"id":487,"pagetitle":"Public API","title":"FrameTransformations.Orient.geoc2pos","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.geoc2pos","content":" FrameTransformations.Orient.geoc2pos  —  Function geoc2pos(r::Number, λ::Number, ϕ::Number)\ngeoc2pos(geoc::AbstractArray) Transform geocentric coordinates in a cartesian position vector, given the longitude  λ ,  the geocentric latitude  ϕ  and the radius  r . source"},{"id":488,"pagetitle":"Public API","title":"FrameTransformations.Orient.pos2geoc","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.pos2geoc","content":" FrameTransformations.Orient.pos2geoc  —  Function pos2geoc(pos::AbstractVector) Transform a cartesian 3-elements position vector  pos  into radius, longitude and geocentric  latitude, respectively. source"},{"id":489,"pagetitle":"Public API","title":"FrameTransformations.Orient.geod2pos","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.geod2pos","content":" FrameTransformations.Orient.geod2pos  —  Function geod2pos(h::Number, λ::Number, ϕ::Number, R::Number, f::Number) Transform longitude  λ , geodetic latitude  ϕ  and altitude over the reference ellipsoid to  a cartesian position vector, given the reference radius  R  and the flattening  f . References Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA. source"},{"id":490,"pagetitle":"Public API","title":"FrameTransformations.Orient.pos2geod","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.pos2geod","content":" FrameTransformations.Orient.pos2geod  —  Function pos2geod(pos::AbstratVector, R::Number, f::Number, toll::Number=1e-12) Transform a cartesian 3-elements position vector  pos  into longitude, geodetic latitude  and altitude over the reference ellipsoid with radius  R  and flattening  f .  References Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA. source"},{"id":491,"pagetitle":"Public API","title":"Axes ID","ref":"/FrameTransformations/stable/Modules/orient_api/#orient_axesid","content":" Axes ID This is a list of NAIF IDs for standard axes that are used in astrodynamic applications.  Note Although they are listed in the public documentation section, these IDs are not directly exported by the package."},{"id":492,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_B1950","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_B1950","content":" FrameTransformations.Orient.AXESID_B1950  —  Constant AXESID_B1950 NAIF Axes ID for the Mean Equator and Dynamical Equinox of the Besselian year 1950.  source"},{"id":493,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_ECLIPB1950","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_ECLIPB1950","content":" FrameTransformations.Orient.AXESID_ECLIPB1950  —  Constant AXESID_ECLIPB1950 NAIF Axes ID for the Mean Ecliptic Equinox of B1950. source"},{"id":494,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_ECLIPJ2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_ECLIPJ2000","content":" FrameTransformations.Orient.AXESID_ECLIPJ2000  —  Constant AXESID_ECLIPJ2000 NAIF Axes ID for the Mean Ecliptic Equinox of J2000 (ECLIPJ2000)  source"},{"id":495,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_FK4","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_FK4","content":" FrameTransformations.Orient.AXESID_FK4  —  Constant AXESID_FK4 NAIF Axes ID for the FK4 reference frame. source"},{"id":496,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_GALACTIC","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_GALACTIC","content":" FrameTransformations.Orient.AXESID_GALACTIC  —  Constant AXESID_GALACTIC NAIF Axes ID for the Galactic System II reference frame. source"},{"id":497,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_GCRF","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_GCRF","content":" FrameTransformations.Orient.AXESID_GCRF  —  Constant AXESID_GCRF Axes ID for the Geocentric Celestial Reference Frame (GCRFF) Note Although the ICRF and GCRF axes are identical, they are based upon a different  timescale. A different ID is here assigned to provide a robust way of distinguishing  between the two. 23 has been chosen because it is one the unassigned axes ID among the  built-in SPICE frames. source"},{"id":498,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_ICRF","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_ICRF","content":" FrameTransformations.Orient.AXESID_ICRF  —  Constant AXESID_ICRF NAIF Axes ID for the International Celestial Reference Frame (ICRF) source"},{"id":499,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_ITRF","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_ITRF","content":" FrameTransformations.Orient.AXESID_ITRF  —  Constant AXESID_ITRF NAIF Axes ID for the International Terrestrial Reference Frame (ITRF) Note This ID is based upon the ID used to refer to the ITRF93 in NAIF's high-accuracy  Earth rotation model PCK kernels. source"},{"id":500,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MEME2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MEME2000","content":" FrameTransformations.Orient.AXESID_MEME2000  —  Constant AXESID_MEME2000 Axes ID for the Mean Dynamical Equator and Equinox of J2000.0.  Note In SPICE the J2000 and ICRF axes are considered equal, thus there exist no  specific NAIF ID for the MEME2000 axes. 22 has been chosen because it is the  first unassigned axes ID among the built-in SPICE frames.  source"},{"id":501,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MOONME_DE421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONME_DE421","content":" FrameTransformations.Orient.AXESID_MOONME_DE421  —  Constant AXESID_MOONME_DE421 NAIF axes id for the DE421 Moon Mean Earth/Mean Rotation axes  (ME421). source"},{"id":502,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE421","content":" FrameTransformations.Orient.AXESID_MOONPA_DE421  —  Constant AXESID_MOONPA_DE421 NAIF axes id for the DE421 Moon Principal Axes (PA421). source"},{"id":503,"pagetitle":"Public API","title":"FrameTransformations.Orient.AXESID_MOONPA_DE440","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.AXESID_MOONPA_DE440","content":" FrameTransformations.Orient.AXESID_MOONPA_DE440  —  Constant AXESID_MOONPA_DE440 NAIF Axes id for the DE440 Moon Principal Axes (PA440). source"},{"id":504,"pagetitle":"Public API","title":"Default Rotation Matrices","ref":"/FrameTransformations/stable/Modules/orient_api/#orient_dcms","content":" Default Rotation Matrices Note Although they are listed in the public documentation section, the rotation matrices of some older frames (e.g., B1950, FK4 and GALACTIC) are not exported by the package."},{"id":505,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_B1950_TO_ECLIPB1950","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_B1950_TO_ECLIPB1950","content":" FrameTransformations.Orient.DCM_B1950_TO_ECLIPB1950  —  Constant DCM_B1950_TO_ECLIPB1950 DCM for the rotation from the Mean Equator and Dynamical Equinox of B1950 ( MEMEB1950 ) to the Mean Ecliptic Equinox of B1950. This corresponds to the transformation  B1950 -> ECLIPB1950   in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory. References SPICE  Library source"},{"id":506,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_B1950_TO_FK4","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_B1950_TO_FK4","content":" FrameTransformations.Orient.DCM_B1950_TO_FK4  —  Constant DCM_B1950_TO_FK4 DCM for the rotation from the Mean Equator and Dynamical Equinox of B1950 ( MEMEB1950 ) ot  the FK4 reference frame.  Note The FK4 reference frame is obtained from the B1950 frame by applying the equinox offset  determined by Fricke. References SPICE  Library source"},{"id":507,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000","content":" FrameTransformations.Orient.DCM_ICRF_TO_ECLIPJ2000  —  Constant DCM_ICRF_TO_ECLIPJ2000 DCM for the rotation from the International Celestial Reference Frame ( ICRF ) to the  Mean Ecliptic Equinox of J2000 ( ECLIPJ2000 ). source"},{"id":508,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_ICRF_TO_MEME2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_ICRF_TO_MEME2000","content":" FrameTransformations.Orient.DCM_ICRF_TO_MEME2000  —  Constant DCM_ICRF_TO_MEME2000 DCM for the rotation from the International Celestial Reference Frame ( ICRF ) and the  Mean Equator and Equinox of J2000.0 ( MEME2000 ). This corresponds to the  J2000  frame in  the SPICE toolkit. Note The frame bias is here computed using the IAU 2006 Precession model, similarly to ESA's  GODOT. Some other software libraries, such as Orekit, use the frame bias of the IAU 2000  precession model. The two definitions differ of about 1 arcsecond. Moreover, according to  Hilton   there are multiple possibilities to define the proper rotation between the ICRS and  the MEME2000. The transformation implemented here correspond to Eq. 6 using the parameters  in Table 3, line 1 (RIERS). References Hilton, James L., and Catherine Y. Hohenkerk. – Rotation matrix from the mean    dynamical equator and equinox at J2000. 0 to the ICRS. – Astronomy & Astrophysics    513.2 (2004): 765-770. DOI:  10.1051/0004-6361:20031552 SOFA docs source"},{"id":509,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_FK4_TO_GALACTIC","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_FK4_TO_GALACTIC","content":" FrameTransformations.Orient.DCM_FK4_TO_GALACTIC  —  Constant DCM_FK4_TO_GALACTIC DCM for the rotation from the FK4 frame to the Galactic System II reference frame. Note As the SPICE toolkit, we assume that this rotation is derived from the FK4 frame. References SPICE  Library source"},{"id":510,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MEME2000_TO_ECLIPJ2000","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MEME2000_TO_ECLIPJ2000","content":" FrameTransformations.Orient.DCM_MEME2000_TO_ECLIPJ2000  —  Constant DCM_MEME2000_TO_ECLIPJ2000 DCM for the rotation from the Mean Equator and Equinox of J2000 ( MEME2000 ) to the  Mean Ecliptic Equinox. This corresponds to the transformation  J2000 -> ECLIPJ2000   in the SPICE toolkit, and uses the mean obliquity of the ecliptic from the IAU 1976 theory. source"},{"id":511,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MEME2000_TO_B1950","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MEME2000_TO_B1950","content":" FrameTransformations.Orient.DCM_MEME2000_TO_B1950  —  Constant DCM_MEME2000_TO_B1950 DCM for the rotation from the Mean Equator and Equinox of J2000.0 ( MEME2000 ) to the Mean Equator and Dynamical Equinox of B1950 ( B1950 ). Note This rotation is obtained by precessing the J2000 frame backwards from Julian year 2000  to Besselian year 1950, using the 1976 IAU precession model. The rotation values  are taken from the SPICE toolkit.  References SPICE  Library source"},{"id":512,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421","content":" FrameTransformations.Orient.DCM_MOON_PA421_TO_ME421  —  Constant DCM_MOON_PA421_TO_ME421 DCM for the rotation from the Moon Principal Axis 421 (PA421) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes. References J. G. Williams et al. (2008),  DE421 Lunar Orbit, Physical Librations, and Surface Coordinates ,    DE421 Lunar Ephemeris and Orientation source"},{"id":513,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421","content":" FrameTransformations.Orient.DCM_MOON_PA430_TO_ME421  —  Constant DCM_MOON_PA430_TO_ME421 DCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes. References Folkner M. William et al. (2014),  The Planetary and Lunar EphemeridesDE430 and DE431 J. G. Williams et al. (2013),  DE430 Lunar Orbit, Physical Librations, and Surface Coordinates ,    DE430 Lunar Ephemeris and Orientation source"},{"id":514,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430","content":" FrameTransformations.Orient.DCM_MOON_PA430_TO_ME430  —  Constant DCM_MOON_PA430_TO_ME430 DCM for the rotation from the Moon Principal Axis 430 (PA430) to the Moon Mean  Earth/Mean Rotation DE430 (ME430) axes. References Folkner M. William et al. (2014),  The Planetary and Lunar EphemeridesDE430 and DE431 J. G. Williams et al. (2013),  DE430 Lunar Orbit, Physical Librations, and Surface Coordinates ,    DE430 Lunar Ephemeris and Orientation source"},{"id":515,"pagetitle":"Public API","title":"FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","ref":"/FrameTransformations/stable/Modules/orient_api/#FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421","content":" FrameTransformations.Orient.DCM_MOON_PA440_TO_ME421  —  Constant DCM_MOON_PA440_TO_ME421 DCM for the rotation from the Moon Principal Axis 440 (PA440) to the Moon Mean  Earth/Mean Rotation DE421 (ME421) axes. References Park, S. R. et al. (2021),  The JPL Planetary and Lunar Ephemerides DE440 and DE441 ,   DOI: 10.3847/1538-3881/abd414 source"},{"id":518,"pagetitle":"Low-level API","title":"Orient's Low-level API","ref":"/FrameTransformations/stable/Modules/orient_lapi/#low_orient_api","content":" Orient's Low-level API Although this routines are not meant to be used outside of the package, they are here documented to aid future developments or to help users that require specific computations."},{"id":519,"pagetitle":"Low-level API","title":"Outdated IAU Models","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Outdated-IAU-Models","content":" Outdated IAU Models"},{"id":520,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.iau1980","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.iau1980","content":" FrameTransformations.Orient.iau1980  —  Constant iau1980 The singleton instance of type  IAU1980 , representing the IAU 1980 family of models. source"},{"id":521,"pagetitle":"Low-level API","title":"Fundamental Arguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Fundamental-Arguments","content":" Fundamental Arguments"},{"id":522,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.FundamentalArguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.FundamentalArguments","content":" FrameTransformations.Orient.FundamentalArguments  —  Type FundamentalArguments{N <: Number} Type storing the fundamental luni-solar and planetary arguments. Fields Mₐ  – Mean anomaly of the Moon  Sₐ  – Mean anomaly of the Sun uₘ  – Mean longitude of the Moon minus mean longitude of the ascending node  F Dₛ  – Mean elongation of the Moon from the Sun  Ωₘ  – Mean longitude of the Moon's ascending node λ_Me  – Mercury's mean heliocentric longitude λ_Ve  – Venus's mean heliocentric longitude λ_Ea  – Earth's mean heliocentric longitude λ_Ma  – Mars's mean heliocentric longitude λ_Ju  – Jupiter's mean heliocentric longitude λ_Sa  – Saturn's mean heliocentric longitude λ_Ur  – Uranus's mean heliocentric longitude λ_Ne  – Neptune's mean heliocentric longitude pₐ  – General precession in longitude source"},{"id":523,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.LuniSolarArguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.LuniSolarArguments","content":" FrameTransformations.Orient.LuniSolarArguments  —  Function LuniSolarArguments(t::Number, m::IAUModel) Compute the fundamental (Delaunay) Luni-Solar arguments, in radians, associated to the  desired IAU model  m , at time  t  expressed in  TDB  Julian centuries since  J2000 . The returned values depend on the input model as follows:  IAU2006A : the Delaunay expressions are taken from the IERS 2010 Conventions. IAU2000B : the expressions are taken from Simon et al. (1994), following ERFA's   implementation of nut00b.c Outputs Mₐ  – Mean anomaly of the Moon Sₐ  – Mean anomaly of the Sun uₘ  – Mean longitude of the Moon minus mean longitude of the         ascending node  F Dₛ  – Mean elongation of the Moon from the Sun Ωₘ  – Mean longitude of the Moon's ascending node References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 Simon, J. et al., (1994), Numerical expressions for precession formulae and mean elements for the  Moon and the planets. ERFA  software library source"},{"id":524,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.PlanetaryArguments","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.PlanetaryArguments","content":" FrameTransformations.Orient.PlanetaryArguments  —  Function PlanetaryArguments(t::Number) Compute the fundamental planetary arguments and the general precession, in radians,  at time  t  expressed in  TDB  Julian centuries since  J2000 . Outputs λ☿  – Mercury's mean heliocentric longitude. λ♀  – Venus's mean heliocentric longitude. λe  – Earth's mean heliocentric longitude. λ♂  – Mars's mean heliocentric longitude. λ♃  – Jupiter's mean heliocentric longitude. λ♄  – Saturn's mean heliocentric longitude. λ⛢  – Uranus's mean heliocentric longitude. λ♆  – Neptune's mean heliocentric longitude. pλ  – General precession in longitude. References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 source"},{"id":525,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mano_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_moon","content":" FrameTransformations.Orient.fa_mano_moon  —  Function fa_mano_moon(t::Number) Return the mean anomaly of the Moon  Mₐ , in radians, at time  t  expressed in  TDB  Julian  centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":526,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mano_sun","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mano_sun","content":" FrameTransformations.Orient.fa_mano_sun  —  Function fa_mano_sun(t::Number) Return the mean anomaly of the Sun  Sₐ  in radians, at time  t  expressed in  TDB  Julian  centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":527,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_moon","content":" FrameTransformations.Orient.fa_mlon_moon  —  Function fa_mlon_moon(t::Number) Return the mean longitude of the Moon's ascending node  Ω  in radians, at time  t  expressed in  TDB  Julian centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":528,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlat_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlat_moon","content":" FrameTransformations.Orient.fa_mlat_moon  —  Function fa_mlat_moon(t::Number) Return the mean longitude of the Moon minus the mean longitude of the ascending node  F  in radians, at time  t  expressed in  TDB  Julian centuries since  J2000 .   References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":529,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_melo_moon","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_melo_moon","content":" FrameTransformations.Orient.fa_melo_moon  —  Function fa_melo_moon(t::Number) Return the mean elongation of the Moon from the Sun  D  in radians, at time  t  expressed in   TDB  Julian centuries since  J2000 . References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":530,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_precession","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_precession","content":" FrameTransformations.Orient.fa_precession  —  Function fa_precession(t::Number)  Return the general accumulated precession in longitude  pₐ  in radians, at time  t   expressed in  TDB  Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":531,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mercury","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mercury","content":" FrameTransformations.Orient.fa_mlon_mercury  —  Function fa_mlon_mercury(t::Number) Return the mean heliocentric longitude of Mercury in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":532,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_venus","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_venus","content":" FrameTransformations.Orient.fa_mlon_venus  —  Function fa_mlon_venus(t::Number) Return the mean heliocentric longitude of Venus in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":533,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_earth","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_earth","content":" FrameTransformations.Orient.fa_mlon_earth  —  Function fa_mlon_earth(t::Number) Return the mean heliocentric longitude of Earth in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":534,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_mars","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_mars","content":" FrameTransformations.Orient.fa_mlon_mars  —  Function fa_mlon_mars(t::Number) Return the mean heliocentric longitude of Mars in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":535,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_jupiter","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_jupiter","content":" FrameTransformations.Orient.fa_mlon_jupiter  —  Function fa_mlon_jupiter(t::Number) Return the mean heliocentric longitude of Jupiter in radians, at time  t  expressed in  TDB  Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":536,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_saturn","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_saturn","content":" FrameTransformations.Orient.fa_mlon_saturn  —  Function fa_mlon_saturn(t::Number) Return the mean heliocentric longitude of Saturn in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":537,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_uranus","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_uranus","content":" FrameTransformations.Orient.fa_mlon_uranus  —  Function fa_mlon_uranus(t::Number) Return the mean heliocentric longitude of Uranus in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":538,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fa_mlon_neptune","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fa_mlon_neptune","content":" FrameTransformations.Orient.fa_mlon_neptune  —  Function fa_mlon_neptune(t::Number) Return the mean heliocentric longitude of Neptune in radians, at time  t  expressed in  TDB   Julian centuries since  J2000 .  References Luzum, B. and Petit G. (2012). The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  software library source"},{"id":539,"pagetitle":"Low-level API","title":"Precession","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Precession","content":" Precession"},{"id":540,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.frame_bias","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.frame_bias","content":" FrameTransformations.Orient.frame_bias  —  Function frame_bias(::IAU2000Model) Compute the frame bias components of the IAU 2000 precession-nutation models, in radians. Notes The frame bias corrections in longitude and obliquity are required to correct for the  offset between the GCRS pole and the mean  J2000  pole. They define, with respect  to the GCRS axes, a J2000 mean pole that is consistent with teh IAU 2000A precession-nutation  model.  The function also returns an offset in right ascension taken from Chapront et al. (2002), necessary to completely describe the frame bias, but that is not part of the original IAU  2000A model. References ERFA  software library source"},{"id":541,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fw_angles","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fw_angles","content":" FrameTransformations.Orient.fw_angles  —  Function fw_angles(m::IAU2006Model, t::Number) Compute the precession angles in radians, following the IAU 2006 Fukushima-Williams 4-angle  formulation at time  t  expressed in  TT  Julian centuries since  J2000 . Outputs γ  – F-W 1st angle ϕ  – F-W 2nd angle ψ  – F-W 3rd angle    ε  – F-W 4th angle References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":542,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fw_matrix","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fw_matrix","content":" FrameTransformations.Orient.fw_matrix  —  Function fw_matrix(γ, ϕ, ψ, ε) Form the Nutation-Precession-Bias (NPB) rotation matrix given the Fukushima-Williams angles,  expressed in radians. The present function can construct three different matrices depending on which angles are  supplied as arguments:  NPB : To obtain the Nutation-Precession-Bias matrix, generate the four standard FW    precession angles (̄γ, ̄ϕ, ̄ψ, ϵₐ) then generate the nutation components Δψ and Δϵ and add them    to ̄ψ, ϵₐ. Finally, call the present functions using those four angles as arguments.  PB : To obtain the precession-frame bias matrix, generate the four standard FW precession    angles and call the present function.  B : To obtain the frame bias matrix, generate the four standard FW precession angles at    date J2000.0 and call this function. The remaining nutation-only and precession only matrices can be obtained by combining these  three appropriately.  References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":543,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.precession_angles","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.precession_angles","content":" FrameTransformations.Orient.precession_angles  —  Function precession_angles(m::IAU1980Model, t::Number) Compute the precession angles from Lieske et al. 1977 model, in radians, at time  t   expressed in  TT  Julian centuries since  J2000 . References ERFA  software library source"},{"id":544,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.precession_rate","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.precession_rate","content":" FrameTransformations.Orient.precession_rate  —  Function precession_rate(m::IAU2000Model, t::Number) Compute the precession-rate part of the IAU 2000 precession-nutation models, in radians, at  time  t  expressed as  TT  Julian centuries since  J2000 . References ERFA  software library source"},{"id":545,"pagetitle":"Low-level API","title":"IERS Routines","ref":"/FrameTransformations/stable/Modules/orient_lapi/#IERS-Routines","content":" IERS Routines"},{"id":546,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.bpn2xy","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.bpn2xy","content":" FrameTransformations.Orient.bpn2xy  —  Function bpn2xy(A::AbstractMatrix) Compute the CIP X and Y coordinates from the bias-precession-nutation matrix, in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":547,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cip_coords","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cip_coords","content":" FrameTransformations.Orient.cip_coords  —  Function cip_coords(m::IAUModel, t::Number) Computes the CIP X, Y coordinates, in radians, according to the IAU model  m  at time  t   expressed in  TT  Julian Centuries since  J2000 . This function has been implemented for the  IAU2000 ,  IAU2006  and the  CPN  models. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations source"},{"id":548,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cio_locator","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cio_locator","content":" FrameTransformations.Orient.cio_locator  —  Function cio_locator(m::IAUModel, t::Number, x::Number, y::Number) Compute the CIO Locator  s  in radians, according to the IAU Model  m , given the CIP  coordinates  X  and  Y  at time  t  expressed in  TT  Julian centuries since  J2000 The function has been implemented for the  IAU2000 ,  IAU2006  and the  CPN  models. References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 Capitaine N. and Wallace P. T. (2008), Concise CIO based precession-nutation formulations ERFA  library ERFA  library source"},{"id":549,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cip_motion","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cip_motion","content":" FrameTransformations.Orient.cip_motion  —  Function cip_motion(m::IAUModel, t::Number, dx::Number=0.0, dy::Number=0.0) Compute the CIRS to GCRS rotation matrix, according to the IAU Model  m , at time  t  expressed in  TT  Julian centuries since  J2000 . Optional IERS corrections for  free-core nutation and time depedented effects can be provided through  dx  and  dy .  References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":550,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_angle","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_angle","content":" FrameTransformations.Orient.earth_rotation_angle  —  Function earth_rotation_angle(t::Number) Compute the Earth Rotation Angle (ERA) in radians, i.e., the angle between the Celestial  Intermediate Origin (CIO) and the Terrestrial Intermediate Origin (TIO) at time  t   expressed as UT1 days since  J2000 . Note The function uses the fractional UT1 date to gain additional precision in the  computations (0.002737.. instead of 1.002737..) References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 ERFA  library source"},{"id":551,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.earth_rotation_rate","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.earth_rotation_rate","content":" FrameTransformations.Orient.earth_rotation_rate  —  Function earth_rotation_rate() Compute the nominal Earth angular velocity.  source earth_rotation_rate(LOD::Number) Compute the true angular velocity of the Earth accounting for the Length of the Day, i.e.,  the instantaneous rate of change of UT1 with respect to a uniform time scale.  source"},{"id":552,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.equinoxes_equation","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.equinoxes_equation","content":" FrameTransformations.Orient.equinoxes_equation  —  Function equinoxes_equation(m::IAUModel, tt::Number) Compute the Equation of the Equinoxes, in radians, according to the IAU Model  m  given  time  tt  expressed in  TT  Julian centuries since J2000.  This function has been implemented for the IAU2006 and IAU2000 models. Note This function neglects the difference between  TT  and  TDB . References ERFA  ee00a  routine. ERFA  ee06a  routine. source"},{"id":553,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.era_rotm","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.era_rotm","content":" FrameTransformations.Orient.era_rotm  —  Function era_rotm(t::Number) Compute the TIRS to CIRS Earth Rotation matrix, according to the IERS 2010  conventions at time  t  expressed as UT1 days since  J2000 . References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 source"},{"id":554,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.fw2xy","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.fw2xy","content":" FrameTransformations.Orient.fw2xy  —  Function fw2xy(ϵ::Number, ψ::Number, γ::Number, φ::Number) Compute the CIP X and Y coordinates from Fukushima-Williams bias-precession-nutation  angles, in radians. Inputs ϵ  – F-W angle with IAU 2006A/B nutation corrections.  ψ  – F-W angle with IAU 2006A/B nutation corrections. γ  – F-W angle   ϕ  – F-W angle References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 source"},{"id":555,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.origins_equation","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.origins_equation","content":" FrameTransformations.Orient.origins_equation  —  Function origins_equation(m::IAU2006Model, t::Number) Compute the Equation of the Origins (EO), in radians, following the IAU2006 precession and  IAU2000A nutation models, given time  t  expressed in  TT  Julian centuries since J2000.0.  References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  eo06a  routine. source"},{"id":556,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.tio_locator","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.tio_locator","content":" FrameTransformations.Orient.tio_locator  —  Function tio_locator(t::Number) Compute the TIO locator  s'  at date, positioning the Terrestrial Intermediate Origin on  the equator of the Celestial Intermediate Pole (CIP) at time  t  expressed as  TT  Julian  centuries since J2000.  This function approximates the unpredictable motion of the TIO locator s' with its secular  drift of ~0.47 μas/century.  References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 Lambert, S. and Bizouard C. (2002), Positioning the Terrestrial Ephemeris Origin in the  Terrestrial Reference Frame,  DOI: 10.1051/0004-6361:20021139 source"},{"id":557,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.polar_motion","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.polar_motion","content":" FrameTransformations.Orient.polar_motion  —  Function polar_motion(t::Number, xₚ::Number, yₚ::Number) Compute the Polar Motion rotation matrix from ITRF to TIRS, according to the  IERS 2010 Conventions, at time  t  expressed in  TT  Julian centuries since  J2000 .  The function requires  xp  and  yp , the Celestial Intermediate Pole (CIP) coordinates with  respect to the International Celestial Reference Frame (ITFR). References Luzum, B. and Petit G. (2012), The IERS Conventions (2010),   IERS Technical Note No. 36 source"},{"id":558,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.xys2m","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.xys2m","content":" FrameTransformations.Orient.xys2m  —  Function xys2m(x::Number, y::Number, s::Number) Compute the Intermediate-to-Celestial matrix given the CIP  x ,  y' coordinates and the CIO  locator s`, all in radians. References Wallace P. T. and Capitaine N. (2006), Precession-nutation procedures consistent with  IAU 2006 resolutions,  DOI: 10.1051/0004-6361:20065897 ERFA  library source"},{"id":559,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.ecliptic_pole","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.ecliptic_pole","content":" FrameTransformations.Orient.ecliptic_pole  —  Function ecliptic_pole(m::IAU2006Model, t::Number) Computes ecliptic pole of date in ICRF. Wallace, P. T., & Capitaine, N. (2006). Precession-nutation procedures consistent with IAU  2006 resolutions. Astronomy & Astrophysics, Eq. 20. source"},{"id":560,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.cip","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.cip","content":" FrameTransformations.Orient.cip  —  Function cip(m::IAUModel, t::Number) Compute Celestial Intermediate Pole vector. Wallace, P. T., & Capitaine, N. (2006). Precession-nutation procedures consistent with IAU  2006 resolutions. Astronomy & Astrophysics. source"},{"id":561,"pagetitle":"Low-level API","title":"EOP Data","ref":"/FrameTransformations/stable/Modules/orient_lapi/#EOP-Data","content":" EOP Data"},{"id":562,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.EOPData","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.EOPData","content":" FrameTransformations.Orient.EOPData  —  Type EOPData{T} EOP Data for IAU 2000A. Fields filename  : File where the EOP data are stored.  j2000  : Independent valiable - time - in UTC. j2000_TT  : Independent valiable - time - in TT. x, y : Polar motion with respect to the crust (arcsec). UT1_UTC : Irregularities of the rotation angle (s). UT1_TT : Irregularities of the rotation angle (s) w.r.t. TT timescale. LOD : Length of day offset (ms). dX, dY : Celestial pole offsets referred to the model IAU2000A (milliarcsec). source"},{"id":563,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.EOPInterpolator","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.EOPInterpolator","content":" FrameTransformations.Orient.EOPInterpolator  —  Type EOPInterpolator{T} EOP Data for IAU 2000A. Fields init : A flag indicating whether the EOPInterpolator has been initialized. j2000 : Independent variable (time), in UTC. j2000_TT : Independent variable (time), in TT. x, y : Polar motion with respect to the crust (arcsec). UT1_UTC : Irregularities of the rotation angle (s). UT1_TT : Irregularities of the rotation angle (s) with respect to TT timescale. LOD : Length of day offset (ms). dX, dY : Celestial pole offsets referred to the model IAU2000A (milliarcsec). x_TT, y_TT : Polar motion with respect to the crust (arcsec) parametrized by TT epoch. UT1_TT : Irregularities of the rotation angle (s) parametrized by TT epoch. LOD_TT : Length of day offset (ms) parametrized by TT epoch. dX_TT, dY_TT : Celestial pole offsets referred to the model IAU2000A (milliarcsec) parametrized by TT epoch. source"},{"id":564,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.IERS_EOP_DATA","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.IERS_EOP_DATA","content":" FrameTransformations.Orient.IERS_EOP_DATA  —  Constant IERS_EOP_DATA Earth Orientation Parameters Data: x/y pole, UT1-UTC, LOD, dX, dY (smoothed values at 1-day  intervals) with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014. See also:  EOPData source"},{"id":565,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.set_eop_data","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.set_eop_data","content":" FrameTransformations.Orient.set_eop_data  —  Function set_eop_data(filename) Set Earth Orientation Parameters (EOP) to be used for frames transformations from JSMD   .eop.dat  file.   source"},{"id":566,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.read_iers_eop_finals","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.read_iers_eop_finals","content":" FrameTransformations.Orient.read_iers_eop_finals  —  Function read_iers_eop_finals(filename::AbstractString) Read IERS EOP C04 files in csv format. Returns j2000_utc : Julian days since J2000 in UTC. j2000_tt : Julian days since J2000 in TT (Terrestrial Time). x_pole : Celestial pole offset in the X direction (arcsec). y_pole : Celestial pole offset in the Y direction (arcsec). ut1_utc : UT1-UTC time difference (s). ut1_tt : UT1-TT time difference (s). lod : Length of Day (s). dX : Celestial pole offset rate in the X direction (milliarcsec). dY : Celestial pole offset rate in the Y direction (milliarcsec). The function reads IERS EOP C04 files in CSV format and extracts relevant Earth Orientation  Parameters (EOP) data. It then updates predictions, filling missing values with zeros for  LOD, dX, and dY.  Finally, the function parametrizes EOP with respect to both UTC and TT time scales for  convenience. References https://maia.usno.navy.mil/ser7/readme.finals2000A http://hpiers.obspm.fr/eoppc/bul/bulb/explanatory.html https://maia.usno.navy.mil source"},{"id":567,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.read_eop","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.read_eop","content":" FrameTransformations.Orient.read_eop  —  Function read_eop(filename) Read Earth Orientation Parameters (EOP) from JSMD  .eop.dat  file.   source"},{"id":568,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.offset_utc2ut1","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.offset_utc2ut1","content":" FrameTransformations.Orient.offset_utc2ut1  —  Function offset_utc2ut1(seconds) Return the offset, in seconds, between  UTC  and  UT1 . source"},{"id":569,"pagetitle":"Low-level API","title":"Transformations","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Transformations","content":" Transformations"},{"id":570,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_mod","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_mod","content":" FrameTransformations.Orient.orient_rot3_icrf_to_mod  —  Function orient_rot3_icrf_to_mod(tt::Number) Compute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Mean Equinox Mean Equator of Date at time  tt , expressed in TT seconds since  J2000 . Mean Equator Of Date is obtained applying frame bias and precession to the ICRF pole and origin. Fukushima-Williams parametrization for the equator and ecliptic precession is used.  Consistent with the IAU2006 precession model. source"},{"id":571,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_tod","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_tod","content":" FrameTransformations.Orient.orient_rot3_icrf_to_tod  —  Function orient_rot3_icrf_to_tod(tt::Number; [m]::IAU2006Model=iau2006a) Compute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the True Equator of Date at time  tt , expressed in TT seconds since  J2000 . True Equator of Date is obtained applying frame bias, precession and nutation to the ICRF  pole and origin. source"},{"id":572,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_teme","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_teme","content":" FrameTransformations.Orient.orient_rot3_icrf_to_teme  —  Function orient_rot3_icrf_to_teme(tt::Number; [m]::IAUModel=iau2006a) Compute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the True Equator, Mean Equinox of date at time  tt , expressed in TT seconds since  J2000 . See also See also  orient_rot3_mod_to_teme  and  orient_rot3_icrf_to_mod . source"},{"id":573,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_mod_to_teme","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_mod_to_teme","content":" FrameTransformations.Orient.orient_rot3_mod_to_teme  —  Function orient_rot3_mod_to_teme(tt::Number; [m]::IAU2006Model=iau2006a) Compute the rotation matrix from the Mean Equator of Date (MOD) frame to the True Equator,  Mean Equinox of date at time  tt , expressed in TT seconds since  J2000 . This is implemented with a small angle approx of Eq. 4 of Vallado, \"Coordinate Frames of the  US Space Object Catalogs.\"  source"},{"id":574,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_itrf_to_pef","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_itrf_to_pef","content":" FrameTransformations.Orient.orient_rot3_itrf_to_pef  —  Function orient_rot3_itrf_to_pef(t::Number) Compute the rotation matrix from the International Terrestrial Reference Frame (ITRF) to  the Pseudo-Earth Fixed Frame at time  t , expressed in TT seconds since  J2000 . References Vallado, D. A (2013). Fundamentals of Astrodynamics and Applications, Microcosm Press,    Hawthorn, CA, USA. See also See also  IERS_EOP . source"},{"id":575,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_pef_to_tod","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_pef_to_tod","content":" FrameTransformations.Orient.orient_rot3_pef_to_tod  —  Function orient_rot3_pef_to_tod(tt::Number; [m]::IAUModel=iau2006a) Compute the rotation matrix from the Pseudo-Earth Fixed (PEF) to the True Equator of Date  (TOD) Frame at time  tt , expressed in TT seconds since  J2000 . This is using IAU-76/FK5 Reduction. This is a sidereal time only rotation. Eq. 3-80, Sec. 3.7.3 of Vallado (2013). See also See also  orient_gast . source"},{"id":576,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot6_pef_to_tod","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot6_pef_to_tod","content":" FrameTransformations.Orient.orient_rot6_pef_to_tod  —  Function orient_rot6_pef_to_tod(tt::Number; [m]::IAUModel=iau2006a) Compute the rotation matrix and the derivative of the transformation from the Pseudo-Earth  Fixed (PEF) to the True Equator of Date (TOD) Frame at time  tt , expressed in TT seconds  since  J2000 . This is using IAU-76/FK5 Reduction. This is a sidereal time only rotation. Eq. 3-80, Sec. 3.7.3 of Vallado (2013). See also See also  orient_rot3_pef_to_tod ,  orient_gast  and  IERS_EOP . source"},{"id":577,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_tod_to_mod","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_tod_to_mod","content":" FrameTransformations.Orient.orient_rot3_tod_to_mod  —  Function orient_rot3_tod_to_mod(tt::Number; [m]::IAU2006Model=iau2006a) Compute the rotation matrix from the True Equator of Date (TOD) to the Mean Equator of Date (MOD)  Frame at time  tt , expressed in TT seconds since  J2000 . This is using IAU-76/FK5 Reduction. This is a nutation only rotation. Eq. 3-86, Sec. 3.7.3 of Vallado (2013). source"},{"id":578,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot3_icrf_to_pef","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot3_icrf_to_pef","content":" FrameTransformations.Orient.orient_rot3_icrf_to_pef  —  Function orient_rot3_icrf_to_pef(tt::Number; [m]::IAU2006Model=iau2006a) Compute the rotation matrix from the International Celestial Reference Frame (ICRF) to  the Pseudo Earth Fixed (PEF) Frame at time  tt , expressed in TT seconds since  J2000 . See also See also  orient_rot3_icrf_to_tod ,  orient_rot3_pef_to_tod  and   orient_rot6_icrf_to_pef . source"},{"id":579,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.orient_rot6_icrf_to_pef","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.orient_rot6_icrf_to_pef","content":" FrameTransformations.Orient.orient_rot6_icrf_to_pef  —  Function orient_rot6_icrf_to_pef(tt::Number; [m]::IAU2006Model=iau2006a) Compute the rotation matrix the derivative of the transformation from the International  Celestial Reference Frame (ICRF) to the Pseudo Earth Fixed (PEF) Frame at time  tt ,  expressed in TT seconds since  J2000 . See also See also  orient_rot3_icrf_to_pef . source"},{"id":580,"pagetitle":"Low-level API","title":"Geodesy","ref":"/FrameTransformations/stable/Modules/orient_lapi/#Geodesy","content":" Geodesy"},{"id":581,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.geoc2pv","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.geoc2pv","content":" FrameTransformations.Orient.geoc2pv  —  Function geoc2pv(geoc::AbstractVector) Transform a spherical geocentric 6-elements state vector (radius, longitude, geocentric  latitude and their derivatives) into a cartesian 6-elements vector (position and velocity). source"},{"id":582,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.pv2geoc","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.pv2geoc","content":" FrameTransformations.Orient.pv2geoc  —  Function pv2geoc(pv::AbstractVector) Transform a cartesian 6-elements state vector (position and velocity) into radius, longitude,  geocentric latitude and their derivatives, respectively. source"},{"id":583,"pagetitle":"Low-level API","title":"TPC Parsing","ref":"/FrameTransformations/stable/Modules/orient_lapi/#TPC-Parsing","content":" TPC Parsing"},{"id":584,"pagetitle":"Low-level API","title":"FrameTransformations.Orient.TPC","ref":"/FrameTransformations/stable/Modules/orient_lapi/#FrameTransformations.Orient.TPC","content":" FrameTransformations.Orient.TPC  —  Type TPC <: JSMDInterfaces.FilesIO.AbstractFile A type representing TPC files. source"},{"id":585,"pagetitle":"Low-level API","title":"JSMDInterfaces.FilesIO.load","ref":"/FrameTransformations/stable/Modules/orient_lapi/#JSMDInterfaces.FilesIO.load","content":" JSMDInterfaces.FilesIO.load  —  Function load(file::TPC{1}) Open a JPL ASCII  .tpc  file and parse its data in a dictionary. source load(files::TPC) Open a group of JPL ASCII  .tpc  files and parse their data in a dictionary. source"},{"id":588,"pagetitle":"01 - Frame System","title":"Frame System Overview","ref":"/FrameTransformations/stable/Tutorials/gen/t00_frames/#tutorial_00_frames","content":" Frame System Overview This example was generated on 2024-01-05T20:08:57.734. The core object of  FrameTransformations  is the  FrameSystem , which provides the capability to compute relative position, orientation and their time derivatives up to order 3 (jerk), between standard and user-defined point and axes. It works by creating two separate graphs that silently store and manage all the parent-child relationships between the user-registered axes and points, in the form of  Frames.FramePointNode  and  Frames.FrameAxesNode . These two objects define two precise entities: Axes : defines an orientation in space. These are related each other by means of a  Rotation  transformation which relate one axes to a parent axes in a certain time interval. Points : defines a location in space. These are related each other by means of a  Translation  transformation which relate one point to a parent point in a particular axes in a certain time interval. Note A single  FrameSystem  instance simultaneously handles both the axes and point graphs, regardless of what the user registers in it. For instance, if no points are added, the point graph will remain empty. Additionally, any node can have several childs, each with different transformations with respect to the parent node. Moreover, nodes can be  created  independenlty of each other (by means of the  @axes , and  @point  macros). However, they shall be  registered  within the  FrameSystem  before being used in a transformation or as parents of other nodes."},{"id":589,"pagetitle":"01 - Frame System","title":"Basic Constructors","ref":"/FrameTransformations/stable/Tutorials/gen/t00_frames/#Basic-Constructors","content":" Basic Constructors The creation of a generic  FrameSystem  requires the definition of the maximum desired transformation order and of its  DataType , which in most applications is a  Float64 . The transformation order is always one greater than the maximum desired time derivative. For instance, if the user only desires to compute position and velocity components (i.e., order 1 time-derivative), the transformation order to be used is 2. Thus, the maximum allowed transformation order is 4. In this example, we highlight the most basic way to initialise a  FrameSystem : F = FrameSystem{2, Float64}() FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n)\n From this example, you can see that within the frame system there are both point and axes graphs. However, at the moment they are completely empty since the graph was just created. Each  FrameSystem  object is assigned a reference timescale that is used to perform computations with epochs and to parse ephemeris files. The default timescale is the  BarycentricDynamicalTime , however, the user is free to select the most suited timescale for his applications. In this example, we set the  InternationalAtomicTime  as the reference scale. F = FrameSystem{2, Float64, InternationalAtomicTime}() FrameSystem{2, Float64, InternationalAtomicTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n)\n"},{"id":590,"pagetitle":"01 - Frame System","title":"Ephemerides Support","ref":"/FrameTransformations/stable/Tutorials/gen/t00_frames/#Ephemerides-Support","content":" Ephemerides Support In certain scenarios, the transformations require usage of binary ephemeris kernels, e.g., the JPL's DE440 files. To support this applications, an ephemeris provider can be associated to a  FrameSystem . Since this package leverages a set of standard interfaces, any ephemeris reader that exposes JSMD-compatible interfaces can be used as a backend in FrameTransformations. Currently, the only two supported readers are our own  Ephemerides.jl  or  CalcephEphemeris.jl . Although the former only can only parse binary PCK/SPK kernels, it seamlessly integrates with  ForwardDiff  since it is completely written in Julia. Once the desired ephemeris provider is created, it can be associated to the frame system object. However, in this case the reference timescale is retrieved from the ephemeris kernels and cannot be specified by the user. In this example we begin loading an old DE421 kernerl to pass to the ephemeris reader. using Ephemerides, Downloads\n\nurl = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(Downloads.download(url));\n\nF = FrameSystem{2, Float64}(eph) FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n)\n As you can see, the default  NullEphemerisProvider  has been replaced by the user-constructed one. This page was generated using  Literate.jl ."},{"id":593,"pagetitle":"02 - Axes","title":"Axes Creation and Rotations","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#tutorial_01_axes","content":" Axes Creation and Rotations This example was generated on 2024-01-05T20:08:57.794. To compute relative orientations,  FrameTransformations  provides the capability to define custom and standard reference axes (e.g., the ITRF) and arbitrarily connect them through the  FrameSystem  In turn, this allows the computation of the relative orientation and its derivatives (up to order 3) between any two registered axes. At the time being, the following types of axes are supported: Inertial axes : these are the only ones which can be used as root axes to initialise the axes graph. Fixed offset axes : they have a constant orientation with respect to their parent axes. Rotating axes : the orientation of these axes depends only on time and is computed t through the custom functions provided by the user Computable axes : they are computed through two vectors that are defined within the frame system itself. Computable axes are the equivalent of SPICE's parameterized two-vector frames. Projected axes : the orientation of these axes depends only on time and is computed through the custom functions provided by the user. Projected axes are similar to rotating axis, except that all the positions, velocity, etc ... are rotated by the 0-order rotation (i.e. the derivatives of the rotation matrix are null, despite the rotation depends on time). Ephemeris axes : these are constructed by extracting the Euler rotation angles and their derivatives from the binary PCK kernels that are loaded within the  FrameSystem . Note This package provides a dedicated function to register each type of supported axes. Additionally, higher-level functions to automatically register standard astronomical reference axes are also provided, e.g.,  add_axes_eclipj2000! . Before diving into the creation of the axes graph, it is worth highlighting that transformations that express the relative orientation or its time-derivatives between two generic set of axes are represented by a  Rotation  object, which stores a Direction Cosine Matrix (DCM) and its derivatives. This package leverages the already available  ReferenceFrameRotations.jl  to define the DCM objects. A time-fixed rotation between two axes and its derivative can then be expressed as follows: using FrameTransformations\nusing ReferenceFrameRotations\n\ndcm  = angle_to_dcm(π/3, :Z)\nδdcm = DCM(0I)\n\nR = Rotation(dcm, δdcm) Rotation{2, Float64}(([0.5000000000000001 0.8660254037844386 0.0; -0.8660254037844386 0.5000000000000001 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) R[1] DCM{Float64}:\n  0.5       0.866025  0.0\n -0.866025  0.5       0.0\n  0.0       0.0       1.0 R[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 A rotation object is returned by all the rotation functions that are applied to the  FrameSystem . It provide overloads to the basic algebraic operations so that multiplication and inversions can be efficiently computed leveraging the properties of rotation matrixes. For example, to rotate a generic vector  v , we can simply do: v = [1., -6., 3., 0., 5., 0]\nR*v 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -4.696152422706631\n -3.8660254037844393\n  3.0\n  4.330127018922193\n  2.5000000000000004\n  0.0 The inverse can instead be taken as: inv(R) Rotation{2, Float64}(([0.5000000000000001 -0.8660254037844386 0.0; 0.8660254037844386 0.5000000000000001 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) See the  Rotation API  for more information on this object."},{"id":594,"pagetitle":"02 - Axes","title":"Graph Initialisation","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#Graph-Initialisation","content":" Graph Initialisation In this section we will display how to create a frame system to compute generic axes rotation. First of all, we need to load both this package and an ephemeris reader. The latter will be used to compute the orientation of the Moon's Principal Axes (PA) 440,  whose Euler angles are defined in binary PCK kernels and to retrieve the positions of the planets. In this example, we will use our own   Ephemerides.jl  package and download the kernels from NAIF's website. using Ephemerides\n\nurl_pck = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/moon_pa_de421_1900-2050.bpc\";\nurl_spk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\n\neph = EphemerisProvider([download(url_spk), download(url_pck)])\n\nG = FrameSystem{3, Float64}(eph) FrameSystem{3, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 2-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n)\n To initialise the axes computational graph, a set of root axes must be initially registered. These will serve as the uppermost node of the graph and have no parents, meaning their orientation is not specified. Only inertial axes can be used as root axes of the  FrameSystem . Before registering the axes, the  @axes  macro is used to define an acronym, an ID and a name of each set of axes that we wish to register in the system. If a name is not provided, a default one is used. In this example, we will use the  ICRF  as our base root inertial axes. @axes ICRF 1 InternationalCelestialReferenceFrame\n\nadd_axes_inertial!(G, ICRF) Once a set of root axes has been registered, any other type of axes can be added to the system. Note For standard applications, it is good practice that the axes's IDs are as in agreement with NAIF's numbering system. A list of IDs for the most common axes is provided in the Orient submodule. Note The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the axes are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. For instance, one could register a set of rotating axes named  ICRF . Inertial axes are those that are fixed with respect to the star background. They are the only ones that can be used as root axes in the frame system but can also be defined through a relative orientation with respect to another set of inertial axis. In this example, we register the  ECLIPJ2000  as a set of inertial axes with respect to the  ICRF . Since the set of root axes has already been defined, all the future usages of the  add_axes_inertial!  function require a parent set of axes and a DCM with the relative orientation. @axes ECLIPJ2000 17\n\nadd_axes_inertial!(G, ECLIPJ2000; parent=ICRF, dcm=DCM_ICRF_TO_ECLIPJ2000)\n\nR = rotation6(G, ICRF, ECLIPJ2000, 10.0) Rotation{2, Float64}(([0.9999999999999941 -9.698854433992582e-8 4.57581833871911e-8; 7.078368694637674e-8 0.9174820489188898 0.3977771862633533; -8.05621421162006e-8 -0.3977771862633478 0.9174820489188915], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) R[1] DCM{Float64}:\n  1.0         -9.69885e-8  4.57582e-8\n  7.07837e-8   0.917482    0.397777\n -8.05621e-8  -0.397777    0.917482 R[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Notice that we leveraged the default DCM provided by Orient's to express the relative orientation between the  ICRF  and the  ECLIPJ2000 . For a set of default DCM exported by Orient, check the  API documentation . Additionally, since it is an inertial frame, the time derivative of the rotation is null."},{"id":595,"pagetitle":"02 - Axes","title":"Fixed-offset Axes","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#Fixed-offset-Axes","content":" Fixed-offset Axes Fixed-offset axes have a constant orientation with respect to their parent axes in time. We previously saw that inertial axes can also be used to define axes with a fixed orientation  with respect to their parents. However, while inertial axes do not rotate with respect to the star background, fixed offset axes are only constant with respect to their parent axes, but might be rotating with respect to some other inertial axes. In this example, we register  FO1  as a set of axes with a fixed rotation of  π/4  around the Z-axis with respect to the  ICRF . @axes FO1 2\n\nrot = angle_to_dcm(π/4, :Z)\n\nadd_axes_fixedoffset!(G, FO1, ICRF, rot) The state rotation matrix can then be obtained as: R = rotation6(G, ICRF, FO1, 86400) Rotation{2, Float64}(([0.7071067811865476 0.7071067811865475 0.0; -0.7071067811865475 0.7071067811865476 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) R[1] DCM{Float64}:\n  0.707107  0.707107  0.0\n -0.707107  0.707107  0.0\n  0.0       0.0       1.0 R[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 Since  FO1  has a constant orientation with respect to the  ICRF , the time derivative of the rotation matrix  R[2]  is infact null. For further information see the  add_axes_fixedoffset!  documentation."},{"id":596,"pagetitle":"02 - Axes","title":"Rotating Axes","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#rot_axes","content":" Rotating Axes Rotating axes are generic, time-dependant, non-inertial axes. In order to register this kind of axes, a function (and optionally its derivatives) that expresses the relative orientation of this axes must be defined. This function shall return a Direction Cosine Matrix (DCM), available from the  ReferenceFrameRotations.jl  package. @axes RotAx 3\n\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(G, RotAx, FO1, fun) If we now compute the orientation between the  ICRF  and  RotAx  at  π/4  we obtain an identity rotation, since the orientation of  RotAx  is directed in the opposite direction of  FO1 . R1 = rotation6(G, ICRF, RotAx, π/4) Rotation{2, Float64}(([1.0 0.0 0.0; 1.0146536357569526e-17 1.0 0.0; 0.0 0.0 1.0], [-1.0146536357569526e-17 -1.0 0.0; 1.0 0.0 0.0; 0.0 0.0 0.0])) R1[1] DCM{Float64}:\n 1.0          0.0  0.0\n 1.01465e-17  1.0  0.0\n 0.0          0.0  1.0 R2 = rotation6(G, ICRF, RotAx, π/2) Rotation{2, Float64}(([0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 0.7071067811865475 0.0; 0.0 0.0 1.0], [-0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 -0.7071067811865476 0.0; 0.0 0.0 0.0])) R2[2] DCM{Float64}:\n -0.707107  -0.707107  0.0\n  0.707107  -0.707107  0.0\n  0.0        0.0       0.0 Notice that, although we only provided a function that expresses the relative orientation, the frame system has automatically computed its time-derivative via Automatic Differentiation (AD) of  fun . This becomes particularly useful for rapid prototyping or when the manual differentiation requires a lot of time. The functions for higher-order derivatives, must return the original DCM and its derivatives up to their orders. For example: using JSMDUtils.Math\n\n@axes RotAx2 4\n\nfun(t) = angle_to_dcm(-t, :Z)\ndfun(t) = (angle_to_dcm(-t, :Z), Math.angle_to_δdcm([-t, -1], :Z))\n\nadd_axes_rotating!(G, RotAx2, FO1, fun, dfun)\n\nR2 = rotation6(G, ICRF, RotAx2, π/2) Rotation{2, Float64}(([0.7071067811865475 -0.7071067811865476 0.0; 0.7071067811865476 0.7071067811865475 0.0; 0.0 0.0 1.0], [-0.7071067811865476 -0.7071067811865475 0.0; 0.7071067811865475 -0.7071067811865476 0.0; 0.0 0.0 0.0])) R2[2] DCM{Float64}:\n -0.707107  -0.707107  0.0\n  0.707107  -0.707107  0.0\n  0.0        0.0       0.0 We can see the results are in agreement with the previous example. For more details, see  add_axes_rotating!  documentation."},{"id":597,"pagetitle":"02 - Axes","title":"Projected Axes","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#Projected-Axes","content":" Projected Axes Projected axes are a particular type of inertial axes. In this case the rotation is built by means of a time dependant function  f(t) . However, all the derivatives of  f(t)  are assumed to be zero. This axes type is usually used to build True-of-Date (TOD) axes sets. In this example, we illustrate this difference by registering two new set of axes with the same relative orientation with respect to the  ICRF , one rotating and one projected. @axes ProjAx 500\n@axes RotAx3 501\n\nfun(t) = angle_to_dcm(-t, :Z)\n\nadd_axes_rotating!(G, RotAx3, ICRF, fun)\nadd_axes_projected!(G, ProjAx, ICRF, fun)\n\nR1 = rotation6(G, ICRF, RotAx3, 50.0)\nR2 = rotation6(G, ICRF, ProjAx, 50.0) Rotation{2, Float64}(([0.9649660284921133 0.26237485370392877 0.0; -0.26237485370392877 0.9649660284921133 0.0; 0.0 0.0 1.0], [0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0])) R1[1] - R2[1] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 R1[2] DCM{Float64}:\n 0.262375  -0.964966  0.0\n 0.964966   0.262375  0.0\n 0.0        0.0       0.0 R2[2] DCM{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n 0.0  0.0  0.0 As you can see, while the relative orientation  R[1]  is equal, the time-derivative of the projected-axes orientation is null. For further information see the  add_axes_projected!  documentation."},{"id":598,"pagetitle":"02 - Axes","title":"Computable Axes","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#Computable-Axes","content":" Computable Axes Computable axes are a kind of  time-dependant axes . In this case, differently from the rotating axes, the axes and their derivatives are computed through two time-dependant vectors which are expressed using any type of point that is registered in the system. These axes are the equivalent of SPICE's two-vector frames. In this example, we will register two ephemeris points, the Solar system barycenter and the Sun. For more information on how this operation is performed, see the  points tutorial . The two vectors that generate the set of computable axes are defined with the  ComputableAxesVector  object, by specifing the vector center and target point and its order, i.e., whether we are interested in the position, velocity or acceleration of that vector. A symbol is used to specify which direction the vectors have to align with. In this example, the axes are constructed with the X-axis parallel to the instantaneous SSB to Sun direction, whereas the secondary vector is chosen parallel to the SSB to Sun velocity vector (order 2). Then, the component of this vector orthogonal to the X-axis is used to create the Y-axis. @axes SunFrame 600\n\n@point SSB 0 SolarSystemBarycenter\n@point Sun 10 SunPoint\n\nadd_point_root!(G, SSB, ICRF)\nadd_point_ephemeris!(G, Sun)\n\nv1 = ComputableAxesVector(Sun, SSB, 1)\nv2 = ComputableAxesVector(Sun, SSB, 2)\n\nadd_axes_computable!(G, SunFrame, ICRF, v1, v2, :XY)\n\nR = rotation6(G, ICRF, SunFrame, 0.0) Rotation{2, Float64}(([0.9307646313076896 0.3452349713257856 0.12037448101796602; -0.3646672694138606 0.8528460137376037 0.37372645005420435; 0.026362543976245705 -0.39174799479456546 0.9196947998382602], [-4.876410895608863e-9 1.1404444386663028e-8 4.997552250715579e-9; -1.24485977115153e-8 -4.583740451381578e-9 -1.686718623822076e-9; -3.054887777376799e-11 7.144454909647363e-11 3.1307782740910527e-11])) For further information see the  add_axes_computable!  documentation. Note The center and target point can either be specified with their integer IDs or their name aliases."},{"id":599,"pagetitle":"02 - Axes","title":"Ephemeris Axes","ref":"/FrameTransformations/stable/Tutorials/gen/t01_axes/#Ephemeris-Axes","content":" Ephemeris Axes Ephemeris axes a are a type of time-dependent axes which are build by means of Euler angles contained within a binary PCK ephemeris kernel. For example, in practice these are used to express the orientation of high-accuracy Lunar body-fixed frames (i.e., the Principal Axes) or the Earth's ITRF. Note To properly compute the orientation of these axes, the  FrameSystem  object must contain an ephemeris provider that has loaded the necessary PCK kernels. Additionally, in this case the ID of the registered axes must match the ID contained in the PCK kernels. In this example, the ephemeris provider  eph  in the frame system  G  has loaded the DE421 PCK kernel containing the orientation of the Moon's Principal Axes (PA421). NAIF's system has assigned to such set of axes the ID  31006 . If a different ID was assigned to the  MoonPA , the function would have thrown an error. A set of default axes IDs is also defined within the  Orient 's submodule for ease of use. The function also requires the user to specify the rotation sequence to convert the Euler angles to a proper rotation matrix. @axes MoonPA 31006\n\nadd_axes_ephemeris!(G, MoonPA, :ZXZ)\n\nR = rotation9(G, ICRF, MoonPA, 86400.0) Rotation{3, Float64}(([0.6219855961037569 0.7077415949385507 0.33501604891898906; -0.7827096425059984 0.5741656785808802 0.24020697131409327; -0.022350252069861617 -0.4116255681242284 0.911078952615425], [-2.0835792981059603e-6 1.5281546248856286e-6 6.400222345301864e-7; -1.6557195262995373e-6 -1.8840097087356063e-6 -8.917889621565607e-7; -3.880601321351557e-10 -4.740262874274574e-10 -2.236848750095691e-10], [-4.407703819959643e-12 -5.014536010737041e-12 -2.3750017657161296e-12; 5.546289270719377e-12 -4.068112024772315e-12 -1.7038759932684681e-12; 2.130250244357035e-15 -4.0450577593420844e-17 3.3516097976061354e-17])) For further information see the  add_axes_ephemeris!  documentation. This page was generated using  Literate.jl ."},{"id":602,"pagetitle":"03 - Points","title":"Points Creation and Translations","ref":"/FrameTransformations/stable/Tutorials/gen/t02_points/#tutorial_02_points","content":" Points Creation and Translations This example was generated on 2024-01-05T20:08:57.800. Similarly to  axes ,  FrameTransformations  also provides the capability to define custom and standard reference points (e.g., the Solar System Barycenter) and arbitrarily connect them through the  FrameSystem  In turn, this allows the computation of the relative position and its derivatives (up to order 3) between any two registered points and express it in any known set of axes. At the time being, the following types of points are supported: Root point : it is the root of the point graph. Fixed points : are those whose positions have a constant offset with respect their parent point in a given set of axes. Dynamical points : the position of these points depends only on time and is computed through custom user-defined functions. Ephemeris points : are those whose state-vector is retrieved from binary SPK kernels (e.g., DE440) that are loaded within the  FrameSystem . Updatable points : differently from all the other classes, the state vector for updatable points must be manually updated at a given epoch before it can be used in any transformation at the same epoch. Note This package provides a dedicated function to register each type of supported points."},{"id":603,"pagetitle":"03 - Points","title":"Graph Initialisation","ref":"/FrameTransformations/stable/Tutorials/gen/t02_points/#Graph-Initialisation","content":" Graph Initialisation In this section we will display how to create a frame system to compute generic points transformation. Differently from the axes graph, each register point is also associated to a set of axes. Hence, this tutorial assumes the reader to already be familiar with the different types of axes and their definitions. First of all, we need to load both this package and an ephemeris reader. The latter will be used to retrieve the positions of the planets from the binary SPK kernels. In this example, we will use our own  Ephemerides.jl  package and download the kernels from NAIF's website. To initialise the point graph, we first need to define a root point. This, in turn, must be associated to an arbitrary set of axes. Therefore, we begin by definining a generic  SatelliteFrame , here considered as inertial, and then register a root point, called  SpacecraftCenter  in our graph. Similarly, to axes, the  @point  macro is used to define an acronym, an ID and a name of each point that we wish to register in the system. If a name is not provided, a default one is used. using FrameTransformations\n\nG = FrameSystem{2, Float64}() FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: EMPTY\n  axes: EMPTY\n)\n A root point can be registered using the  add_point_root!  function: @axes SATF 1 SatelliteFrame\n\nadd_axes_inertial!(G, SATF)\n\n@point SC -10000 SpacecraftCenter\n\nadd_point_root!(G, SC, SATF) Tip For standard applications, it is good practice that the points's IDs are as in agreement with NAIF's numbering system. This becomes mandatory to properly read JPL's SPK kernels. Note The frame system uses an integer system based on the user-defined IDs to compute the transformations between axes and points. The name and acronym of the point are only used as aliases to provide a user-friendly interface to the transformations and do not have any other meaning. We can now see that our axes and point graphs are populating themselves: G FrameSystem{2, Float64, BarycentricDynamicalTime, JSMDUtils.NullEphemerisProvider}(\n  eph: JSMDUtils.NullEphemerisProvider(),\n  points: \t \n\t SC\n\t \n  axes: \t\n\tSATF\n\t\n)\n"},{"id":604,"pagetitle":"03 - Points","title":"Fixed Points","ref":"/FrameTransformations/stable/Tutorials/gen/t02_points/#Fixed-Points","content":" Fixed Points Fixed points have a constant relative position vector with respect to their parent points in a given set of axes. Similarly to fixed-offset axes, these points are fixed w.r.t. their parents but might be moving with respect to others. In this example, we use the  add_point_fixed!  function to register the location of an antenna and two solar panels, which are generally fixed in the satellite body-fixed frame. To do so, we define a position offset in the form of a 3-elements vector with respect to the  SpacecraftCenter . @point SACL -10101 SolarArrayCenterLeft\n@point SACR -10102 SolarArrayCenterRight\n@point Antenna -10001\n\nsa_offset_left = [1.0, 0.0, 0.0]\nsa_offset_right = [-1.0, 0.0, 0.0]\nan_offset = [0.0, 0.0, -1.0]\n\nadd_point_fixed!(G, SACL, SC, SATF, sa_offset_left)\nadd_point_fixed!(G, SACR, SC, SATF, sa_offset_right)\nadd_point_fixed!(G, Antenna, SC, SATF, an_offset) As a result the graph is now populated with the new points and we can finally compute their relative positions and velocities with the proper transformation functions: vector3(G, SACL, SC, SATF, 0.0) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -1.0\n -0.0\n -0.0 vector6(G, Antenna, SACR, SATF, 10.0) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -1.0\n -0.0\n  1.0\n -0.0\n -0.0\n -0.0 As expected, since these points are fixed, the relative velocity vector is null."},{"id":605,"pagetitle":"03 - Points","title":"Dynamical Points","ref":"/FrameTransformations/stable/Tutorials/gen/t02_points/#Dynamical-Points","content":" Dynamical Points Dynamical points are generic time-dependent points whose position vector (and optionally its derivatives) are only function of time. However, differently from ephemeris points, their position is computed through user-defined functions. @point TimeDependantAppendage -10003\n\nfun(t) = [cos(t), sin(t), 0]\n\nadd_point_dynamical!(G, TimeDependantAppendage, SACL, SATF, fun)\n\nvector6(G, TimeDependantAppendage, SC, SATF, π/3) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -1.5\n -0.8660254037844386\n -0.0\n  0.8660254037844386\n -0.5000000000000001\n -0.0 Note To avoid allocations,  fun  should return a static array. Similarly to rotating-axes, if the user only provides the function to compute the relative position, the remaining derivatives are automatically retrievied via automatic differentiation of  fun . On the other hand, if those functions are specified, they must return a single vector that stacks all the components. For instance, for the second order derivative of  fun , the function should return a 9-elements vector containing the relative position, velocity and acceleration. For example: @point TimeDependantAppendage2 -10004\n\nfun(t) = [cos(t), sin(t), 0]\ndfun(t) = [cos(t), sin(t), 0, -sin(t), cos(t), 0]\n\nadd_point_dynamical!(G, TimeDependantAppendage2, SACL, SATF, fun, dfun)\n\nvector6(G, TimeDependantAppendage2, SC, SATF, π/3) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n -1.5\n -0.8660254037844386\n -0.0\n  0.8660254037844386\n -0.5000000000000001\n -0.0 We can again see that the results are in agreement with the previous example. For more details, consult the  add_point_dynamical!  documentation."},{"id":606,"pagetitle":"03 - Points","title":"Updatable Points","ref":"/FrameTransformations/stable/Tutorials/gen/t02_points/#updatable_points","content":" Updatable Points Updatable points are a class of point whose states at a given epoch must be manually updated before any other computation at the same epoch can occur. They can be inserted in the computational graphs as follows: @point UA -10002 UpdatableAppendage\n\nadd_point_updatable!(G, UA, SC, SATF) If we now call a transformation involving this point, an error will be thrown because we have not registered any state for this point. To do so, we use the  update_point!  function and then evaluate the relative position: ua_pos = [0.0, -1.0, 0.0]\nupdate_point!(G, UA, ua_pos, 0.0)\nvector3(G, Antenna, UA, SATF, 0.0) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n -0.0\n -1.0\n  1.0 Note Updatable points do not store any history of the updated states. Meaning that each time a state is updated at a different epoch, the information of the older epochs is completely lost."},{"id":607,"pagetitle":"03 - Points","title":"Ephemeris Points","ref":"/FrameTransformations/stable/Tutorials/gen/t02_points/#Ephemeris-Points","content":" Ephemeris Points Ephemeris points are a type of time-dependent points whose position and higher-order derivatives are retrieved from a binary SPK ephemeris kernel. However, differently from all other points, in this case the set of axes is automatically inferred from those contained in the ephemeris kernels. In case such set is not yet registered in the frame system, an error will be thrown. Note To properly compute the position of these points, the  FrameSystem  object must contain an ephemeris provider that has loaded the necessary kernels. Additionally, in this case the ID of the registered points must match the ID contained in the SPK kernels. In this example, we define a new frame system  F  and give it an ephemeris provider that has loaded the DE421 SPK kernel, containing the position of the major planets and/or their barycenters of the Solar System. using Ephemerides\n\nspk = \"https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/a_old_versions/de421.bsp\";\neph = EphemerisProvider(download(spk))\n\nF = FrameSystem{2, Float64}(eph) FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: EMPTY\n  axes: EMPTY\n)\n We now register some points that are stored in the kernels using the  add_point_ephemeris!  function: @axes ICRF 1\n\n@point SSB 0\n@point Sun 10\n@point EMB 3\n@point Earth 399\n\nadd_axes_inertial!(F, ICRF)\nadd_point_root!(F, SSB, ICRF)\nadd_point_ephemeris!(F, Sun)\nadd_point_ephemeris!(F, EMB)\nadd_point_ephemeris!(F, Earth)\n\nF FrameSystem{2, Float64, BarycentricDynamicalTime, Ephemerides.EphemerisProvider}(\n  eph: 1-kernel EphemerisProvider,\n  points: \t \n\t SSB\n\t  ├── Sun \n\t  ├── EMB \n\t   ├── Earth \n\t \n  axes: \t\n\tICRF\n\t\n)\n Notice that this function does not requires the parent point. Indeed, the parent is automatically set to those contained in the descriptors of the ephemeris kernels. For instance, in the DE421, the Earth-Moon Barycenter (EMB) is defined with respect to the SSB, which the frame system automatically uses as parent for the EMB. Similarly, the EMB is the default parent point for the Earth. Warning If a parent point is not specified and the point in the kernels has not yet been registered, an error is thrown. Finally, we can retrieve the transformation data as usual: vector6(F, EMB, SSB, ICRF, 1000.0) 6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n  2.759995209870437e7\n -1.323531471584033e8\n -5.741553718780777e7\n 29.776022371337408\n  5.043381864962445\n  2.1867059592436777 vector3(F, Earth, SSB, ICRF, 0.0) 3-element StaticArraysCore.SVector{3, Float64} with indices SOneTo(3):\n  2.756663231104537e7\n -1.3236142853828153e8\n -5.7418647383661106e7 This page was generated using  Literate.jl ."},{"id":610,"pagetitle":"04 - Loading EOP Data","title":"Loading IERS EOP data","ref":"/FrameTransformations/stable/Tutorials/gen/t03_eop/#tutorial_03_eop","content":" Loading IERS EOP data This example was generated on 2024-01-05T20:08:57.805. When working with frames associated with the Earth, it is imperative to incorporate Earth Orientation Parameters (EOP) data. The EOP data are required for the accurate construction of  various Earth associated frames within the  FrameSystem ."},{"id":611,"pagetitle":"04 - Loading EOP Data","title":"Creating compatible EOP file","ref":"/FrameTransformations/stable/Tutorials/gen/t03_eop/#Creating-compatible-EOP-file","content":" Creating compatible EOP file To minimize dependencies on external sources,  FrameTransformations  defines a standardized format for EOP data. The expected format consists of a file with the '.eop.dat' extension. This file should contain columns representing different Earth orientation parameters. The columns include: J2000 UTC : Julian Date (UTC) for J2000 epoch. J2000 TT : Julian Date (Terrestrial Time) for J2000 epoch. X-Pole : X-coordinate of the Celestial Intermediate Pole (CIP) in microarcseconds. Y-Pole : Y-coordinate of the Celestial Intermediate Pole (CIP) in microarcseconds. UT1-UTC : The difference between Coordinated Universal Time (UTC) and Universal Time 1 (UT1), in seconds. UT1-TT : The difference between UT1 and TT, in seconds. LOD : Length of Day, the excess length of a day in milliseconds. dX : Nutation correction in the X-direction in microarcseconds. dY : Nutation correction in the Y-direction in microarcseconds. Ensure that the provided EOP file adheres to this format. If needed, use the  Orient.prepare_eop  utility function to generate a file in the correct format before attempting to load the data."},{"id":612,"pagetitle":"04 - Loading EOP Data","title":"Loading EOP data","ref":"/FrameTransformations/stable/Tutorials/gen/t03_eop/#Loading-EOP-data","content":" Loading EOP data Once a EOP file compatible with the reader is avaliable, the data could be loaded in the environment for later use by the  FrameSystem . To initialize the EOP just run the  Orient.init_eop  function and provide as input the previosly formatted file. This page was generated using  Literate.jl ."},{"id":615,"pagetitle":"05 - Light Time Corrections","title":"Light Time Corrections","ref":"/FrameTransformations/stable/Tutorials/gen/t04_lighttime/#tutorial_04_lighttime","content":" Light Time Corrections This example was generated on 2024-01-05T20:08:57.810. In this tutorial we will explore FrameTransformations.jl capabilities to account for aberration corrections when computing the relative position and velocity between two points. Indeed, this package is capable of replicating all of SPICE's aberration correction features. Assuming we are in the  Reception  case, in which photons depart from the target's location at the light-time correted epoch  et-lt  and arrive at the observer's location at  et , the following corrections are available: One-way Light Time : it provides the position of the target at the moment it emitted photons arriving at the observer at  et . Stellar Aberration : it corrects for one-way light time aswell as stellar aberration by modifiying the relative position to account for the observer's velocity relative to the solar system barycenter. The output is the apparent position of the target as seen by the observer. For a more detailed overview of this concepts, please refer to the original  SPICE documentation ."},{"id":616,"pagetitle":"05 - Light Time Corrections","title":"One-way Light Time","ref":"/FrameTransformations/stable/Tutorials/gen/t04_lighttime/#One-way-Light-Time","content":" One-way Light Time Note Work in progress"},{"id":617,"pagetitle":"05 - Light Time Corrections","title":"Stellar Aberration","ref":"/FrameTransformations/stable/Tutorials/gen/t04_lighttime/#Stellar-Aberration","content":" Stellar Aberration Note Work in progress This page was generated using  Literate.jl ."},{"id":620,"pagetitle":"06 - Multithreading","title":"Multithreading","ref":"/FrameTransformations/stable/Tutorials/gen/t05_multithread/#tutorial_05_threads","content":" Multithreading This example was generated on 2024-01-05T20:08:57.814. Note Work in progress This page was generated using  Literate.jl ."},{"id":623,"pagetitle":"Benchmarks","title":"Performance Benchmarks","ref":"/FrameTransformations/stable/benchmarks/#Performance-Benchmarks","content":" Performance Benchmarks A comparative analysis of the execution times of various routines of this package against  other state-of-the-art packages and libraries is here reported. "},{"id":624,"pagetitle":"Benchmarks","title":"IERS Rotation Models","ref":"/FrameTransformations/stable/benchmarks/#IERS-Rotation-Models","content":" IERS Rotation Models The Orient sub-module provides the capability to compute high-accuracy Earth rotation models based on the IERS 2010 conventions. However, differently from traditional packages, it leverages Julia's metaprogramming capabilities to generate optimised functions for the computation of the lengthy 2000A/B nutation series. A comparison against both  ERFA.jl  and  SatelliteToolbox.jl  is here reported. Details These time benchmarks have been obtained on an Intel Core i7-6700 @ 3.4 GHz with 16 GB of RAM"},{"id":625,"pagetitle":"Benchmarks","title":"Relative Orientation","ref":"/FrameTransformations/stable/benchmarks/#Relative-Orientation","content":" Relative Orientation Frames' performance have been tested against both  GODOT  and  SPICE.jl , two of the most-popular packages that can be used to define a system of reference axes and points and to compute the transformations between them. In particular, a comparative analysis of the execution times for computing the relative orientation between different reference axes has been carried out across four distinct scenarios:  Case 1 : From ICRF to the ECLIPJ2000 frame, a time-fixed rotation.  Case 2 : From the IAU-MOON to the ICRF, a time-dependent rotation.  Case 3 : From the IAU-MOON to the ICRF and subsequently to the IAU_EARTH.  Case 4 : From the IAU-MOON, to the ICRF, to the ECLIPJ2000 and finally a shift to the Sun-Earth rotating two-vector frame. Notice that the Sun and Earth positions are retrieved from binary ephemeris kernels. Details These time benchmarks have been obtained on an Intel Core i7-12700 @ 4.7 GHz with 32 GB of RAM This figure also underlines the capability of FrameTransformations (here referred to as  Multiverse ) to use different ephemeris readers as backends within the computational graph."},{"id":626,"pagetitle":"Benchmarks","title":"Relative States","ref":"/FrameTransformations/stable/benchmarks/#Relative-States","content":" Relative States Note Work in progress"},{"id":629,"pagetitle":"Roadmap","title":"Development Roadmap","ref":"/FrameTransformations/stable/roadmap/#Development-Roadmap","content":" Development Roadmap The following table reports the desired list of features considered in the development of  this package, together with their development status. The following color legend is used:  Description 🔵 Stable, deeply tested 🟢 Developed, working, partially tested 🟡 In development 🔴 Development not started but planned ⚪ Outdated/no more supported"},{"id":630,"pagetitle":"Roadmap","title":"Frames","ref":"/FrameTransformations/stable/roadmap/#Frames","content":" Frames All the initially desired features of Frames have been implemented. We are currently working  to avoid undesired allocations when using dual numbers. \n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n Feature Status Comment \n        Create a graph of custom points.\n     🔵 Points could be defined in different ways (not only associated to ephemeris). \n        Create a graph of custom axes.\n     🔵 Axes models for MEME2000, ITRF, IAU models and many others are already implemented and tested within FrameTransformationsFrameTransformations. \n        Get a state of a point relative to another in a custom frame.\n     🔵 Deeply tested against NAIF's SPICE. \n        Full compatibility with ForwardDiff.jl shall be assured.\n     🟡 Partial compatibility is already available. We are resolving the \n    last issues related to undesired allocations when using dual numbers. "},{"id":631,"pagetitle":"Roadmap","title":"Orient","ref":"/FrameTransformations/stable/roadmap/#Orient","content":" Orient All the features of the Orient submodule have been developed and tested. No major updates are currently foreseen. \n.tg  {border-collapse:collapse;border-spacing:0;}\n.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;\n  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}\n.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}\n.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}\n Feature Status Comment \n        Create IAU standard-based body-fixed rotation matrices.\n     🔵 Deeply tested against NAIF's SPICE. \n        Create ITRF (IERS-based) rotation matrices.\n     🔵 Deeply tested against ERFA. Models with different precisions are available. \n        Fetch leapseconds files automatically.\n     🟢"},{"id":634,"pagetitle":"AstroRepresentations.jl","title":"AstroRepresentations.jl","ref":"/AstroRepresentations/stable/#AstroRepresentations.jl","content":" AstroRepresentations.jl Astrodynamical states representations and transformations."},{"id":637,"pagetitle":"Angles","title":"Angles Transformations","ref":"/AstroRepresentations/stable/angles/#Angles-Transformations","content":" Angles Transformations"},{"id":638,"pagetitle":"Angles","title":"AstroRepresentations.tan_to_eca","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tan_to_eca","content":" AstroRepresentations.tan_to_eca  —  Function tan_to_eca(tan::Number, ecc::Number) Convert true anomaly to eccentric anomaly. source"},{"id":639,"pagetitle":"Angles","title":"AstroRepresentations.tan_to_hya","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tan_to_hya","content":" AstroRepresentations.tan_to_hya  —  Function tan_to_hya(tan::Number, ecc::Number) Convert true anomaly to hyperbolic anomaly. source"},{"id":640,"pagetitle":"Angles","title":"AstroRepresentations.tan_to_man","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tan_to_man","content":" AstroRepresentations.tan_to_man  —  Function tan_to_man(tan::Number, ecc::Number) Convert true anomaly into mean anomaly source"},{"id":641,"pagetitle":"Angles","title":"AstroRepresentations.tan_to_par","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.tan_to_par","content":" AstroRepresentations.tan_to_par  —  Function tan_to_par(ta::Number) Convert true anomaly to parabolic anomaly. source"},{"id":642,"pagetitle":"Angles","title":"AstroRepresentations.eca_to_tan","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.eca_to_tan","content":" AstroRepresentations.eca_to_tan  —  Function eca_to_tan(eca::Number, ecc::Number) Convert eccentric anomaly to true anomaly. source"},{"id":643,"pagetitle":"Angles","title":"AstroRepresentations.hya_to_tan","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.hya_to_tan","content":" AstroRepresentations.hya_to_tan  —  Function hya_to_tan(hca::Number, ecc::Number) Convert hyperbolic anomaly to true anomaly. source"},{"id":644,"pagetitle":"Angles","title":"AstroRepresentations.man_to_tan","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.man_to_tan","content":" AstroRepresentations.man_to_tan  —  Function man_to_tan(man::Number, ecc::Number) Convert mean anomaly to true anomaly. source"},{"id":645,"pagetitle":"Angles","title":"AstroRepresentations.par_to_tan","ref":"/AstroRepresentations/stable/angles/#AstroRepresentations.par_to_tan","content":" AstroRepresentations.par_to_tan  —  Function par_to_tan(pca::Number) Convert parabolic anomaly to true anomaly. source"},{"id":648,"pagetitle":"States","title":"State Transformations","ref":"/AstroRepresentations/stable/states/#State-Transformations","content":" State Transformations"},{"id":649,"pagetitle":"States","title":"Classical Orbital Elements (coe)","ref":"/AstroRepresentations/stable/states/#Classical-Orbital-Elements-(coe)","content":" Classical Orbital Elements (coe)"},{"id":650,"pagetitle":"States","title":"AstroRepresentations.convert6_cart_to_coe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_cart_to_coe","content":" AstroRepresentations.convert6_cart_to_coe  —  Function convert6_cart_to_coe(sv::AbstractVector{<:Number}, μ::Number, [args]...) Convert cartesian state representation into classical orbital elements. Inputs sv  – state vector –  L, T μ  – center gravitational parameter  –  L³/T² Output Classical orbital elements representation of the state as a  SVector{6} .  References Vallado, David A. -  Fundamentals of astrodynamics and applications . Vol. 12.  Springer Science & Business Media, 2001. source"},{"id":651,"pagetitle":"States","title":"AstroRepresentations.convert6_coe_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_coe_to_cart","content":" AstroRepresentations.convert6_coe_to_cart  —  Function convert6_coe_to_cart(sv::AbstractVector{<:Number}, μ::Number, [args]...) Convert classical orbital elements state vector to cartesian state. Inputs sv  – Keplerian elements –  L, rad μ  – Center's gravitational parameter  –  L³/T² Output Cartesian representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications . Vol. 12.  Springer Science & Business Media, 2001. source"},{"id":652,"pagetitle":"States","title":"Equinoctial Orbital Elements (equi)","ref":"/AstroRepresentations/stable/states/#Equinoctial-Orbital-Elements-(equi)","content":" Equinoctial Orbital Elements (equi)"},{"id":653,"pagetitle":"States","title":"AstroRepresentations.convert6_cart_to_equi","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_cart_to_equi","content":" AstroRepresentations.convert6_cart_to_equi  —  Function convert6_cart_to_equi(sv::AbstractVector{<:Number}, μ::Number, [args]...) Convert cartesian state vector to Equinoctial keplerian elements. Inputs sv  – state vector –  L, T μ  – center gravitational parameter  –  L³/T² Output Equinoctial representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. Cefola - DOI: 10.2514/6.1972-937 source"},{"id":654,"pagetitle":"States","title":"AstroRepresentations.convert6_equi_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_equi_to_cart","content":" AstroRepresentations.convert6_equi_to_cart  —  Function convert6_equi_to_cart(equi::AbstractVector{<:Number}, μ::Number, [args]...) Convert equinoctial state elements to cartesian state. Inputs equi  – Equinoctial elements –  L, rad μ  – center gravitational parameter  –  L³/T² Output Cartesian representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. Cefola - DOI: 10.2514/6.1972-937 source"},{"id":655,"pagetitle":"States","title":"AstroRepresentations.convert6_coe_to_equi","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_coe_to_equi","content":" AstroRepresentations.convert6_coe_to_equi  —  Function convert6_coe_to_equi(coe::AbstractVector{<:Number}, [args]...) Convert classical orbital elements state vector to Equinoctial keplerian elements. Inputs coe  – Keplerian elements –  L, rad Output Equinoctial representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. source"},{"id":656,"pagetitle":"States","title":"AstroRepresentations.convert6_equi_to_coe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_equi_to_coe","content":" AstroRepresentations.convert6_equi_to_coe  —  Function convert6_equi_to_coe(coe::AbstractVector{<:Number}, [args]...) Convert Equinoctial keplerian elements to classical orbital elements state vector . Inputs equi  – Equinoctial elements –  L, rad Output Keplerian representation of the state as a  SVector{6} . References Vallado, David A. -  Fundamentals of astrodynamics and applications , 2013. source"},{"id":657,"pagetitle":"States","title":"Spherical State Representation (sphe)","ref":"/AstroRepresentations/stable/states/#Spherical-State-Representation-(sphe)","content":" Spherical State Representation (sphe)"},{"id":658,"pagetitle":"States","title":"AstroRepresentations.convert6_cart_to_sphe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_cart_to_sphe","content":" AstroRepresentations.convert6_cart_to_sphe  —  Function convert6_cart_to_sphe(sv::AbstractVector{<:Number}, [args]...) Convert cartesian state into spherical (ra-dec) representation. source"},{"id":659,"pagetitle":"States","title":"AstroRepresentations.convert6_sphe_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert6_sphe_to_cart","content":" AstroRepresentations.convert6_sphe_to_cart  —  Function convert6_sphe_to_cart(sv::AbstractVector{<:Number}, [args]...) Convert spherical (ra-dec) state into cartesian representation. source"},{"id":660,"pagetitle":"States","title":"AstroRepresentations.convert3_cart_to_sphe","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert3_cart_to_sphe","content":" AstroRepresentations.convert3_cart_to_sphe  —  Function convert3_cart_to_sphe(sv::AbstractVector{<:Number}, [args]...) Convert cartesian position into spherical (ra-dec). source"},{"id":661,"pagetitle":"States","title":"AstroRepresentations.convert3_sphe_to_cart","ref":"/AstroRepresentations/stable/states/#AstroRepresentations.convert3_sphe_to_cart","content":" AstroRepresentations.convert3_sphe_to_cart  —  Function convert6_sphe_to_cart(sv::AbstractVector{<:Number}, [args]...) Convert spherical (ra-dec) position into cartesian. source"},{"id":664,"pagetitle":"Home","title":"JSMDInterfaces.jl","ref":"/JSMDInterfaces/stable/#JSMDInterfaces.jl","content":" JSMDInterfaces.jl An interface-only package for the JSMD ecosystem JSMDInterfacesUtils.jl handles all the interface definitions for the  JSMD  ecosystem. It is a low-level and low dependency library made to be  depended on by the higher-level libraries to supply a common interface."},{"id":667,"pagetitle":"Ephemeris","title":"Ephemeris","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#Ephemeris","content":" Ephemeris"},{"id":668,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.AbstractEphemerisProvider","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.AbstractEphemerisProvider","content":" JSMDInterfaces.Ephemeris.AbstractEphemerisProvider  —  Type AbstractEphemerisProvider Abstract type to represent ephemeris types. source"},{"id":669,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.EphemAxesRecord","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.EphemAxesRecord","content":" JSMDInterfaces.Ephemeris.EphemAxesRecord  —  Type EphemAxesRecord Store an orientation record metadata. Fields target  – NAIF ID of the target axes. jd_start  – Julian date of the first time. jd_end  – Julian date of the last time. axes  – NAIF ID of the reference axes. source"},{"id":670,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.EphemPointRecord","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.EphemPointRecord","content":" JSMDInterfaces.Ephemeris.EphemPointRecord  —  Type EphemPointRecord Store a position record metadata. Fields target  – NAIF ID of the target point. center  – NAIF ID of the center point. jd_start  – Julian date of the first time. jd_end  – Julian date of the last time. axes  – NAIF ID of the reference axes. source"},{"id":671,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.EphemerisError","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.EphemerisError","content":" JSMDInterfaces.Ephemeris.EphemerisError  —  Type JSMDInterfaces.Ephemeris.EphemerisError A type representing ephemeris load or computations errors. source"},{"id":672,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.ephem_compute!","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.ephem_compute!-Tuple{Any, JSMDInterfaces.Ephemeris.AbstractEphemerisProvider, Number, Number, Int64, Int64, Int64}","content":" JSMDInterfaces.Ephemeris.ephem_compute!  —  Method ephem_compute!(res, eph::AbstractEphemerisProvider, jd0::Number, time::Number, \n    target::Int, center::Int, order::Int) Abstract method to compute position and derivatives up to  order  of  target  with  respect to  center  at the Julian Date  jd0 + time . Inputs eph  – Ephemeris provider. jd0 ,  time  –  jd0 + time  must be equal to the Julian Day for the time coordinate    corresponding to the ephemeris.  target  – The body or reference point whose coordinates are required.  center  – The origin of the coordinate system.  order  – The order of derivatives from 0 (position) to 3 (position, velocity,    acceleration and jerk). source"},{"id":673,"pagetitle":"Ephemeris","title":"JSMDInterfaces.Ephemeris.ephem_orient!","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.Ephemeris.ephem_orient!-Tuple{Any, JSMDInterfaces.Ephemeris.AbstractEphemerisProvider, Number, Number, Int64, Int64, Int64}","content":" JSMDInterfaces.Ephemeris.ephem_orient!  —  Method ephem_orient!(res, eph::AbstractEphemerisProvider, jd0::Number, time::Number, \n    target::Int, center::Int, order::Int) Abstract method to compute Euler angles and derivatives up to  order  for the orientation of  the  target  axes at epoch  jd0 + time . Inputs eph  – Ephemeris provider. jd0 ,  time  –  jd0 + time  must be equal to the Julian Day for the time coordinate    corresponding to the ephemeris.  target  – The axes whose orientation is required. center  – The parent set of axes. order  – The order of derivatives from 0 (angles) to 3 (angles, angles rate, etc...). source"},{"id":674,"pagetitle":"Ephemeris","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDInterfaces/stable/interfaces/Ephemeris/#JSMDInterfaces.FilesIO.load-Tuple{Type{<:JSMDInterfaces.Ephemeris.AbstractEphemerisProvider}, Any}","content":" JSMDInterfaces.FilesIO.load  —  Method load(::Type{<:AbstractEphemerisProvider}, files) Load ephemeris files. source"},{"id":677,"pagetitle":"Errors","title":"Errors","ref":"/JSMDInterfaces/stable/interfaces/Errors/#Errors","content":" Errors"},{"id":678,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.AbstractGenericException","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.AbstractGenericException","content":" JSMDInterfaces.Errors.AbstractGenericException  —  Type AbstractGenericException A supertype for all ecosystem related errors. source"},{"id":679,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.GenericError","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.GenericError","content":" JSMDInterfaces.Errors.GenericError  —  Type JSMDInterfaces.Errors.GenericError A type representing generic errors. source"},{"id":680,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.NotImplementedError","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.NotImplementedError","content":" JSMDInterfaces.Errors.NotImplementedError  —  Type JSMDInterfaces.Errors.NotImplementedError A type representing not implemented errors. source"},{"id":681,"pagetitle":"Errors","title":"JSMDInterfaces.Errors.@custom_error","ref":"/JSMDInterfaces/stable/interfaces/Errors/#JSMDInterfaces.Errors.@custom_error-Tuple{Any}","content":" JSMDInterfaces.Errors.@custom_error  —  Macro @custom_error Create a type representing a custom error type. source"},{"id":684,"pagetitle":"FilesIO","title":"FilesIO","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#FilesIO","content":" FilesIO"},{"id":685,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.filepath","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.filepath","content":" JSMDInterfaces.FilesIO.filepath  —  Function filepath(files::AbstractFile, idx::Int=1) Return the path of the  idx -th file within  files .  source"},{"id":686,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.filepaths","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.filepaths-Tuple{JSMDInterfaces.FilesIO.AbstractFile}","content":" JSMDInterfaces.FilesIO.filepaths  —  Method filepaths(files::AbstractFile) Return the path of all the files loaded within  file . source"},{"id":687,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.load-Tuple{JSMDInterfaces.FilesIO.AbstractArchiveNode}","content":" JSMDInterfaces.FilesIO.load  —  Method function load(::AbstractArchiveNode) Generic loader for JSMD archive nodes. source"},{"id":688,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.load-Tuple{JSMDInterfaces.FilesIO.AbstractFile}","content":" JSMDInterfaces.FilesIO.load  —  Method load(files::T) where T <: AbstractFile Generic loader of different file/s formats. source"},{"id":689,"pagetitle":"FilesIO","title":"JSMDInterfaces.FilesIO.@filetype","ref":"/JSMDInterfaces/stable/interfaces/FilesIO/#JSMDInterfaces.FilesIO.@filetype-Tuple{Any, Any}","content":" JSMDInterfaces.FilesIO.@filetype  —  Macro filetype(ftype, suptype) Create a type representing a specific file and the associated   filepaths  and  filepath  implementations. source"},{"id":692,"pagetitle":"Frames","title":"Frames","ref":"/JSMDInterfaces/stable/interfaces/Frames/#Frames","content":" Frames"},{"id":693,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.AbstractJSMDFrameGraph","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.AbstractJSMDFrameGraph","content":" JSMDInterfaces.Frames.AbstractJSMDFrameGraph  —  Type AbstractJSMDFrameGraph Abstract type for frames graphs.  Subtype it to create a new frames graph compatible with the ecosystem. source"},{"id":694,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation12","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation12-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation12  —  Method rotation12(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix, its first, second and third  derivative between two axes within a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":695,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation3","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation3-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation3  —  Method rotation3(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix between two axes within  a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":696,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation6","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation6-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation6  —  Method rotation6(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix and its first derivative  between two axes within a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":697,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.rotation9","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.rotation9-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.rotation9  —  Method rotation9(model::F, from::Int, to::Int, time::Number) This function serves as an interface for constructing a rotation matrix, its first, second  derivative between two axes within a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or axis for the rotation matrix. to::Int : The destination node or axis for the rotation matrix. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":698,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector12","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector12-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector12  —  Method vector12(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position, velocity, acceleration, and jerk vector  using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":699,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector3","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector3-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector3  —  Method vector3(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position vector using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":700,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector6","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector6-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector6  —  Method vector6(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position and velocity vector using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":701,"pagetitle":"Frames","title":"JSMDInterfaces.Frames.vector9","ref":"/JSMDInterfaces/stable/interfaces/Frames/#JSMDInterfaces.Frames.vector9-Tuple{JSMDInterfaces.Frames.AbstractJSMDFrameGraph, Int64, Int64, Int64, Number}","content":" JSMDInterfaces.Frames.vector9  —  Method vector9(model::F, from::Int, to::Int, axis::Int, time::Number) This function serves as an interface for constructing a position, velocity, and acceleration vector  using a frame graph model. Arguments model::F : An instance of a subtype of  AbstractJSMDFrameGraph , representing the frame graph model. from::Int : The source node or point for the vector. to::Int : The destination node or point for the vector. axis::Int : The specific axis of the vector. time::T : The independent variable (time), in seconds since J2000. Warning Concrete implementations of  AbstractJSMDFrameGraph  must provide this function! source"},{"id":704,"pagetitle":"Graph","title":"Graph","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graph","content":" Graph"},{"id":705,"pagetitle":"Graph","title":"JSMDInterfaces.Graph.AbstractJSMDGraph","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#JSMDInterfaces.Graph.AbstractJSMDGraph","content":" JSMDInterfaces.Graph.AbstractJSMDGraph  —  Type AbstractJSMDGraph{T} Abstract type for graphs.  Subtype it to create graphs compatible with the JSMD ecosystem. Graphs here could be compatible with both JSMD ecosystem and  Graphs.jl : For  JSMD  compatibility, see also:  get_path . For  Graphs.jl  compatibility, see also:  Graphs.jl interface source"},{"id":706,"pagetitle":"Graph","title":"JSMDInterfaces.Graph.AbstractJSMDGraphNode","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#JSMDInterfaces.Graph.AbstractJSMDGraphNode","content":" JSMDInterfaces.Graph.AbstractJSMDGraphNode  —  Type AbstractJSMDGraphNode Abstract type for graph nodes.  Subtype it to create a node graph compatible with the JSMD ecosystem. source"},{"id":707,"pagetitle":"Graph","title":"Graphs.SimpleGraphs.add_edge!","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graphs.SimpleGraphs.add_edge!-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, Int64, Int64, Int64}","content":" Graphs.SimpleGraphs.add_edge!  —  Method add_edge!(g::AbstractJSMDGraph, from::Int, to::Int, cost::Int) This function add an edge between  from  and  to  with weight  cost . source"},{"id":708,"pagetitle":"Graph","title":"Graphs.SimpleGraphs.add_vertex!","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graphs.SimpleGraphs.add_vertex!-Union{Tuple{N}, Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, N}} where N<:JSMDInterfaces.Graph.AbstractJSMDGraphNode","content":" Graphs.SimpleGraphs.add_vertex!  —  Method add_node!(g::AbstractJSMDGraph, vertex::AbstractJSMDGraphNode) This function adds  vertex  to the graph  g . source"},{"id":709,"pagetitle":"Graph","title":"Graphs.has_path","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#Graphs.has_path-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, Int64, Int64}","content":" Graphs.has_path  —  Method has_path(g::AbstractJSMDGraph, from::Int, to::Int) Return true if there is a path between  from  and  to  in the graph  g . source"},{"id":710,"pagetitle":"Graph","title":"JSMDInterfaces.Graph.get_path","ref":"/JSMDInterfaces/stable/interfaces/Graphs/#JSMDInterfaces.Graph.get_path-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraph, Int64, Int64}","content":" JSMDInterfaces.Graph.get_path  —  Method get_path(g::AbstractJSMDGraph, from::Int, to::Int) Get the nodes on hte path between and including  from' and to . Returns an empty array if  either from or to are not part of g` or if there is no path between them. source"},{"id":713,"pagetitle":"Interface","title":"Interface","ref":"/JSMDInterfaces/stable/interfaces/Interface/#Interface","content":" Interface"},{"id":714,"pagetitle":"Interface","title":"JSMDInterfaces.Interface.@interface","ref":"/JSMDInterfaces/stable/interfaces/Interface/#JSMDInterfaces.Interface.@interface-Tuple{Any}","content":" JSMDInterfaces.Interface.@interface  —  Macro @interface This macro can be used to create a in interface function within the  JSMD ecosystem.  Interface functions are intended as functions with some abstract  types as inputs throwing a  NotImplementedError  as default behaviour. source"},{"id":717,"pagetitle":"Math","title":"Math","ref":"/JSMDInterfaces/stable/interfaces/Math/#Math","content":" Math"},{"id":718,"pagetitle":"Math","title":"JSMDInterfaces.Math.AbstractInterpolationMethod","ref":"/JSMDInterfaces/stable/interfaces/Math/#JSMDInterfaces.Math.AbstractInterpolationMethod","content":" JSMDInterfaces.Math.AbstractInterpolationMethod  —  Type AbstractInterpolationMethod Abstract type representing any interpolation method. source"},{"id":719,"pagetitle":"Math","title":"JSMDInterfaces.Math.interpolate","ref":"/JSMDInterfaces/stable/interfaces/Math/#JSMDInterfaces.Math.interpolate-Tuple{JSMDInterfaces.Math.AbstractInterpolationMethod, Any}","content":" JSMDInterfaces.Math.interpolate  —  Method interpolate(::AbstractInterpolationMethod, x) Abstract interpolator call method. source"},{"id":722,"pagetitle":"Models","title":"Models","ref":"/JSMDInterfaces/stable/interfaces/Models/#Models","content":" Models"},{"id":723,"pagetitle":"Models","title":"JSMDInterfaces.Models.AbstractJSMDModel","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.AbstractJSMDModel","content":" JSMDInterfaces.Models.AbstractJSMDModel  —  Type AbstractJSMDModel Basic abstract type for every JSMD compatible model.  source"},{"id":724,"pagetitle":"Models","title":"JSMDInterfaces.Models.AbstractJSMDModelData","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.AbstractJSMDModelData","content":" JSMDInterfaces.Models.AbstractJSMDModelData  —  Type AbstractJSMDModelData Basic abstract type for every JSMD compatible model data.  JSMD  ModelData  types are the interface of the JSMD environment with the external world,  and are meant to provide a model agnostic interface to any customly formatted file. The main objective of this data type is to create a JSMD simulation compatible  Model   by means of the  parse_model  interface. source"},{"id":725,"pagetitle":"Models","title":"JSMDInterfaces.Models.dump_model","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.dump_model-Union{Tuple{N}, Tuple{JSMDInterfaces.Models.AbstractJSMDModel, N, Vararg{Any}}} where N<:JSMDInterfaces.FilesIO.AbstractArchiveNode","content":" JSMDInterfaces.Models.dump_model  —  Method dump_model(::AbstractJSMDModel, ::N, args...; \n    kargs...) where {N <: AbstractArchiveNode} This function serves as an interface to dump to an archive node a JSMD compatible model. source"},{"id":726,"pagetitle":"Models","title":"JSMDInterfaces.Models.load_model","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.load_model-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Type{<:JSMDInterfaces.Models.AbstractJSMDModel}, N, Vararg{Any}}} where {T, N<:JSMDInterfaces.FilesIO.AbstractArchiveNode}","content":" JSMDInterfaces.Models.load_model  —  Method load_model(::Type{T}, ::Type{ <: AbstractJSMDModel}, ::N, \n    args...; kargs...) where {T, N <: AbstractArchiveNode} This function serves as an interface to load from an archive node a JSMD compatible model. source"},{"id":727,"pagetitle":"Models","title":"JSMDInterfaces.Models.parse_data","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.parse_data-Union{Tuple{D}, Tuple{T}, Tuple{Type{T}, Type{D}, AbstractString}} where {T, D<:JSMDInterfaces.Models.AbstractJSMDModelData}","content":" JSMDInterfaces.Models.parse_data  —  Method parse_data(::Type{T}, ::Type{D}, ::AbstractString; \n    kargs...) where {T, D <: AbstractJSMDModelData} end This function serves as an interface to create a JSMD compatible  model data object from a file. source"},{"id":728,"pagetitle":"Models","title":"JSMDInterfaces.Models.parse_model","ref":"/JSMDInterfaces/stable/interfaces/Models/#JSMDInterfaces.Models.parse_model-Union{Tuple{M}, Tuple{D}, Tuple{T}, Tuple{Type{T}, Type{M}, Type{D}, Vararg{Any}}} where {T, D<:JSMDInterfaces.Models.AbstractJSMDModelData, M<:JSMDInterfaces.Models.AbstractJSMDModel}","content":" JSMDInterfaces.Models.parse_model  —  Method parse_model(::Type{T}, ::Type{M}, ::Type{D}, args...; \n    kargs...) where {T, D <: AbstractJSMDModelData, M <: AbstractJSMDModel} This function serves as an interface to create a JSMD compatible  model type from a  ModelData  type. source"},{"id":731,"pagetitle":"Home","title":"JSMDUtils.jl","ref":"/JSMDUtils/stable/#JSMDUtils.jl","content":" JSMDUtils.jl A utily package for the JSMD ecosystem JSMDUtils.jl is a low-level package holding different utility functions and type definitions that are reused by many packages within the  JSMD  ecosystem. "},{"id":734,"pagetitle":"API","title":"JSMDUtils API","ref":"/JSMDUtils/stable/api/#JSMDUtils-API","content":" JSMDUtils API"},{"id":735,"pagetitle":"API","title":"Math","ref":"/JSMDUtils/stable/api/#Math","content":" Math"},{"id":736,"pagetitle":"API","title":"JSMDUtils.Math.InterpAkima","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpAkima","content":" JSMDUtils.Math.InterpAkima  —  Type InterpAkima{T, N} <: AbstractInterpolationMethod Type storing an Akima spline nodes and coefficient.  T  is the interpolation data type  and  N  is the spline dimension (i.e., the number of interpolated functions). Fields n  – Number of node points. xn  – Interpolated node points.  yn  – Node points function values  c  – Akima polynomial coefficients.  source"},{"id":737,"pagetitle":"API","title":"JSMDUtils.Math.InterpAkima","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpAkima-Tuple{AbstractVector, AbstractArray}","content":" JSMDUtils.Math.InterpAkima  —  Method InterpAkima(x::AbstractVector, y::AbstractArray) Construct an Akima spline interpolant from a set of data points  x  and their values  y .  Multi-dimensional splines can be constructed passing  y  as a subtype of  AbstractMatrix  such  that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points. References Akima, H. (1970),  A New Method of Interpolation and Smooth Curve Fitting Based on Local   Procedures, Journal of the ACM,  DOI: source"},{"id":738,"pagetitle":"API","title":"JSMDUtils.Math.InterpCubicSplines","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpCubicSplines","content":" JSMDUtils.Math.InterpCubicSplines  —  Type InterpCubicSplines(x::AbstractVector, y::AbstractArray, type::Symbol=:Natural) Construct a cubic spline interpolant from a set of data points  x  and their values  y .  Multi-dimensional splines can be constructed by passing  y  as a subtype of  AbstractMatrix ,  such that each row contains a different set of values to be interpolated and the number of  columns equals the number of data points. Different boundary conditions can be applied based on the specified  type :  :Natural : the second derivative of the first and the last polynomial are equal to    zero at the boundary points.  :NotAKnot : the third derivatives of the first and last two polynomials are    equal in the points where they meet each other. :Periodic : the first and second derivatives at the initial and final points are equal. :Quadratic : the first and the last polynomial are quadratic.  source"},{"id":739,"pagetitle":"API","title":"JSMDUtils.Math.InterpCubicSplines","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.InterpCubicSplines","content":" JSMDUtils.Math.InterpCubicSplines  —  Type InterpCubicSplines{T, N} <: AbstractInterpolationMethod Type storing a cubic spline nodes and coefficients.  T  is the spline data type and   N  is the spline dimension (i.e., the number of interpolated functions).  Fields n  – Number of node points. m  – Size of the interpolated element.  xn  – Interpolated node points. yn  – Node points function values.  c  –  Spline polynomials coefficients.  type  – Boundary conditions type. source"},{"id":740,"pagetitle":"API","title":"JSMDInterfaces.Math.interpolate","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpAkima{T, 1}, Number, Bool}} where T","content":" JSMDInterfaces.Math.interpolate  —  Method interpolate(ak::InterpAkima, x::Number, flat::Bool=true) Interpolate the Akima spline  ak  at point  x . If the spline has a single  dimension (e.g.,  InterpAkima{T, 1} ), a scalar value is returned. Otherwise, an  SVector  is computed.  If  x  is outside the boundary range of  sp  a flat extrapolation is used by default.  If the  flat  argument is  false , the first and last polynomials will be used to  compute all the outside values. source"},{"id":741,"pagetitle":"API","title":"JSMDInterfaces.Math.interpolate","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.Math.interpolate-Union{Tuple{T}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number}, Tuple{JSMDUtils.Math.InterpCubicSplines{T, 1}, Number, Bool}} where T","content":" JSMDInterfaces.Math.interpolate  —  Method interpolate(sp::InterpCubicSplines, x::Number, flat::Bool=true) Interpolate the cubic spline  sp  at point  x . If the spline has a single  dimension (e.g.,  InterpCubicSpline{T, 1} ), a scalar value is returned. Otherwise, an  SVector  is computed.  If  x  is outside the boundary range of  sp  a flat extrapolation is used by default.  If the  flat  argument is  false , the first and last polynomials will be used to  compute all the outside values. source"},{"id":742,"pagetitle":"API","title":"JSMDUtils.Math.D²","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.D²-Tuple{Any, Any}","content":" JSMDUtils.Math.D²  —  Method D²(f, x::Real) Return  d²f/dx²  evaluated at  x  using ForwardDiff, assuming  f  is called as  f(x) . This method assumes that  isa(f(x), Union{Real, AbstractArray}) . source"},{"id":743,"pagetitle":"API","title":"JSMDUtils.Math.D³","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.D³-Tuple{Any, Any}","content":" JSMDUtils.Math.D³  —  Method D³(f, x::Real) Return  d³f/dx³  evaluated at  x  using ForwardDiff, assuming  f  is called as  f(x) . This method assumes that  isa(f(x), Union{Real, AbstractArray}) . source"},{"id":744,"pagetitle":"API","title":"JSMDUtils.Math.D¹","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.D¹-Tuple{Any, Any}","content":" JSMDUtils.Math.D¹  —  Method D¹(f, x::Real) Return  df/dx  evaluated at  x  using ForwardDiff, assuming  f  is called as  f(x) . This method assumes that  isa(f(x), Union{Real, AbstractArray}) . source"},{"id":745,"pagetitle":"API","title":"JSMDUtils.Math._3angles_to_δdcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math._3angles_to_δdcm-Tuple{Any, Symbol}","content":" JSMDUtils.Math._3angles_to_δdcm  —  Method _3angles_to_δdcm(θ, rot_seq::Symbol) Compute the time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":746,"pagetitle":"API","title":"JSMDUtils.Math._3angles_to_δ²dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math._3angles_to_δ²dcm-Tuple{Any, Symbol}","content":" JSMDUtils.Math._3angles_to_δ²dcm  —  Method _3angles_to_δ²dcm(θ, rot_seq::Symbol) Compute the 2nd time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":747,"pagetitle":"API","title":"JSMDUtils.Math._3angles_to_δ³dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math._3angles_to_δ³dcm-Tuple{Any, Symbol}","content":" JSMDUtils.Math._3angles_to_δ³dcm  —  Method _3angles_to_δ³dcm(θ, rot_seq::Symbol) Compute the 3rd order time derivative of the DCM with all the angles stored in a single vector  to optimise computations.  source"},{"id":748,"pagetitle":"API","title":"JSMDUtils.Math.angle_to_δdcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angle_to_δdcm","content":" JSMDUtils.Math.angle_to_δdcm  —  Function angle_to_δdcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX) Compute the derivative of the direction cosine matrix that perform a set of rotations ( θ ,   ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation input must be an indexable  objected which includes the angle and its first time derivative. The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δ²dcm source"},{"id":749,"pagetitle":"API","title":"JSMDUtils.Math.angle_to_δ²dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angle_to_δ²dcm","content":" JSMDUtils.Math.angle_to_δ²dcm  —  Function angle_to_δ²dcm(θ[, ϕ[, γ]], rot_seq::Symbol = :ZYX) Compute the second order time derivative of the direction cosine matrix that perform  a set of rotations ( θ ,  ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation  input must be an indexable objected which includes the angle and its first and second order  time derivatives. The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δdcm source"},{"id":750,"pagetitle":"API","title":"JSMDUtils.Math.angle_to_δ³dcm","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angle_to_δ³dcm","content":" JSMDUtils.Math.angle_to_δ³dcm  —  Function angle_to_δ³dcm(θ::Number[, ϕ::Number[, γ::Number]], rot_seq::Symbol = :Z) Compute the second order time derivative of the direction cosine matrix that perform  a set of rotations ( θ ,  ϕ ,  γ ) about the coordinate axes in  rot_seq . Each rotation  input must be an indexable objected which includes the angle and its time derivatives up to  order 3 (jerk). The rotation sequence is defined by a  Symbol  specifing the rotation axes. The possible  values depend on the number of rotations as follows:  1 rotation  ( θ₁ ):  :X ,  :Y , or  :Z . 2 rotations  ( θ₁ ,  θ₂ ):  :XY ,  :XZ ,  :YX ,  :YZ ,  :ZX , or  :ZY . 3 rotations  ( θ₁ ,  θ₂ ,  θ₃ ):  :XYX ,  XYZ ,  :XZX ,  :XZY ,  :YXY ,    :YXZ ,  :YZX ,  :YZY ,  :ZXY ,  :ZXZ ,  :ZYX , or  :ZYZ Note This function assigns  dcm = A3 * A2 * A1  in which  Ai  is the DCM related with the  i -th rotation,  i Є [1,2,3] . If the  i -th rotation is not specified, then  Ai = I . See also See also  angle_to_δdcm source"},{"id":751,"pagetitle":"API","title":"JSMDUtils.Math.angleplane","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angleplane-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.angleplane  —  Method angleplane(v1::AbstractArray, n::AbstractArray) Compute the angle between a vector  v1  and (its projection on) a plane with normal  n , in rad.  source"},{"id":752,"pagetitle":"API","title":"JSMDUtils.Math.angleplaned","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.angleplaned-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.angleplaned  —  Method angleplaned(v1::AbstractArray, n::AbstractArray) Compute the angle between a vector  v1  and (its projection on) a plane with normal  n , in deg.  source"},{"id":753,"pagetitle":"API","title":"JSMDUtils.Math.anglevec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.anglevec-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.anglevec  —  Method anglevec(v1::AbstractArray, v2::AbstractArray) Compute the angle between two vectors  v1  and  v2 , in rad. source"},{"id":754,"pagetitle":"API","title":"JSMDUtils.Math.anglevecd","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.anglevecd-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.anglevecd  —  Method anglevecd(v1::AbstractArray, v2::AbstractArray) Compute the angle between two vectors  v1  and  v2 , in deg. source"},{"id":755,"pagetitle":"API","title":"JSMDUtils.Math.cross12","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross12-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross12  —  Method cross12(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its 1st, 2nd and 3rd order time derivatives.  Note x  and  y  must be 12-elements state vectors (position, velocity and acceleration) source"},{"id":756,"pagetitle":"API","title":"JSMDUtils.Math.cross3","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross3-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross3  —  Method cross3(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y , considering only their first 3 elements. source"},{"id":757,"pagetitle":"API","title":"JSMDUtils.Math.cross6","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross6-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross6  —  Method cross6(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its time derivative.  Note x  and  y  must be 6-elements state vectors, with the last elements of each vector  representing the time derivatives of the first three. source"},{"id":758,"pagetitle":"API","title":"JSMDUtils.Math.cross9","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.cross9-Tuple{AbstractVector, AbstractVector}","content":" JSMDUtils.Math.cross9  —  Method cross9(x::AbstractVector, y::AbstractVector) Compute the cross product between  x  and  y  and its 1st and 2nd-order time derivatives.  Note x  and  y  must be 9-elements state vectors (position, velocity and acceleration) source"},{"id":759,"pagetitle":"API","title":"JSMDUtils.Math.projplane","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.projplane-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.projplane  —  Method projplane(v1::AbstractArray, n::AbstractArray) Compute the orthogonal projection of a vector  v1  on a plane with normal  n . source"},{"id":760,"pagetitle":"API","title":"JSMDUtils.Math.projvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.projvec-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.projvec  —  Method projvec(v1::AbstractArray, v2::AbstractArray) Compute the orthogonal projection of a vector  v1  on a vector  v2 . source"},{"id":761,"pagetitle":"API","title":"JSMDUtils.Math.skew","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.skew-Tuple{AbstractArray}","content":" JSMDUtils.Math.skew  —  Method skew(a) Create a skew matrix from the vector  v . source"},{"id":762,"pagetitle":"API","title":"JSMDUtils.Math.unitcross","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.unitcross-Tuple{AbstractArray, AbstractArray}","content":" JSMDUtils.Math.unitcross  —  Method unitcross(v1::AbstractArray, v2::AbstractArray) Compute the normalized cross product of  v1  and  v2 . source"},{"id":763,"pagetitle":"API","title":"JSMDUtils.Math.unitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.unitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.unitvec  —  Method unitvec(v::AbstractVector) Normalise the vector  v . source"},{"id":764,"pagetitle":"API","title":"JSMDUtils.Math.δunitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.δunitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.δunitvec  —  Method δunitvec(v::AbstractVector) Compute the time derivative of a unit vector  v . source"},{"id":765,"pagetitle":"API","title":"JSMDUtils.Math.δ²unitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.δ²unitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.δ²unitvec  —  Method δ²unitvec(v::AbstractVector) Compute the 2nd-order time derivative of a unit vector  v . source"},{"id":766,"pagetitle":"API","title":"JSMDUtils.Math.δ³unitvec","ref":"/JSMDUtils/stable/api/#JSMDUtils.Math.δ³unitvec-Tuple{AbstractVector}","content":" JSMDUtils.Math.δ³unitvec  —  Method δ³unitvec(v::AbstractVector) Compute the 3rd-order time derivative of a unit vector  v . source"},{"id":767,"pagetitle":"API","title":"Autodiff","ref":"/JSMDUtils/stable/api/#Autodiff","content":" Autodiff"},{"id":768,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoHessianConfig","content":" JSMDUtils.Autodiff.AutoHessianConfig  —  Type AutoHessianConfig Wrapper object around a  ForwardDiff.HessianConfig  type.  source"},{"id":769,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoHessianConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoHessianConfig-Tuple{Any}","content":" JSMDUtils.Autodiff.AutoHessianConfig  —  Method AutoHessianConfig(x) Generate a  Autodiff.AutoHessianConfig  instance based on the type and shape of the  input vector  x .  The returned  AutoHessianConfig  instance contains all the work buffers required by   Autodiff.hessian!  when the target function takes the form  f(x) . The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers.  Warning The dual numbers that are generated from this instance all share the   Autodiff.JSMDDiffTag  tag, which could lead to perturbation confusion if the  hessian operation is not used with care. See Also See also  Autodiff.hessian! . source"},{"id":770,"pagetitle":"API","title":"JSMDUtils.Autodiff.JSMDDiffTag","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.JSMDDiffTag","content":" JSMDUtils.Autodiff.JSMDDiffTag  —  Type JSMDDiffTag Singleton to be used as a ForwardDiff tag for the JSMD ecosystem. source"},{"id":771,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoGradientConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoGradientConfig-Tuple{Any}","content":" JSMDUtils.Autodiff.AutoGradientConfig  —  Method AutoGradientConfig(x) Generate a  ForwardDiff.GradientConfig  instance based on the type and shape of the  input  x .  The returned  GradientConfig  instance contains all the work buffers required by   Autodiff.gradient! . The chunk size is automatically set to 1 since it is part of  the type. Having a larger chunk-size improves performance but would require a greater  number of dispatches for the function wrappers.  Warning The dual numbers that are generated from this instance all share the   Autodiff.JSMDDiffTag  tag, which could lead to perturbation confusion if the  gradient operation is not used with care. See also See also  Autodiff.gradient! source"},{"id":772,"pagetitle":"API","title":"JSMDUtils.Autodiff.AutoJacobianConfig","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.AutoJacobianConfig-Tuple{Any}","content":" JSMDUtils.Autodiff.AutoJacobianConfig  —  Method AutoJacobianConfig(x) Generate a  ForwardDiff.JacobianConfig  instance based on the type and shape of the  input vector  x .  The returned  JacobianConfig  instance contains all the work buffers required by   Autodiff.jacobian!  when the target function takes the form  f(x) . The chunk  size is automatically set to 1 since it is part of the type. Having a larger chunk-size  improves performance but would require a greater number of dispatches for the function  wrappers.  AutoJacobianConfig(y, x) Generate a  ForwardDiff.JacobianConfig  instance based on the type and shape of the  input vector  x  and the output vector  y .  The returned  JacobianConfig  instance contains all the work buffers required by   Autodiff.jacobian!  when the target function takes the in-place form  f!(y, x). Warning The dual numbers that are generated from this instance all share the   Autodiff.JSMDDiffTag  tag, which could lead to perturbation confusion if the  gradient operation is not used with care. See Also See also  Autodiff.jacobian! . source"},{"id":773,"pagetitle":"API","title":"JSMDUtils.Autodiff.derivative","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.derivative-Tuple{Any, Number}","content":" JSMDUtils.Autodiff.derivative  —  Method derivative(f, x::Number) Return  df/dx  evaluated at  x , assuming  f  is called as  f(x) .  Note This function assumes that  isa(f(x), Union{Real, AbstractArray}) . Warning The dual numbers generated by this function are tagged with the   Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain  scenarios. Hence, this derivative operation should be used with care. See also See also  Autodiff.gradient!  and  Autodiff.hessian! source"},{"id":774,"pagetitle":"API","title":"JSMDUtils.Autodiff.gentag","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.gentag-Tuple{Any}","content":" JSMDUtils.Autodiff.gentag  —  Method gentag(x) Generate a dual tag for the element type of  x . source"},{"id":775,"pagetitle":"API","title":"JSMDUtils.Autodiff.gradient!","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.gradient!-Tuple{Any, Any, Any}","content":" JSMDUtils.Autodiff.gradient!  —  Method gradient!(res, f, x)\ngradient!(res, f, x, cfg::GradientConfig) Compute  ∇f  evaluated at  x  and store the output in  res , assuming  f  is called as   f(x) . To avoid runtime allocations, a  GradientConfig  instance must be provided.  Note This function assumes that  isa(f(x), Real) . Warning If the gradient config has been setup with  Autodiff.AutoGradientConfig ,  the dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag   which could lead to perturbation confusion in certain scenarios. Hence, this gradient  operation should be used with care. See Also See also  Autodiff.AutoGradientConfig source"},{"id":776,"pagetitle":"API","title":"JSMDUtils.Autodiff.hessian!","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.hessian!-Tuple{Any, Any, Any}","content":" JSMDUtils.Autodiff.hessian!  —  Method hessian!(res, f, x)\nhessian!(res, f, x, ahc::AutoHessianConfig) Compute  H(f)  (i.e.,  J(∇(f)) ) evaluated at  x  and store the output in  res , assuming   f  is called as  f(x) . To avoid runtime allocations, an  Autodiff.AutoHessianConfig   instance must be provided.  Note This function assumes that  isa(f(x), Real) . Warning The dual numbers generated by this function are tagged with the   Autodiff.JSMDDiffTag  which could lead to perturbation confusion in certain  scenarios. Hence, this hessian operation should be used with care. See Also See also  Autodiff.AutoHessianConfig .  source"},{"id":777,"pagetitle":"API","title":"JSMDUtils.Autodiff.jacobian!","ref":"/JSMDUtils/stable/api/#JSMDUtils.Autodiff.jacobian!-Tuple{Any, Any, Any}","content":" JSMDUtils.Autodiff.jacobian!  —  Method jacobian!(res, f, x)\njacobian!(res, f, x, cfg::JacobianConfig) Compute  J(f)  evaluated at the input vector  x  and store the result in  res , assuming   f  is called as  f(x) . To avoid runtime allocations, a  JacobianConfig  instance must be  provided.  Note This function assumes that  isa(f(x), Union{AbstractArray}) . jacobian!(res, f!, y, x) jacobian!(res, f!, y, x, cfg::JacobianConfig) Compute  J(f)  evaluated at the input vector  x  and store the result in  res , assuming   f  is called as  f!(y, x) , where the result is stored in  y . To avoid runtime allocations, a  JacobianConfig  instance must be  provided.  Warning If the jacobian config has been setup with  Autodiff.AutoJacobianConfig ,  the dual numbers generated by this function are tagged with the  Autodiff.JSMDDiffTag   which could lead to perturbation confusion in certain scenarios. Hence, this jacobian  operation should be used with care. See Also See also  Autodiff.AutoJacobianConfig source"},{"id":778,"pagetitle":"API","title":"FileUtils","ref":"/JSMDUtils/stable/api/#FileUtils","content":" FileUtils"},{"id":779,"pagetitle":"API","title":"JSMDUtils.FileUtils.JSON","ref":"/JSMDUtils/stable/api/#JSMDUtils.FileUtils.JSON","content":" JSMDUtils.FileUtils.JSON  —  Type JSMDUtils.FileUtils.JSON <: JSMDInterfaces.FilesIO.AbstractFile A type representing JSMDUtils.FileUtils.JSON files. source"},{"id":780,"pagetitle":"API","title":"JSMDUtils.FileUtils.TXT","ref":"/JSMDUtils/stable/api/#JSMDUtils.FileUtils.TXT","content":" JSMDUtils.FileUtils.TXT  —  Type JSMDUtils.FileUtils.TXT <: JSMDInterfaces.FilesIO.AbstractFile A type representing JSMDUtils.FileUtils.TXT files. source"},{"id":781,"pagetitle":"API","title":"JSMDUtils.FileUtils.YAML","ref":"/JSMDUtils/stable/api/#JSMDUtils.FileUtils.YAML","content":" JSMDUtils.FileUtils.YAML  —  Type JSMDUtils.FileUtils.YAML <: JSMDInterfaces.FilesIO.AbstractFile A type representing JSMDUtils.FileUtils.YAML files. source"},{"id":782,"pagetitle":"API","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.JSON{1}}","content":" JSMDInterfaces.FilesIO.load  —  Method load(file::JSON{1}) Open a JSON file and parse its data in a dictionary. source"},{"id":783,"pagetitle":"API","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.TXT{1}}","content":" JSMDInterfaces.FilesIO.load  —  Method load(file::TXT{1}) Open a TEXT file and parse its data in a list of strings. source"},{"id":784,"pagetitle":"API","title":"JSMDInterfaces.FilesIO.load","ref":"/JSMDUtils/stable/api/#JSMDInterfaces.FilesIO.load-Tuple{JSMDUtils.FileUtils.YAML{1}}","content":" JSMDInterfaces.FilesIO.load  —  Method load(file::YAML{1}) Open a YAML file and parse its data in a dictionary. source"},{"id":785,"pagetitle":"API","title":"Miscellaneous","ref":"/JSMDUtils/stable/api/#Miscellaneous","content":" Miscellaneous"},{"id":786,"pagetitle":"API","title":"JSMDUtils.NullEphemerisProvider","ref":"/JSMDUtils/stable/api/#JSMDUtils.NullEphemerisProvider","content":" JSMDUtils.NullEphemerisProvider  —  Type EmptyEphemerisProvider <: AbstractEphemerisProvider Empty provider to initialise the frame system without loading  ephemeris files.  source"},{"id":787,"pagetitle":"API","title":"JSMDUtils.format_camelcase","ref":"/JSMDUtils/stable/api/#JSMDUtils.format_camelcase-Tuple{S} where S<:AbstractString","content":" JSMDUtils.format_camelcase  —  Method format_camelcase(str::AbstractString) Format  str  in CamelCase, such that the first letter of each word  in the sentence is capitalized and spaces are removed. source"},{"id":788,"pagetitle":"API","title":"JSMDUtils.format_snakecase","ref":"/JSMDUtils/stable/api/#JSMDUtils.format_snakecase-Tuple{S} where S<:AbstractString","content":" JSMDUtils.format_snakecase  —  Method format_snakecase(str::AbstractString) Format  str  in SnakeCase, such that all the letters are in lower case and  spaces are replaced with underscores. source"},{"id":791,"pagetitle":"Home","title":"SMDGraphs","ref":"/SMDGraphs/stable/#SMDGraphs","content":" SMDGraphs A simple, light, and flexible API for graph-like data structure handling. The purpose of SMDGraphs.jl is to enable efficient support for graph operations and analysis  on custom user-defined datatypes. It achieves so by offering a set of light-weight wrappers  around  Graphs.jl . "},{"id":792,"pagetitle":"Home","title":"Installation","ref":"/SMDGraphs/stable/#Installation","content":" Installation This package can be installed using Julia's package manager:  julia> import Pkg; \njulia> Pkg.add(\"SMDGraphs.jl\")"},{"id":793,"pagetitle":"Home","title":"Overview","ref":"/SMDGraphs/stable/#Overview","content":" Overview This package currently supports the following graph-like structures: Mapped-Node Graphs"},{"id":794,"pagetitle":"Home","title":"Supporting","ref":"/SMDGraphs/stable/#Supporting","content":" Supporting This package was developed as part of the  JSMD  ecosystem.  If you found this package useful in your applications, please consider starring the repository."},{"id":797,"pagetitle":"API","title":"API","ref":"/SMDGraphs/stable/api/#API","content":" API"},{"id":798,"pagetitle":"API","title":"SMDGraphs.MappedNodeGraph","ref":"/SMDGraphs/stable/api/#SMDGraphs.MappedNodeGraph","content":" SMDGraphs.MappedNodeGraph  —  Type MappedNodeGraph{N, G} <: AbstractJSMDGraph{Int} Create a graph with mapped nodes.  Fields graph  – Graph mid  – Mapped id to nodes dictionary nodes  – Mapped nodes  edges  – List of the edges between the nodes  paths  – List of the available paths in the graph Constructors MappedNodeGraph{N}(g::G) where {G <: AbstractGraph, N <: AbstractGraphNode} source"},{"id":799,"pagetitle":"API","title":"SMDGraphs.MappedDiGraph","ref":"/SMDGraphs/stable/api/#SMDGraphs.MappedDiGraph-Union{Tuple{Type{N}}, Tuple{N}} where N","content":" SMDGraphs.MappedDiGraph  —  Method MappedDiGraph(::Type{N}) where {N} Construct a directed  MappedNodeGraph  from node type  N . source"},{"id":800,"pagetitle":"API","title":"SMDGraphs.MappedGraph","ref":"/SMDGraphs/stable/api/#SMDGraphs.MappedGraph-Union{Tuple{Type{N}}, Tuple{N}} where N","content":" SMDGraphs.MappedGraph  —  Method MappedGraph(::Type{N}) where {N} Construct a  MappedNodeGraph  from node type  N . source"},{"id":801,"pagetitle":"API","title":"SMDGraphs.add_edge_cost!","ref":"/SMDGraphs/stable/api/#SMDGraphs.add_edge_cost!-Union{Tuple{N}, Tuple{T}, Tuple{SMDGraphs.MappedNodeGraph{T, N}, Int64, Int64, Int64}} where {T, N<:Graphs.SimpleGraphs.SimpleGraph}","content":" SMDGraphs.add_edge_cost!  —  Method add_edge_cost!(g::MappedNodeGraph{T, <:SimpleGraph}, fid::Int, tid::Int, cost::Int) For a  SimpleGraph  type, register the edge cost between the nodes with mapped IDs   fid  and  tid  in both directions.   source"},{"id":802,"pagetitle":"API","title":"SMDGraphs.add_edge_cost!","ref":"/SMDGraphs/stable/api/#SMDGraphs.add_edge_cost!-Union{Tuple{T}, Tuple{SMDGraphs.MappedNodeGraph{T}, Int64, Int64, Int64}} where T","content":" SMDGraphs.add_edge_cost!  —  Method add_edge_cost!(g::MappedNodeGraph, fid::Int, tid::Int, cost::Int) Register the cost between of the edge from the node with mapped ID  fid  to the  node with mapped ID  tid .  source"},{"id":803,"pagetitle":"API","title":"SMDGraphs.compute_paths!","ref":"/SMDGraphs/stable/api/#SMDGraphs.compute_paths!-Union{Tuple{SMDGraphs.MappedNodeGraph{T}}, Tuple{T}} where T","content":" SMDGraphs.compute_paths!  —  Method compute_paths(g::MappedNodeGraph) Compute all possible paths in the graph. source"},{"id":804,"pagetitle":"API","title":"SMDGraphs.get_edgecosts","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_edgecosts-Union{Tuple{T}, Tuple{SMDGraphs.MappedNodeGraph{T}, Int64, Int64}} where T","content":" SMDGraphs.get_edgecosts  —  Method get_edgecosts(g::MappedNodeGraph, from::Int, to::Int) Get all costs assigned to the edges between  from  and  to . Returns an empty array if  either  from  or  to  are not a part of  g  or if there is no path between them. source"},{"id":805,"pagetitle":"API","title":"SMDGraphs.get_mappedid","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_mappedid-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_mappedid  —  Method get_mappedid(g::MappedNodeGraph, node::Int) Get the mappedid associated with a node. The mappedid is the internal ID that is assigned  to the node within the graph. source"},{"id":806,"pagetitle":"API","title":"SMDGraphs.get_mappednode","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_mappednode-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_mappednode  —  Method get_mappednode(g::MappedNodeGraph, mid::Int) Get the node associated to the given mapped id. source"},{"id":807,"pagetitle":"API","title":"SMDGraphs.get_node","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_node-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_node  —  Method get_node(g::MappedNodeGraph, node::Int) Get the node associated with a node index. source"},{"id":808,"pagetitle":"API","title":"SMDGraphs.get_node_id","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_node_id-Tuple{JSMDInterfaces.Graph.AbstractJSMDGraphNode}","content":" SMDGraphs.get_node_id  —  Method get_node_id(b::AbstractJSMDGraphNode) Get the mapped-id of an  AbstractJSMDGraphNode . Warning This method is abstract! A concrete implementation for each concrete node shall be defined. source"},{"id":809,"pagetitle":"API","title":"SMDGraphs.get_outerid","ref":"/SMDGraphs/stable/api/#SMDGraphs.get_outerid-Tuple{SMDGraphs.MappedNodeGraph, Int64}","content":" SMDGraphs.get_outerid  —  Method get_outerid(g::MappedNodeGraph, id::Int) Return the id of the node associated to the mapped id  id . The outer ID is the ID that is  assigned to the node by the user. source"},{"id":812,"pagetitle":"Mapped Graphs","title":"Mapped-Node Graphs","ref":"/SMDGraphs/stable/mappedgraph/#Mapped-Node-Graphs","content":" Mapped-Node Graphs Mapped-Node graphs enable graph operations on any custom user-defined  concrete type, effectively replacing the integer nodes of the  Graphs.jl  graph, with the desired type. To enforce type-stability and avoid allocations,  the linking between the inner graph nodes and the custom nodes is achieved via  an integer mapping. Therefore, the only requirement is that an integer ID can  be associated to the custom type. The user will then be able to retrieve the  items in the nodes through this ID."},{"id":813,"pagetitle":"Mapped Graphs","title":"Usage","ref":"/SMDGraphs/stable/mappedgraph/#Usage","content":" Usage Suppose that you want to create a graph to connect items that store planetary bodies  properties. First, we will define our custom node type, which must be  a sub-type of  AbstractJSMDGraphNode : import JSMDInterfaces.Graph: AbstractJSMDGraphNode \n\nstruct SpaceBody{T} <: AbstractGraphNode\n    radius::T\n    density::T\n    id::Int \n    name::String\nend Before using this structure as node, the function  SMDGraphs.get_node_id  must be implemented for this data-type. For this reason, we have included within  SpaceBody  an integer field to store the ID of the body. SMDGraphs.get_node_id(body::SpaceBody) = body.id We are now ready to create our custom graph. The  MappedNodeGraph  constructor is called as follows: import SMDGraphs: MappedGraph\ngraph = MappedGraph(SpaceBody{Float64}) This line will create an empty  SimpleGraph  with nodes of type  SpaceBody{Float64} . A directed  SimpleDiGraph  graph is also supported by replacing the above line  with the  MappedDiGraph  constructor. To avoid allocations, all the nodes must belong  to the same concrete type. To show the capabilities of mapped graphs, we will define a bunch of custom bodies and add them to the graph.  # Define some custom bodies \nearth = SpaceBody(6378.0, 5.51, 399, \"Earth\")\nsun = SpaceBody(696340.0, 1.41, 10, \"Sun\")\nmoon = SpaceBody(1737.4, 3.34, 301, \"Moon\")\n\n# Populate the graph with these bodies\nSMDGraphs.add_vertex!(graph, earth)\nSMDGraphs.add_vertex!(graph, sun)\nSMDGraphs.add_vertex!(graph, moon) Please note that the order in which these bodies are added to the graph does not matter,  because it will only affect the inner ID associated to each node. To access the items  stored inside the graph, we can use either their user-defined ID or the internal one. The latter is retrieved with the  SMDGraphs.get_mappedid  function: julia> SMDGraphs.get_node(graph, 399)\nSpaceBody{Float64}(6378.0, 5.51, 399, \"Earth\")\n\njulia> SMDGraphs.get_mappedid(graph, 301)\n3\n\njulia> SMDGraphs.get_mappednode(graph, 3)\nSpaceBody{Float64}(1737.4, 3.34, 301, \"Moon\") Here we have retrieved Earth's property through its nominal ID and exploited   get_mappedid  and  get_mappednode  to discover the internal ID of the Moon and access its content. Connections between the items in the graph are easily added as follows:  SMDGraphs.add_edge!(graph, 10, 399)\nSMDGraphs.add_edge!(graph, 399, 301) By providing an additional integer input to  add_edge! , a weight factor  can be associated to the edge. The default weight is null. Finally, the path between two nodes is retrived as:  julia> path = SMDGraphs.get_path(graph, 10, 301);\njulia> print(path)\n[2, 1, 3] Note that  get_path  returns an integer vector of internal IDs instead of the user-defined ones. This enables a faster retrieval of the nodes via  SMDGraphs.get_mappednode , allowing to skip the dictionary lookup for the ID mapping of each node in the path."}]